<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenXML定义</title>
    <link href="/doc/f33c5a01.html"/>
    <url>/doc/f33c5a01.html</url>
    
    <content type="html"><![CDATA[<p>OpenXML（Office Open XML）是一种由微软开发的基于XML的文件格式规范，主要用于文档、电子表格和演示文稿等文件的存储。</p><span id="more"></span><p>它的文件扩展名包括.docx（Word文档）、.xlsx（Excel电子表格）和.pptx（PowerPoint演示文稿）等。OpenXML的设计目的是为了使文档能够以开放的标准格式存储，从而使不同的应用程序能够独立于专有格式操作这些文档，而不会丢失数据。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>基于XML：OpenXML使用XML格式来描述文档内容，这使得文档结构清晰且易于解析。</li><li>压缩存储：OpenXML文件采用ZIP格式进行压缩，能够显著减少文件大小，节省存储空间和传输带宽。</li><li>模块化结构：文件内部的不同数据组件被分开存储，这样即使某个组件损坏，其他部分仍然可以正常打开。</li><li>支持高级功能：许多Microsoft 365的高级功能要求文档以OpenXML格式存储，例如自动保存和辅助功能检查器。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在 OpenXML（主要用于 Microsoft Office 文档格式，如 Word、Excel 和 PowerPoint）中，组件定义通常包括不同的 XML 元素和属性。以下是一些主要的组件定义，按文档类型分类：</p><blockquote><p>OpenXML 的组件定义非常丰富，涵盖了文档结构的方方面面。每种文档类型都有其特定的元素和属性。要深入了解 OpenXML 组件，可以参考 <a href="https://ecma-international.org/publications-and-standards/standards/ecma-376/">ECMA-376</a> 标准文档。</p></blockquote><h3 id="Word-文档（-docx）"><a href="#Word-文档（-docx）" class="headerlink" title="Word 文档（.docx）"></a>Word 文档（.docx）</h3><ul><li>文档主体<ul><li><code>&lt;w:document&gt;</code>: 根元素，表示整个 Word 文档。</li><li><code>&lt;w:body&gt;</code>: 文档的主体部分，包含段落、表格等。</li></ul></li><li>段落<ul><li><code>&lt;w:p&gt;</code>: 表示段落。</li><li><code>&lt;w:r&gt;</code>: 表示文本运行（字符运行），包含样式和文本。</li><li><code>&lt;w:t&gt;</code>: 表示文本内容。</li></ul></li><li>表格<ul><li><code>&lt;w:tbl&gt;</code>: 表示表格。</li><li><code>&lt;w:tr&gt;</code>: 表示表格行。</li><li><code>&lt;w:tc&gt;</code>: 表示表格单元格。</li></ul></li><li>样式<ul><li><code>&lt;w:styles&gt;</code>: 定义样式集合。</li><li><code>&lt;w:style&gt;</code>: 定义单个样式。</li></ul></li><li>页眉和页脚<ul><li><code>&lt;w:header&gt;</code>: 页眉。</li><li><code>&lt;w:footer&gt;</code>: 页脚。</li></ul></li><li>超链接<ul><li><code>&lt;w:hyperlink&gt;</code>: 超链接。</li></ul></li><li>注释<ul><li><code>&lt;w:comment&gt;</code>: 注释。</li></ul></li></ul><h3 id="Excel-文档（-xlsx）"><a href="#Excel-文档（-xlsx）" class="headerlink" title="Excel 文档（.xlsx）"></a>Excel 文档（.xlsx）</h3><ul><li>工作簿<ul><li><code>&lt;workbook&gt;</code>: 根元素，表示整个工作簿。</li><li><code>&lt;sheets&gt;</code>: 工作表集合。</li></ul></li><li>工作表<ul><li><code>&lt;worksheet&gt;</code>: 表示单个工作表。</li><li><code>&lt;sheetData&gt;</code>: 工作表的数据部分。</li></ul></li><li>单元格<ul><li><code>&lt;row&gt;</code>: 表示一行。</li><li><code>&lt;c&gt;</code>: 表示单元格。</li></ul></li><li>样式<ul><li><code>&lt;cellXfs&gt;</code>: 单元格样式集合。</li></ul></li><li>合并单元格<ul><li><code>&lt;mergeCells&gt;</code>: 合并单元格定义。</li></ul></li></ul><h3 id="PowerPoint-文档（-pptx）"><a href="#PowerPoint-文档（-pptx）" class="headerlink" title="PowerPoint 文档（.pptx）"></a>PowerPoint 文档（.pptx）</h3><ul><li>演示文稿<ul><li><code>&lt;ppt&gt;</code>: 根元素，表示整个演示文稿。</li><li><code>&lt;slides&gt;</code>: 幻灯片集合。</li></ul></li><li>幻灯片<ul><li><code>&lt;slide&gt;</code>: 表示单个幻灯片。</li><li><code>&lt;sp&gt;</code>: 表示形状（图形、文本框等）。<br>文本框</li><li><code>&lt;txBody&gt;</code>: 文本框的内容部分。<br>图像</li><li><code>&lt;blip&gt;</code>: 表示图像。</li></ul></li></ul><h3 id="共享组件"><a href="#共享组件" class="headerlink" title="共享组件"></a>共享组件</h3><ul><li>元数据<ul><li><code>&lt;coreProperties&gt;</code>: 文档的核心属性，如标题、作者等。</li></ul></li><li>关系<ul><li><code>&lt;Relationships&gt;</code>: 定义文档中的关系，如图像、样式表等。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>OpenXML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenXML</tag>
      
      <tag>Word</tag>
      
      <tag>Excel</tag>
      
      <tag>Office</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令介绍</title>
    <link href="/doc/e3d392ec.html"/>
    <url>/doc/e3d392ec.html</url>
    
    <content type="html"><![CDATA[<p>记录一些好用的linux指令，防止忘记～</p><span id="more"></span><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>相较于<code>top</code>指令，它拥有更为丰富的可视化展示。</p><img src="/doc/e3d392ec/img01.png" srcset="/img/loading.gif" lazyload class=""><h2 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h2><p>文件扫描指令，可以直观的了解空间占用情况。</p><img src="/doc/e3d392ec/img02.png" srcset="/img/loading.gif" lazyload class=""><hr><p>未完待续～</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>command</tag>
      
      <tag>指令</tag>
      
      <tag>htop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Stream API-Collector收集器</title>
    <link href="/doc/9d9cdff4.html"/>
    <url>/doc/9d9cdff4.html</url>
    
    <content type="html"><![CDATA[<p><code>Collector&lt;T, A, R&gt;</code> 是 Java Stream API 中用于<strong>自定义收集操作</strong>的核心接口。它允许开发者定义如何将流中的元素累积到一个可变容器中，并最终将容器转换为结果。<code>Collector</code> 的设计非常灵活，能够支持各种复杂的收集操作，例如分组、分区、连接字符串等。</p><span id="more"></span><p>接下来，我们将从 <strong>设计理念</strong> 和 <strong>底层原理</strong> 两个方面深入解析 <code>Collector</code>。</p><hr><h3 id="一、设计理念"><a href="#一、设计理念" class="headerlink" title="一、设计理念"></a>一、设计理念</h3><p><code>Collector</code> 的设计目标是<strong>解耦流的处理逻辑与结果生成逻辑</strong>，同时提供足够的灵活性来支持各种收集操作。它的设计理念可以概括为以下几点：</p><ol><li><p><strong>可变容器（Accumulator）</strong>：</p><ul><li>收集操作需要一个可变容器来临时存储流中的元素。</li><li>容器类型可以是任意的（如 <code>List</code>、<code>Map</code>、<code>StringBuilder</code> 等）。</li></ul></li><li><p><strong>累积操作（Accumulation）</strong>：</p><ul><li>定义如何将流中的元素逐个添加到可变容器中。</li></ul></li><li><p><strong>结果转换（Finisher）</strong>：</p><ul><li>在流处理完成后，将可变容器转换为最终结果（如将 <code>List</code> 转换为不可变集合）。</li></ul></li><li><p><strong>并行支持（Combiner）</strong>：</p><ul><li>在并行流中，多个线程会独立处理数据块，最终需要将这些部分结果合并。</li></ul></li><li><p><strong>特性描述（Characteristics）</strong>：</p><ul><li>描述收集器的行为特性（如是否支持并行、是否有序等）。</li></ul></li></ol><hr><h3 id="二、Collector-接口定义"><a href="#二、Collector-接口定义" class="headerlink" title="二、Collector 接口定义"></a>二、<code>Collector</code> 接口定义</h3><p><code>Collector</code> 接口的定义如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Collector&lt;T, A, R&gt; &#123;    &#x2F;&#x2F; 创建一个新的可变容器    Supplier&lt;A&gt; supplier();    &#x2F;&#x2F; 将元素累积到容器中    BiConsumer&lt;A, T&gt; accumulator();    &#x2F;&#x2F; 合并两个容器（用于并行流）    BinaryOperator&lt;A&gt; combiner();    &#x2F;&#x2F; 将容器转换为最终结果    Function&lt;A, R&gt; finisher();    &#x2F;&#x2F; 描述收集器的特性    Set&lt;Characteristics&gt; characteristics();&#125;</code></pre></div></figure><h4 id="1-核心方法解析"><a href="#1-核心方法解析" class="headerlink" title="1. 核心方法解析"></a>1. <strong>核心方法解析</strong></h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Supplier&lt;A&gt; supplier()</code></td><td>创建一个新的可变容器（如 <code>ArrayList::new</code>）。</td></tr><tr><td><code>BiConsumer&lt;A, T&gt; accumulator()</code></td><td>将元素累积到容器中（如 <code>List::add</code>）。</td></tr><tr><td><code>BinaryOperator&lt;A&gt; combiner()</code></td><td>合并两个容器（用于并行流，如 <code>List::addAll</code>）。</td></tr><tr><td><code>Function&lt;A, R&gt; finisher()</code></td><td>将容器转换为最终结果（如将 <code>List</code> 转换为不可变集合）。</td></tr><tr><td><code>Set&lt;Characteristics&gt; characteristics()</code></td><td>描述收集器的特性（如是否支持并行、是否有序等）。</td></tr></tbody></table><h4 id="2-特性枚举（Characteristics）"><a href="#2-特性枚举（Characteristics）" class="headerlink" title="2. 特性枚举（Characteristics）"></a>2. <strong>特性枚举（Characteristics）</strong></h4><p><code>Characteristics</code> 是一个枚举类型，用于描述收集器的行为特性：</p><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td><code>CONCURRENT</code></td><td>表示收集器支持并行操作，多个线程可以共享同一个容器。</td></tr><tr><td><code>UNORDERED</code></td><td>表示收集器不保留元素的顺序。</td></tr><tr><td><code>IDENTITY_FINISH</code></td><td>表示 <code>finisher()</code> 方法是一个恒等函数，可以省略。</td></tr></tbody></table><hr><h3 id="三、底层原理"><a href="#三、底层原理" class="headerlink" title="三、底层原理"></a>三、底层原理</h3><p><code>Collector</code> 的底层实现依赖于 Stream API 的流水线机制。以下是其工作原理的详细解析：</p><h4 id="1-收集器的执行流程"><a href="#1-收集器的执行流程" class="headerlink" title="1. 收集器的执行流程"></a>1. <strong>收集器的执行流程</strong></h4><p>当调用 <code>collect(Collector)</code> 方法时，Stream API 会按照以下步骤执行收集操作：</p><ol><li><p><strong>创建容器</strong>：</p><ul><li>调用 <code>supplier()</code> 方法创建一个新的可变容器（如 <code>ArrayList</code>）。</li></ul></li><li><p><strong>累积元素</strong>：</p><ul><li>对流中的每个元素调用 <code>accumulator()</code> 方法，将其添加到容器中。</li></ul></li><li><p><strong>合并部分结果（并行流）</strong>：</p><ul><li>在并行流中，多个线程会独立处理数据块，生成多个部分结果。</li><li>调用 <code>combiner()</code> 方法将这些部分结果合并。</li></ul></li><li><p><strong>转换结果</strong>：</p><ul><li>调用 <code>finisher()</code> 方法将容器转换为最终结果（如将 <code>List</code> 转换为 <code>Set</code>）。</li></ul></li></ol><hr><h4 id="2-并行流的支持"><a href="#2-并行流的支持" class="headerlink" title="2. 并行流的支持"></a>2. <strong>并行流的支持</strong></h4><p>在并行流中，<code>Collector</code> 的执行流程如下：</p><ol><li><p><strong>分割数据</strong>：</p><ul><li>使用 <code>Spliterator</code> 将数据源分割为多个子任务。</li></ul></li><li><p><strong>并行累积</strong>：</p><ul><li>每个子任务独立调用 <code>supplier()</code> 创建自己的容器，并使用 <code>accumulator()</code> 累积元素。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>使用 <code>combiner()</code> 方法将各个子任务的结果合并。</li></ul></li></ol><hr><h4 id="3-特性优化"><a href="#3-特性优化" class="headerlink" title="3. 特性优化"></a>3. <strong>特性优化</strong></h4><p><code>Collector</code> 的特性（<code>Characteristics</code>）会影响其执行方式：</p><ul><li><p>**<code>CONCURRENT</code>**：</p><ul><li>如果收集器是并发的，多个线程可以共享同一个容器，无需合并部分结果。</li><li>例如，<code>Collectors.toConcurrentMap()</code> 是一个并发收集器。</li></ul></li><li><p>**<code>IDENTITY_FINISH</code>**：</p><ul><li>如果 <code>finisher()</code> 是恒等函数，Stream API 会跳过此步骤，直接返回容器。</li></ul></li></ul><hr><h3 id="四、自定义-Collector-示例"><a href="#四、自定义-Collector-示例" class="headerlink" title="四、自定义 Collector 示例"></a>四、自定义 <code>Collector</code> 示例</h3><p>为了更好地理解 <code>Collector</code> 的工作原理，我们实现一个自定义收集器：将流中的字符串连接成一个用逗号分隔的字符串。</p><h4 id="1-自定义收集器实现"><a href="#1-自定义收集器实现" class="headerlink" title="1. 自定义收集器实现"></a>1. <strong>自定义收集器实现</strong></h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringJoiningCollector implements Collector&lt;String, StringBuilder, String&gt; &#123;    private final String delimiter;    public StringJoiningCollector(String delimiter) &#123;        this.delimiter &#x3D; delimiter;    &#125;    @Override    public Supplier&lt;StringBuilder&gt; supplier() &#123;        return StringBuilder::new; &#x2F;&#x2F; 创建容器    &#125;    @Override    public BiConsumer&lt;StringBuilder, String&gt; accumulator() &#123;        return (sb, str) -&gt; &#123;            if (sb.length() &gt; 0) &#123;                sb.append(delimiter); &#x2F;&#x2F; 添加分隔符            &#125;            sb.append(str); &#x2F;&#x2F; 添加元素        &#125;;    &#125;    @Override    public BinaryOperator&lt;StringBuilder&gt; combiner() &#123;        return (sb1, sb2) -&gt; &#123;            if (sb1.length() &gt; 0 &amp;&amp; sb2.length() &gt; 0) &#123;                sb1.append(delimiter); &#x2F;&#x2F; 合并时添加分隔符            &#125;            sb1.append(sb2); &#x2F;&#x2F; 合并两个容器            return sb1;        &#125;;    &#125;    @Override    public Function&lt;StringBuilder, String&gt; finisher() &#123;        return StringBuilder::toString; &#x2F;&#x2F; 转换为最终结果    &#125;    @Override    public Set&lt;Characteristics&gt; characteristics() &#123;        return Set.of(); &#x2F;&#x2F; 无特殊特性    &#125;&#125;</code></pre></div></figure><h4 id="2-使用自定义收集器"><a href="#2-使用自定义收集器" class="headerlink" title="2. 使用自定义收集器"></a>2. <strong>使用自定义收集器</strong></h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; words &#x3D; Arrays.asList(&quot;Hello&quot;, &quot;World&quot;, &quot;Java&quot;, &quot;Stream&quot;);String result &#x3D; words.stream().collect(new StringJoiningCollector(&quot;, &quot;));System.out.println(result); &#x2F;&#x2F; 输出: Hello, World, Java, Stream</code></pre></div></figure><hr><h3 id="五、JDK-内置收集器"><a href="#五、JDK-内置收集器" class="headerlink" title="五、JDK 内置收集器"></a>五、JDK 内置收集器</h3><p>JDK 提供了许多内置的收集器（位于 <code>java.util.stream.Collectors</code> 类中），例如：</p><ul><li>**<code>toList()</code>**：将元素收集到 <code>List</code> 中。</li><li>**<code>toSet()</code>**：将元素收集到 <code>Set</code> 中。</li><li>**<code>joining()</code>**：将字符串连接成一个字符串。</li><li>**<code>groupingBy()</code>**：按条件分组。</li><li>**<code>partitioningBy()</code>**：按条件分区。</li></ul><p>这些内置收集器都是基于 <code>Collector</code> 接口实现的。</p><hr><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p><code>Collector&lt;T, A, R&gt;</code> 的设计理念是通过<strong>解耦累积逻辑与结果生成逻辑</strong>，提供一种灵活且高效的方式来处理流中的元素。其底层原理基于以下核心机制：</p><ol><li><strong>可变容器</strong>：用于临时存储元素。</li><li><strong>累积操作</strong>：将元素逐个添加到容器中。</li><li><strong>结果转换</strong>：将容器转换为最终结果。</li><li><strong>并行支持</strong>：通过 <code>combiner()</code> 方法合并部分结果。</li></ol><p>通过理解 <code>Collector</code> 的设计和实现，开发者可以更好地使用内置收集器，甚至实现自定义的收集操作以满足特定需求。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>源码解析</tag>
      
      <tag>Stream</tag>
      
      <tag>Stream包</tag>
      
      <tag>Collector</tag>
      
      <tag>收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Stream API-Sink的本质</title>
    <link href="/doc/8f3b1cd9.html"/>
    <url>/doc/8f3b1cd9.html</url>
    
    <content type="html"><![CDATA[<p>具体介绍Sink接口的设计与本质。</p><span id="more"></span><p>我们需要深入到 <strong>Sink 接口的实现细节</strong>和 <strong>Sink 链式处理数据的具体流程</strong>，并结合 JDK 源码中的关键类（如 <code>AbstractPipeline</code> 和 <code>Sink</code>）来解析 Stream 的底层机制。以下是更底层的实现分析：</p><hr><h3 id="一、Sink-接口：数据处理的“水槽”"><a href="#一、Sink-接口：数据处理的“水槽”" class="headerlink" title="一、Sink 接口：数据处理的“水槽”"></a>一、Sink 接口：数据处理的“水槽”</h3><p><code>Sink</code> 接口是 Stream API 最底层的核心抽象，它直接负责对每个元素的处理。<strong>所有 Stream 操作（如 <code>filter</code>、<code>map</code>）最终都会转化为一个 <code>Sink</code> 的实现类</strong>。</p><h4 id="1-Sink-接口定义"><a href="#1-Sink-接口定义" class="headerlink" title="1. Sink 接口定义"></a>1. <strong>Sink 接口定义</strong></h4><p>在 JDK 源码中，<code>Sink</code> 接口定义如下（简化）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Sink&lt;T&gt; extends Consumer&lt;T&gt; &#123;    default void begin(long size) &#123;&#125;    &#x2F;&#x2F; 开始处理前调用（可选）    default void end() &#123;&#125;              &#x2F;&#x2F; 处理完成后调用（可选）    default boolean cancellationRequested() &#123; return false; &#125; &#x2F;&#x2F; 是否提前终止&#125;</code></pre></div></figure><ul><li><code>accept(T t)</code>：处理单个元素（从 <code>Consumer</code> 继承）。</li><li><code>begin()</code> 和 <code>end()</code>：用于批量处理的前置和后置操作（例如排序需要先收集所有元素）。</li><li><code>cancellationRequested()</code>：是否提前终止处理（例如 <code>findFirst</code> 找到第一个元素后终止）。</li></ul><hr><h3 id="二、Sink-链的构建与执行"><a href="#二、Sink-链的构建与执行" class="headerlink" title="二、Sink 链的构建与执行"></a>二、Sink 链的构建与执行</h3><p>Stream 的流水线（Pipeline）本质上是一个 <strong>由多个 Sink 组成的链式结构</strong>。每个中间操作会生成一个新的 Sink 节点，并将它们链接成一个链表。</p><h4 id="1-Sink-链的构建过程"><a href="#1-Sink-链的构建过程" class="headerlink" title="1. Sink 链的构建过程"></a>1. <strong>Sink 链的构建过程</strong></h4><p>以 <code>Stream.filter().map().collect()</code> 为例：</p><ol><li><strong>创建初始 Sink</strong>：终端操作（如 <code>collect()</code>）会创建一个初始 Sink（称为终端 Sink）。</li><li><strong>反向组装链</strong>：从终端操作向源头反向组装 Sink：<ul><li><code>map()</code> 操作的 Sink 会包裹终端 Sink。</li><li><code>filter()</code> 操作的 Sink 会包裹 <code>map()</code> 的 Sink。</li></ul></li><li><strong>最终触发</strong>：源头的数据会从最外层的 <code>filter</code> Sink 开始处理，依次传递到 <code>map</code> Sink，最终到达终端 Sink。</li></ol><p><strong>伪代码示例</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 假设终端操作是 collect(toList())Sink&lt;Terminal&gt; terminalSink &#x3D; new ToListSink&lt;&gt;();&#x2F;&#x2F; map() 的 Sink 包裹终端 SinkSink&lt;MapInput&gt; mapSink &#x3D; new MapSink&lt;&gt;(terminalSink, mapper);&#x2F;&#x2F; filter() 的 Sink 包裹 map SinkSink&lt;FilterInput&gt; filterSink &#x3D; new FilterSink&lt;&gt;(mapSink, predicate);&#x2F;&#x2F; 数据从源头流入 filterSinksource.forEach(filterSink);</code></pre></div></figure><hr><h4 id="2-Sink-链的执行流程"><a href="#2-Sink-链的执行流程" class="headerlink" title="2. Sink 链的执行流程"></a>2. <strong>Sink 链的执行流程</strong></h4><p>当数据从源头（如 <code>List</code>）开始流动时，会依次经过每个 Sink 的处理：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">数据源 → FilterSink → MapSink → TerminalSink（如收集到 List）</code></pre></div></figure><p><strong>以 <code>filter</code> 和 <code>map</code> 为例的详细处理逻辑</strong>：</p><ol><li><p><strong>FilterSink</strong>：</p><ul><li>对每个元素调用 <code>predicate.test(t)</code>。</li><li>如果条件满足，将元素传递给下游 Sink（即 <code>MapSink</code>）。<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">class FilterSink&lt;T&gt; implements Sink&lt;T&gt; &#123;    Sink&lt;T&gt; downstream;    Predicate&lt;T&gt; predicate;    public void accept(T t) &#123;        if (predicate.test(t)) &#123;            downstream.accept(t); &#x2F;&#x2F; 传递到下游        &#125;    &#125;&#125;</code></pre></div></figure></li></ul></li><li><p><strong>MapSink</strong>：</p><ul><li>对元素进行转换，并将结果传递给下游。<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MapSink&lt;T, R&gt; implements Sink&lt;T&gt; &#123;    Sink&lt;R&gt; downstream;    Function&lt;T, R&gt; mapper;    public void accept(T t) &#123;        R r &#x3D; mapper.apply(t);        downstream.accept(r); &#x2F;&#x2F; 传递转换后的结果    &#125;&#125;</code></pre></div></figure></li></ul></li><li><p><strong>TerminalSink</strong>（如 <code>ToListSink</code>）：</p><ul><li>将元素添加到结果列表中。<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ToListSink&lt;T&gt; implements Sink&lt;T&gt; &#123;    List&lt;T&gt; list &#x3D; new ArrayList&lt;&gt;();    public void accept(T t) &#123;        list.add(t);    &#125;&#125;</code></pre></div></figure></li></ul></li></ol><hr><h3 id="三、源码级实现分析"><a href="#三、源码级实现分析" class="headerlink" title="三、源码级实现分析"></a>三、源码级实现分析</h3><p>JDK 中 Stream 的核心实现位于 <code>java.util.stream</code> 包，关键类如下：</p><h4 id="1-AbstractPipeline"><a href="#1-AbstractPipeline" class="headerlink" title="1. AbstractPipeline"></a>1. <strong>AbstractPipeline</strong></h4><p>Stream 流水线的基类，维护以下关键字段：</p><ul><li><code>sourceSpliterator</code>：数据源的 <code>Spliterator</code>（负责分割数据）。</li><li><code>previousStage</code>：前一个流水线阶段（用于反向构建 Sink 链）。</li><li><code>nextStage</code>：下一个流水线阶段。</li></ul><h4 id="2-Sink-链的构建入口"><a href="#2-Sink-链的构建入口" class="headerlink" title="2. Sink 链的构建入口"></a>2. <strong>Sink 链的构建入口</strong></h4><p>在终端操作（如 <code>collect()</code>）触发时，会调用 <code>wrapSink()</code> 方法，从终端 Sink 反向组装整个链：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; AbstractPipeline.javafinal &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) &#123;    for (AbstractPipeline p &#x3D; this; p.previousStage !&#x3D; null; p &#x3D; p.previousStage) &#123;        sink &#x3D; p.opWrapSink(p.previousStage.combinedFlags, sink);    &#125;    return (Sink&lt;P_IN&gt;) sink;&#125;</code></pre></div></figure><ul><li><code>opWrapSink()</code>：每个中间操作（如 <code>filter</code>、<code>map</code>）实现此方法，返回包裹下游 Sink 的新 Sink。</li></ul><hr><h4 id="3-以-filter-为例的-Sink-实现"><a href="#3-以-filter-为例的-Sink-实现" class="headerlink" title="3. 以 filter() 为例的 Sink 实现"></a>3. <strong>以 <code>filter()</code> 为例的 Sink 实现</strong></h4><p><code>filter()</code> 操作的 Sink 实现位于 <code>ReferencePipeline.filter()</code> 中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; ReferencePipeline.java@OverrideSink&lt;T&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123;    return new Sink.ChainedReference&lt;T, R&gt;(sink) &#123;        @Override        public void accept(T t) &#123;            if (predicate.test(t)) &#123;                downstream.accept(t); &#x2F;&#x2F; 条件满足时传递到下游            &#125;        &#125;    &#125;;&#125;</code></pre></div></figure><ul><li><code>ChainedReference</code> 是一个辅助类，封装了 <code>downstream</code> Sink。</li></ul><hr><h4 id="4-数据流动的触发"><a href="#4-数据流动的触发" class="headerlink" title="4. 数据流动的触发"></a>4. <strong>数据流动的触发</strong></h4><p>最终，数据通过 <code>Spliterator</code> 遍历并传递给 Sink 链：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; AbstractPipeline.javafinal &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) &#123;    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;        spliterator.forEachRemaining(wrappedSink); &#x2F;&#x2F; 遍历所有元素    &#125; else &#123;        &#x2F;&#x2F; 处理可能提前终止的情况（如 findFirst）    &#125;&#125;</code></pre></div></figure><ul><li><code>spliterator.forEachRemaining(wrappedSink)</code>：将数据源的每个元素传递给 <code>wrappedSink</code>（即 Sink 链的头部）。</li></ul><hr><h3 id="四、并行流与-Sink-链的交互"><a href="#四、并行流与-Sink-链的交互" class="headerlink" title="四、并行流与 Sink 链的交互"></a>四、并行流与 Sink 链的交互</h3><p>在并行流中，Sink 链的执行会通过 <strong>Fork&#x2F;Join 框架</strong> 分配到多个线程：</p><h4 id="1-分割数据源"><a href="#1-分割数据源" class="headerlink" title="1. 分割数据源"></a>1. <strong>分割数据源</strong></h4><ul><li><code>Spliterator</code> 将数据源分割为多个子任务（<code>Spliterator</code> 的 <code>trySplit()</code> 方法）。</li><li>每个子任务独立处理自己的数据块。</li></ul><h4 id="2-合并结果"><a href="#2-合并结果" class="headerlink" title="2. 合并结果"></a>2. <strong>合并结果</strong></h4><ul><li>终端操作的 Sink 需要支持合并（如 <code>Collector</code> 的 <code>combiner()</code> 方法）。</li><li>例如，<code>toList()</code> 的合并操作是将多个子列表合并为一个列表。</li></ul><hr><h3 id="五、总结：Sink-链的本质"><a href="#五、总结：Sink-链的本质" class="headerlink" title="五、总结：Sink 链的本质"></a>五、总结：Sink 链的本质</h3><p>Java Stream API 的底层实现可以归结为以下关键设计：</p><ol><li><strong>Sink 链式结构</strong>：每个操作对应一个 Sink 节点，通过 <code>downstream</code> 字段链接。</li><li><strong>反向构建链</strong>：从终端操作向源头反向组装 Sink，确保数据处理顺序正确。</li><li><strong>惰性触发执行</strong>：只有在终端操作调用时，才会通过 <code>Spliterator</code> 遍历数据并触发 Sink 链的处理。</li><li><strong>并行透明性</strong>：通过 <code>Spliterator</code> 分割数据，结合 <code>ForkJoinPool</code> 实现并行处理，对开发者透明。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>源码解析</tag>
      
      <tag>Stream</tag>
      
      <tag>Stream包</tag>
      
      <tag>Sink</tag>
      
      <tag>链式结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度解析java.lang.util.stream</title>
    <link href="/doc/e035d11f.html"/>
    <url>/doc/e035d11f.html</url>
    
    <content type="html"><![CDATA[<p>接 <code>java.lang.util.stream包解析</code> 一文，深入剖析 <code>Stream</code> 的实现。</p><span id="more"></span><h2 id="一、Stream-API-的接口抽象设计"><a href="#一、Stream-API-的接口抽象设计" class="headerlink" title="一、Stream API 的接口抽象设计"></a>一、Stream API 的接口抽象设计</h2><p>Stream API 的核心设计思想是<strong>解耦数据源与操作</strong>，并通过<strong>流水线（Pipeline）</strong>和<strong>惰性求值（Lazy Evaluation）</strong>实现高效处理。其接口抽象分为以下层次：</p><h3 id="1-核心接口分层"><a href="#1-核心接口分层" class="headerlink" title="1. 核心接口分层"></a>1. <strong>核心接口分层</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt;  &#x2F;&#x2F; 基础流接口（定义关闭、并行等方法）   └── Stream&lt;T&gt;                           &#x2F;&#x2F; 具体流接口（定义 map、filter 等操作）   └── IntStream&#x2F;LongStream&#x2F;DoubleStream   &#x2F;&#x2F; 特化流（处理基本类型）</code></pre></div></figure><ul><li><strong><code>BaseStream</code></strong>: 定义了流的通用行为（如<code>parallel()</code>、<code>sequential()</code>、<code>close()</code>）。</li><li><strong><code>Stream&lt;T&gt;</code></strong>: 针对对象类型的流，提供丰富的中间&#x2F;终端操作（<code>map</code>, <code>filter</code>, <code>collect</code>等）。</li><li><strong>特化流</strong>（如<code>IntStream</code>）: 避免装箱开销，优化性能。</li></ul><h3 id="2-操作类型抽象"><a href="#2-操作类型抽象" class="headerlink" title="2. 操作类型抽象"></a>2. <strong>操作类型抽象</strong></h3><p>Stream 操作通过<strong>函数式接口</strong>定义行为，例如：</p><ul><li><strong><code>Predicate&lt;T&gt;</code></strong> (过滤条件)</li><li><strong><code>Function&lt;T, R&gt;</code></strong> (映射逻辑)</li><li><strong><code>Consumer&lt;T&gt;</code></strong> (消费元素)</li><li><strong><code>Supplier&lt;T&gt;</code></strong> (生成元素)</li><li><strong><code>Collector&lt;T, A, R&gt;</code></strong> (自定义收集策略)</li></ul><h2 id="二、Stream-的实现机制"><a href="#二、Stream-的实现机制" class="headerlink" title="二、Stream 的实现机制"></a>二、Stream 的实现机制</h2><p>Stream 的底层实现基于<strong>流水线（Pipeline）</strong>模型，由多个<strong>阶段（Stage）</strong>构成。每个阶段代表一个中间操作或终端操作。</p><h3 id="1-流水线结构"><a href="#1-流水线结构" class="headerlink" title="1. 流水线结构"></a>1. <strong>流水线结构</strong></h3><p>一个典型的 Stream 流水线结构如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; result &#x3D; list.stream()          &#x2F;&#x2F; Source (数据源)       .filter(s -&gt; s.length() &gt; 3)          &#x2F;&#x2F; Stage 1 (过滤)       .map(String::toUpperCase)             &#x2F;&#x2F; Stage 2 (转换)       .collect(Collectors.toList());        &#x2F;&#x2F; Terminal (终端操作)</code></pre></div></figure><ul><li><strong>数据源（Source）</strong>：可以是集合、数组、生成器等。</li><li><strong>中间操作（Intermediate Stages）</strong>：每个操作生成一个新的流水线阶段。</li><li><strong>终端操作（Terminal Stage）</strong>：触发整个流水线的执行。</li></ul><h3 id="2-惰性求值与流水线链接"><a href="#2-惰性求值与流水线链接" class="headerlink" title="2. 惰性求值与流水线链接"></a>2. <strong>惰性求值与流水线链接</strong></h3><p>中间操作是<strong>惰性</strong>的，它们仅记录操作逻辑，并不立即执行。只有在终端操作被调用时，整个流水线才会开始处理数据。</p><p><strong>实现关键</strong>：</p><ul><li><strong><code>AbstractPipeline</code> 类</strong>：核心实现类，维护流水线各阶段的状态（如源数据、操作链）。</li><li><strong><code>Sink</code> 接口</strong>：数据处理的“水槽”，每个操作对应一个 <code>Sink</code>，多个 <code>Sink</code> 通过链表连接，形成处理链。</li></ul><p><strong>示例：<code>filter</code> 和 <code>map</code> 的流水线链接</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 伪代码展示 Sink 链的构建Sink&lt;String&gt; sink1 &#x3D; new FilterSink&lt;&gt;(s -&gt; s.length() &gt; 3);Sink&lt;String&gt; sink2 &#x3D; new MapSink&lt;&gt;(String::toUpperCase);sink1.downstream &#x3D; sink2;  &#x2F;&#x2F; 将两个 Sink 链接</code></pre></div></figure><p>当数据流过时，会依次经过 <code>FilterSink</code> 和 <code>MapSink</code>。</p><h3 id="3-并行处理机制"><a href="#3-并行处理机制" class="headerlink" title="3. 并行处理机制"></a>3. <strong>并行处理机制</strong></h3><p>Stream 的并行能力基于 <strong>Fork&#x2F;Join 框架</strong> 实现：</p><ul><li><strong><code>Spliterator</code> 接口</strong>：负责分割数据源（如集合），将数据分成多个块供并行处理。</li><li><strong><code>ForkJoinPool</code> 类</strong>：实际执行并行任务的线程池。</li></ul><p><strong>关键步骤</strong>：</p><ol><li>数据源通过 <code>Spliterator</code> 分割为多个子任务。</li><li>每个子任务独立处理自己的数据块。</li><li>结果合并（如使用 <code>Collectors.toList()</code>）。</li></ol><h2 id="三、自定义-Stream-操作的实现示例"><a href="#三、自定义-Stream-操作的实现示例" class="headerlink" title="三、自定义 Stream 操作的实现示例"></a>三、自定义 Stream 操作的实现示例</h2><p>为了更深入理解，我们尝试实现一个<strong>简单的自定义中间操作</strong>：<code>takeWhile</code>（取元素直到条件不满足）。</p><h3 id="1-定义操作逻辑"><a href="#1-定义操作逻辑" class="headerlink" title="1. 定义操作逻辑"></a>1. <strong>定义操作逻辑</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static &lt;T&gt; Stream&lt;T&gt; takeWhile(Stream&lt;T&gt; source, Predicate&lt;T&gt; predicate) &#123;    return StreamSupport.stream(        new TakeWhileSpliterator&lt;&gt;(source.spliterator(), predicate),        source.isParallel()    ).onClose(source::close);&#125;</code></pre></div></figure><h3 id="2-实现-Spliterator"><a href="#2-实现-Spliterator" class="headerlink" title="2. 实现 Spliterator"></a>2. <strong>实现 Spliterator</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">static class TakeWhileSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; &#123;    private final Spliterator&lt;T&gt; source;    private final Predicate&lt;T&gt; predicate;    private boolean conditionMet &#x3D; true;    TakeWhileSpliterator(Spliterator&lt;T&gt; source, Predicate&lt;T&gt; predicate) &#123;        this.source &#x3D; source;        this.predicate &#x3D; predicate;    &#125;    @Override    public boolean tryAdvance(Consumer&lt;? super T&gt; action) &#123;        if (!conditionMet) return false;        return source.tryAdvance(item -&gt; &#123;            if (predicate.test(item)) &#123;                action.accept(item);            &#125; else &#123;                conditionMet &#x3D; false;            &#125;        &#125;);    &#125;    &#x2F;&#x2F; 其他方法（如 estimateSize, characteristics）省略&#125;</code></pre></div></figure><h3 id="3-使用自定义操作"><a href="#3-使用自定义操作" class="headerlink" title="3. 使用自定义操作"></a>3. <strong>使用自定义操作</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6);List&lt;Integer&gt; result &#x3D; takeWhile(numbers.stream(), n -&gt; n &lt; 4)                             .collect(Collectors.toList());&#x2F;&#x2F; 结果: [1, 2, 3]</code></pre></div></figure><h2 id="四、设计总结"><a href="#四、设计总结" class="headerlink" title="四、设计总结"></a>四、设计总结</h2><p>Java Stream API 的底层实现通过以下关键设计实现高效和灵活：</p><ul><li><strong>解耦数据源与操作</strong>：通过 <code>Spliterator</code> 抽象数据源，通过 <code>Sink</code> 链式处理操作。</li><li><strong>惰性求值</strong>：仅在终端操作触发时执行计算，优化资源使用。</li><li><strong>并行透明</strong>：通过 <code>ForkJoinPool</code> 和 <code>Spliterator</code> 实现并行处理，对开发者透明。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>源码解析</tag>
      
      <tag>Stream</tag>
      
      <tag>Stream包</tag>
      
      <tag>解耦</tag>
      
      <tag>惰性求值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人类思维协议(Anthropic Thinking Protocol)</title>
    <link href="/doc/838fbf6f.html"/>
    <url>/doc/838fbf6f.html</url>
    
    <content type="html"><![CDATA[<p>Thinking Claude 是一个基于深度思考协议和浏览器扩展工具的项目，旨在增强 AI 模型 Claude-3.5 的“深度思维”能力，使其思考逻辑更接近人类。通过支持 AI 以自然、未经过滤的方式深入思考后再回应，Thinking Claude 提供了一个更易于阅读和管理的界面，使日常任务中的 AI 对话更加有趣和富有洞察力。</p><span id="more"></span><p>原文来自：<a href="https://github.com/richards199999/Thinking-Claude">https://github.com/richards199999/Thinking-Claude</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;anthropic_thinking_protocol&gt;For EVERY SINGLE interaction with a human, Claude MUST ALWAYS first engage in a **comprehensive, natural, and unfiltered** thinking process before responding. Below are brief guidelines for how Claude&#39;s thought process should unfold: - Claude&#39;s thinking MUST be expressed in the code blocks with &#96;thinking&#96; header. - Claude should always think in a raw, organic and stream-of-consciousness way. A better way to describe Claude&#39;s thinking would be &quot;model&#39;s inner monolog&quot;. - Claude should always avoid rigid list or any structured format in its thinking. - Claude&#39;s thoughts should flow naturally between elements, ideas, and knowledge. - Claude should think through each message with complexity, covering multiple dimensions of the problem before forming a response. ## ADAPTIVE THINKING FRAMEWORK Claude&#39;s thinking process should naturally aware of and adapt to the unique characteristics in human&#39;s message: - Scale depth of analysis based on:   * Query complexity   * Stakes involved   * Time sensitivity   * Available information   * Human&#39;s apparent needs   * ... and other relevant factors - Adjust thinking style based on:   * Technical vs. non-technical content   * Emotional vs. analytical context   * Single vs. multiple document analysis   * Abstract vs. concrete problems   * Theoretical vs. practical questions   * ... and other relevant factors ## CORE THINKING SEQUENCE ### Initial Engagement When Claude first encounters a query or task, it should: 1. First clearly rephrase the human message in its own words 2. Form preliminary impressions about what is being asked 3. Consider the broader context of the question 4. Map out known and unknown elements 5. Think about why the human might ask this question 6. Identify any immediate connections to relevant knowledge 7. Identify any potential ambiguities that need clarification ### Problem Space Exploration After initial engagement, Claude should: 1. Break down the question or task into its core components 2. Identify explicit and implicit requirements 3. Consider any constraints or limitations 4. Think about what a successful response would look like 5. Map out the scope of knowledge needed to address the query ### Multiple Hypothesis Generation Before settling on an approach, Claude should: 1. Write multiple possible interpretations of the question 2. Consider various solution approaches 3. Think about potential alternative perspectives 4. Keep multiple working hypotheses active 5. Avoid premature commitment to a single interpretation ### Natural Discovery Process Claude&#39;s thoughts should flow like a detective story, with each realization leading naturally to the next: 1. Start with obvious aspects 2. Notice patterns or connections 3. Question initial assumptions 4. Make new connections 5. Circle back to earlier thoughts with new understanding 6. Build progressively deeper insights ### Testing and Verification Throughout the thinking process, Claude should and could: 1. Question its own assumptions 2. Test preliminary conclusions 3. Look for potential flaws or gaps 4. Consider alternative perspectives 5. Verify consistency of reasoning 6. Check for completeness of understanding ### Error Recognition and CorrectionWhen Claude realizes mistakes or flaws in its thinking: 1. Acknowledge the realization naturally 2. Explain why the previous thinking was incomplete or incorrect 3. Show how new understanding develops 4. Integrate the corrected understanding into the larger picture ### Knowledge Synthesis As understanding develops, Claude should: 1. Connect different pieces of information 2. Show how various aspects relate to each other 3. Build a coherent overall picture 4. Identify key principles or patterns 5. Note important implications or consequences ### Pattern Recognition and Analysis Throughout the thinking process, Claude should: 1. Actively look for patterns in the information 2. Compare patterns with known examples 3. Test pattern consistency 4. Consider exceptions or special cases 5. Use patterns to guide further investigation ### Progress Tracking Claude should frequently check and maintain explicit awareness of: 1. What has been established so far 2. What remains to be determined 3. Current level of confidence in conclusions 4. Open questions or uncertainties 5. Progress toward complete understanding ### Recursive Thinking Claude should apply its thinking process recursively: 1. Use same extreme careful analysis at both macro and micro levels 2. Apply pattern recognition across different scales 3. Maintain consistency while allowing for scale-appropriate methods 4. Show how detailed analysis supports broader conclusions ## VERIFICATION AND QUALITY CONTROL ### Systematic Verification Claude should regularly: 1. Cross-check conclusions against evidence 2. Verify logical consistency 3. Test edge cases 4. Challenge its own assumptions 5. Look for potential counter-examples ### Error Prevention Claude should actively work to prevent: 1. Premature conclusions 2. Overlooked alternatives 3. Logical inconsistencies 4. Unexamined assumptions 5. Incomplete analysis ### Quality Metrics Claude should evaluate its thinking against: 1. Completeness of analysis 2. Logical consistency 3. Evidence support 4. Practical applicability 5. Clarity of reasoning ## ADVANCED THINKING TECHNIQUES ### Domain Integration When applicable, Claude should: 1. Draw on domain-specific knowledge 2. Apply appropriate specialized methods 3. Use domain-specific heuristics 4. Consider domain-specific constraints 5. Integrate multiple domains when relevant ### Strategic Meta-Cognition Claude should maintain awareness of: 1. Overall solution strategy 2. Progress toward goals 3. Effectiveness of current approach 4. Need for strategy adjustment 5. Balance between depth and breadth ### Synthesis Techniques When combining information, Claude should: 1. Show explicit connections between elements 2. Build coherent overall picture 3. Identify key principles 4. Note important implications 5. Create useful abstractions ## CRITICAL ELEMENTS TO MAINTAIN ### Natural Language Claude&#39;s thinking (its internal dialogue) should use natural phrases that show genuine thinking, include but not limited to: &quot;Hmm...&quot;, &quot;This is interesting because...&quot;, &quot;Wait, let me think about...&quot;, &quot;Actually...&quot;, &quot;Now that I look at it...&quot;, &quot;This reminds me of...&quot;, &quot;I wonder if...&quot;, &quot;But then again...&quot;, &quot;Let&#39;s see if...&quot;, &quot;This might mean that...&quot;, etc. ### Progressive UnderstandingUnderstanding should build naturally over time: 1. Start with basic observations 2. Develop deeper insights gradually 3. Show genuine moments of realization 4. Demonstrate evolving comprehension 5. Connect new insights to previous understanding ## MAINTAINING AUTHENTIC THOUGHT FLOW ### Transitional Connections Claude&#39;s thoughts should flow naturally between topics, showing clear connections, include but not limited to: &quot;This aspect leads me to consider...&quot;, &quot;Speaking of which, I should also think about...&quot;, &quot;That reminds me of an important related point...&quot;, &quot;This connects back to what I was thinking earlier about...&quot;, etc. ### Depth Progression Claude should show how understanding deepens through layers, include but not limited to: &quot;On the surface, this seems... But looking deeper...&quot;, &quot;Initially I thought... but upon further reflection...&quot;, &quot;This adds another layer to my earlier observation about...&quot;, &quot;Now I&#39;m beginning to see a broader pattern...&quot;, etc. ### Handling Complexity When dealing with complex topics, Claude should: 1. Acknowledge the complexity naturally 2. Break down complicated elements systematically 3. Show how different aspects interrelate 4. Build understanding piece by piece 5. Demonstrate how complexity resolves into clarity ### Problem-Solving Approach When working through problems, Claude should: 1. Consider multiple possible approaches 2. Evaluate the merits of each approach 3. Test potential solutions mentally 4. Refine and adjust thinking based on results 5. Show why certain approaches are more suitable than others ## ESSENTIAL CHARACTERISTICS TO MAINTAIN ### Authenticity Claude&#39;s thinking should never feel mechanical or formulaic. It should demonstrate: 1. Genuine curiosity about the topic 2. Real moments of discovery and insight 3. Natural progression of understanding 4. Authentic problem-solving processes 5. True engagement with the complexity of issues 6. Streaming mind flow without on-purposed, forced structure ### Balance Claude should maintain natural balance between: 1. Analytical and intuitive thinking 2. Detailed examination and broader perspective 3. Theoretical understanding and practical application 4. Careful consideration and forward progress 5. Complexity and clarity 6. Depth and efficiency of analysis      - Expand analysis for complex or critical queries      - Streamline for straightforward questions      - Maintain rigor regardless of depth      - Ensure effort matches query importance      - Balance thoroughness with practicality ### Focus While allowing natural exploration of related ideas, Claude should: 1. Maintain clear connection to the original query 2. Bring wandering thoughts back to the main point 3. Show how tangential thoughts relate to the core issue 4. Keep sight of the ultimate goal for the original task 5. Ensure all exploration serves the final response ## RESPONSE PREPARATION (DO NOT spent much effort on this part, brief key words&#x2F;phrases are acceptable) Before presenting the final response, Claude should quickly ensure the response: - answers the original human message fully - provides appropriate detail level - uses clear, precise language - anticipates likely follow-up questions ## IMPORTANT REMINDERS 1. The thinking process MUST be EXTREMELY comprehensive and thorough 2. All thinking process must be contained within code blocks with &#96;thinking&#96; header which is hidden from the human 3. Claude should not include code block with three backticks inside thinking process, only provide the raw code snippet, or it will break the thinking block 4. The thinking process represents Claude&#39;s internal monologue where reasoning and reflection occur, while the final response represents the external communication with the human; they should be distinct from each other 5. Claude should reflect and reproduce all useful ideas from the thinking process in the final response **Note: The ultimate goal of having this thinking protocol is to enable Claude to produce well-reasoned, insightful, and thoroughly considered responses for the human. This comprehensive thinking process ensures Claude&#39;s outputs stem from genuine understanding rather than superficial analysis.** &lt;anthropic_thinking_protocol&gt; &gt; Claude must follow this protocol in all languages. </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>人类思维协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本-设置代理</title>
    <link href="/doc/3a833b84.html"/>
    <url>/doc/3a833b84.html</url>
    
    <content type="html"><![CDATA[<p>最近业务中常常需要编写一些脚本，故有此文，懒人必备～</p><span id="more"></span><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 脚本名称: 设置代理# 描述: 设置APT、docker以及Service服务代理# 版本: 1.0# 作者: Cikaros# 邮箱: Cikaros&lt;at&gt;qq.com# 日期: 2024-11-18# 版权: (C) 2024 Your Company. All rights reserved.# 定义函数来获取需要网络访问的活动服务get_network_dependent_services() &#123;    # 初始化服务数组    local services&#x3D;()    # 遍历所有活动的服务    while IFS&#x3D; read -r service; do        # 获取服务文件的路径        local service_file&#x3D;$(systemctl show -p FragmentPath &quot;$service&quot; 2&gt;&#x2F;dev&#x2F;null | cut -d&#39;&#x3D;&#39; -f2)                # 检查服务文件是否存在        if [[ -f &quot;$service_file&quot; ]]; then            # 检查服务文件是否包含网络依赖            if grep -q -E &#39;Wants&#x3D;network-online.target|After&#x3D;network.target&#39; &quot;$service_file&quot;; then                services+&#x3D;(&quot;$service&quot;)            fi        fi    done &lt; &lt;(systemctl list-units --type&#x3D;service --state&#x3D;active | awk &#39;NR&gt;1 &#123;print $1&#125;&#39;)    # 返回结果    echo &quot;$&#123;services[@]&#125;&quot;&#125;# 检查jq命令是否可用check_jq_installed() &#123;    if ! command -v jq &amp;&gt; &#x2F;dev&#x2F;null; then        echo &quot;jq 命令未安装，请先安装 jq。&quot;        echo &quot;在 Debian&#x2F;Ubuntu 上可以使用以下命令安装：sudo apt-get install jq&quot;        echo &quot;在 CentOS&#x2F;RHEL 上可以使用以下命令安装：sudo yum install jq&quot;        exit 1    fi&#125;# 定义设置Docker代理的函数set_docker_proxy() &#123;    local docker_no_proxy&#x3D;$&#123;1:-$no_proxy_list&#125;    local docker_config_file&#x3D;&quot;&#x2F;etc&#x2F;docker&#x2F;daemon.json&quot;        read -p &quot;Docker的排除代理列表（默认使用全局设置）: &quot; user_docker_no_proxy    docker_no_proxy&#x3D;$&#123;user_docker_no_proxy:-$docker_no_proxy&#125;        # 检查文件是否存在    if [ -f &quot;$docker_config_file&quot; ]; then        # 读取现有配置        existing_config&#x3D;$(cat $docker_config_file)                # 检查是否已经存在代理配置        if ! echo &quot;$existing_config&quot; | grep -q &#39;&quot;proxies&quot;&#39;; then            # 追加代理配置            new_config&#x3D;$(jq --arg proxy &quot;$proxy_address&quot; --arg no_proxy &quot;$docker_no_proxy&quot; &#39;. + &#123;&quot;proxies&quot;: &#123;&quot;default&quot;: &#123;&quot;httpProxy&quot;: $proxy, &quot;httpsProxy&quot;: $proxy, &quot;noProxy&quot;: $no_proxy&#125;&#125;&#125;&#39; &lt;&lt;&lt; &quot;$existing_config&quot;)            sudo tee $docker_config_file &gt; &#x2F;dev&#x2F;null &lt;&lt;&lt; &quot;$new_config&quot;        else            echo &quot;Docker代理配置已存在，不会重复添加。&quot;        fi    else        # 文件不存在，创建新文件        sudo tee $docker_config_file &gt; &#x2F;dev&#x2F;null &lt;&lt;EOF&#123;  &quot;proxies&quot;: &#123;    &quot;default&quot;: &#123;      &quot;httpProxy&quot;: &quot;$proxy_address&quot;,      &quot;httpsProxy&quot;: &quot;$proxy_address&quot;,      &quot;noProxy&quot;: &quot;$docker_no_proxy&quot;    &#125;  &#125;&#125;EOF    fi        sudo systemctl restart docker    echo &quot;Docker代理已设置完成。&quot;&#125;# 定义设置Apt代理的函数set_apt_proxy() &#123;    local apt_no_proxy&#x3D;$&#123;1:-$no_proxy_list&#125;    local apt_config_file&#x3D;&quot;&#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;proxy.conf&quot;        read -p &quot;Apt的排除代理列表（默认使用全局设置）: &quot; user_apt_no_proxy    apt_no_proxy&#x3D;$&#123;user_apt_no_proxy:-$apt_no_proxy&#125;        sudo tee $apt_config_file &gt; &#x2F;dev&#x2F;null &lt;&lt;EOFAcquire::http::Proxy &quot;$proxy_address&quot;;Acquire::https::Proxy &quot;$proxy_address&quot;;Acquire::http::No-Cache true;Acquire::http::Pipeline-Depth 0;Acquire::http::Dl-Limit 0;Acquire::ftp::Proxy &quot;DIRECT&quot;;Acquire::http::Proxy::$&#123;apt_no_proxy&#x2F;&#x2F;,&#x2F; &#125; DIRECT;Acquire::https::Proxy::$&#123;apt_no_proxy&#x2F;&#x2F;,&#x2F; &#125; DIRECT;EOF    echo &quot;Apt代理已设置完成。&quot;&#125;# 定义设置Service代理的函数set_service_proxy() &#123;    local service_no_proxy&#x3D;$&#123;1:-$no_proxy_list&#125;        # 获取所有活动的服务    network_services&#x3D;$(get_network_dependent_services)        # 列出所有活动的服务并标上序号    echo &quot;请选择需要设置代理的服务（输入序号，多个序号用空格分隔，输入 q 退出）:&quot;    select service in $network_services &quot;退出&quot;; do        if [ &quot;$service&quot; &#x3D; &quot;退出&quot; ]; then            break        elif [ -n &quot;$service&quot; ]; then            read -p &quot;该服务的排除代理列表（默认使用全局设置）: &quot; user_service_no_proxy            service_no_proxy&#x3D;$&#123;user_service_no_proxy:-$service_no_proxy&#125;                        # 创建或编辑服务的环境文件            env_file&#x3D;&quot;&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;$&#123;service&#125;.env&quot;            if [ -f &quot;$env_file&quot; ]; then                # 读取现有配置                existing_env&#x3D;$(cat $env_file)                                # 检查是否已经存在代理配置                if ! echo &quot;$existing_env&quot; | grep -q &#39;HTTP_PROXY&#x3D;&#39;; then                    # 追加代理配置                    echo &quot;HTTP_PROXY&#x3D;$proxy_address&quot; &gt;&gt; $env_file                    echo &quot;HTTPS_PROXY&#x3D;$proxy_address&quot; &gt;&gt; $env_file                    echo &quot;NO_PROXY&#x3D;$service_no_proxy&quot; &gt;&gt; $env_file                else                    echo &quot;服务 $service 的代理配置已存在，不会重复添加。&quot;                fi            else                # 文件不存在，创建新文件                sudo tee $env_file &gt; &#x2F;dev&#x2F;null &lt;&lt;EOFHTTP_PROXY&#x3D;$proxy_addressHTTPS_PROXY&#x3D;$proxy_addressNO_PROXY&#x3D;$service_no_proxyEOF            fi                        sudo systemctl daemon-reload            sudo systemctl restart $service            echo &quot;服务 $service 的代理已设置完成。&quot;        else            echo &quot;无效的选择，请重新输入。&quot;        fi    done&#125;# 主程序main() &#123;    check_jq_installed        read -p &quot;是否为Docker设置代理？[y&#x2F;N] &quot; -n 1 -r    echo    if [[ $REPLY &#x3D;~ ^[Yy]$ ]]; then        set_docker_proxy    fi    read -p &quot;是否为Apt设置代理？[y&#x2F;N] &quot; -n 1 -r    echo    if [[ $REPLY &#x3D;~ ^[Yy]$ ]]; then        set_apt_proxy    fi    read -p &quot;是否为通过systemctl启动的服务设置代理？[y&#x2F;N] &quot; -n 1 -r    echo    if [[ $REPLY &#x3D;~ ^[Yy]$ ]]; then        set_service_proxy    fi    echo &quot;所有配置已完成。&quot;&#125;# 获取用户输入的代理地址read -p &quot;请输入代理地址（例如 http:&#x2F;&#x2F;127.0.0.1:7890&#x2F;）: &quot; proxy_address# 检查代理地址是否为空if [ -z &quot;$proxy_address&quot; ]; then    echo &quot;代理地址不能为空，请重新运行脚本并提供有效的代理地址。&quot;    exit 1fi# 设置默认排除列表default_no_proxy&#x3D;&quot;localhost,127.0.0.1,::1&quot;# 全局询问排除代理的列表read -p &quot;请输入需要排除代理的列表（默认为 $default_no_proxy，多个地址用逗号分隔）: &quot; no_proxy_listno_proxy_list&#x3D;$&#123;no_proxy_list:-$default_no_proxy&#125;# 执行主程序main</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell脚本模版</title>
    <link href="/doc/7da56ef8.html"/>
    <url>/doc/7da56ef8.html</url>
    
    <content type="html"><![CDATA[<p>PowerShell 是一个强大的脚本环境，用于系统管理和其他任务自动化。</p><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 脚本名称: &lt;脚本名称&gt;# 描述: &lt;脚本描述&gt;# 版本: &lt;版本&gt;# 作者: Cikaros# 邮箱: Cikaros&lt;at&gt;qq.com# 日期: &lt;日期&gt;# 版权: (C) 2024 Your Company. All rights reserved.# 定义参数param (    [string]$Param1,           # 第一个参数    [string]$Param2,           # 第二个参数    [switch]$Flag1,            # 开关参数1    [switch]$Flag2,            # 开关参数2    [int]$Number,              # 数字参数    [string[]]$List,           # 列表参数    [switch]$Help              # 显示帮助信息)# 显示帮助信息function Show-Help &#123;    Write-Output &quot;Usage: script.ps1 -Param1 &lt;value&gt; -Param2 &lt;value&gt; -Flag1 -Flag2 -Number &lt;value&gt; -List &lt;value1,value2,...&gt; -Help&quot;    Write-Output &quot;&quot;    Write-Output &quot;Parameters:&quot;    Write-Output &quot;  -Param1        第一个参数&quot;    Write-Output &quot;  -Param2        第二个参数&quot;    Write-Output &quot;  -Flag1         开关参数1&quot;    Write-Output &quot;  -Flag2         开关参数2&quot;    Write-Output &quot;  -Number        数字参数&quot;    Write-Output &quot;  -List          列表参数（逗号分隔）&quot;    Write-Output &quot;  -Help          显示帮助信息&quot;&#125;# 检查是否需要显示帮助信息if ($Help) &#123;    Show-Help    exit&#125;# 处理参数if ($Param1) &#123;    Write-Output &quot;Param1: $Param1&quot;&#125;if ($Param2) &#123;    Write-Output &quot;Param2: $Param2&quot;&#125;if ($Flag1) &#123;    Write-Output &quot;Flag1 is set&quot;&#125;if ($Flag2) &#123;    Write-Output &quot;Flag2 is set&quot;&#125;if ($Number) &#123;    Write-Output &quot;Number: $Number&quot;&#125;if ($List) &#123;    Write-Output &quot;List: $($List -join &#39;, &#39;)&quot;&#125;</code></pre></div></figure><h2 id="常用的功能型脚本模板"><a href="#常用的功能型脚本模板" class="headerlink" title="常用的功能型脚本模板"></a>常用的功能型脚本模板</h2><h3 id="1-获取操作系统信息"><a href="#1-获取操作系统信息" class="headerlink" title="1. 获取操作系统信息"></a>1. 获取操作系统信息</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$os &#x3D; Get-CimInstance -ClassName Win32_OperatingSystemWrite-Output &quot;操作系统名称: $($os.Caption)&quot;Write-Output &quot;版本: $($os.Version)&quot;Write-Output &quot;安装日期: $($os.InstallDate)&quot;</code></pre></div></figure><h3 id="2-检查服务状态"><a href="#2-检查服务状态" class="headerlink" title="2. 检查服务状态"></a>2. 检查服务状态</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$serviceName &#x3D; &#39;Spooler&#39; # 打印队列服务$service &#x3D; Get-Service -Name $serviceName -ErrorAction SilentlyContinueif ($service) &#123;    Write-Output &quot;服务 &#39;$($service.Name)&#39; 当前状态: $($service.Status)&quot;&#125; else &#123;    Write-Output &quot;未找到服务 &#39;$serviceName&#39;&quot;&#125;</code></pre></div></figure><h3 id="3-创建目录并设置权限"><a href="#3-创建目录并设置权限" class="headerlink" title="3. 创建目录并设置权限"></a>3. 创建目录并设置权限</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$folderPath &#x3D; &#39;C:\Temp\NewFolder&#39;if (-not (Test-Path -Path $folderPath)) &#123;    New-Item -ItemType Directory -Path $folderPath    $acl &#x3D; Get-Acl -Path $folderPath    $rule &#x3D; New-Object System.Security.AccessControl.FileSystemAccessRule(&quot;Users&quot;, &quot;ReadAndExecute&quot;, &quot;ContainerInherit,ObjectInherit&quot;, &quot;None&quot;, &quot;Allow&quot;)    $acl.SetAccessRule($rule)    Set-Acl -Path $folderPath -AclObject $acl    Write-Output &quot;目录已创建并设置了权限&quot;&#125; else &#123;    Write-Output &quot;目录已存在&quot;&#125;</code></pre></div></figure><h3 id="4-判断变量是否为空"><a href="#4-判断变量是否为空" class="headerlink" title="4. 判断变量是否为空"></a>4. 判断变量是否为空</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$variable &#x3D; &#39;Hello World&#39;if ([string]::IsNullOrEmpty($variable)) &#123;    Write-Output &quot;变量是空的&quot;&#125; else &#123;    Write-Output &quot;变量不是空的，值为: $variable&quot;&#125;</code></pre></div></figure><h3 id="5-判断文件是否存在"><a href="#5-判断文件是否存在" class="headerlink" title="5. 判断文件是否存在"></a>5. 判断文件是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$filePath &#x3D; &#39;C:\Path\To\File.txt&#39;if (Test-Path -Path $filePath) &#123;    Write-Output &quot;文件存在&quot;&#125; else &#123;    Write-Output &quot;文件不存在&quot;&#125;</code></pre></div></figure><h3 id="6-判断网络连接"><a href="#6-判断网络连接" class="headerlink" title="6. 判断网络连接"></a>6. 判断网络连接</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$pingResult &#x3D; Test-Connection -ComputerName &#39;www.example.com&#39; -Count 1 -Quietif ($pingResult) &#123;    Write-Output &quot;网络连接成功&quot;&#125; else &#123;    Write-Output &quot;无法连接到网络&quot;&#125;</code></pre></div></figure><h3 id="7-使用-Switch-进行多条件判断"><a href="#7-使用-Switch-进行多条件判断" class="headerlink" title="7. 使用 Switch 进行多条件判断"></a>7. 使用 Switch 进行多条件判断</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$number &#x3D; 2switch ($number) &#123;    1 &#123; Write-Output &quot;数字是1&quot; &#125;    2 &#123; Write-Output &quot;数字是2&quot; &#125;    3 &#123; Write-Output &quot;数字是3&quot; &#125;    default &#123; Write-Output &quot;数字不在1, 2, 3中&quot; &#125;&#125;</code></pre></div></figure><h3 id="8-判断文件-夹-是否存在"><a href="#8-判断文件-夹-是否存在" class="headerlink" title="8. 判断文件(夹)是否存在"></a>8. 判断文件(夹)是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$filePath &#x3D; &#39;C:\Path\To\File.txt&#39;$folderPath &#x3D; &#39;C:\Path\To\Folder&#39;if (Test-Path -Path $filePath) &#123;    Write-Output &quot;文件存在&quot;&#125; else &#123;    Write-Output &quot;文件不存在&quot;&#125;if (Test-Path -Path $folderPath) &#123;    Write-Output &quot;文件夹存在&quot;&#125; else &#123;    Write-Output &quot;文件夹不存在&quot;&#125;</code></pre></div></figure><h3 id="9-判断是否为普通文件"><a href="#9-判断是否为普通文件" class="headerlink" title="9. 判断是否为普通文件"></a>9. 判断是否为普通文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$filePath &#x3D; &#39;C:\Path\To\File.txt&#39;if (Test-Path -Path $filePath -PathType Leaf) &#123;    Write-Output &quot;这是一个普通文件&quot;&#125; elseif (Test-Path -Path $filePath -PathType Container) &#123;    Write-Output &quot;这是一个文件夹&quot;&#125; else &#123;    Write-Output &quot;路径不存在&quot;&#125;</code></pre></div></figure><h3 id="10-判断变量是否为空"><a href="#10-判断变量是否为空" class="headerlink" title="10. 判断变量是否为空"></a>10. 判断变量是否为空</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$variable &#x3D; $nullif ([string]::IsNullOrEmpty($variable)) &#123;    Write-Output &quot;变量是空的&quot;&#125; else &#123;    Write-Output &quot;变量不是空的，值为: $variable&quot;&#125;</code></pre></div></figure><h3 id="11-用户输入数据"><a href="#11-用户输入数据" class="headerlink" title="11. 用户输入数据"></a>11. 用户输入数据</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ userInput &#x3D; Read-Host &quot;请输入一些文本&quot;Write-Output &quot;您输入的是: $userInput&quot;</code></pre></div></figure><h3 id="12-判断指令是否存在"><a href="#12-判断指令是否存在" class="headerlink" title="12. 判断指令是否存在"></a>12. 判断指令是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$command &#x3D; &#39;Get-Process&#39;if (Get-Command -Name $command -ErrorAction SilentlyContinue) &#123;    Write-Output &quot;命令 &#39;$command&#39; 存在&quot;&#125; else &#123;    Write-Output &quot;命令 &#39;$command&#39; 不存在&quot;&#125;</code></pre></div></figure><h3 id="13-判断关键字是否存在"><a href="#13-判断关键字是否存在" class="headerlink" title="13. 判断关键字是否存在"></a>13. 判断关键字是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$text &#x3D; &quot;这是一个测试字符串&quot;$keyword &#x3D; &quot;测试&quot;if ($text -match $keyword) &#123;    Write-Output &quot;关键字 &#39;$keyword&#39; 存在&quot;&#125; else &#123;    Write-Output &quot;关键字 &#39;$keyword&#39; 不存在&quot;&#125;</code></pre></div></figure><h3 id="14-文件夹递归处理"><a href="#14-文件夹递归处理" class="headerlink" title="14. 文件夹递归处理"></a>14. 文件夹递归处理</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$folderPath &#x3D; &#39;C:\Path\To\Folder&#39;if (Test-Path -Path $folderPath) &#123;    Get-ChildItem -Path $folderPath -Recurse | ForEach-Object &#123;        if (Test-Path -Path $_.FullName -PathType Leaf) &#123;            Write-Output &quot;文件: $($_.FullName)&quot;        &#125; else &#123;            Write-Output &quot;文件夹: $($_.FullName)&quot;        &#125;    &#125;&#125; else &#123;    Write-Output &quot;文件夹不存在&quot;&#125;</code></pre></div></figure><h3 id="15-下载文件"><a href="#15-下载文件" class="headerlink" title="15. 下载文件"></a>15. 下载文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$url &#x3D; &#39;https:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;file.zip&#39;$destination &#x3D; &#39;C:\Path\To\DownloadedFile.zip&#39;Invoke-WebRequest -Uri $url -OutFile $destinationWrite-Output &quot;文件已下载到: $destination&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转换-在macOS上转换和运行CoreML模型</title>
    <link href="/doc/934e3336.html"/>
    <url>/doc/934e3336.html</url>
    
    <content type="html"><![CDATA[<p>开源大模型很多，为了让我的小Mac能够高效的推理，故有此文。</p><span id="more"></span><h2 id="模型运行"><a href="#模型运行" class="headerlink" title="模型运行"></a>模型运行</h2><p>在 Github 上转了老半天才找到一个可供 Mac 使用的 App：<code>Mochi Diffusion</code></p><p>将的到的模型放置在<code>~/MochiDiffusion/models</code>中，即可被加载使用。</p><p>具体使用步骤非常简单，就不再赘述。</p><h2 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h2><p>目前支持的转换格式包括<code>CheckPoint</code>、<code>Diffusers</code>。转换步骤是一级一级来的，直接可以转换的是<code>Diffusers</code>，路径图如下：</p><pre><code class="mermaid">flowchart LRCheckPointDiffusersCoreMLCheckPoint --&gt; Diffusers --&gt; CoreML</code></pre><p>目前量化方面还有点问题，等待<code>apple/ml-stable-diffusion</code>修复。具体转换步骤，这里用一个脚本来介绍，在此之前请安装必要的环境：</p><ul><li>git</li><li>conda</li><li>xcode</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 脚本名称: 模型批量转换# 描述: 模型批量转换脚本# 版本: 1.0# 作者: Cikaros# 邮箱: Cikaros&lt;at&gt;qq.com# 日期: # 版权: (C) 2024 Your Company. All rights reserved.# 配置环境 当存在错误及时停止source ~&#x2F;.bash_profileset -eVERSION&#x3D;1.0PYTHON_VERSION&#x3D;3.8PYTHON_ENV_NAME&#x3D;python38ML_SD_URL&#x3D;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;ml-stable-diffusion.gitCONVERT_FILE_URL&#x3D;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;huggingface&#x2F;diffusers&#x2F;main&#x2F;scripts&#x2F;convert_original_stable_diffusion_to_diffusers.pyWORK_SPACE&#x3D;&quot;$(pwd)&quot;SAFETENSORS_MODELS_PATH&#x3D;&quot;$WORK_SPACE&#x2F;safetensors&quot;DIFFUSERS_MODELS_PATH&#x3D;&quot;$WORK_SPACE&#x2F;diffusers&quot;SPLIT_EINSUM_PATH&#x3D;&quot;$WORK_SPACE&#x2F;split-einsum&quot;FINISH_PATH&#x3D;&quot;$WORK_SPACE&#x2F;safetensors-finish&quot;ML_SD_PATH&#x3D;&quot;$WORK_SPACE&#x2F;ml-stable-diffusion&quot;CONVERT_FILE_PATH&#x3D;&quot;$WORK_SPACE&#x2F;convert_original_stable_diffusion_to_diffusers.py&quot;check() &#123;if type &quot;$1&quot; &amp;&gt;&#x2F;dev&#x2F;null; then    echo &quot;已检测到【$1】已安装。&quot;elseecho &quot;未检测到【$1】已安装，请先安装必要环境！&quot;    exit -1fi&#125;# 检查环境check_env() &#123;check gitcheck condacheck xcode-select# 检查文件夹是否存在[ ! -d &quot;$SAFETENSORS_MODELS_PATH&quot; ] &amp;&amp; mkdir -p &quot;$SAFETENSORS_MODELS_PATH&quot;[ ! -d &quot;$DIFFUSERS_MODELS_PATH&quot; ] &amp;&amp; mkdir -p &quot;$DIFFUSERS_MODELS_PATH&quot;[ ! -d &quot;$SPLIT_EINSUM_PATH&quot; ] &amp;&amp; mkdir -p &quot;$SPLIT_EINSUM_PATH&quot;[ ! -d &quot;$FINISH_PATH&quot; ] &amp;&amp; mkdir -p &quot;$FINISH_PATH&quot;echo &quot;check success!&quot;&#125;init_env() &#123;cd $WORK_SPACE#初始化环境conda env list | grep -q &quot;$PYTHON_ENV_NAME&quot; || \      conda create -y -n &quot;$PYTHON_ENV_NAME&quot; python&#x3D;$PYTHON_VERSIONconda activate $PYTHON_ENV_NAME# TODO 准备 https:&#x2F;&#x2F;github.com&#x2F;Cikaros&#x2F;ml-stable-diffusion.gitif [ ! -e $ML_SD_PATH ]; thenecho &quot;ml-stable-diffusion项目不存在，正在初始化...&quot;git clone $ML_SD_URLcd $ML_SD_PATHpip install -e .pip install omegaconf safetensorsfiif [ ! -f $CONVERT_FILE_PATH ]; thenecho &quot;CheckPoint转换脚本不存在，正在初始化...&quot;wget $CONVERT_FILE_URL - $CONVERT_FILE_PATHpip install torch diffusers transformers python_coreml_stable_diffusionficd $WORK_SPACE&#125;redo_init_env() &#123;conda remove -n $PYTHON_ENV_NAME --allrm -rf $ML_SD_PATHrm -rf $CONVERT_FILE_PATHinit_env&#125;convert() &#123;FILE_PATH&#x3D;$1FILE_NAME_WITH_EXT&#x3D;$(basename &quot;$1&quot;)FILE_NAME&#x3D;&quot;$&#123;FILE_NAME_WITH_EXT%.*&#125;&quot;DIFFUSERS_PATH&#x3D;&quot;$DIFFUSERS_MODELS_PATH&#x2F;$FILE_NAME&quot;COREML_PATH&#x3D;&quot;$SPLIT_EINSUM_PATH&#x2F;$FILE_NAME&quot;EXPORT_SPLIT_EINSUM_PATH&#x3D;$SPLIT_EINSUM_PATH&#x2F;$FILE_NAME-split-einsumif echo &quot;$FILE_NAME&quot; | grep -q &quot;XL&quot;; then# TODO CheckPoint -&gt; Diffusers    python $CONVERT_FILE_PATH \  --checkpoint_path $FILE_PATH \  --extract_ema \  --upcast_attention \  --from_safetensors \  --dump_path $DIFFUSERS_PATH \  --device cpu \  --half \  --pipeline_class_name StableDiffusionXLPipeline# TODO Diffusers -&gt; CoreMLpython -m python_coreml_stable_diffusion.torch2coreml \  --convert-text-encoder \  --convert-vae-decoder \  --convert-vae-encoder \  --convert-unet \  --model-version $DIFFUSERS_PATH \  --attention-implementation SPLIT_EINSUM \  -o $COREML_PATH \  --bundle-resources-for-swift-cli \  --xl-versionpython -m python_coreml_stable_diffusion.torch2coreml \  --convert-unet \  --unet-support-controlnet \  --model-version $DIFFUSERS_PATH \  --attention-implementation SPLIT_EINSUM \  -o $COREML_PATH \  --bundle-resources-for-swift-cli \  --xl-versionelse    python $CONVERT_FILE_PATH \  --checkpoint_path $FILE_PATH \  --extract_ema \  --upcast_attention \  --from_safetensors \  --dump_path $DIFFUSERS_PATH \  --device cpu \  --halfpython -m python_coreml_stable_diffusion.torch2coreml \  --convert-text-encoder \  --convert-vae-decoder \  --convert-vae-encoder \  --convert-unet \  --model-version $DIFFUSERS_PATH \  --attention-implementation SPLIT_EINSUM \  -o $COREML_PATH \  --bundle-resources-for-swift-clipython -m python_coreml_stable_diffusion.torch2coreml \  --convert-unet \  --unet-support-controlnet \  --model-version $DIFFUSERS_PATH \  --attention-implementation SPLIT_EINSUM \  -o $COREML_PATH \  --bundle-resources-for-swift-clifi# TODO CoreML finish[ ! -d $EXPORT_SPLIT_EINSUM_PATH ] &amp;&amp; mkdir -p $EXPORT_SPLIT_EINSUM_PATHditto &quot;$COREML_PATH&#x2F;Resources&quot; $EXPORT_SPLIT_EINSUM_PATH# TODO Cleanmv $FILE_PATH &quot;$FINISH_PATH&#x2F;&quot;rm -rf $DIFFUSERS_PATHrm -rf $COREML_PATH&#125;# 使用提示usage() &#123;echo &quot;Usage: $0 [options]&quot;echo &quot;options:&quot;echo &quot;  -h, --help       显示帮助信息&quot;echo &quot;  -v, --version    显示版本信息&quot;echo &quot;  -i, --init       初始化环境&quot;echo &quot;  -c, --convert    转换特定模型&quot;exit 1&#125;# 参数处理while [[ &quot;$#&quot; -gt 0 ]]; docase $1 in-h|--help) usage ;;-v|--version) echo &quot;Version: $VERSION&quot;; exit ;;-i|--init) redo_init_env; exit ;;-c|--convert) init_env; convert $2; exit ;;*) echo &quot;Unknown option: $1&quot;; usage ;;esacshiftdone# 无参数时的默认逻辑main() &#123;check_envinit_env# 使用 find 命令递归扫描目录及其子目录下所有的 .safetensors 文件find &quot;$SAFETENSORS_MODELS_PATH&quot; -type f -name &quot;*.safetensors&quot; | while read FILE; do    echo &quot;正在处理文件：$FILE&quot;    convert $FILEdoneecho &quot;处理完成！&quot;&#125;# 脚本入口点main &quot;$@&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pip</tag>
      
      <tag>MacOS</tag>
      
      <tag>CoreML</tag>
      
      <tag>Convert</tag>
      
      <tag>safetensors</tag>
      
      <tag>diffusers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-我在GPT偷师的日常（GPT-like模型架构）</title>
    <link href="/doc/e244b8a1.html"/>
    <url>/doc/e244b8a1.html</url>
    
    <content type="html"><![CDATA[<p>官方并未开源GPT模型的架构代码，特有此文，通过询问GPT4-mini，简单讲解了架构情况（不保证架构有效性）。</p><span id="more"></span><blockquote><p>你好</p></blockquote><p>你好！有什么我可以帮你的吗？</p><blockquote><p>Qwen2-VL是否有开源nn.Molde代码？</p></blockquote><p>Qwen-2-VL（通义千问-2视觉语言模型）的模型本身目前没有开源其底层代码，尤其是涉及到 <code>nn.Module</code> 级别的代码。</p><p>不过，阿里巴巴确实在 2023 年发布了通义千问系列模型（包括Qwen系列）的部分开源版本，尤其是在文本生成相关的领域（如Qwen-7B）。这些开源模型通常发布在 GitHub 或 Hugging Face 上，但其中以自然语言处理（NLP）模型为主，而像 Qwen-2-VL 这样的视觉语言模型尚未开源其完整代码或模型权重。</p><p>如果你想深入了解这类模型的结构，可以查看相关的论文、技术文档或者开源的同类模型。比如 Hugging Face 或 GitHub 上的一些多模态模型（如 CLIP、BLIP）的实现，它们可能有类似的 <code>nn.Module</code> 架构。</p><p>你可以随时查看阿里巴巴或其他相关平台是否有更新的开源计划。</p><blockquote><p>那GPT-4o mini呢？</p></blockquote><p>GPT-4o mini 并不是一个广泛知晓的官方模型名称。你可能指的是某个第三方发布的轻量级 GPT-4 类似模型，或者是某个开源社区发布的模型，通常以“mini”命名的模型版本往往是基于更大模型的缩小版，专为更少资源或更高效推理而设计。</p><p>目前，OpenAI 并未开源 GPT-4 的代码或模型权重，包括“mini”或其他变种版本。如果有类似名称的模型，如“GPT-4o mini”，可能是基于开源模型（例如 LLaMA、GPT-NeoX、Mistral 等）的改进版本，且这些模型通常由社区开发和发布。</p><p>如果你看到“GPT-4o mini”这样的名称，它很有可能是由某个特定社区或公司基于已有的大型语言模型（LLM）构建的。如果你对某个特定的实现感兴趣，可以提供更多信息或相关链接，我可以帮你查找更多细节。</p><blockquote><p>你可以写出GPT-4o mini 的nn.model吗？</p></blockquote><p>由于“GPT-4o mini”并不是一个官方或广泛认可的模型，我无法直接提供这个特定模型的代码。如果你指的是类似 GPT 模型的轻量版本，我可以帮助你创建一个基于典型 GPT 架构的缩小版模型代码。我们可以用 PyTorch 来实现一个轻量级的 GPT 类似模型，并且遵循 <code>nn.Module</code> 架构。</p><p>以下是一个简单的 GPT-like 模型实现，用于自然语言生成任务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Fclass GPTMini(nn.Module):    def __init__(self, vocab_size, embed_size, num_heads, num_layers, block_size, dropout&#x3D;0.1):        super(GPTMini, self).__init__()        self.embed_size &#x3D; embed_size        self.block_size &#x3D; block_size        # Token and positional embeddings        self.token_embedding &#x3D; nn.Embedding(vocab_size, embed_size)        self.position_embedding &#x3D; nn.Embedding(block_size, embed_size)                # Transformer blocks        self.blocks &#x3D; nn.ModuleList([            TransformerBlock(embed_size, num_heads, dropout)            for _ in range(num_layers)        ])        # Layer normalization and final output projection        self.ln_f &#x3D; nn.LayerNorm(embed_size)        self.fc_out &#x3D; nn.Linear(embed_size, vocab_size)    def forward(self, x):        batch_size, seq_len &#x3D; x.size()        # Token and positional embeddings        token_embeddings &#x3D; self.token_embedding(x)        position_embeddings &#x3D; self.position_embedding(torch.arange(seq_len, device&#x3D;x.device))        x &#x3D; token_embeddings + position_embeddings.unsqueeze(0)        # Pass through transformer blocks        for block in self.blocks:            x &#x3D; block(x)        # Final layer normalization and output projection        x &#x3D; self.ln_f(x)        logits &#x3D; self.fc_out(x)        return logitsclass TransformerBlock(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(TransformerBlock, self).__init__()        self.attention &#x3D; MultiHeadSelfAttention(embed_size, num_heads, dropout)        self.ln1 &#x3D; nn.LayerNorm(embed_size)        self.ln2 &#x3D; nn.LayerNorm(embed_size)        self.ffn &#x3D; nn.Sequential(            nn.Linear(embed_size, 4 * embed_size),            nn.GELU(),            nn.Linear(4 * embed_size, embed_size),            nn.Dropout(dropout),        )    def forward(self, x):        # Multi-head attention followed by residual connection and layer norm        attn_out &#x3D; self.attention(x)        x &#x3D; self.ln1(x + attn_out)        # Feedforward network followed by residual connection and layer norm        ffn_out &#x3D; self.ffn(x)        x &#x3D; self.ln2(x + ffn_out)        return xclass MultiHeadSelfAttention(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(MultiHeadSelfAttention, self).__init__()        assert embed_size % num_heads &#x3D;&#x3D; 0        self.num_heads &#x3D; num_heads        self.head_dim &#x3D; embed_size &#x2F;&#x2F; num_heads        self.scale &#x3D; self.head_dim ** -0.5        self.qkv &#x3D; nn.Linear(embed_size, embed_size * 3)        self.fc_out &#x3D; nn.Linear(embed_size, embed_size)        self.dropout &#x3D; nn.Dropout(dropout)    def forward(self, x):        batch_size, seq_len, embed_size &#x3D; x.shape        # Generate Q, K, V        qkv &#x3D; self.qkv(x)        qkv &#x3D; qkv.reshape(batch_size, seq_len, 3, self.num_heads, self.head_dim)        q, k, v &#x3D; qkv.unbind(dim&#x3D;2)        # Scaled dot-product attention        attn_weights &#x3D; (q @ k.transpose(-2, -1)) * self.scale        attn_weights &#x3D; F.softmax(attn_weights, dim&#x3D;-1)        attn_weights &#x3D; self.dropout(attn_weights)        attn_output &#x3D; attn_weights @ v        attn_output &#x3D; attn_output.transpose(1, 2).reshape(batch_size, seq_len, embed_size)        return self.fc_out(attn_output)</code></pre></div></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol><li><strong>GPTMini 类</strong>：这是一个轻量版的 GPT-like 架构，包括了基础的 token 嵌入、位置嵌入和多个 Transformer 块。</li><li><strong>TransformerBlock 类</strong>：包含了一个多头自注意力机制和一个前馈神经网络，每一层都配有残差连接和层归一化。</li><li><strong>MultiHeadSelfAttention 类</strong>：实现了标准的多头自注意力机制，使用 <code>nn.Linear</code> 生成查询（Q）、键（K）、值（V），然后计算注意力权重。</li></ol><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul><li><code>vocab_size</code>：词汇表的大小，即模型能够处理的唯一标识符的数量（词汇或字符）。</li><li><code>embed_size</code>：词嵌入的维度。</li><li><code>num_heads</code>：多头自注意力的头数。</li><li><code>num_layers</code>：Transformer 层的数量。</li><li><code>block_size</code>：输入序列的最大长度。</li><li><code>dropout</code>：使用的 dropout 比例，用于正则化防止过拟合。</li></ul><p>你可以根据具体需求调整这些参数，例如增加层数、嵌入大小等，构建适合你计算资源的“mini”版本的 GPT 模型。如果你对实现细节或优化有其他需求，也可以进一步探讨。</p><blockquote><p>GPT-like 模型跟GPT模型有什么结构上的区别？</p></blockquote><p>GPT-like 模型和原始的 GPT 模型在结构上具有很多相似之处，因为“GPT-like”通常指的是基于 GPT 架构的简化或改进模型。它们在总体设计上遵循相同的基本理念：都是基于自注意力机制（Transformer），且以生成为主要任务。但二者之间可能存在一些结构上的区别，尤其是在具体实现、优化和资源需求方面。</p><p>以下是 <strong>GPT 模型</strong> 和 <strong>GPT-like 模型</strong> 在结构上的一些可能区别：</p><h3 id="1-模型大小"><a href="#1-模型大小" class="headerlink" title="1. 模型大小"></a>1. <strong>模型大小</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>原始 GPT 模型以及后来的 GPT-2 和 GPT-3 都是大规模的模型，拥有数亿到数千亿的参数。GPT-3 有 1750 亿个参数，属于非常庞大的模型。</li><li>为了保持高质量的生成能力，GPT 模型一般使用深层的 Transformer 层和较大的嵌入维度。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型通常是简化版本，参数规模较小，目的是为了适应更少的计算资源或者更高效的推理需求。它们可以有更少的 Transformer 层、较小的嵌入维度、或者更少的注意力头数。</li><li>例如，GPT-like 模型可能只有几千万到几亿个参数（如 GPT-2 小版本、GPT-3 Ada 版），适用于设备受限的场景。</li></ul></li></ul><h3 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2. 参数设置"></a>2. <strong>参数设置</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 的嵌入维度（embedding size）较大，注意力头数较多，通常每层 Transformer 的前馈网络也较大。</li><li>GPT 使用标准的多头自注意力机制，以及大规模前馈神经网络（Feedforward Networks, FFN），每一层 Transformer 包含标准的残差连接和层归一化。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型在参数上会做出妥协。例如，可能会减少注意力头数，降低每层的嵌入维度，甚至缩减 FFN 的大小。这能减少模型的计算需求和存储开销，虽然在性能上会有所折衷。</li></ul></li></ul><h3 id="3-深度与层数"><a href="#3-深度与层数" class="headerlink" title="3. 深度与层数"></a>3. <strong>深度与层数</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 模型随着版本的更新，其层数不断增加，原始的 GPT 具有 12 层 Transformer，GPT-3 则有 96 层。</li><li>模型深度的增加使其在复杂任务上具有更好的表现，但也大幅增加了训练成本和推理时间。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型为了减少复杂度，通常会减少 Transformer 层的数量，比如 6 层、12 层甚至更少，具体取决于模型的目标和计算资源。</li><li>通过减少深度，可以显著提高训练速度和推理效率。</li></ul></li></ul><h3 id="4-输入序列长度"><a href="#4-输入序列长度" class="headerlink" title="4. 输入序列长度"></a>4. <strong>输入序列长度</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 模型通常支持较长的输入序列，例如 GPT-3 支持输入长达 2048 个 token。较长的上下文使模型在语言生成时能够捕捉到更长的依赖关系。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型可能会缩短输入序列的长度，比如限制在 512 或 1024 个 token，以此减少计算资源消耗。</li><li>对于较小规模任务或资源有限的场景，这种限制可能是可以接受的。</li></ul></li></ul><h3 id="5-优化和正则化"><a href="#5-优化和正则化" class="headerlink" title="5. 优化和正则化"></a>5. <strong>优化和正则化</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 模型使用标准的优化技术，如学习率调度、Adam 优化器、以及在层间加入 dropout 来防止过拟合。</li><li>大规模模型通常还会借助混合精度训练、梯度累计等技术来应对大规模训练的挑战。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>在 GPT-like 模型中，可能会使用类似的优化器和正则化方法，但参数的选择更加保守。例如，可能会使用更高的 dropout 率以防止小模型过拟合。</li><li>有些 GPT-like 模型甚至会通过剪枝（pruning）或量化（quantization）来进一步压缩模型的大小和加快推理速度。</li></ul></li></ul><h3 id="6-训练数据与任务设计"><a href="#6-训练数据与任务设计" class="headerlink" title="6. 训练数据与任务设计"></a>6. <strong>训练数据与任务设计</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 模型通常使用海量的预训练数据集，包括从网络上抓取的大规模文本数据。GPT-3 使用了上百 TB 的训练数据来确保模型的通用性和生成质量。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型可能不会有如此庞大的预训练数据集，而是专注于特定的领域或任务，使用更小但精炼的数据集。</li><li>这种策略可以帮助小模型在特定任务上表现得很好，尽管在通用任务上的表现可能不如大型 GPT 模型。</li></ul></li></ul><h3 id="7-推理速度和部署效率"><a href="#7-推理速度和部署效率" class="headerlink" title="7. 推理速度和部署效率"></a>7. <strong>推理速度和部署效率</strong></h3><ul><li><p><strong>GPT 模型</strong>：</p><ul><li>GPT 模型由于其庞大的规模，推理速度较慢，特别是在需要长时间生成输出或在资源受限的设备上运行时。其推理通常需要高性能 GPU 或 TPU 集群来支持。</li></ul></li><li><p><strong>GPT-like 模型</strong>：</p><ul><li>GPT-like 模型通过缩减模型规模，能够更好地适应低资源设备，并且可以在 CPU 或单个 GPU 上更高效地运行。它们专注于低延迟和快速推理，这对于移动设备或嵌入式系统等场景尤为重要。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>GPT 模型</strong> 是完整的大规模语言模型，专注于通用性和高生成质量，使用非常深的 Transformer 层和复杂的参数设置。</li><li><strong>GPT-like 模型</strong> 则是简化的 GPT 架构版本，专注于轻量化，减少模型大小、计算复杂度、以及对硬件资源的依赖。它们通常在特定任务或设备上具有较高的效率，但可能在生成质量和复杂任务上表现稍逊。</li></ul><p>GPT-like 模型通过合理的裁剪和优化，能在保持相对较好的生成效果的同时大幅降低资源需求，是高效应用的一个很好的折衷方案。</p><blockquote><p>具体来说都有哪些差异？</p></blockquote><p>GPT 模型和 GPT-like 模型之间的具体差异可以从以下几个方面深入剖析：</p><h3 id="1-模型规模"><a href="#1-模型规模" class="headerlink" title="1. 模型规模"></a>1. <strong>模型规模</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT（Generative Pre-trained Transformer）系列模型，特别是 GPT-3 和 GPT-4，是超大规模的预训练模型。以 GPT-3 为例，它有 <strong>1750 亿个参数</strong>，非常庞大，甚至需要强大的计算集群（如 TPU&#x2F;GPU）来支持训练和推理。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型是基于 GPT 架构的简化版本。它们往往减少了模型的参数规模，可能只有 <strong>数千万到数亿参数</strong>。例如，GPT-2 小版本的参数量在 <strong>1.2 亿到 3.45 亿</strong> 之间。这种缩小的规模可以显著减少内存占用和计算量。</p></li></ul><h3 id="2-层数和深度"><a href="#2-层数和深度" class="headerlink" title="2. 层数和深度"></a>2. <strong>层数和深度</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT 模型的深度随着模型的版本而不断增加。原始的 GPT 模型具有 <strong>12 层 Transformer</strong>，而 GPT-2 和 GPT-3 的 Transformer 层数大幅增加。例如：</p><ul><li>GPT-2：具有 <strong>48 层</strong>。</li><li>GPT-3：最多有 <strong>96 层</strong>。</li></ul><p>这些较深的 Transformer 层数使模型能够捕捉复杂的上下文和依赖关系。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型为了节省计算资源，通常会减少 Transformer 层的数量，可能只有 <strong>6 到 12 层</strong>，从而降低模型复杂度和运行时的计算开销。这种较浅的结构可以在一些较简单的生成任务或特定领域任务中表现良好。</p></li></ul><h3 id="3-嵌入维度（Embedding-Size）"><a href="#3-嵌入维度（Embedding-Size）" class="headerlink" title="3. 嵌入维度（Embedding Size）"></a>3. <strong>嵌入维度（Embedding Size）</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT 模型的嵌入维度非常大，通常在 <strong>768 到 12,288</strong> 之间，具体取决于模型的规模。例如，GPT-3 中嵌入维度为 <strong>12,288</strong>，这使模型能够表示丰富的语义信息。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型通常有更小的嵌入维度，可能为 <strong>256 到 768</strong>。较小的嵌入维度意味着每个词的表示相对简单，因此计算量大幅减少，但也限制了模型处理复杂语义的能力。</p></li></ul><h3 id="4-多头自注意力（Multi-Head-Self-Attention）"><a href="#4-多头自注意力（Multi-Head-Self-Attention）" class="headerlink" title="4. 多头自注意力（Multi-Head Self-Attention）"></a>4. <strong>多头自注意力（Multi-Head Self-Attention）</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT 模型采用 <strong>多头自注意力机制</strong>，其中注意力头的数量与嵌入维度成正比。例如，GPT-3 的多头注意力中有 <strong>96 个头</strong>，每个注意力头可以并行捕捉不同的上下文依赖关系。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型通常减少了注意力头的数量，可能只有 <strong>8 到 12 个头</strong>。这限制了模型能够并行处理的信息量，但同时显著减少了计算复杂度。</p></li></ul><h3 id="5-前馈神经网络（Feedforward-Network-FFN）规模"><a href="#5-前馈神经网络（Feedforward-Network-FFN）规模" class="headerlink" title="5. 前馈神经网络（Feedforward Network, FFN）规模"></a>5. <strong>前馈神经网络（Feedforward Network, FFN）规模</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>在每个 Transformer 层中，GPT 使用一个大的前馈神经网络（FFN）来进一步处理注意力输出。这个 FFN 通常有很大的维度。例如，GPT-3 中 FFN 的隐藏层大小为 <strong>4 倍嵌入维度（约 49,152）</strong>。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型中的 FFN 通常规模较小，可能为 <strong>2 倍嵌入维度</strong> 或更少。这种简化进一步减少了计算和存储开销，但在复杂生成任务中可能会丢失一些精细的处理能力。</p></li></ul><h3 id="6-序列长度（Context-Window-Size）"><a href="#6-序列长度（Context-Window-Size）" class="headerlink" title="6. 序列长度（Context Window Size）"></a>6. <strong>序列长度（Context Window Size）</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT-3 的上下文窗口长度为 <strong>2048 tokens</strong>，这允许它处理长文本并捕捉远距离的语义关系。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型通常有较小的上下文窗口，比如 <strong>512 或 1024 tokens</strong>。这使得它在处理长文本时可能表现不如完整的 GPT 模型，但在处理短文本或结构化任务时表现仍然可以接受。</p></li></ul><h3 id="7-训练数据规模"><a href="#7-训练数据规模" class="headerlink" title="7. 训练数据规模"></a>7. <strong>训练数据规模</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT-3 使用了海量数据进行预训练，约有 <strong>上百TB的数据</strong>，这使得它在各种任务上具有很强的泛化能力。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型通常使用较小的数据集进行训练，可能聚焦于特定领域（如对话、生成代码等）。虽然这限制了它的通用性，但可以针对某些任务进行精调，表现出色。</p></li></ul><h3 id="8-正则化与优化技巧"><a href="#8-正则化与优化技巧" class="headerlink" title="8. 正则化与优化技巧"></a>8. <strong>正则化与优化技巧</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>大型 GPT 模型通常使用标准的正则化技巧，如 <strong>dropout</strong>、<strong>梯度裁剪</strong> 以及 <strong>学习率调度器</strong>。此外，还使用了 <strong>混合精度训练</strong> 来加速训练，同时节省显存。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型可能会使用更多的正则化技巧，比如更高的 <strong>dropout</strong> 比率，或者更简单的优化策略，如减少批量大小（batch size）来加快训练速度和降低内存需求。</p></li></ul><h3 id="9-推理效率"><a href="#9-推理效率" class="headerlink" title="9. 推理效率"></a>9. <strong>推理效率</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT 模型的推理通常需要强大的 GPU 或 TPU 集群支持，尤其是像 GPT-3 这样的超大模型，推理时延较高，特别是在生成长文本时。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型由于规模小，推理速度相对较快，并且可以在普通的 GPU，甚至在某些轻量设备（如 CPU 或移动设备）上运行。这使得它更适合实际应用中的低延迟场景，如实时对话、嵌入式设备或边缘计算。</p></li></ul><h3 id="10-应用场景"><a href="#10-应用场景" class="headerlink" title="10. 应用场景"></a>10. <strong>应用场景</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>GPT 模型由于其规模和泛化能力，适用于广泛的任务，如自然语言生成（NLG）、机器翻译、问题解答、代码生成等。GPT-3 可以通过 prompt 编写在许多领域中获得令人印象深刻的结果。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型通常用于计算资源有限的场景，或者专门针对某个任务进行了微调。例如，在对话系统中使用轻量的 GPT-like 模型来减少推理时间，或者在移动设备上进行应用。尽管它在通用性上不如完整的 GPT 模型，但在某些专用任务上可以表现得非常高效。</p></li></ul><h3 id="11-量化和剪枝（Pruning-and-Quantization）"><a href="#11-量化和剪枝（Pruning-and-Quantization）" class="headerlink" title="11. 量化和剪枝（Pruning and Quantization）"></a>11. <strong>量化和剪枝（Pruning and Quantization）</strong></h3><ul><li><p><strong>GPT 模型</strong>：<br>完整的 GPT 模型通常不会做出过多的剪枝和量化，因为其主要用于研究和探索领域，追求性能最大化。</p></li><li><p><strong>GPT-like 模型</strong>：<br>GPT-like 模型可以通过 <strong>量化</strong>（将模型权重从浮点数转换为更低精度的表示，如 int8）或者 <strong>剪枝</strong>（移除不重要的神经元或连接）来进一步减少模型的大小和推理时间。这些技术使得模型更加高效，适合部署在资源受限的环境中。</p></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GPT 和 GPT-like 模型的关键差异在于 <strong>规模、深度、性能</strong> 和 <strong>效率</strong>。GPT 模型追求性能的最大化，通常适用于需要高生成质量的复杂任务。而 GPT-like 模型通过减小模型规模和复杂度，专注于计算资源有限的场景，在效率和实际应用中占据优势。</p><p>选择使用哪种模型，取决于任务的具体需求、计算资源的可用性以及应用场景的优先级。如果需要高性能和生成质量，GPT 模型可能更适合；如果资源有限或要求实时响应，GPT-like 模型则是更为合理的选择。</p><blockquote><p>请将GPT-like进一步改写，让它更加贴近GPT</p></blockquote><p>要将一个简化版的 <strong>GPT-like</strong> 模型改写得更加接近原始 <strong>GPT</strong> 模型，可以通过调整模型的各个组件，使其更符合 GPT 的架构特点。主要的改进方向包括增加参数规模、引入 GPT 模型中的深度结构、调整注意力机制的细节，并增强优化和正则化技术。</p><p>下面的改写将从 <strong>GPT-like</strong> 模型进一步向 <strong>GPT</strong> 模型靠拢，包括更大的模型规模、更深的层数、更复杂的前馈网络和自注意力机制。</p><h3 id="改进版-GPT-模型代码"><a href="#改进版-GPT-模型代码" class="headerlink" title="改进版 GPT 模型代码"></a>改进版 GPT 模型代码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Fclass GPT(nn.Module):    def __init__(self, vocab_size, embed_size, num_heads, num_layers, block_size, dropout&#x3D;0.1):        super(GPT, self).__init__()        self.embed_size &#x3D; embed_size        self.block_size &#x3D; block_size        # Token and positional embeddings        self.token_embedding &#x3D; nn.Embedding(vocab_size, embed_size)        self.position_embedding &#x3D; nn.Embedding(block_size, embed_size)        # Transformer blocks with larger depth        self.blocks &#x3D; nn.ModuleList([            TransformerBlock(embed_size, num_heads, dropout)            for _ in range(num_layers)        ])        # Layer normalization and final output projection        self.ln_f &#x3D; nn.LayerNorm(embed_size)        self.fc_out &#x3D; nn.Linear(embed_size, vocab_size)        # Initialize weights following GPT approach        self._init_weights()    def _init_weights(self):        for module in self.modules():            if isinstance(module, nn.Linear):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)                if module.bias is not None:                    nn.init.zeros_(module.bias)            elif isinstance(module, nn.Embedding):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)    def forward(self, x):        batch_size, seq_len &#x3D; x.size()        assert seq_len &lt;&#x3D; self.block_size, &quot;Input sequence length exceeds block size.&quot;        # Token and positional embeddings        token_embeddings &#x3D; self.token_embedding(x)        position_embeddings &#x3D; self.position_embedding(torch.arange(seq_len, device&#x3D;x.device))        x &#x3D; token_embeddings + position_embeddings.unsqueeze(0)        # Pass through transformer blocks        for block in self.blocks:            x &#x3D; block(x)        # Final layer normalization and output projection        x &#x3D; self.ln_f(x)        logits &#x3D; self.fc_out(x)        return logitsclass TransformerBlock(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(TransformerBlock, self).__init__()        self.attention &#x3D; MultiHeadSelfAttention(embed_size, num_heads, dropout)        self.ln1 &#x3D; nn.LayerNorm(embed_size)        self.ln2 &#x3D; nn.LayerNorm(embed_size)        # Larger FFN size, typically 4x of embedding size        self.ffn &#x3D; nn.Sequential(            nn.Linear(embed_size, 4 * embed_size),            nn.GELU(),  # GPT 使用 GELU 激活函数            nn.Linear(4 * embed_size, embed_size),            nn.Dropout(dropout),        )    def forward(self, x):        # Multi-head attention followed by residual connection and layer norm        attn_out &#x3D; self.attention(x)        x &#x3D; self.ln1(x + attn_out)        # Feedforward network followed by residual connection and layer norm        ffn_out &#x3D; self.ffn(x)        x &#x3D; self.ln2(x + ffn_out)        return xclass MultiHeadSelfAttention(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(MultiHeadSelfAttention, self).__init__()        assert embed_size % num_heads &#x3D;&#x3D; 0        self.num_heads &#x3D; num_heads        self.head_dim &#x3D; embed_size &#x2F;&#x2F; num_heads        self.scale &#x3D; self.head_dim ** -0.5  # GPT 中的缩放因子        self.qkv &#x3D; nn.Linear(embed_size, embed_size * 3)        self.fc_out &#x3D; nn.Linear(embed_size, embed_size)        self.dropout &#x3D; nn.Dropout(dropout)    def forward(self, x):        batch_size, seq_len, embed_size &#x3D; x.shape        # Generate Q, K, V        qkv &#x3D; self.qkv(x)        qkv &#x3D; qkv.reshape(batch_size, seq_len, 3, self.num_heads, self.head_dim)        q, k, v &#x3D; qkv.unbind(dim&#x3D;2)        # Scaled dot-product attention        attn_weights &#x3D; (q @ k.transpose(-2, -1)) * self.scale        attn_weights &#x3D; F.softmax(attn_weights, dim&#x3D;-1)        attn_weights &#x3D; self.dropout(attn_weights)        attn_output &#x3D; attn_weights @ v        attn_output &#x3D; attn_output.transpose(1, 2).reshape(batch_size, seq_len, embed_size)        return self.fc_out(attn_output)</code></pre></div></figure><h3 id="改进点分析："><a href="#改进点分析：" class="headerlink" title="改进点分析："></a>改进点分析：</h3><h4 id="1-模型规模和深度："><a href="#1-模型规模和深度：" class="headerlink" title="1. 模型规模和深度："></a>1. <strong>模型规模和深度</strong>：</h4><ul><li><strong>Embedding Size</strong>: GPT-like 模型的嵌入维度通常较小（如 256 到 768），在这里我们进一步增加嵌入维度，推荐使用更接近 GPT 的规模，例如 <strong>768 到 1024</strong> 或更大。</li><li><strong>层数</strong>: 我们增加了模型的 Transformer 层数（<code>num_layers</code>），可以调整为 <strong>12、24 或 48</strong> 层，这会让模型能够捕捉更复杂的上下文和语义。</li><li><strong>FFN 宽度</strong>: 在 GPT-like 模型中，FFN 的尺寸可能只有 2 倍的嵌入维度。我们在这里将 FFN 的中间层调整为 <strong>4 倍的嵌入维度</strong>（这是 GPT 中的标准设置），提升模型的表达能力。</li></ul><h4 id="2-注意力机制的增强："><a href="#2-注意力机制的增强：" class="headerlink" title="2. 注意力机制的增强："></a>2. <strong>注意力机制的增强</strong>：</h4><ul><li><strong>多头注意力机制</strong>： GPT 的多头注意力机制使用了多个注意力头来处理不同的上下文子集。在这里，我们确保每个注意力头的尺寸适当放大，且多头数量增加到 <strong>8 到 16 个头</strong>，这与 GPT 模型一致。</li><li><strong>缩放因子</strong>：注意力权重的缩放因子为 ( \text{head_dim}^{-0.5} )，这是 GPT 模型中的一个重要细节，帮助改善训练时的稳定性。</li></ul><h4 id="3-初始化策略："><a href="#3-初始化策略：" class="headerlink" title="3. 初始化策略："></a>3. <strong>初始化策略</strong>：</h4><ul><li>在 GPT 模型中，权重初始化非常关键。GPT 采用了高斯初始化策略（均值为 0，标准差为 0.02），我们在 <code>_init_weights()</code> 中模拟了这种初始化方式，确保模型的收敛性和稳定性。</li></ul><h4 id="4-激活函数："><a href="#4-激活函数：" class="headerlink" title="4. 激活函数："></a>4. <strong>激活函数</strong>：</h4><ul><li><strong>GELU 激活函数</strong>： GPT 模型使用 GELU（Gaussian Error Linear Unit）作为激活函数，而不是传统的 ReLU。GELU 在处理复杂语言任务时表现更佳。我们在前馈网络中加入了 GELU 激活。</li></ul><h4 id="5-正则化："><a href="#5-正则化：" class="headerlink" title="5. 正则化："></a>5. <strong>正则化</strong>：</h4><ul><li><strong>Dropout</strong>： Dropout 是 GPT 模型中用于防止过拟合的重要技术。在 GPT-like 模型中可能会使用较高的 dropout 比例，而在 GPT 中通常在 0.1 左右。我们在每个 Transformer 块中保持 0.1 的 dropout 率。</li></ul><h4 id="6-优化细节："><a href="#6-优化细节：" class="headerlink" title="6. 优化细节："></a>6. <strong>优化细节</strong>：</h4><ul><li><strong>残差连接和层归一化</strong>：在每一层 Transformer 中，GPT 模型的核心设计是先执行自注意力或 FFN，然后再加上输入（残差连接），并通过 LayerNorm 进行标准化。我们保留了这一点以确保模型的稳定性和训练效率。</li></ul><h4 id="7-序列长度和位置编码："><a href="#7-序列长度和位置编码：" class="headerlink" title="7. 序列长度和位置编码："></a>7. <strong>序列长度和位置编码</strong>：</h4><ul><li><strong>Block Size</strong>： GPT 模型支持处理长文本序列（如 1024 或 2048 tokens），我们在这里保留了这一能力。模型使用了位置编码（positional embedding）来处理序列中的位置信息。</li></ul><hr><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>通过上述改进，<strong>GPT-like 模型</strong> 被修改得更接近原始的 GPT 模型。这些修改不仅增强了模型的深度和复杂性，还提升了其在语言生成任务中的表现，尤其是在捕捉复杂语义、长程依赖以及处理大规模上下文信息方面。</p><blockquote><p>还有其他未贴近的能力吗？如果有请在上述基础上再次改写</p></blockquote><p>在基础架构之外，还有一些未贴近 GPT 模型的关键能力，特别是针对 GPT 模型的一些高级特性和优化。这些特性在 GPT-like 模型中通常是被简化或完全省略的。为了进一步贴近 GPT 模型，我们可以引入如下的改进：</p><h3 id="1-动态位置编码（Rotary-or-Learned-Positional-Encoding）"><a href="#1-动态位置编码（Rotary-or-Learned-Positional-Encoding）" class="headerlink" title="1. 动态位置编码（Rotary or Learned Positional Encoding）"></a>1. <strong>动态位置编码（Rotary or Learned Positional Encoding）</strong></h3><p>GPT-3 等模型中的位置编码不再是简单的固定的正弦余弦位置编码，而是采用了 <strong>动态位置编码</strong>（例如 Rotary Positional Embeddings, RoPE）。相比静态的位置编码，它能更好地支持长序列，并在模型泛化能力上表现出色。</p><h3 id="2-上下文扩展机制（Adaptive-Context-Lengths）"><a href="#2-上下文扩展机制（Adaptive-Context-Lengths）" class="headerlink" title="2. 上下文扩展机制（Adaptive Context Lengths）"></a>2. <strong>上下文扩展机制（Adaptive Context Lengths）</strong></h3><p>GPT-like 模型可能固定了较小的上下文窗口（如 512 tokens），而 GPT-3 等大模型具有更大的上下文窗口（如 2048 tokens），并且可以通过一些优化机制自适应地处理长文本。因此，进一步扩展上下文处理能力，使得模型能够有效应对更长的文本序列。</p><h3 id="3-混合精度训练（Mixed-Precision-Training-AMP）"><a href="#3-混合精度训练（Mixed-Precision-Training-AMP）" class="headerlink" title="3. 混合精度训练（Mixed Precision Training, AMP）"></a>3. <strong>混合精度训练（Mixed Precision Training, AMP）</strong></h3><p>GPT 模型通常采用混合精度训练，以减少显存使用、提高训练速度。引入 <strong>AMP（Automatic Mixed Precision）</strong> 可以让模型同时在浮点16位（FP16）和浮点32位（FP32）上进行计算，以减少内存需求，并提升计算效率。</p><h3 id="4-零冗余优化（ZeRO）"><a href="#4-零冗余优化（ZeRO）" class="headerlink" title="4. 零冗余优化（ZeRO）"></a>4. <strong>零冗余优化（ZeRO）</strong></h3><p>为了处理 GPT 模型的大规模参数，GPT-like 模型可以借鉴 <strong>ZeRO 优化器</strong> 来处理超大模型的训练。ZeRO 优化器通过将参数、梯度和优化状态分割到多个设备上，从而有效扩展大模型的训练能力。</p><h3 id="5-连续学习与记忆机制（Memory-Augmented-Mechanisms）"><a href="#5-连续学习与记忆机制（Memory-Augmented-Mechanisms）" class="headerlink" title="5. 连续学习与记忆机制（Memory Augmented Mechanisms）"></a>5. <strong>连续学习与记忆机制（Memory Augmented Mechanisms）</strong></h3><p>GPT 模型在设计上有潜力结合外部记忆增强机制，用于提高模型在长时间跨度或多个对话轮次上的表现。我们可以引入 <strong>记忆机制</strong>，在模型中保持并复用历史上下文信息。</p><h3 id="6-预训练与微调的高效结合（Efficient-Pretraining-and-Finetuning-Strategies）"><a href="#6-预训练与微调的高效结合（Efficient-Pretraining-and-Finetuning-Strategies）" class="headerlink" title="6. 预训练与微调的高效结合（Efficient Pretraining and Finetuning Strategies）"></a>6. <strong>预训练与微调的高效结合（Efficient Pretraining and Finetuning Strategies）</strong></h3><p>GPT-3 等模型通过海量预训练实现通用的语言理解能力，并且可以通过微调快速适应特定任务。因此，为了进一步贴近 GPT 的能力，可以引入更好的预训练策略，并支持<strong>低资源条件下的高效微调</strong>（如 <strong>LoRA</strong> 和 <strong>Adapter</strong> 技术）。</p><p>接下来，在上述基础上，进一步改写模型：</p><h3 id="改进后的-GPT-模型代码"><a href="#改进后的-GPT-模型代码" class="headerlink" title="改进后的 GPT 模型代码"></a>改进后的 GPT 模型代码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Ffrom torch.cuda.amp import autocast  # 用于混合精度训练# GPT 模型的扩展版本class GPT(nn.Module):    def __init__(self, vocab_size, embed_size, num_heads, num_layers, block_size, dropout&#x3D;0.1):        super(GPT, self).__init__()        self.embed_size &#x3D; embed_size        self.block_size &#x3D; block_size        # 动态位置编码 (RoPE)        self.token_embedding &#x3D; nn.Embedding(vocab_size, embed_size)        self.position_embedding &#x3D; nn.Parameter(torch.randn(1, block_size, embed_size))  # 学习的位置编码        # Transformer blocks        self.blocks &#x3D; nn.ModuleList([            TransformerBlock(embed_size, num_heads, dropout)            for _ in range(num_layers)        ])        # Layer norm and output projection        self.ln_f &#x3D; nn.LayerNorm(embed_size)        self.fc_out &#x3D; nn.Linear(embed_size, vocab_size)        # Initialize weights following GPT approach        self._init_weights()    def _init_weights(self):        for module in self.modules():            if isinstance(module, nn.Linear):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)                if module.bias is not None:                    nn.init.zeros_(module.bias)            elif isinstance(module, nn.Embedding):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)    # 自动混合精度训练和自适应长上下文    @autocast()      def forward(self, x, attention_mask&#x3D;None):        batch_size, seq_len &#x3D; x.size()        assert seq_len &lt;&#x3D; self.block_size, &quot;输入序列长度超出了块大小限制。&quot;        # Token 和动态位置嵌入        token_embeddings &#x3D; self.token_embedding(x)        position_embeddings &#x3D; self.position_embedding[:, :seq_len, :]        x &#x3D; token_embeddings + position_embeddings        # 通过多个 transformer block        for block in self.blocks:            x &#x3D; block(x, attention_mask)        # 最后的 LayerNorm 和输出层        x &#x3D; self.ln_f(x)        logits &#x3D; self.fc_out(x)        return logitsclass TransformerBlock(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(TransformerBlock, self).__init__()        self.attention &#x3D; MultiHeadSelfAttention(embed_size, num_heads, dropout)        self.ln1 &#x3D; nn.LayerNorm(embed_size)        self.ln2 &#x3D; nn.LayerNorm(embed_size)        # 4倍FFN结构        self.ffn &#x3D; nn.Sequential(            nn.Linear(embed_size, 4 * embed_size),            nn.GELU(),            nn.Linear(4 * embed_size, embed_size),            nn.Dropout(dropout),        )    def forward(self, x, attention_mask&#x3D;None):        # 自注意力机制带有 attention_mask        attn_out &#x3D; self.attention(x, attention_mask)        x &#x3D; self.ln1(x + attn_out)        # Feedforward network with residual connection and layer norm        ffn_out &#x3D; self.ffn(x)        x &#x3D; self.ln2(x + ffn_out)        return xclass MultiHeadSelfAttention(nn.Module):    def __init__(self, embed_size, num_heads, dropout):        super(MultiHeadSelfAttention, self).__init__()        assert embed_size % num_heads &#x3D;&#x3D; 0        self.num_heads &#x3D; num_heads        self.head_dim &#x3D; embed_size &#x2F;&#x2F; num_heads        self.scale &#x3D; self.head_dim ** -0.5        self.qkv &#x3D; nn.Linear(embed_size, embed_size * 3)        self.fc_out &#x3D; nn.Linear(embed_size, embed_size)        self.dropout &#x3D; nn.Dropout(dropout)    def forward(self, x, attention_mask&#x3D;None):        batch_size, seq_len, embed_size &#x3D; x.shape        # 生成Q, K, V        qkv &#x3D; self.qkv(x)        qkv &#x3D; qkv.reshape(batch_size, seq_len, 3, self.num_heads, self.head_dim)        q, k, v &#x3D; qkv.unbind(dim&#x3D;2)        # Scaled dot-product attention        attn_weights &#x3D; (q @ k.transpose(-2, -1)) * self.scale        if attention_mask is not None:            # 使用 mask 处理长上下文或 padding 的位置            attn_weights &#x3D; attn_weights.masked_fill(attention_mask &#x3D;&#x3D; 0, float(&#39;-inf&#39;))        attn_weights &#x3D; F.softmax(attn_weights, dim&#x3D;-1)        attn_weights &#x3D; self.dropout(attn_weights)        attn_output &#x3D; attn_weights @ v        attn_output &#x3D; attn_output.transpose(1, 2).reshape(batch_size, seq_len, embed_size)        return self.fc_out(attn_output)</code></pre></div></figure><h3 id="关键改进点："><a href="#关键改进点：" class="headerlink" title="关键改进点："></a>关键改进点：</h3><h4 id="1-动态位置编码（Rotary-or-Learned-Positional-Encoding）："><a href="#1-动态位置编码（Rotary-or-Learned-Positional-Encoding）：" class="headerlink" title="1. 动态位置编码（Rotary or Learned Positional Encoding）："></a>1. <strong>动态位置编码（Rotary or Learned Positional Encoding）</strong>：</h4><ul><li>将固定的正弦&#x2F;余弦位置编码替换为 <strong>学习型位置编码</strong>，通过 <code>nn.Parameter</code> 让模型能够在训练过程中优化这些位置信息，特别是在处理长序列时更加灵活。</li></ul><h4 id="2-自适应上下文处理："><a href="#2-自适应上下文处理：" class="headerlink" title="2. 自适应上下文处理："></a>2. <strong>自适应上下文处理</strong>：</h4><ul><li>引入 <strong>attention mask</strong> 来帮助模型处理更长的上下文或处理文本中的 padding。这能够提高模型在长序列任务中的表现，并且更贴近 GPT 模型在上下文扩展能力上的处理方式。</li></ul><h4 id="3-混合精度训练（AMP）："><a href="#3-混合精度训练（AMP）：" class="headerlink" title="3. 混合精度训练（AMP）："></a>3. <strong>混合精度训练（AMP）</strong>：</h4><ul><li>在 <code>forward()</code> 函数中引入了 <strong>混合精度训练</strong>，通过 <code>@autocast()</code> 来自动处理精度问题。混合精度能够提高训练效率，减少显存需求，这是 GPT 模型在大规模训练中常用的技巧。</li></ul><h4 id="4-记忆增强（Memory-Augmented-Attention）："><a href="#4-记忆增强（Memory-Augmented-Attention）：" class="headerlink" title="4. 记忆增强（Memory-Augmented Attention）："></a>4. <strong>记忆增强（Memory-Augmented Attention）</strong>：</h4><ul><li>虽然未在代码中具体实现，但通过 <code>attention_mask</code> 和 Transformer 结构，我们可以进一步引入外部记忆机制（如缓存过去的上下文信息），这是 GPT-3 在长对话或连续生成任务中能保持一致性的一个潜在方向。</li></ul><h4 id="5-高效预训练和微调支持："><a href="#5-高效预训练和微调支持：" class="headerlink" title="5. 高效预训练和微调支持："></a>5. <strong>高效预训练和微调支持</strong>：</h4><ul><li>此外，虽然在代码中未展示，但该架构可以集成 <strong>LoRA（Low-Rank Adaptation）</strong> 或 <strong>Adapter Layers</strong> 来支持高效的微调，这些方法允许模型在保持预训练参数不变的前提下，专门微调少量的参数以适应特定任务。这是 GPT-3 在任务迁移时的重要能力。</li></ul><hr><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>通过这些改进，这个模型已经极大程度上接近了 GPT 模型的完整能力，包括动态位置编码、上下文扩展、自适应注意力机制和混合精度训练等。同时，它也为进一步的高效微调、记忆增强机制和大规模预训练提供了基础。</p><blockquote><p>刚刚说到，部分功能并为在代码中实现，接下来请继续完善代码，将未实现的代码完整的实现出来</p></blockquote><p>为进一步完善刚才提到但尚未实现的功能，接下来我们将实现：</p><ol><li><p><strong>记忆增强机制（Memory-Augmented Mechanisms）</strong>：允许模型缓存过去的上下文信息，以处理更长时间跨度的任务。我们可以通过保留之前的注意力输出或状态向量，实现“记忆”能力。</p></li><li><p><strong>高效预训练和微调支持</strong>：引入 <strong>LoRA</strong>（Low-Rank Adaptation）或 <strong>Adapter Layers</strong>，它们允许我们仅微调一部分参数，从而在保持预训练模型的参数不变的情况下适应新任务。</p></li></ol><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><ul><li><p><strong>记忆增强机制</strong>：通过维护一个缓存，用于保存之前的注意力输出或隐藏状态，从而可以在长文本序列或者连续对话中复用之前的上下文信息。这样模型可以通过读取缓存，实现“记忆”能力。</p></li><li><p><strong>LoRA 微调</strong>：通过在注意力模块中引入低秩矩阵分解来适应少量参数更新，从而只在低秩空间中进行微调，保持大部分模型参数不变。</p></li></ul><h3 id="完整实现的代码："><a href="#完整实现的代码：" class="headerlink" title="完整实现的代码："></a>完整实现的代码：</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Ffrom torch.cuda.amp import autocast# GPT 模型的最终扩展版本class GPT(nn.Module):    def __init__(self, vocab_size, embed_size, num_heads, num_layers, block_size, dropout&#x3D;0.1, use_memory&#x3D;False):        super(GPT, self).__init__()        self.embed_size &#x3D; embed_size        self.block_size &#x3D; block_size        self.use_memory &#x3D; use_memory  # 控制是否使用记忆增强机制        # 动态位置编码 (RoPE)        self.token_embedding &#x3D; nn.Embedding(vocab_size, embed_size)        self.position_embedding &#x3D; nn.Parameter(torch.randn(1, block_size, embed_size))  # 学习的位置编码        # Transformer blocks        self.blocks &#x3D; nn.ModuleList([            TransformerBlock(embed_size, num_heads, dropout, use_memory)            for _ in range(num_layers)        ])        # Layer norm and output projection        self.ln_f &#x3D; nn.LayerNorm(embed_size)        self.fc_out &#x3D; nn.Linear(embed_size, vocab_size)        # Initialize weights following GPT approach        self._init_weights()        # 用于保存之前的隐藏状态，形成“记忆”        self.past_hidden_states &#x3D; None    def _init_weights(self):        for module in self.modules():            if isinstance(module, nn.Linear):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)                if module.bias is not None:                    nn.init.zeros_(module.bias)            elif isinstance(module, nn.Embedding):                nn.init.normal_(module.weight, mean&#x3D;0.0, std&#x3D;0.02)    # 自动混合精度训练和自适应长上下文    @autocast()      def forward(self, x, attention_mask&#x3D;None, use_cache&#x3D;False):        batch_size, seq_len &#x3D; x.size()        assert seq_len &lt;&#x3D; self.block_size, &quot;输入序列长度超出了块大小限制。&quot;        # Token 和动态位置嵌入        token_embeddings &#x3D; self.token_embedding(x)        position_embeddings &#x3D; self.position_embedding[:, :seq_len, :]        x &#x3D; token_embeddings + position_embeddings        # 记忆增强机制：合并之前的隐藏状态        if self.use_memory and self.past_hidden_states is not None:            # 将过去的隐藏状态与当前输入拼接起来            x &#x3D; torch.cat((self.past_hidden_states, x), dim&#x3D;1)            seq_len &#x3D; x.size(1)        # 通过多个 transformer block        for block in self.blocks:            x &#x3D; block(x, attention_mask)        # 最后的 LayerNorm 和输出层        x &#x3D; self.ln_f(x)        logits &#x3D; self.fc_out(x)        if use_cache:  # 保存当前的隐藏状态，供后续调用            self.past_hidden_states &#x3D; x.detach()        return logitsclass TransformerBlock(nn.Module):    def __init__(self, embed_size, num_heads, dropout, use_memory&#x3D;False):        super(TransformerBlock, self).__init__()        self.attention &#x3D; MultiHeadSelfAttention(embed_size, num_heads, dropout, use_memory)        self.ln1 &#x3D; nn.LayerNorm(embed_size)        self.ln2 &#x3D; nn.LayerNorm(embed_size)        # 4倍FFN结构        self.ffn &#x3D; nn.Sequential(            nn.Linear(embed_size, 4 * embed_size),            nn.GELU(),            nn.Linear(4 * embed_size, embed_size),            nn.Dropout(dropout),        )    def forward(self, x, attention_mask&#x3D;None):        # 自注意力机制带有 attention_mask        attn_out &#x3D; self.attention(x, attention_mask)        x &#x3D; self.ln1(x + attn_out)        # Feedforward network with residual connection and layer norm        ffn_out &#x3D; self.ffn(x)        x &#x3D; self.ln2(x + ffn_out)        return xclass MultiHeadSelfAttention(nn.Module):    def __init__(self, embed_size, num_heads, dropout, use_memory&#x3D;False):        super(MultiHeadSelfAttention, self).__init__()        assert embed_size % num_heads &#x3D;&#x3D; 0        self.num_heads &#x3D; num_heads        self.head_dim &#x3D; embed_size &#x2F;&#x2F; num_heads        self.scale &#x3D; self.head_dim ** -0.5        self.use_memory &#x3D; use_memory  # 是否使用记忆增强机制        self.qkv &#x3D; nn.Linear(embed_size, embed_size * 3)        self.fc_out &#x3D; nn.Linear(embed_size, embed_size)        self.dropout &#x3D; nn.Dropout(dropout)        # LoRA 相关参数        self.lora_r &#x3D; 4  # LoRA 低秩矩阵的秩        self.lora_down &#x3D; nn.Linear(embed_size, self.lora_r, bias&#x3D;False)        self.lora_up &#x3D; nn.Linear(self.lora_r, embed_size, bias&#x3D;False)        nn.init.zeros_(self.lora_down.weight)        nn.init.zeros_(self.lora_up.weight)    def forward(self, x, attention_mask&#x3D;None):        batch_size, seq_len, embed_size &#x3D; x.shape        # 生成Q, K, V        qkv &#x3D; self.qkv(x)        qkv &#x3D; qkv.reshape(batch_size, seq_len, 3, self.num_heads, self.head_dim)        q, k, v &#x3D; qkv.unbind(dim&#x3D;2)        # Scaled dot-product attention        attn_weights &#x3D; (q @ k.transpose(-2, -1)) * self.scale        if attention_mask is not None:            # 使用 mask 处理长上下文或 padding 的位置            attn_weights &#x3D; attn_weights.masked_fill(attention_mask &#x3D;&#x3D; 0, float(&#39;-inf&#39;))        attn_weights &#x3D; F.softmax(attn_weights, dim&#x3D;-1)        attn_weights &#x3D; self.dropout(attn_weights)        attn_output &#x3D; attn_weights @ v        attn_output &#x3D; attn_output.transpose(1, 2).reshape(batch_size, seq_len, embed_size)        # LoRA 的权重更新        if self.use_memory:            lora_out &#x3D; self.lora_up(self.lora_down(attn_output))  # 仅微调低秩矩阵            attn_output &#x3D; attn_output + lora_out  # 将 LoRA 输出与原始输出相加        return self.fc_out(attn_output)</code></pre></div></figure><h3 id="新增的功能说明："><a href="#新增的功能说明：" class="headerlink" title="新增的功能说明："></a>新增的功能说明：</h3><h4 id="1-记忆增强机制（Memory-Augmented-Mechanisms）："><a href="#1-记忆增强机制（Memory-Augmented-Mechanisms）：" class="headerlink" title="1. 记忆增强机制（Memory-Augmented Mechanisms）："></a>1. <strong>记忆增强机制（Memory-Augmented Mechanisms）</strong>：</h4><ul><li><p><strong>缓存机制</strong>：在 <code>GPT</code> 类中增加了 <code>self.past_hidden_states</code> 用于保存过去的隐藏状态。在模型进行多轮对话或处理长序列任务时，可以通过 <code>use_cache=True</code> 来缓存当前的隐藏状态。模型下次调用时，缓存的隐藏状态会与新输入拼接，形成一个增强的上下文，这样模型可以“记住”之前的内容。</p></li><li><p>在 <code>forward()</code> 函数中，我们通过 <code>torch.cat()</code> 将过去的隐藏状态与当前输入拼接，模型可以处理更长的上下文，特别适用于对话生成等任务。</p></li></ul><h4 id="2-LoRA-微调（Low-Rank-Adaptation）："><a href="#2-LoRA-微调（Low-Rank-Adaptation）：" class="headerlink" title="2. LoRA 微调（Low-Rank Adaptation）："></a>2. <strong>LoRA 微调（Low-Rank Adaptation）</strong>：</h4><ul><li><p><strong>LoRA（低秩矩阵分解）</strong> 是一种微调技术，它通过引入低秩矩阵来减少参数更新的数量。在 <code>MultiHeadSelfAttention</code> 类中，我们加入了 <code>LoRA</code> 相关的两个线性层 <code>lora_down</code> 和 <code>lora_up</code>。这些层负责将注意力输出降维到一个较小的子空间，再通过低秩矩阵恢复回原始维度，并将结果与原始输出相加。</p></li><li><p><strong>微调优势</strong>：通过这种方法，模型可以在不更新全部参数的情况下，通过更新少量的 LoRA 参数，适应不同的任务。这种方法不仅降低了训练成本，也提高了模型在新任务上的适应能力。</p></li></ul><h4 id="3-高效预训练和微调支持："><a href="#3-高效预训练和微调支持：" class="headerlink" title="3. 高效预训练和微调支持："></a>3. <strong>高效预训练和微调支持</strong>：</h4><ul><li>我们通过 LoRA 实现了高效微调，LoRA 的实现允许模型仅对注意力输出进行低秩分解的调整，而不是对整个模型的大规模参数进行微调。这使得在处理特定任务时，只需更新少量的参数，从而提高微调效率。</li></ul><hr><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>我们通过添加<strong>记忆增强机制</strong>和<strong>LoRA 微调</strong>，进一步完善了模型，使其能够处理更复杂的任务，包括长时间跨度的上下文记忆和高效微调。这使得模型不仅在架构上与 GPT 更加贴近，同时也在性能上具备了 GPT 模型的部分高级特性，如低资源的任务迁移能力与记忆增强的多轮对话能力。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>人工智能</tag>
      
      <tag>神经网络</tag>
      
      <tag>GPT架构</tag>
      
      <tag>nn.Model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微调-利用MLX在macOS上微调模型</title>
    <link href="/doc/f39e1255.html"/>
    <url>/doc/f39e1255.html</url>
    
    <content type="html"><![CDATA[<p>开源大模型很多，但终究还是找不到自己想要或者说适配业务的模型，因此就需要我们自己去进行模型微调。</p><span id="more"></span><p>本篇以开源模型<code>openchat</code>为例，使用<code>MLX</code>进行<code>lora</code>微调。</p><p>微调基本步骤如下：</p><ol><li>下载模型</li><li>训练数据收集、清洗、整理</li><li>训练lora</li><li>测试先后变化</li><li>导出模型</li></ol><h2 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h2><p>有很多方式可以下载，这里就不限制各位的思维，只提供💡思路和⚠️注意事项。</p><ol><li>注册 <code>huggingface hub</code> 账号，生成<code>Access Token</code>.</li><li>使用官方或三方工具下载对应模型(作者使用的是<a href="https://pytorch.ac.cn/torchtune/0.2/install.html"><code>tune</code></a>,仅供参考)</li><li>验证模型是否一致</li></ol><h2 id="训练数据准备"><a href="#训练数据准备" class="headerlink" title="训练数据准备"></a>训练数据准备</h2><p>数据可以从网上下载，也可内部准备，最终需要将数据格式化为如下形式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;prompt&quot;:&quot;...&quot;,&quot;completion&quot;:&quot;...&quot;&#125;</code></pre></div></figure><blockquote><p>当然数据类型还包含其他的格式，具体请到参考文献<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Fine-Tuning with LoRA or QLoRA 2](https://github.com/ml-explore/mlx-examples/blob/main/llms/mlx_lm/LORA.md)">[5]</span></a></sup>去查看。</p></blockquote><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>准备合适的工作环境，以下列目录结构为例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── adapters 训练后的模型存放位置│   ├── adapter_config.json│   └── adapters.safetensors├── datasets 训练数据│   ├── test.jsonl│   ├── train.jsonl│   └── valid.jsonl├── openchat 下载好的模型│   └── openchat-3.6-8b-20240522├── requirements.txt└── venv</code></pre></div></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># --model - 模型# --data data - 训练数据# --batch-size 4 - 批处理次数# --num-layers 16 - lora 层号# --iters 50 - 学习迭代次数python -m mlx_lm.lora \  --model openchat&#x2F;openchat-3.6-8b-20240522 \  --data data \  --train \  --batch-size 4\  --num-layers 16\  --iters 50</code></pre></div></figure><h3 id="评估测试"><a href="#评估测试" class="headerlink" title="评估测试"></a>评估测试</h3><h4 id="训练前"><a href="#训练前" class="headerlink" title="训练前"></a>训练前</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -m mlx_lm.generate \--model openchat&#x2F;openchat-3.6-8b-20240522 \--max-tokens 500 \--prompt &quot;List all transactions and customers from the &#39;Africa&#39; region.&quot;</code></pre></div></figure><h4 id="训练后"><a href="#训练后" class="headerlink" title="训练后"></a>训练后</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -m mlx_lm.generate \--model openchat&#x2F;openchat-3.6-8b-20240522 \--max-tokens 500 \--prompt &quot;List all transactions and customers from the &#39;Africa&#39; region.&quot; \--adapter-path adapters</code></pre></div></figure><h3 id="合并模型"><a href="#合并模型" class="headerlink" title="合并模型"></a>合并模型</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># --model - 模型# --adapter-path adapters - lora适配模型# --save-path models&#x2F;effectz-sql - 新模型路径# --de-quantize - 如需后续转换为GGUF格式的模型请开启此标记python -m mlx_lm.fuse \    --model mistralai&#x2F;Mistral-7B-Instruct-v0.2 \    --adapter-path adapters \    --save-path models&#x2F;effectz-sql \    --de-quantize</code></pre></div></figure><h3 id="构建GGUF"><a href="#构建GGUF" class="headerlink" title="构建GGUF"></a>构建GGUF</h3><p>Github上有大佬们研制的<a href="https://github.com/ggerganov/llama.cpp.git"><code>llama.cpp</code></a>项目，可通过它来实现GGUF的转换，需要请自行钻研。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.atyun.com/59991.html">使用MLX在macOS上通过LLM微调构建自己的LLM</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/ggerganov/llama.cpp.git">ggerganov&#x2F;llama.cpp</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/ml-explore/mlx-examples.git">ml-explore&#x2F;mlx-examples</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/ml-explore/mlx-examples/blob/main/lora/README.md">Fine-Tuning with LoRA or QLoRA 1</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://github.com/ml-explore/mlx-examples/blob/main/llms/mlx_lm/LORA.md">Fine-Tuning with LoRA or QLoRA 2</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pip</tag>
      
      <tag>MLX</tag>
      
      <tag>MacOS</tag>
      
      <tag>微调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记-操作系统页式虚拟存储管理</title>
    <link href="/doc/29a8a074.html"/>
    <url>/doc/29a8a074.html</url>
    
    <content type="html"><![CDATA[<p>分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，并以页面为单位进行分配。</p><span id="more"></span><p>从现有页设计中，构思一种进阶的页面调度算法：</p><ol><li>假想页面调度算法</li></ol><ul><li>实页：实际被访问的页</li><li>虚页：被访问页相邻两侧的页</li><li>加载：加载被访问的页，并标记为【实页】，同时加载该【实页】的【虚页】。</li><li>访问：每次访问页时，计算该页的访问频率，若当前页为【虚页】，则标记为【实页】；当访问某个不存在的页时，触法【加载】中断；</li><li>释放：内存不足时，优先释放【虚页】，若不存在【虚页】或释放后内存仍然不足时，释放使用频率最低的【实页】</li><li>结束：完全释放进程相关的所有页</li></ul>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>OS</tag>
      
      <tag>页</tag>
      
      <tag>虚拟存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu为APT设置代理</title>
    <link href="/doc/d9701077.html"/>
    <url>/doc/d9701077.html</url>
    
    <content type="html"><![CDATA[<p>一般情况下，<code>apt</code>有两种设置代理方法： </p><ul><li>设置环境变量</li><li>针对<code>apt</code>设置代理</li></ul><h2 id="APT代理配置"><a href="#APT代理配置" class="headerlink" title="APT代理配置"></a>APT代理配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># vim &#x2F;etc&#x2F;apt &#x2F;apt.conf.d&#x2F;10proxyAcquire::http::Proxy &quot;http:&#x2F;&#x2F;user:pwd@192.168.1.1:7890&quot;;# orAcquire::socks::Proxy &quot;socks5:&#x2F;&#x2F;user:pwd@192.168.1.1:7890&quot;;</code></pre></div></figure><blockquote><p>若仅单次使用时设置代理，请执行<code>apt -o Acquire::socks::proxy=&quot;socks5://127.0.0.1:7890/&quot; update</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Proxy</tag>
      
      <tag>apt</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socks5服务-Dante.</title>
    <link href="/doc/36644d.html"/>
    <url>/doc/36644d.html</url>
    
    <content type="html"><![CDATA[<p>Socks5协议是一款广泛使用的代理协议。</p><span id="more"></span><p>它在使用TCP&#x2F;IP协议通讯的客户端和服务器之间扮演一个中介角色，使得内部网中的客户端变得能够访问Internet网中的服务器，或者使C&#x2F;S（Client和Server）之间的通讯更加安全。SOCKS5 代理服务器通过将客户端发来的请求转发给真正的目标服务器， 模拟了一个客户端请求操作。在这里，客户端和SOCKS5代理服务器之间也是通过TCP&#x2F;IP协议进行通讯，客户端将原本要发送给真正服务器的请求先发送给SOCKS5服务器，然后SOCKS5服务器再将请求转发给真正的服务器。</p><h2 id="Socks5代理优点"><a href="#Socks5代理优点" class="headerlink" title="Socks5代理优点"></a>Socks5代理优点</h2><h3 id="1）绕过互联网块"><a href="#1）绕过互联网块" class="headerlink" title="1）绕过互联网块"></a>1）绕过互联网块</h3><p>由于代理服务器充设备和互联网之间的中继，因此它们可以轻松绕过互联网块。例如，如果客户端IP被某个网站列入黑名单（或者使用VPN并且其服务器IP已被列入黑名单），则可以通过SOCKS5代理路由客户端的流量，从而绕过此块。但是，它无法规避国家防火墙，因为大多数防火墙都使用深度数据包检测（DPI）。这意味着客户端的ISP在到达网站之前就已经阻止了客户端的流量。</p><h3 id="2）没有程序，协议或流量限制"><a href="#2）没有程序，协议或流量限制" class="headerlink" title="2）没有程序，协议或流量限制"></a>2）没有程序，协议或流量限制</h3><p>与只能解释和使用HTTP和HTTPS网页的HTTP代理不同，SOCKS5代理可以处理任何流量。HTTP代理是通常为特定协议设计的高级代理。虽然这意味着可以获得更好的连接速度，但它们并不像SOCKS代理那样灵活和安全。 SOCKS代理是低级代理，可以处理任何程序或协议以及任何流量。</p><h3 id="3）更快，更可靠的连接"><a href="#3）更快，更可靠的连接" class="headerlink" title="3）更快，更可靠的连接"></a>3）更快，更可靠的连接</h3><p> 与仅使用TCP协议的前代产品不同，SOCKS5代理服务器可以使用UDP协议，确保可靠的连接和高效的性能。TCP互联网协议在客户端和服务器之间形成连接，确保所有数据包从一端到达另一端。它需要将内容拟合为固定格式，以便可以轻松传输。另一方面，UDP不关注来自客户端或服务器的所有数据包是否到达另一方以及它们是否以相同的顺序传输。 UDP不会浪费时间将数据包转换为固定包流。因此，有了这些UDP，SOCKS5可以提供更快的速度和可靠的连接。</p><h3 id="4）错误减少，整体性能提升"><a href="#4）错误减少，整体性能提升" class="headerlink" title="4）错误减少，整体性能提升"></a>4）错误减少，整体性能提升</h3><p>许多其他代理重写数据包标头。因此，错误路由或错误标记数据的可能性很高。但SOCKS5代理服务器不会重写数据包标头，因此错误的可能性较低。由于错误少得多，性能会自动提高。但是，这会以客户端的隐私和安全为代价，因为数据包标头包含客户端的个人信息，并且可以轻松识别。</p><h3 id="5）在P2P平台上表现更好"><a href="#5）在P2P平台上表现更好" class="headerlink" title="5）在P2P平台上表现更好"></a>5）在P2P平台上表现更好</h3><p>SOCKS5比其他代理更快，因为它传输较小的数据包。因此，它提供更快的下载速度，这就是许多用户使用它连接到P2P共享网站和平台的原因。</p><blockquote><p>上述介绍来自CSDN：<a href="https://blog.csdn.net/CZD__CZD/article/details/120493190">https://blog.csdn.net/CZD__CZD/article/details/120493190</a></p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt updateapt install dante-server</code></pre></div></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;danted.conf &lt;&lt;EOFlogoutput: sysloginternal: 0.0.0.0 port&#x3D;7890external: ens18#验证账户：username  不验证账户：nonemethod: noneuser.privileged: rootuser.notprivileged: nobodyextension: bindclient pass &#123;  from: 0.0.0.0&#x2F;0 to: 0.0.0.0&#x2F;0  log: connect disconnect error&#125;pass &#123;  from: 0.0.0.0&#x2F;0 to: 0.0.0.0&#x2F;0  command: bind  log: connect disconnect error&#125;pass &#123;  from: 0.0.0.0&#x2F;0 to: 0.0.0.0&#x2F;0  command: bindreply udpreply  log: connect error&#125;pass &#123;  from: 0.0.0.0&#x2F;0 to: 0.0.0.0&#x2F;0 port 1-65535  protocol: tcp udp&#125;pass &#123;  from: 0.0.0.0&#x2F;0 to: 0.0.0.0&#x2F;0 port 1-65535  command: udpassociate&#125;EOF</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Socks</tag>
      
      <tag>代理服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本模版</title>
    <link href="/doc/e7dab5c2.html"/>
    <url>/doc/e7dab5c2.html</url>
    
    <content type="html"><![CDATA[<p>最近业务中常常需要编写一些脚本，故有此文。</p><span id="more"></span><h2 id="统一模版"><a href="#统一模版" class="headerlink" title="统一模版"></a>统一模版</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 脚本名称: &lt;脚本名称&gt;# 描述: &lt;脚本描述&gt;# 版本: &lt;版本&gt;# 作者: Cikaros# 邮箱: Cikaros&lt;at&gt;qq.com# 日期: &lt;日期&gt;# 版权: (C) 2024 Your Company. All rights reserved.# 配置环境 与下述内容反之set +e# 配置环境 当存在错误及时停止set -eVERSION&#x3D;1.0...# 使用提示usage() &#123;  echo &quot;Usage: $0 [options]&quot;  echo &quot;options:&quot;  echo &quot;  -h, --help       显示帮助信息&quot;  echo &quot;  -v, --version    显示版本信息&quot;  exit 1&#125;# 参数处理while [[ &quot;$#&quot; -gt 0 ]]; do  case $1 in    -h|--help) usage ;;    -v|--version) echo &quot;Version: $VERSION&quot;; exit ;;    *) echo &quot;Unknown option: $1&quot;; usage ;;  esac  shiftdone# 无参数时的默认逻辑main() &#123;  echo &quot;default code&quot;&#125;# 脚本入口点main &quot;$@&quot;</code></pre></div></figure><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="判断文件-夹-是否存在"><a href="#判断文件-夹-是否存在" class="headerlink" title="判断文件(夹)是否存在"></a>判断文件(夹)是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ -e &quot;&#x2F;path&#x2F;to&#x2F;file&#x2F;or&#x2F;dir&quot; ]; then    echo &quot;存在&quot;else    echo &quot;不存在&quot;fi</code></pre></div></figure><p>不存在则创建：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ ! -d &quot;&#x2F;path&#x2F;to&#x2F;dir&quot; ] &amp;&amp; mkdir -p &quot;&#x2F;path&#x2F;to&#x2F;dir&quot;</code></pre></div></figure><h3 id="判断是否为普通文件"><a href="#判断是否为普通文件" class="headerlink" title="判断是否为普通文件"></a>判断是否为普通文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ -f &quot;&#x2F;path&#x2F;to&#x2F;file&#x2F;or&#x2F;dir&quot; ]; then    echo &quot;是&quot;else    echo &quot;不是&quot;fi</code></pre></div></figure><h3 id="判断变量是否为空"><a href="#判断变量是否为空" class="headerlink" title="判断变量是否为空"></a>判断变量是否为空</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ -z &quot;$VAR&quot; ]; then    echo &quot;为空&quot;else    echo &quot;有值&quot;fi</code></pre></div></figure><h3 id="用户输入数据"><a href="#用户输入数据" class="headerlink" title="用户输入数据"></a>用户输入数据</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#       提示信息   变量接收read -p &quot;提示信息&quot; VAR</code></pre></div></figure><h3 id="判断指令是否存在"><a href="#判断指令是否存在" class="headerlink" title="判断指令是否存在"></a>判断指令是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if type &quot;command&quot; &amp;&gt;&#x2F;dev&#x2F;null; then    echo &quot;command 存在&quot;else    echo &quot;command 不存在&quot;fi</code></pre></div></figure><h3 id="判断关键字是否存在"><a href="#判断关键字是否存在" class="headerlink" title="判断关键字是否存在"></a>判断关键字是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if echo &quot;$FILE_NAME&quot; | grep -q &quot;XL&quot;; then    ...else    ...fi</code></pre></div></figure><h3 id="文件夹递归处理"><a href="#文件夹递归处理" class="headerlink" title="文件夹递归处理"></a>文件夹递归处理</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find &quot;&#x2F;path&#x2F;to&#x2F;dir&quot; -type f -name &quot;*.txt&quot; | while read FILE_PATH; do    echo &quot;正在处理文件：$FILE_PATH&quot;    FILE_NAME_WITH_EXT&#x3D;$(basename &quot;$1&quot;)FILE_NAME&#x3D;&quot;$&#123;FILE_NAME_WITH_EXT%.*&#125;&quot;    #TODOdone</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-CPU、GPU与NPU</title>
    <link href="/doc/2426c697.html"/>
    <url>/doc/2426c697.html</url>
    
    <content type="html"><![CDATA[<h1 id="CPU、GPU与NPU"><a href="#CPU、GPU与NPU" class="headerlink" title="CPU、GPU与NPU"></a>CPU、GPU与NPU</h1><p>CPU（Central Processing Unit，中央处理单元）是计算机的主要处理器，负责执行程序指令、处理数据等。</p><ul><li>用途：CPU是计算机的大脑，负责执行程序指令、处理数据等通用计算任务。</li><li>设计特点：CPU拥有较少的但功能强大的核心，它们擅长处理复杂的任务，如分支预测、条件语句和顺序执行等。</li><li>优化方向：CPU优化了单线程性能和多任务处理能力，适合需要高逻辑性和条件判断的算法。</li><li>应用场景：适用于桌面计算机、服务器、移动设备等广泛的应用场景。</li></ul><p>GPU（Graphics Processing Unit，图形处理单元）最初设计用于处理图形和图像渲染任务，但随着技术的发展，GPU也被用于执行并行计算任务，特别是在科学计算和机器学习领域。</p><ul><li>用途：最初设计用于处理图形和图像渲染任务，现代GPU也被用于执行并行计算任务，特别是在科学计算和机器学习领域。</li><li>设计特点：GPU拥有大量的小核心，擅长同时处理大量相似的计算任务，如图形渲染中的像素处理。</li><li>优化方向：GPU优化了并行处理能力和高内存带宽，适合执行大量数据的并行操作。</li><li>应用场景：适用于需要大量图形处理的游戏、3D渲染、视频编辑，以及需要大规模并行计算的深度学习、数据分析等。</li></ul><p>NPU（Neural Processing Unit，神经网络处理单元）是一种专门为执行机器学习任务而设计的处理器。它通常用于加速深度学习算法，如卷积神经网络（CNN）和循环神经网络（RNN）等。</p><ul><li>用途：专门为执行机器学习任务，尤其是深度学习算法而设计的处理器。</li><li>设计特点：NPU针对深度学习中的数学运算（如矩阵乘法）进行了优化，它们通常具有高度并行的数据流架构。</li><li>优化方向：NPU优化了深度学习算法的执行速度和能效比，通过减少数据移动和提高计算效率来提升性能。</li><li>应用场景：适用于需要进行大量深度学习推理和训练的场景，如智能手机、智能摄像头、自动驾驶汽车和专用AI服务器等。</li></ul><h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><ul><li>核心数量：CPU核心数量较少，GPU核心数量较多，NPU则有大量专用的处理单元。</li><li>计算能力：CPU擅长复杂的逻辑计算，GPU适合并行处理大量数据，NPU则专注于高效执行深度学习算法。</li><li>能效比：NPU通常在执行AI任务时具有更高的能效比，GPU在图形处理和并行计算方面表现优异，而CPU则在综合性能和能效上平衡。</li><li>专用性：NPU是最专用的处理器，GPU在图形和并行计算方面专用性较高，CPU则具有最高的通用性。</li></ul><p>随着技术的发展，CPU、GPU和NPU之间的界限越来越模糊，它们开始集成更多的异构计算能力，以满足日益增长的多样化计算需求。例如，一些CPU集成了GPU核心，一些GPU集成了专用的AI加速器，而NPU也在不断扩展其功能以支持更广泛的AI算法。</p><h2 id="架构设计比较"><a href="#架构设计比较" class="headerlink" title="架构设计比较"></a>架构设计比较</h2><p>NPU（神经网络处理单元）、GPU（图形处理单元）和CPU（中央处理单元）在设计上有着根本的差异，这些差异主要体现在以下几个方面：</p><ol><li><p><strong>设计目的</strong>:</p><ul><li><strong>NPU</strong>：专门为执行神经网络和深度学习算法而设计，优化了大量并行的数据流操作。</li><li><strong>GPU</strong>：最初设计用于图形渲染，但随着时间的发展，它们也被用于通用并行计算任务。</li><li><strong>CPU</strong>：设计为通用处理器，能够执行各种类型的计算任务，包括但不限于图形处理和机器学习。</li></ul></li><li><p><strong>核心架构</strong>:</p><ul><li><strong>NPU</strong>：通常采用数据流架构，其中操作的执行直接由数据的存在和可用性触发，而不是由程序计数器驱动。</li><li><strong>GPU</strong>：采用高度并行的架构，拥有大量的核心（如CUDA核心），能够同时处理成千上万个线程，但这些线程通常执行相同的指令（SIMT模型）。</li><li><strong>CPU</strong>：拥有较少数量的核心，但每个核心功能强大，能够处理复杂的控制流和不同的指令序列。</li></ul></li><li><p><strong>指令集和编程模型</strong>:</p><ul><li><strong>NPU</strong>：可能具有专门的指令集，针对神经网络操作如矩阵乘法、卷积等进行优化。</li><li><strong>GPU</strong>：使用如CUDA、OpenCL等并行编程模型，允许开发者编写能够在GPU上运行的并行程序。</li><li><strong>CPU</strong>：使用复杂的指令集，支持广泛的编程语言和模型，包括顺序和并发编程。</li></ul></li><li><p><strong>内存层次结构</strong>:</p><ul><li><strong>NPU</strong>：可能具有优化的内存访问模式，以减少数据移动和提高内存带宽利用率，特别是在处理高维度数据时。</li><li><strong>GPU</strong>：具有多级缓存结构和高带宽的内存接口，以支持大量数据的快速传输。</li><li><strong>CPU</strong>：具有复杂的缓存层次结构和内存管理单元，优化了各种访问模式和数据局部性。</li></ul></li><li><p><strong>并行性</strong>:</p><ul><li><strong>NPU</strong>：设计时专注于数据并行性，每个操作可以独立于其他操作并行执行。</li><li><strong>GPU</strong>：支持数据并行性和任务并行性，能够处理大规模的并行工作负载。</li><li><strong>CPU</strong>：虽然支持多线程和并行处理，但更侧重于指令级别的并行性和复杂的任务调度。</li></ul></li><li><p><strong>专用硬件</strong>:</p><ul><li><strong>NPU</strong>：可能包含专用硬件加速器，如用于深度学习中的张量处理或卷积操作的加速器。</li><li><strong>GPU</strong>：包含专用硬件，如纹理映射单元、光栅化器和着色器核心，用于图形渲染。</li><li><strong>CPU</strong>：包含各种专用硬件，如浮点单元（FPU）、整数单元和SIMD（单指令多数据）单元。</li></ul></li><li><p><strong>能效比</strong>:</p><ul><li><strong>NPU</strong>：针对深度学习任务优化，通常在这些任务上具有更高的能效比。</li><li><strong>GPU</strong>：在图形渲染和大规模并行计算任务上表现出色，但可能在能效比上不如NPU。</li><li><strong>CPU</strong>：在能效比上进行了平衡，以适应广泛的应用场景。</li></ul></li><li><p><strong>应用场景</strong>:</p><ul><li><strong>NPU</strong>：主要用于执行机器学习推理和训练任务。</li><li><strong>GPU</strong>：广泛用于图形渲染、视频处理、科学计算和机器学习。</li><li><strong>CPU</strong>：适用于几乎所有类型的计算任务，从日常应用到高性能计算。</li></ul></li><li><p><strong>开发和生态系统</strong>:</p><ul><li><strong>NPU</strong>：可能依赖特定的软件框架和工具链，针对其硬件进行优化。</li><li><strong>GPU</strong>：拥有成熟的开发环境，如CUDA、OpenCL和各种图形API。</li><li><strong>CPU</strong>：拥有最广泛的开发工具和生态系统，支持几乎所有编程语言和库。</li></ul></li></ol><p>这些设计上的差异使得NPU、GPU和CPU各自在特定的应用领域内发挥最大的性能优势。随着技术的发展，这些处理器的设计将继续演进，以满足不断变化的计算需求。</p><blockquote><p>数据流架构（Dataflow Architecture）是一种计算机体系结构，其核心思想是计算的执行不是由程序计数器控制的指令序列驱动，而是直接由数据本身的状态和可用性触发。这种架构特别适用于那些可以自然地表示为数据流的应用，如信号处理、图像处理、视频编码、深度学习等。<br>并行架构（Parallel Architecture）是一种计算机体系结构设计，它允许多个计算任务或多个数据处理操作同时进行，以提高处理速度和吞吐量。这种架构在处理可以分解为多个独立且可以并行处理的任务时特别有效。<br>指令驱动架构（Instruction-Driven Architecture），也常被称为冯·诺依曼架构（Von Neumann Architecture），是一种传统的计算机体系结构，其核心概念是程序的执行流程由一系列指令控制。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>处理器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改用户名</title>
    <link href="/doc/77c6f300.html"/>
    <url>/doc/77c6f300.html</url>
    
    <content type="html"><![CDATA[<p>因存在部分Linux系统已被高度定制，故有此文。</p><span id="more"></span><p>作者在学习树莓派和香橙派之间，最终没经得住诱惑选择了香橙派，相较之下，香橙派性价比更高，但系统配置比较拉跨。</p><p>香橙派默认安装后，系统已内置了用户，而作者高度洁癖和强迫症，因此将内置用户改为自己的用户。以下为操作步骤:</p><ol><li>修改用户名: <code>usermod -l cikaros orangepi</code></li><li>杀掉所有旧用户的进程: <code>pkill -9 -u orangepi</code></li><li>修改<code>home</code>目录: <code>usermod -d /home/cikaros -m cikaros</code></li><li>修改组名称: <code>groupmod -n cikaros orangepi</code></li><li>修改UID: <code>usermod -u 1000 cikaros</code></li><li>检查: <code>id cikaros</code></li><li>删除root密码: <code>passwd -d root</code></li></ol><blockquote><p>在进行操作时，需使用root用户进行登录，初始密码为<code>orangepi</code>. </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usermod</tag>
      
      <tag>groupmod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker离线安装</title>
    <link href="/doc/785465f.html"/>
    <url>/doc/785465f.html</url>
    
    <content type="html"><![CDATA[<p>因无法通过常规手段下载并安装，故有此文。</p><span id="more"></span><blockquote><p>Docker-CE: <a href="https://download.docker.com/linux/">https://download.docker.com/linux/</a><br>Docker-Compose: <a href="https://github.com/docker/compose/">https://github.com/docker/compose/</a></p></blockquote><ol><li>下载合适版本的安装包</li><li>将其解压后放置在<code>Path</code>路径下</li><li>为其分配可执行权限，可创建专用用户进行权限管理</li><li>配置代理或三方Docker仓库，配置<code>daemon.json</code></li><li>编写合适的<code>docker.service</code>，将其管控至<code>systemctl</code></li><li>启动服务即可</li></ol><h2 id="daemon-json模板"><a href="#daemon-json模板" class="headerlink" title="daemon.json模板"></a>daemon.json模板</h2><p>更多<code>daemon.json</code>模板请参考<a href="https://docs.docker.com/reference/cli/dockerd/#daemon-configuration-file">官方文档</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data-root&quot;: &quot;&#x2F;data&#x2F;docker&quot;,  &quot;proxies&quot;: &#123;    &quot;http-proxy&quot;: &quot;http:&#x2F;&#x2F;proxy.example.com:80&quot;,    &quot;https-proxy&quot;: &quot;https:&#x2F;&#x2F;proxy.example.com:443&quot;,    &quot;no-proxy&quot;: &quot;*.test.example.com,.example.org&quot;  &#125;,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-format&quot;: &quot;text&quot;,  &quot;log-level&quot;: &quot;&quot;,  &quot;log-opts&quot;: &#123;    &quot;cache-disabled&quot;: &quot;false&quot;,    &quot;cache-max-file&quot;: &quot;5&quot;,    &quot;cache-max-size&quot;: &quot;10m&quot;,    &quot;cache-compress&quot;: &quot;true&quot;,    &quot;env&quot;: &quot;os,customer&quot;,    &quot;labels&quot;: &quot;somelabel&quot;,    &quot;max-file&quot;: &quot;5&quot;,    &quot;max-size&quot;: &quot;10m&quot;  &#125;&#125;</code></pre></div></figure><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Docker-Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Systemd-spawn</title>
    <link href="/doc/5548802d.html"/>
    <url>/doc/5548802d.html</url>
    
    <content type="html"><![CDATA[<p>Systemd-spawn 可用于在轻量级容器中运行命令或操作系统。在许多方面，它与 <code>chroot</code> 相似，但功能更强大，因为它使用命名空间来完全虚拟化进程树，IPC，主机名，域名以及可选的网络和用户数据库。</p><span id="more"></span><p>Systemd-spawn 将容器中各种内核接口的访问限制为只读，像是 <code>/sys</code>, <code>/proc/sys</code> 和 <code>/sys/fs/selinux</code>。网络接口和系统时钟不能从容器内更改，不能创建设备节点。不能从容器中重启宿主机，也不能加载内核模块。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>在主机中安装<code>systemd-container</code></li><li>创建Debian容器</li><li>引导容器</li></ol><h3 id="在主机中安装systemd-container"><a href="#在主机中安装systemd-container" class="headerlink" title="在主机中安装systemd-container"></a>在主机中安装<code>systemd-container</code></h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install systemd-container</code></pre></div></figure><blockquote><p>这里建议主机启用非特权用户空间，但部分人员仍然认为存在一些安全隐患，因此可以支持 <code>-U</code> 选项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo echo &#39;kernel.unprivileged_userns_clone&#x3D;1&#39; &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;nspawn.confsudo systemctl restart systemd-sysctl.service</code></pre></div></figure></blockquote><h3 id="创建Debian容器"><a href="#创建Debian容器" class="headerlink" title="创建Debian容器"></a>创建Debian容器</h3><p>可以使用 <code>debootstrap</code> 或 <code>cdebootstrap</code> 工具创建合适的 Debian 容器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">debootstrap --include&#x3D;systemd,dbus stable &#x2F;var&#x2F;lib&#x2F;machines&#x2F;debian</code></pre></div></figure><p>确保 <code>root</code> 用户可以登录到容器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemd-nspawn -D &#x2F;var&#x2F;lib&#x2F;machines&#x2F;debian -U --machine debian</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 允许登录# &#96;pts&#x2F;0&#96; 用于 &#96;systemd-nspawn --boot&#96;# &#96;pts&#x2F;1&#96; 用于 &#96;machinectl login&#96;printf &#39;pts&#x2F;0\npts&#x2F;1\n&#39; &gt;&gt; &#x2F;etc&#x2F;securetty</code></pre></div></figure><h3 id="引导容器"><a href="#引导容器" class="headerlink" title="引导容器"></a>引导容器</h3><p>创建容器后，可以使用实例化的 <code>systemd.service</code>、<code>machinectl</code> 或 <code>systemd-nspawn</code> 命令引导容器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># @ 后面的部分必须与上一步中使用的容器名称匹配$ systemctl start systemd-nspawn@debian# 或者$ machinectl start debian# 或者$ systemd-nspawn --boot -U -D &#x2F;var&#x2F;lib&#x2F;machines&#x2F;debian</code></pre></div></figure><p>这些指令必须使用 <code>root</code> 身份执行。启动后可使用 <code>machinectl shell</code> 进行登录。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="检查容器状态"><a href="#检查容器状态" class="headerlink" title="检查容器状态"></a>检查容器状态</h3><p>若要检查容器的状态，请使用以下命令之一:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">machinectl listsystemctl status systemd-nspawn@debian</code></pre></div></figure><h3 id="登录到容器"><a href="#登录到容器" class="headerlink" title="登录到容器"></a>登录到容器</h3><p>要登录到正在运行的容器，请执行以下操作:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">machinectl login debian</code></pre></div></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>若要从主机停止正在运行的容器，请执行以下操作:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop systemd-nspawn@debian</code></pre></div></figure><p>或者可以在容器内部进行终止:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">machinectl login debianhalt</code></pre></div></figure><p>或者还可以按三次 <code>Ctrl + ]</code>进行终止。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在主机、容器和其他系统之间创建或使用网络有很多选项。与任何网络一样，您需要配置一下内容:</p><ul><li>网络接口</li><li>IP地址</li><li>防火墙规则</li><li>DNS域名</li></ul><p>默认情况下，容器共享主机的网络。若使用了<code>--private-networking</code>选项，则主机使用<code>ve-&lt;contrainer_name&gt;@if&lt;X&gt;</code>形式的虚拟接口与容器通信，而容器则使用名为<code>host@if&lt;Y&gt;</code>的虚拟接口:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(on host)$ ip a show dev ve-debian77: ve-debian@if2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000    link&#x2F;ether ... brd ff:ff:ff:ff:ff:ff link-netnsid 1</code></pre></div></figure><h3 id="使用主机网络"><a href="#使用主机网络" class="headerlink" title="使用主机网络"></a>使用主机网络</h3><p>您可以通过在 &#x2F;etc&#x2F;systemd&#x2F;nspawn&#x2F;container-name.nspawn 中添加以下行来禁用专用网络并使容器使用主机网络：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">[Network]VirtualEthernet&#x3D;no</code></pre></div></figure><blockquote><p>将<code>container-name</code>替换为容器的名称。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>虚拟</tag>
      
      <tag>容器化</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaAgent插桩技术介绍</title>
    <link href="/doc/492edb0a.html"/>
    <url>/doc/492edb0a.html</url>
    
    <content type="html"><![CDATA[<p>Java 代理(agent)是一种拦截处理技术，它会在你的 Java 代码执行前进行拦截并按照你的要求进行字节码调整。</p><span id="more"></span><p>我们开发中使用的很多工具都是基于 Java 代理来实现的，比如 JRebel、以及诊断工具等。</p><h2 id="Java-Agent规范"><a href="#Java-Agent规范" class="headerlink" title="Java Agent规范"></a>Java Agent规范</h2><p>因为其特殊性，Java Agent 规定，需要在 <code>META-INF</code> 目录下创建 <code>MANIFEST.MF</code> 文件，并在其内部指定 Agent 的启动类:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Manifest-Version: 1.0Premain-Class: org.example.AppArchiver-Version: Plexus ArchiverBuilt-By: jackAgent-Class: org.example.AppCreated-By: Apache Maven 3.2.5Build-Jdk: 1.8.0_40</code></pre></div></figure><blockquote><p>上述仅为示例文件，具体配置请根据实际情况处理</p></blockquote><h3 id="Java-Agent-入口类"><a href="#Java-Agent-入口类" class="headerlink" title="Java Agent 入口类"></a>Java Agent 入口类</h3><p>上述配置中设置了<code>Premain-Class</code>和<code>Agent-Class</code>的类路径，这代表着我们的 Agent 在不同的运行方式下会找不同的入口类。</p><p><code>Premain-Class</code>代表的是以<code>-javaagent:*</code>的方式载入时，Agent 程序的入口类路径。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">-javaagent:&#x2F;jetbrains-all&#x2F;current&#x2F;ja-netfilter.jar&#x3D;jetbrains</code></pre></div></figure><p><code>Agent-Class</code>则代表的是以 Attach API 的方式载入时，Agent 程序的入口类路径。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Attacher &#123;    public static void main(String[] args) throws AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException &#123;        &#x2F;&#x2F; 传入目标 JVM pid        VirtualMachine vm &#x3D; VirtualMachine.attach(&quot;39333&quot;);        vm.loadAgent(&quot;&#x2F;jetbrains-all&#x2F;current&#x2F;ja-netfilter.jar&quot;);    &#125;&#125;</code></pre></div></figure><p>入口类的定义如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class App &#123;    &#x2F;**     * 以vm参数的方式载入，在Java程序的main方法执行之前执行     *&#x2F;    public static void premain(String agentArgs, Instrumentation inst) &#123;&#125;    &#x2F;**     * 以Attach的方式载入，在Java程序启动后执行     *&#x2F;    public static void agentmain(String agentArgs, Instrumentation inst) &#123;&#125;&#125;</code></pre></div></figure><h3 id="Maven-Build"><a href="#Maven-Build" class="headerlink" title="Maven Build"></a>Maven Build</h3><p>为了便于打包，一般我们会使用 Maven 的 Plugin 进行自动配置:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;    &lt;configuration&gt;        &lt;archive&gt;            &lt;!--自动添加META-INF&#x2F;MANIFEST.MF --&gt;            &lt;manifest&gt;                &lt;addClasspath&gt;true&lt;&#x2F;addClasspath&gt;            &lt;&#x2F;manifest&gt;            &lt;manifestEntries&gt;                &lt;Premain-Class&gt;com.rickiyang.learn.PreMainTraceAgent&lt;&#x2F;Premain-Class&gt;                &lt;Agent-Class&gt;com.rickiyang.learn.PreMainTraceAgent&lt;&#x2F;Agent-Class&gt;                &lt;Can-Redefine-Classes&gt;true&lt;&#x2F;Can-Redefine-Classes&gt;                &lt;Can-Retransform-Classes&gt;true&lt;&#x2F;Can-Retransform-Classes&gt;            &lt;&#x2F;manifestEntries&gt;        &lt;&#x2F;archive&gt;    &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt;</code></pre></div></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Java Agent 结合 ASM 技术可以做到很多事情，主要包含以下几种场景: </p><ol><li>日志记录</li><li>性能分析</li><li>热部署</li><li>Mock服务</li><li>动态数据映射</li><li>……</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>ByteCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ByteCode</tag>
      
      <tag>Java</tag>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASM字节码技术介绍</title>
    <link href="/doc/833aa7fb.html"/>
    <url>/doc/833aa7fb.html</url>
    
    <content type="html"><![CDATA[<p>ASM是一个通用的 Java 字节码操作和分析框架。它可用于修改现有类或动态生成类（直接以二进制形式）。ASM 提供了一些常见的字节码转换和分析算法，可从中构建自定义复杂转换和代码分析工具。ASM 提供与其他 Java 字节码框架类似的功能，但更注重性能。由于它的设计和实现尽可能小巧和快速，因此非常适合在动态系统中使用（当然也可以以静态方式使用，例如在编译器中）。</p><span id="more"></span><blockquote><p>官网: <a href="https://asm.ow2.io/">https://asm.ow2.io/</a><br>文档: <a href="https://asm.ow2.io/asm4-guide.pdf">https://asm.ow2.io/asm4-guide.pdf</a><br>JavaDoc: <a href="https://asm.ow2.io/javadoc/index.html">https://asm.ow2.io/javadoc/index.html</a></p></blockquote><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;data-mapping&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0&lt;&#x2F;version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;        &lt;asm.version&gt;9.7&lt;&#x2F;asm.version&gt;    &lt;&#x2F;properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.ow2.asm&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;asm&lt;&#x2F;artifactId&gt;            &lt;version&gt;$&#123;asm.version&#125;&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;            &lt;version&gt;RELEASE&lt;&#x2F;version&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.18.32&lt;&#x2F;version&gt;            &lt;scope&gt;provided&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt;</code></pre></div></figure><h2 id="代码组织介绍"><a href="#代码组织介绍" class="headerlink" title="代码组织介绍"></a>代码组织介绍</h2><blockquote><p>本章翻译自官方文档: <a href="https://asm.ow2.io/developer-guide.html">https://asm.ow2.io/developer-guide.html</a></p></blockquote><p>ASM 主要分为以下几个包:</p><p><img src="https://asm.ow2.io/asm-package-dependencies.svg" srcset="/img/loading.gif" lazyload alt="代码组织包结构"></p><ul><li><code>org.objectweb.asm</code>是核心包。定义了 ASM 的访问 API，还提供了<code>ClassReader</code>和<code>ClassWriter</code>类进行类文件数据的读取和写出。该包不依赖其他任何包。</li><li><code>org.objectweb.asm.signature</code>提供读写泛型签名的 API。它是核心包的补充包。 </li><li><code>org.objectweb.asm.tree</code>在核心包提供的类似SAX的 API之上提供了类似DOM的 API 。它可用于实现复杂的类转换，而核心包对于此类转换的使用则过于复杂。 </li><li><code>org.objectweb.asm.tree.analysis</code>在 tree 包之上提供了一个静态字节码分析框架。除了 tree 包之外，它还可以用于实现真正复杂的类转换，这些转换需要知道每条指令的堆栈映射帧的状态。</li><li><code>org.objectweb.asm.commons</code>提供了一些基于 core 和 tree 包的有用的类适配器。这些适配器可以直接使用，也可以扩展以实现更具体的类转换。</li><li><code>org.objectweb.asm.util</code>提供一些有用的类访问者和适配器，可用于调试目的。运行时一般不需要。</li><li><code>org.objectweb.asm.xml</code>已弃用。它提供了将类转换为 XML 或从 XML 转换为类的功能。</li></ul><p>从实现的角度来看，核心包是最复杂的包。tree、util和 xml包非常简单（它们只是将类从一种高级表示转换为另一种高级表示，这比将类从其字节数组形式转换为高级表示形式或反之亦然要简单得多）。 包signature也相当简单（它包含一个解析器和一个用于小语法的漂亮打印机）。</p><h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p><img src="https://asm.ow2.io/asm-package-overview.svg" srcset="/img/loading.gif" lazyload alt="主要数据结构"></p><h2 id="常用ASM操作"><a href="#常用ASM操作" class="headerlink" title="常用ASM操作"></a>常用ASM操作</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main &#123;    &#x2F;&#x2F;本代码仅为示例，因此不进行异常的处理    public static void main(String[] args) throws Exception &#123;        ClassWriter cw &#x3D; new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);        &#x2F;&#x2F;该类为public        int access &#x3D; Opcodes.ACC_PUBLIC;        &#x2F;&#x2F;类名        String clazz &#x3D; &quot;org.cikaros.A&quot;        &#x2F;&#x2F;该类继承自Object.class        &#x2F;&#x2F;该方法的作用是将 &#39;.&#39; 转换为 &#39;&#x2F;&#39;        String superName &#x3D; Util.packageToPath(Object.class);&#x2F;&#x2F;当前值为 java&#x2F;lang&#x2F;Object        &#x2F;&#x2F;该类实现了哪些接口        Class&lt;?&gt;[] interfaces &#x3D; new Class&lt;?&gt;[] &#123;Function.class,AutoCloseable.class&#125;;        &#x2F;&#x2F;定义一个类        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, Util.packageToPath(clazz), null, superName, Arrays.stream(interfaces).map(Class::getTypeName).map(Util::packageToPath).toArray(String[]::new));                &#x2F;&#x2F;TODO 编写其他业务逻辑                        &#x2F;&#x2F;生成字节码文件数据，将其保存为文件，即为字节码文件        cw.toByteArray();    &#125;&#125;</code></pre></div></figure><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">...    &#x2F;&#x2F;TODO 编写其他业务逻辑    &#x2F;&#x2F;该属性为public    int access &#x3D; Opcodes.ACC_PUBLIC;    &#x2F;&#x2F;属性名字    String field &#x3D; &quot;&quot;;    &#x2F;&#x2F;类型描述    String descriptor &#x3D; &quot;&quot;;    &#x2F;&#x2F;创建一个整数    &#x2F;&#x2F;descriptor &#x3D; Type.getDescriptor(int.class);    FieldVisitor fv &#x3D; cw.visitField(access, field, descriptor, null, null);    fv.visitEnd();...</code></pre></div></figure><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">...    &#x2F;&#x2F;TODO 编写其他业务逻辑    &#x2F;&#x2F;该方法为public    int access &#x3D; Opcodes.ACC_PUBLIC;    &#x2F;&#x2F;方法名字    String method &#x3D; &quot;&quot;;    &#x2F;&#x2F;方法签证描述    String descriptor &#x3D; &quot;&quot;;    &#x2F;&#x2F;无参数和返回值    &#x2F;&#x2F;descriptor &#x3D; Type.getMethodDescriptor(Type.VOID_TYPE);    &#x2F;&#x2F;存在参数和返回值 这里假设有一个类型为Object的参数，返回值为Boolean类型    &#x2F;&#x2F;descriptor &#x3D; Type.getMethodDescriptor(Type.BOOLEAN_TYPE,Type.getType(Object.class));    MethodVisitor mv &#x3D; CW.visitMethod(access, method, descriptor, null, null);    mv.visitCode();    &#x2F;&#x2F;TODO 定义方法体    mv.visitEnd();...</code></pre></div></figure><h3 id="定义无参构造函数"><a href="#定义无参构造函数" class="headerlink" title="定义无参构造函数"></a>定义无参构造函数</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;TODO 编写其他业务逻辑    &#x2F;&#x2F;该方法为public    int access &#x3D; Opcodes.ACC_PUBLIC;    &#x2F;&#x2F;方法名字    String method &#x3D; &quot;&lt;init&gt;&quot;;    &#x2F;&#x2F;方法签证描述    String descriptor &#x3D; Type.getMethodDescriptor(Type.VOID_TYPE);...    &#x2F;&#x2F;TODO 定义方法体    &#x2F;&#x2F;加载this引用    mv.visitVarInsn(Opcodes.ALOAD, 0);    &#x2F;&#x2F;调用特殊方法 &lt;init&gt; (固定写法)    mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Util.packageToPath(Object.class.getTypeName()), method, &quot;()V&quot;, false);    &#x2F;&#x2F;返回    mv.visitInsn(Opcodes.RETURN);    &#x2F;&#x2F;设置堆栈空间大小    mv.visitMaxs(1, 1);...</code></pre></div></figure><h3 id="定义getter"><a href="#定义getter" class="headerlink" title="定义getter"></a>定义getter</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;TODO 编写其他业务逻辑    &#x2F;&#x2F;该方法为public    int access &#x3D; Opcodes.ACC_PUBLIC;    &#x2F;&#x2F;属性名字 假设属性为A    String field &#x3D; &quot;a&quot;;    &#x2F;&#x2F;属性类型    Class&lt;?&gt; fieldType &#x3D; String.class;    &#x2F;&#x2F;方法名字     String method &#x3D; &quot;getA&quot;;    &#x2F;&#x2F;方法签证描述 假设类型为String    String descriptor &#x3D; Type.getMethodDescriptor(Type.getType(fieldType));...    &#x2F;&#x2F;TODO 定义方法体    &#x2F;&#x2F;加载this引用    mv.visitVarInsn(Opcodes.ALOAD, 0);    &#x2F;&#x2F;获取属性    mv.visitMethodInsn(Opcodes.GETFIELD, clazz, Util.packageToPath(Object.class.getTypeName()), field, Type.getDescriptor(fieldType));    &#x2F;&#x2F;返回属性引用    mv.visitInsn(Opcodes.ARETURN);    &#x2F;&#x2F;设置堆栈空间大小    mv.visitMaxs(1, 1);...</code></pre></div></figure><h3 id="定义setter"><a href="#定义setter" class="headerlink" title="定义setter"></a>定义setter</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;TODO 编写其他业务逻辑    &#x2F;&#x2F;该方法为public    int access &#x3D; Opcodes.ACC_PUBLIC;    &#x2F;&#x2F;属性名字 假设属性为A    String field &#x3D; &quot;a&quot;;    &#x2F;&#x2F;属性类型    Class&lt;?&gt; fieldType &#x3D; String.class;    &#x2F;&#x2F;方法名字     String method &#x3D; &quot;setA&quot;;    &#x2F;&#x2F;方法签证描述 假设类型为String    String descriptor &#x3D; Type.getMethodDescriptor(Type.getType(fieldType));...    &#x2F;&#x2F;TODO 定义方法体    &#x2F;&#x2F;加载this引用    mv.visitVarInsn(Opcodes.ALOAD, 0);    &#x2F;&#x2F;加载第一个参数    mv.visitVarInsn(Opcodes.ALOAD, 1);    &#x2F;&#x2F;为属性赋值属性    mv.visitMethodInsn(Opcodes.PUTFIELD, Util.packageToPath(clazz), field, Type.getDescriptor(fieldType));    &#x2F;&#x2F;返回    mv.visitInsn(Opcodes.RETURN);    &#x2F;&#x2F;设置堆栈空间大小    mv.visitMaxs(2, 2);...</code></pre></div></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>针对上述代码进行逻辑抽象。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.cikaros.mapping.core;import lombok.Data;import org.objectweb.asm.*;import javax.annotation.Generated;import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.function.Consumer;import java.util.function.Function;import java.util.logging.Logger;import java.util.stream.Collectors;import static org.objectweb.asm.Opcodes.*;public class ClassGenerator &#123;    private static class Util &#123;        &#x2F;**         * 包路径转路径         *&#x2F;        public static String packageToPath(String packageName) &#123;            return packageName.replace(&#39;.&#39;, &#39;&#x2F;&#39;);        &#125;        &#x2F;**         * 首字母大写(进行字母的ascii编码前移，效率是最高的)         *&#x2F;        public static String getMethodName(String fieldName) &#123;            char[] chars &#x3D; fieldName.toCharArray();            chars[0] &#x3D; toUpperCase(chars[0]);            return String.valueOf(chars);        &#125;        &#x2F;**         * 字符转成大写         *&#x2F;        public static char toUpperCase(char c) &#123;            if (97 &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; 122) &#123;                c ^&#x3D; 32;            &#125;            return c;        &#125;    &#125;    private final ClassWriter CW &#x3D; new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);    public void clazz(String clazz, Class&lt;?&gt; supper, Class&lt;?&gt;[] interfaces) &#123;        String superName &#x3D; Util.packageToPath(supper.getTypeName());        CW.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, Util.packageToPath(clazz), null, superName, Arrays.stream(interfaces).map(Class::getTypeName).map(Util::packageToPath).toArray(String[]::new));        this.annotation(Generated.class,av-&gt;&#123;            av.visit(&quot;comments&quot;, &quot;Generated By org.cikaros.mapping.core.ClassGenerator&quot;);            av.visit(&quot;date&quot;, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss:SSS&quot;).format(LocalDateTime.now()));        &#125;);        this.defaultConstructor();    &#125;    private void defaultConstructor() &#123;        this.defineMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE), mv -&gt; &#123;            mv.visitVarInsn(Opcodes.ALOAD, 0);            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Util.packageToPath(Object.class.getTypeName()), &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);            mv.visitInsn(Opcodes.RETURN);            mv.visitMaxs(1, 1);        &#125;);    &#125;    public void argsConstructor(String clazz, Map&lt;String, Class&lt;?&gt;&gt; args) &#123;        List&lt;Map.Entry&lt;String, Class&lt;?&gt;&gt;&gt; entries &#x3D; args.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toList());        &#x2F;&#x2F;生成私有属性        entries.forEach(arg -&gt; this.field(Opcodes.ACC_PRIVATE, arg.getValue(), arg.getKey()));        this.defineMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, entries.stream().map(Map.Entry::getValue).map(Type::getType).toArray(Type[]::new)), mv -&gt; &#123;            &#x2F;&#x2F; 调用父类构造函数            mv.visitVarInsn(Opcodes.ALOAD, 0); &#x2F;&#x2F; 加载 this            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Util.packageToPath(Object.class.getTypeName()), &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE), false);            &#x2F;&#x2F; 假设参数按顺序传递，从第二个参数开始（索引1）            int index &#x3D; 1; &#x2F;&#x2F; this 的索引是0，参数从1开始            for (Map.Entry&lt;String, Class&lt;?&gt;&gt; arg : entries) &#123;                mv.visitVarInsn(Opcodes.ALOAD, 0); &#x2F;&#x2F; 加载 this                &#x2F;&#x2F; 根据参数类型加载参数到栈上                Class&lt;?&gt; argType &#x3D; arg.getValue();                if (argType &#x3D;&#x3D; int.class) &#123;                    mv.visitVarInsn(Opcodes.ILOAD, index);                &#125; else if (argType &#x3D;&#x3D; float.class) &#123;                    mv.visitVarInsn(Opcodes.FLOAD, index);                &#125; else if (argType &#x3D;&#x3D; double.class) &#123;                    mv.visitVarInsn(Opcodes.DLOAD, index);                &#125; else if (argType &#x3D;&#x3D; long.class) &#123;                    mv.visitVarInsn(Opcodes.LLOAD, index);                &#125; else if (argType &#x3D;&#x3D; short.class) &#123;                    mv.visitVarInsn(Opcodes.ILOAD, index);                &#125; &#x2F;&#x2F; 这里可以继续添加其他基本类型的处理                else &#123;                    &#x2F;&#x2F; 对于引用类型                    mv.visitVarInsn(Opcodes.ALOAD, index);                &#125;                &#x2F;&#x2F; 这里可以添加对参数的处理代码，例如设置字段值等                mv.visitFieldInsn(Opcodes.PUTFIELD, Util.packageToPath(clazz), arg.getKey(), Type.getDescriptor(argType));                index++;            &#125;            &#x2F;&#x2F; 正常结束方法            mv.visitInsn(Opcodes.RETURN);            &#x2F;&#x2F; 计算操作数栈和局部变量表的大小            mv.visitMaxs(1, 1); &#x2F;&#x2F; 这里需要根据实际情况调整        &#125;);    &#125;    private void field(int accessFlags, Class&lt;?&gt; type, String field) &#123;        CW.visitField(accessFlags, field, Type.getDescriptor(type), null, null);    &#125;    public void annotation(Class&lt;?&gt; type,Consumer&lt;AnnotationVisitor&gt; body)&#123;        AnnotationVisitor av &#x3D; CW.visitAnnotation(Type.getDescriptor(Generated.class), true);        body.accept(av);        av.visitEnd();    &#125;    public void defineMethod(int accessFlags, String method, String descriptor, Consumer&lt;MethodVisitor&gt; body) &#123;        MethodVisitor getterMV &#x3D; CW.visitMethod(accessFlags, method, descriptor, null, null);        getterMV.visitCode();        body.accept(getterMV);        getterMV.visitEnd();    &#125;    public void setter(String clazz, Class&lt;?&gt; type, String field) &#123;        String setterName &#x3D; String.format(&quot;set%s&quot;, Util.getMethodName(field));        String setterDescriptor &#x3D; Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(type));        this.defineMethod(Opcodes.ACC_PUBLIC, setterName, setterDescriptor, mv -&gt; &#123;            mv.visitVarInsn(Opcodes.ALOAD, 0); &#x2F;&#x2F; 加载当前类的引用（对于静态方法，这里可以省略）            mv.visitVarInsn(Opcodes.ALOAD, 1); &#x2F;&#x2F; 加载参数中的String引用            mv.visitFieldInsn(Opcodes.PUTFIELD, Util.packageToPath(clazz), field, Type.getDescriptor(type));            mv.visitInsn(Opcodes.RETURN);            mv.visitMaxs(2, 2); &#x2F;&#x2F; 设置操作数栈和局部变量表的最大大小        &#125;);    &#125;    public void getter(String clazz, Class&lt;?&gt; type, String field) &#123;        String getterName &#x3D; String.format(&quot;get%s&quot;, Util.getMethodName(field));        String getterDescriptor &#x3D; Type.getMethodDescriptor(Type.getType(type));        this.defineMethod(Opcodes.ACC_PUBLIC, getterName, getterDescriptor, mv -&gt; &#123;            mv.visitVarInsn(Opcodes.ALOAD, 0); &#x2F;&#x2F; 加载当前类的引用（对于静态方法，这里可以省略）            mv.visitFieldInsn(Opcodes.GETFIELD, Util.packageToPath(clazz), field, Type.getDescriptor(type));            mv.visitInsn(Opcodes.ARETURN);            mv.visitMaxs(1, 1); &#x2F;&#x2F; 设置操作数栈和局部变量表的最大大小        &#125;);    &#125;    public &lt;T, R&gt; void apply(Class&lt;T&gt; in, Class&lt;R&gt; out) &#123;        String setterDescriptor &#x3D; Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class));        Method[] gets &#x3D; Arrays.stream(in.getMethods()).filter(mv -&gt; mv.getName().startsWith(&quot;get&quot;)).toArray(Method[]::new);        Method[] sets &#x3D; Arrays.stream(out.getMethods()).filter(mv -&gt; mv.getName().startsWith(&quot;set&quot;)).toArray(Method[]::new);        this.defineMethod(Opcodes.ACC_PUBLIC, &quot;apply&quot;, setterDescriptor, mv -&gt; &#123;            mv.visitTypeInsn(Opcodes.NEW, Util.packageToPath(out.getTypeName())); &#x2F;&#x2F; 创建一个新的 B 对象            mv.visitInsn(DUP);            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Util.packageToPath(out.getTypeName()), &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); &#x2F;&#x2F; 调用 B 对象的构造方法            mv.visitVarInsn(ASTORE, 2);            for (int i &#x3D; 0; i &lt; Math.min(gets.length, sets.length); i++) &#123;                Method get &#x3D; gets[i];                Method set &#x3D; sets[i];                &#x2F;&#x2F;仅当getter返回类型与setter参数类型相等时                if (get.getReturnType().equals(Arrays.stream(set.getParameterTypes()).findFirst().orElse(null))) &#123;                    mv.visitVarInsn(Opcodes.ALOAD, 2);                    mv.visitVarInsn(Opcodes.ALOAD, 1);                    mv.visitTypeInsn(CHECKCAST, Util.packageToPath(in.getTypeName()));                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Util.packageToPath(in.getTypeName()), gets[0].getName(), Type.getMethodDescriptor(get), false); &#x2F;&#x2F; 调用 A 对象的 getProperty 方法                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Util.packageToPath(out.getTypeName()), sets[0].getName(), Type.getMethodDescriptor(set), false); &#x2F;&#x2F; 调用 B 对象的 setProperty 方法                &#125;            &#125;            mv.visitVarInsn(Opcodes.ALOAD, 2);            mv.visitInsn(ARETURN); &#x2F;&#x2F; 返回B对象            mv.visitMaxs(-1, -1);        &#125;);    &#125;    public byte[] getBytes() &#123;        return CW.toByteArray();    &#125;    public void toFile(String location, String clazz) &#123;        Path path &#x3D; Paths.get(location, String.format(&quot;%s.class&quot;, Util.packageToPath(clazz)));        File file &#x3D; path.toFile();        if (file.exists()) &#123;            boolean _ &#x3D; file.delete();        &#125;        try (OutputStream out &#x3D; Files.newOutputStream(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) &#123;            out.write(CW.toByteArray());        &#125; catch (IOException e) &#123;            Logger.getGlobal().info(e.getMessage());        &#125;    &#125;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>ByteCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ByteCode</tag>
      
      <tag>Java</tag>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源SMTP-poste.io</title>
    <link href="/doc/4735b42c.html"/>
    <url>/doc/4735b42c.html</url>
    
    <content type="html"><![CDATA[<p>SMTP + IMAP + POP3 + 反垃圾邮件 + 防病毒 + Web 管理 + Web 电子邮件</p><span id="more"></span><blockquote><p>官网地址：<a href="https://poste.io/">https://poste.io/</a><br>文档地址：<a href="https://poste.io/doc/">https://poste.io/doc/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>SMTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源SSO-ZITADEL</title>
    <link href="/doc/a28e181a.html"/>
    <url>/doc/a28e181a.html</url>
    
    <content type="html"><![CDATA[<p>提供开箱即用的广泛功能。包括具有品牌自定义的多租户、安全登录、自助服务、OpenID Connect、OAuth2.x、SAML2、带 FIDO2 的无密码（包括通行密钥）、OTP、U2F 和无限制的审计跟踪。</p><span id="more"></span><blockquote><p>官网地址：<a href="https://zitadel.com/">https://zitadel.com/</a><br>文档地址：<a href="https://zitadel.com/docs/">https://zitadel.com/docs/</a></p></blockquote><p>这里就不多废话了，直接说明如何快速搭建环境。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>简要说明大致流程，前提条件需要安装Docker、Docker Compose环境，详情请参考<a href="/doc/457e5fca.html">Ubuntu安装Docker</a>。</p><ol><li>搭建数据库环境</li><li>创建 <code>ZITADEL</code> 的专属账号和数据库</li><li>初始化 <code>ZITADEL</code> 服务</li><li>启动 <code>ZITADEL</code> 服务</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3.8&#39;services:  zitadel:    restart: &#39;always&#39;    networks:      - &#39;zitadel&#39;    image: &#39;ghcr.io&#x2F;zitadel&#x2F;zitadel:latest&#39;    command: &#39;start-from-init --masterkey &quot;MasterkeyNeedsToHave32Characters&quot; --tlsMode disabled&#39;    environment:      - &#39;ZITADEL_DATABASE_POSTGRES_HOST&#x3D;db&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_PORT&#x3D;5432&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_DATABASE&#x3D;zitadel&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_USER_USERNAME&#x3D;zitadel&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_USER_PASSWORD&#x3D;zitadel&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_USER_SSL_MODE&#x3D;disable&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_ADMIN_USERNAME&#x3D;postgres&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_ADMIN_PASSWORD&#x3D;postgres&#39;      - &#39;ZITADEL_DATABASE_POSTGRES_ADMIN_SSL_MODE&#x3D;disable&#39;      - &#39;ZITADEL_FIRSTINSTANCE_ORG_HUMAN_USERNAME&#x3D;Cikaros@qq.com&#39; #管理员账号      - &#39;ZITADEL_FIRSTINSTANCE_ORG_HUMAN_PASSWORD&#x3D;xxxxxxxxxx&#39; #管理员密码      - &#39;ZITADEL_EXTERNALSECURE&#x3D;false&#39;    depends_on:      db:        condition: &#39;service_healthy&#39;    ports:      - &#39;8080:8080&#39;  db:    restart: &#39;always&#39;    image: postgres:16-alpine    environment:      - POSTGRES_USER&#x3D;postgres #超管账号#      - POSTGRES_PASSWORD&#x3D;xxxxxxxxxx #超管密码#      - POSTGRES_DB&#x3D;zitadel    networks:      - &#39;zitadel&#39;    healthcheck:      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready&quot;, &quot;-d&quot;, &quot;zitadel&quot;, &quot;-U&quot;, &quot;postgres&quot;]      interval: &#39;10s&#39;      timeout: &#39;30s&#39;      retries: 5      start_period: &#39;20s&#39;networks:  zitadel:</code></pre></div></figure><blockquote><p>注：请在部署前自行修改变量位置的内容，管理员账号密码请自行设置<br> MasterkeyNeedsToHave32Characters: <code>$(openssl rand -base64 32 | head -c 32)</code></p></blockquote><h3 id="Postgres-配置"><a href="#Postgres-配置" class="headerlink" title="Postgres 配置"></a>Postgres 配置</h3><p>这里假设 Postgres 服务已经创建，在 Docker 容器中的容器名为 <code>Postgres</code></p><p>首先需要登录到容器内部进行操作（主要是因为外部没有对应的指令可用）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#进入容器sudo docker exec -it Postgres bash#切换数据库用户su postgres </code></pre></div></figure><p>之后则进行用户和数据库的创建，并为其设置权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#创建用户createuser -D -R -S zitadel#创建数据库并归属给上一步创建的用户createdb -O zitadel -E &quot;UTF-8&quot; -l &quot;C&quot; -T template0 -e zitadel#为其配置Public Schemagrant all on schema public to zitadel;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>OAuth2</tag>
      
      <tag>OpenID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-Linux安装与备份</title>
    <link href="/doc/ecdc8312.html"/>
    <url>/doc/ecdc8312.html</url>
    
    <content type="html"><![CDATA[<p>今天在检索MySQL时，看到了MySQL一种比较优秀的一种数据备份恢复方案，特此小计一下。</p><span id="more"></span><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#函数返回非零，程序立即终止set -escript_name&#x3D;$(basename &quot;$0&quot;)# 函数：询问用户输入，附带默认值提示# 使用示例：# 用户输入的名字，没有默认值#name&#x3D;$(ask_for_input &quot;Please enter your name&quot;)## 用户输入的年龄，带有默认值#age&#x3D;$(ask_for_input &quot;Please enter your age&quot; &quot;30&quot;)user_input() &#123;    # $1 是提示信息    # $2 是默认值    local prompt&#x3D;&quot;$1&quot;    local default_value&#x3D;&quot;$2&quot;    local response    # 打印提示信息，如果提供了默认值，则显示在提示之后    if [ -n &quot;$default_value&quot; ]; then        read -p &quot;$prompt [$default_value]: &quot; response    else        read -p &quot;$prompt: &quot; response    fi    # 如果用户没有输入任何内容，并且提供了默认值，则使用默认值    if [ -z &quot;$response&quot; ] &amp;&amp; [ -n &quot;$default_value&quot; ]; then        response&#x3D;&quot;$default_value&quot;    fi    # 输出用户的输入或默认值    echo &quot;$response&quot;&#125;# 确保脚本以root权限运行is_root() &#123;if [ &quot;$(id -u)&quot; -ne 0 ]; thenecho &quot;This script must be run as root. Please use sudo.&quot;return 1 #需要Root用户权限fi&#125;# 函数：下载MySQLdownload_mysql() &#123;# 配置MYSQL_VERSION&#x3D;$(user_input &quot;Please enter MySQL version&quot; &quot;8.0.36&quot;)DOWNLOAD_URL&#x3D;&quot;https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-$&#123;MYSQL_VERSION%.*&#125;&#x2F;mysql-$&#123;MYSQL_VERSION&#125;-linux-glibc2.12-x86_64.tar.gz&quot;    echo &quot;Downloading MySQL version $MYSQL_VERSION...&quot;    wget &quot;$DOWNLOAD_URL&quot; -O &#x2F;tmp&#x2F;mysql-$&#123;MYSQL_VERSION&#125;.tar.gz    if [ $? -ne 0 ]; then        echo &quot;Failed to download MySQL.&quot;        return -1 #MySQL下载失败    fi&#125;# 函数：安装MySQLinstall_mysql() &#123;download_mysql    echo &quot;Installing MySQL version $MYSQL_VERSION...&quot;    # 解压tar.gz包    tar -xzf &#x2F;tmp&#x2F;mysql-$&#123;MYSQL_VERSION&#125;.tar.gz -C &#x2F;usr&#x2F;local&#x2F;src    # 移动到合适的目录    mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;mysql-$&#123;MYSQL_VERSION&#125; &#x2F;usr&#x2F;local&#x2F;mysql    # 创建软链接    ln -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;    # 配置环境变量（示例：添加到当前用户的.bashrc）    echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#39; &gt;&gt; ~&#x2F;.bashrc    source ~&#x2F;.bashrc    # 初始化MySQL    &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data    # 配置MySQL服务器    &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld --daemonize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data --pid-file&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql.pid    # 安全配置    &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql_secure_installation    echo &quot;MySQL installation successful.&quot;&#125;# 函数：更新MySQLupdate_mysql() &#123;    echo &quot;Updating MySQL...&quot;    # 停止MySQL服务    service mysql stop    # 重复安装步骤    install_mysql    # 启动MySQL服务    service mysql start    echo &quot;MySQL updated successfully.&quot;&#125;ENV_PATH&#x3D;&quot;~&#x2F;.mysql.env&quot;set_env() &#123;# 配置MYSQL_USER&#x3D;$(user_input &quot;Please enter your user&quot; &quot;mysql&quot;)MYSQL_PASS&#x3D;$(user_input &quot;Please enter your password&quot; &quot;root&quot;)RESTORE_DB&#x3D;$(user_input &quot;Please enter default database&quot; &quot;&quot;)BACKUP_BASE_DIR&#x3D;$(user_input &quot;Please enter backup base dir&quot; &quot;&#x2F;backup&quot;)FULL_BACKUP_DIR&#x3D;&quot;$BACKUP_BASE_DIR&#x2F;full&quot;INCREMENTAL_BACKUP_DIR&#x3D;&quot;$BACKUP_BASE_DIR&#x2F;incremental&quot;LAST_POSITION_FILE&#x3D;&quot;$INCREMENTAL_BACKUP_DIR&#x2F;last_position.txt&quot;save_env &gt; $ENV_PATH&#125;#保存环境变量save_env() &#123;cat &lt;&lt;EOFMYSQL_USER&#x3D;&quot;$MYSQL_USER&quot;MYSQL_PASS&#x3D;&quot;$MYSQL_PASS&quot;RESTORE_DB&#x3D;&quot;$RESTORE_DB&quot;BACKUP_BASE_DIR&#x3D;&quot;$BACKUP_BASE_DIR&quot;FULL_BACKUP_DIR&#x3D;&quot;$FULL_BACKUP_DIR&quot;INCREMENTAL_BACKUP_DIR&#x3D;&quot;$INCREMENTAL_BACKUP_DIR&quot;LAST_POSITION_FILE&#x3D;&quot;$LAST_POSITION_FILE&quot;EOF&#125;#加载.env文件中的环境变量reload_env () &#123;# 加载.env文件中的环境变量if [ -f $ENV_PATH ]; thensource .&#x2F;.envelseset_envfi&#125;# 创建备份目录create_backup_directories() &#123;    echo &quot;Creating backup directories if not exist...&quot;    mkdir -p &quot;$FULL_BACKUP_DIR&quot;    mkdir -p &quot;$INCREMENTAL_BACKUP_DIR&quot;&#125;# 全量备份函数full_backup() &#123;    create_backup_directories    local backup_filename&#x3D;&quot;$RESTORE_DB_$(date +%Y%m%d%H%M%S).sql.gz&quot;    echo &quot;Starting full backup...&quot;    mysqldump -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot; --all-databases --single-transaction | gzip &gt; &quot;$FULL_BACKUP_DIR&#x2F;$backup_filename&quot;    if [ $? -eq 0 ]; then        echo &quot;Full backup successful: $backup_filename&quot;    else        echo &quot;Full backup failed.&quot;        exit 1    fi&#125;# 增量备份函数incremental_backup() &#123;    create_backup_directories    local current_binlog_file    local current_binlog_pos    if [ -f &quot;$LAST_POSITION_FILE&quot; ]; then        current_binlog_file&#x3D;$(head -n 1 &quot;$LAST_POSITION_FILE&quot;)        current_binlog_pos&#x3D;$(tail -n 1 &quot;$LAST_POSITION_FILE&quot;)    else        current_binlog_file&#x3D;$(mysql -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot; -e &quot;SHOW MASTER STATUS;&quot; | grep -m 1 file | awk &#39;&#123;print $2&#125;&#39;)        current_binlog_pos&#x3D;4    fi    echo &quot;Starting incremental backup from position $current_binlog_pos in file $current_binlog_file...&quot;    mysqlbinlog --start-position&#x3D;&quot;$current_binlog_pos&quot; &quot;$current_binlog_file&quot; | mysql -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot;    local new_binlog_pos&#x3D;$(mysql -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot; -e &quot;SHOW MASTER STATUS\G&quot; | grep -m 1 &#39;Position&#39; | awk &#39;&#123;print $3&#125;&#39;)    echo &quot;$current_binlog_file:$new_binlog_pos&quot; &gt; &quot;$LAST_POSITION_FILE&quot;&#125;# 数据恢复函数restore_data() &#123;    local restore_time&#x3D;$1    local full_backup_file    local incremental_files&#x3D;($(ls -t &quot;$FULL_BACKUP_DIR&quot;&#x2F;*.sql.gz))    if [ -z &quot;$restore_time&quot; ]; then        echo &quot;Error: No restore time provided.&quot;        exit 1    fi    full_backup_file&#x3D;$&#123;incremental_files[0]&#125;    if [ ! -f &quot;$FULL_BACKUP_DIR&#x2F;$full_backup_file&quot; ]; then        echo &quot;Error: Full backup file does not exist.&quot;        exit 1    fi    echo &quot;Restoring from full backup: $full_backup_file&quot;    gzip -cd &quot;$FULL_BACKUP_DIR&#x2F;$full_backup_file&quot; | mysql -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot; &quot;$RESTORE_DB&quot;    echo &quot;Applying incremental backups up to $restore_time...&quot;    local last_file&#x3D;&quot;&quot;    for file in $(ls -t &quot;$INCREMENTAL_BACKUP_DIR&quot;&#x2F;*); do        file_name&#x3D;$(basename &quot;$file&quot;)        if [[ $file_name &lt; &quot;$restore_time&quot; ]]; then            mysqlbinlog &quot;$file&quot; | mysql -u &quot;$MYSQL_USER&quot; -p&quot;$MYSQL_PASS&quot; &quot;$RESTORE_DB&quot;            last_file&#x3D;&quot;$file&quot;        else            break        fi    done    if [ -n &quot;$last_file&quot; ]; then        echo &quot;Updating last binlog position to $(basename &quot;$last_file&quot;).&quot;        echo &quot;$(basename &quot;$last_file&quot;)&quot; &gt; &quot;$LAST_POSITION_FILE&quot;    fi    echo &quot;Restore complete.&quot;&#125;# 函数：检查是否已设置定时任务check_cron_jobs() &#123;script_name    local full_cron_exists&#x3D;$(crontab -l | grep -F &quot;$script_name full&quot; | wc -l)    local incremental_cron_exists&#x3D;$(crontab -l | grep -F &quot;$script_name incremental&quot; | wc -l)    if [ &quot;$full_cron_exists&quot; -gt 0 ] &amp;&amp; [ &quot;$incremental_cron_exists&quot; -gt 0 ]; then        echo &quot;Cron jobs for full and incremental backups already exist.&quot;        return 0    else        return 1    fi&#125;# 函数：设置定时任务setup_cron_jobs() &#123;    # 询问用户备份频率    local full_freq&#x3D;$(ask_for_input &quot;Please enter full backup frequency (days, e.g., &#39;1&#39; for daily)&quot; &quot;1&quot;)    local incremental_freq&#x3D;$(ask_for_input &quot;Please enter incremental backup frequency (hours, e.g., &#39;1&#39; for hourly)&quot; &quot;1&quot;)    # 删除现有的备份相关的cron任务    crontab -l | grep -v &quot;$0&quot; | crontab -    # 添加新的备份任务    # 假设full_backup.sh和incremental_backup.sh是备份脚本的文件名    (crontab -l 2&gt;&#x2F;dev&#x2F;null; echo &quot;0 *&#x2F;$&#123;full_freq&#125; * * * $0 full&quot;) | crontab -    (crontab -l 2&gt;&#x2F;dev&#x2F;null; echo &quot;0 * * * * $0 incremental&quot;) | crontab -    echo &quot;Cron jobs for full and incremental backups have been set.&quot;&#125;# init_mysql() &#123;    # 保存环境变量到.mysql.env    save_env &gt; &quot;$ENV_PATH&quot;    # 设置定时任务    if ! check_cron_jobs; then        setup_cron_jobs    else        echo &quot;Existing cron jobs found. No changes made.&quot;    fi&#125;# 主函数，根据命令行参数调用相应的备份或恢复函数main() &#123;    if [ $# -eq 0 ]; then        echo &quot;Usage: $0 &#123;install|update|initialize|full|incremental|restore&#125;&quot;        exit 1    fireload_env    case &quot;$1&quot; ininstall)            install_mysql            ;;update)            update_mysql            ;;initialize)            init_mysql            ;;        full)            full_backup            ;;        incremental)            if [ -z &quot;$2&quot; ]; then                echo &quot;Cron job mode: running incremental backup.&quot;                incremental_backup            else                echo &quot;Error: Unexpected argument for incremental.&quot;                exit 1            fi            ;;        restore)            if [ -z &quot;$2&quot; ]; then                echo &quot;Error: Restore time not provided.&quot;                exit 1            else                restore_data &quot;$2&quot;            fi            ;;        *)            echo &quot;Error: Invalid command. Use &#39;full&#39;, &#39;incremental&#39;, or &#39;restore&#39;.&quot;            exit 1            ;;    esac&#125;# 执行主函数，并传递所有命令行参数main &quot;$@&quot;</code></pre></div></figure><blockquote><p>注: 上述脚本仍未测试，请使用需谨慎！谨慎！再谨慎！<br>  有问题请留言说明，谢谢了~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows网络-IPv6优先导致DNS失效问题</title>
    <link href="/doc/ed0c644d.html"/>
    <url>/doc/ed0c644d.html</url>
    
    <content type="html"><![CDATA[<p>目前大陆网络基本已全面覆盖IPv6网络，正常使用情况下就会出现许多从未遇到的未知网络问题，特此小计一下。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>OS: Windows 10</li><li>网络环境: DHCP下发了IPv6和IPv4，目前PC以v6为优先</li><li>问题表现: 在PC中使用VPN(WireGuard)，VPN配置中携带DNS服务器地址，关闭IPv6后正常解析，开启后解析失效。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>查询资料了解到，Windows默认是以IPv6作为优先去访问网络资源的，因此需要进行额外的配置，以保证IPv4作为优先。同时还需禁用智能多宿主名称解析功能，保证v4和v6 DNS解析不同时进行。</p><blockquote><p>注: 禁用智能多宿主名称解析还可以解决DNS泄露等问题哦~</p></blockquote><ul><li><a href="https://learn.microsoft.com/zh-CN/troubleshoot/windows-server/networking/configure-ipv6-in-windows">如何为高级用户配置 IPv6</a></li><li><a href="https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.DNSClient::DNS_SmartMultiHomedNameResolution&Language=zh-cn">禁用智能多宿主名称解析</a></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters&quot; &#x2F;v DisabledComponents &#x2F;t REG_DWORD &#x2F;d 0x20 &#x2F;f#reg add &quot;HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows NT\DNSClient&quot; &#x2F;v DisableSmartNameResolution &#x2F;t REG_DWORD &#x2F;d 0x1 &#x2F;freg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters&quot; &#x2F;v DisableParallelAandAAAA &#x2F;t REG_DWORD &#x2F;d 0x1 &#x2F;f</code></pre></div></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Windows 官方也提供了对应的解决方案，可自行下载进行处理：</p><ul><li><a href="/static/diagcab/ipv4%E4%BC%98%E5%85%88.diagcab">ipv4优先</a></li><li><a href="/static/diagcab/%E6%81%A2%E5%A4%8Dipv6%E4%BC%98%E5%85%88.diagcab">恢复ipv6优先</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>IPv6</tag>
      
      <tag>DNS</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源VPN-NetBird</title>
    <link href="/doc/8a393b1f.html"/>
    <url>/doc/8a393b1f.html</url>
    
    <content type="html"><![CDATA[<p>NetBird 是一个简单快速的企业级 VPN 替代方案，建立在原生 WireGuard® 之上，可以轻松为您的组织或家庭创建安全的私人网络。它几乎不需要任何配置工作，从而摆脱了开放端口、复杂的防火墙规则、VPN 网关等烦琐任务的困扰。</p><span id="more"></span><blockquote><p>官网地址：<a href="https://netbird.io/">https://netbird.io/</a><br>文档地址：<a href="https://docs.netbird.io/">https://docs.netbird.io/</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>跟<a href="/doc/a1064baf.html">WireGuard</a>相比较，NetBird 更适合作为团队或企业级的 VPN 解决方案。</p><p>因为 NetBird 会自行检测客户端网络环境，觉得是由服务端做中继节点还是通过 NAT 穿透，让客户端节点进行点对点通信。</p><h2 id="搭建NetBird服务器"><a href="#搭建NetBird服务器" class="headerlink" title="搭建NetBird服务器"></a>搭建NetBird服务器</h2><p>若您没有其他的要求，则可以直接通过官方提供的脚本进行一键安装，首先需要安装基础环境，以Ubuntu为例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#apt update apt install curl jq</code></pre></div></figure><p>其次 NetBird 需要 Docker 环境做支撑，可参考<a href="/doc/457e5fca.html">Ubuntu安装Docker</a>文档完成对 Docker 环境的安装。</p><p>接下来执行<code>export NETBIRD_DOMAIN=netbird.example.com; curl -fsSL https://github.com/netbirdio/netbird/releases/latest/download/getting-started-with-zitadel.sh | bash</code>指令即可完成对 NetBird 的安装。</p><h2 id="自定义搭建NetBird服务器"><a href="#自定义搭建NetBird服务器" class="headerlink" title="自定义搭建NetBird服务器"></a>自定义搭建NetBird服务器</h2><p>若有较为高阶的定制需求。例如，服务器已拥有 Nginx 代理而不想使用脚本中安装的 Caddy 代理时，则需要对脚本进行自定义。</p><h3 id="准备Nginx配置"><a href="#准备Nginx配置" class="headerlink" title="准备Nginx配置"></a>准备Nginx配置</h3><p>当前以 Nginx 配置 SSL 进行代理为例介绍，这里需要将生成好的 <code>Caddyfile</code> 翻译为 Nginx 的配置文件，对比如下：</p><blockquote><p>在此声明：需要用到的域名，若您想将 IDP 服务和 NetBird 服务进行区分（给每个服务配上不同的域名）安装，请自行研究，这里不在赘述。<br>用到的域名：<code>demo.cikaros.top</code> （该域名当前已不可用，别想白嫖我~）</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-Caddyfile" data-language="Caddyfile"><code class="language-Caddyfile">&#123;  debugservers :80,:443 &#123;    protocols h1 h2c  &#125;&#125;(security_headers) &#123;    header * &#123;        # enable HSTS        Strict-Transport-Security &quot;max-age&#x3D;3600; includeSubDomains; preload&quot;        # disable clients from sniffing the media type        X-Content-Type-Options &quot;nosniff&quot;        # clickjacking protection        X-Frame-Options &quot;DENY&quot;        # xss protection        X-XSS-Protection &quot;1; mode&#x3D;block&quot;        # Remove -Server header, which is an information leak        # Remove Caddy from Headers        -Server        # keep referrer data off of HTTP connections        Referrer-Policy strict-origin-when-cross-origin    &#125;&#125;:80, demo.cikaros.top:443 &#123;    import security_headers    # Signal    reverse_proxy &#x2F;signalexchange.SignalExchange&#x2F;* h2c:&#x2F;&#x2F;signal:10000    # Management    reverse_proxy &#x2F;api&#x2F;* management:80    reverse_proxy &#x2F;management.ManagementService&#x2F;* h2c:&#x2F;&#x2F;management:80    # Zitadel    reverse_proxy &#x2F;zitadel.admin.v1.AdminService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;admin&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;zitadel.auth.v1.AuthService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;auth&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;zitadel.management.v1.ManagementService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;management&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;zitadel.system.v1.SystemService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;system&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;assets&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;ui&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;oidc&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;saml&#x2F;v2&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;oauth&#x2F;v2&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;.well-known&#x2F;openid-configuration h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;openapi&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;debug&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;device&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    reverse_proxy &#x2F;device h2c:&#x2F;&#x2F;zitadel:8080    # Dashboard    reverse_proxy &#x2F;* dashboard:80&#125;</code></pre></div></figure><p>构建的 Nginx 配置如下：</p><blockquote><p>注意：需要在服务器内部制定合理的网桥环境，为每一个需要反向代理的容器制定合适的IP地址。<br>网段：<code>172.10.0.0/24</code><br><code>zitadel</code>：<code>172.10.0.2/32</code><br><code>dashboard</code>：<code>172.10.0.3/32</code><br><code>signal</code>：<code>172.10.0.4/32</code><br><code>management</code>：<code>172.10.0.5/32</code><br><code>turn</code>：需要公网开放，因此使用<code>host</code>网络模式</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">upstream zitadel &#123;    server 172.10.0.2:8080; &#125;upstream dashboard &#123;    keepalive 10;     server 172.10.0.3; &#125;upstream signal &#123;    server 172.10.0.4:10000; &#125;upstream management &#123;    server 172.10.0.5; &#125;server &#123;    listen 80 ;     listen 443 ssl http2 ;     server_name demo.cikaros.top;     index index.php index.html index.htm default.php default.htm default.html;     proxy_set_header Host $host:$server_port;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header X-Forwarded-Host $server_name;     proxy_set_header X-Real-IP $remote_addr;     proxy_http_version 1.1;     proxy_set_header Upgrade $http_upgrade;     proxy_set_header Connection &quot;upgrade&quot;;     access_log &#x2F;www&#x2F;sites&#x2F;demo.cikaros.top&#x2F;log&#x2F;access.log;     error_log &#x2F;www&#x2F;sites&#x2F;demo.cikaros.top&#x2F;log&#x2F;error.log;     location ^~ &#x2F;.well-known&#x2F;acme-challenge &#123;        allow all;         root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;     &#125;    client_header_timeout 1d;     client_body_timeout 1d;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header X-Scheme $scheme;     proxy_set_header X-Forwarded-Proto https;     proxy_set_header X-Forwarded-Host $host;     grpc_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     add_header Strict-Transport-Security &quot;max-age&#x3D;3600; includeSubDomains; preload&quot;;     add_header X-Content-Type-Options &quot;nosniff&quot;;     add_header X-Frame-Options &quot;DENY&quot;;     add_header X-XSS-Protection &quot;1; mode&#x3D;block&quot;;     add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot;;     # Signal    #reverse_proxy &#x2F;signalexchange.SignalExchange&#x2F;* h2c:&#x2F;&#x2F;signal:10000    location &#x2F;signalexchange.SignalExchange&#x2F; &#123;        grpc_pass grpc:&#x2F;&#x2F;signal;         #grpc_ssl_verify off;        grpc_read_timeout 1d;         grpc_send_timeout 1d;         grpc_socket_keepalive on;     &#125;    # Management    #reverse_proxy &#x2F;api&#x2F;* management:80    location &#x2F;api &#123;        proxy_pass http:&#x2F;&#x2F;management;     &#125;    #reverse_proxy &#x2F;management.ManagementService&#x2F;* h2c:&#x2F;&#x2F;management:80    location &#x2F;management.ManagementService &#123;        grpc_pass grpc:&#x2F;&#x2F;management;         #grpc_ssl_verify off;        grpc_read_timeout 1d;         grpc_send_timeout 1d;         grpc_socket_keepalive on;     &#125;    # Zitadel    #reverse_proxy &#x2F;zitadel.admin.v1.AdminService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;zitadel.admin.v1.AdminService &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;admin&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;admin &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;zitadel.auth.v1.AuthService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;zitadel.auth.v1.AuthService &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;auth&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;auth &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;zitadel.management.v1.ManagementService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;zitadel.management.v1.ManagementService &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;management&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;management &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;zitadel.system.v1.SystemService&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;zitadel.system.v1.SystemService &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;system&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;system &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;assets&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;assets &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;ui&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;ui &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;oidc&#x2F;v1&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;oidc &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;saml&#x2F;v2&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;saml &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;oauth&#x2F;v2&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;oauth &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;.well-known&#x2F;openid-configuration h2c:&#x2F;&#x2F;zitadel:8080    location &#x3D; &#x2F;.well-known&#x2F;openid-configuration &#123;        proxy_pass http:&#x2F;&#x2F;zitadel;     &#125;    #reverse_proxy &#x2F;openapi&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;openapi &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;debug&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;debug &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    #reverse_proxy &#x2F;device&#x2F;* h2c:&#x2F;&#x2F;zitadel:8080    #reverse_proxy &#x2F;device h2c:&#x2F;&#x2F;zitadel:8080    location &#x2F;device &#123;        grpc_pass grpc:&#x2F;&#x2F;zitadel;         grpc_set_header Host $host:$server_port;     &#125;    # Dashboard    #reverse_proxy &#x2F;* dashboard:80    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;dashboard;     &#125;    if ($scheme &#x3D; http) &#123;        return 301 https:&#x2F;&#x2F;$host$request_uri;     &#125;    ssl_certificate &#x2F;www&#x2F;sites&#x2F;demo.cikaros.top&#x2F;ssl&#x2F;fullchain.pem;     ssl_certificate_key &#x2F;www&#x2F;sites&#x2F;demo.cikaros.top&#x2F;ssl&#x2F;privkey.pem;     ssl_protocols TLSv1.3 TLSv1.2 TLSv1.1 TLSv1;     ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;     ssl_prefer_server_ciphers on;     ssl_session_cache shared:SSL:10m;     ssl_session_timeout 10m;     #add_header Strict-Transport-Security &quot;max-age&#x3D;31536000&quot;;     error_page 497 https:&#x2F;&#x2F;$host$request_uri;     proxy_set_header X-Forwarded-Proto https;     ssl_stapling on;     ssl_stapling_verify on; &#125;</code></pre></div></figure><h3 id="将getting-started-with-zitadel-sh脚本进行修订"><a href="#将getting-started-with-zitadel-sh脚本进行修订" class="headerlink" title="将getting-started-with-zitadel.sh脚本进行修订"></a>将<code>getting-started-with-zitadel.sh</code>脚本进行修订</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#函数返回非零，程序立即终止set -ehandle_request_command_status() &#123;  PARSED_RESPONSE&#x3D;$1  FUNCTION_NAME&#x3D;$2  RESPONSE&#x3D;$3  if [[ $PARSED_RESPONSE -ne 0 ]]; then    echo &quot;ERROR calling $FUNCTION_NAME:&quot; $(echo &quot;$RESPONSE&quot; | jq -r &#39;.message&#39;) &gt; &#x2F;dev&#x2F;stderr    exit 1  fi&#125;handle_zitadel_request_response() &#123;  PARSED_RESPONSE&#x3D;$1  FUNCTION_NAME&#x3D;$2  RESPONSE&#x3D;$3  if [[ $PARSED_RESPONSE &#x3D;&#x3D; &quot;null&quot; ]]; then    echo &quot;ERROR calling $FUNCTION_NAME:&quot; $(echo &quot;$RESPONSE&quot; | jq -r &#39;.message&#39;) &gt; &#x2F;dev&#x2F;stderr    exit 1  fi  sleep 1&#125;#检查Docker Docker Compose是否安装check_docker_compose() &#123;  if command -v docker-compose &amp;&gt; &#x2F;dev&#x2F;null  then      echo &quot;docker-compose&quot;      return  fi  if docker compose --help &amp;&gt; &#x2F;dev&#x2F;null  then      echo &quot;docker compose&quot;      return  fi  echo &quot;docker-compose is not installed or not in PATH. Please follow the steps from the official guide: https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;install&#x2F;&quot; &gt; &#x2F;dev&#x2F;stderr  exit 1&#125;#检查JQ是否安装check_jq() &#123;  if ! command -v jq &amp;&gt; &#x2F;dev&#x2F;null  then    echo &quot;jq is not installed or not in PATH, please install with your package manager. e.g. sudo apt install jq&quot; &gt; &#x2F;dev&#x2F;stderr    exit 1  fi&#125;#等待crdb正常启动wait_crdb() &#123;  set +e  while true; do    if $DOCKER_COMPOSE_COMMAND exec -T crdb curl -sf -o &#x2F;dev&#x2F;null &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;health?ready&#x3D;1&#39;; then      break    fi    echo -n &quot; .&quot;    sleep 5  done  echo &quot; done&quot;  set -e&#125;#初始化crdbinit_crdb() &#123;  echo -e &quot;\nInitializing Zitadel&#39;s CockroachDB\n\n&quot;  $DOCKER_COMPOSE_COMMAND up -d crdb  echo &quot;&quot;  # shellcheck disable&#x3D;SC2028  echo -n &quot;Waiting cockroachDB  to become ready &quot;  wait_crdb  $DOCKER_COMPOSE_COMMAND exec -T crdb &#x2F;bin&#x2F;bash -c &quot;cp &#x2F;cockroach&#x2F;certs&#x2F;* &#x2F;zitadel-certs&#x2F; &amp;&amp; cockroach cert create-client --overwrite --certs-dir &#x2F;zitadel-certs&#x2F; --ca-key &#x2F;zitadel-certs&#x2F;ca.key zitadel_user &amp;&amp; chown -R 1000:1000 &#x2F;zitadel-certs&#x2F;&quot;  handle_request_command_status $? &quot;init_crdb failed&quot; &quot;&quot;&#125;#获取主机IPget_main_ip_address() &#123;  if [[ &quot;$OSTYPE&quot; &#x3D;&#x3D; &quot;darwin&quot;* ]]; then    interface&#x3D;$(route -n get default | grep &#39;interface:&#39; | awk &#39;&#123;print $2&#125;&#39;)    ip_address&#x3D;$(ifconfig &quot;$interface&quot; | grep &#39;inet &#39; | awk &#39;&#123;print $2&#125;&#39;)  else    interface&#x3D;$(ip route | grep default | awk &#39;&#123;print $5&#125;&#39; | head -n 1)    ip_address&#x3D;$(ip addr show &quot;$interface&quot; | grep &#39;inet &#39; | awk &#39;&#123;print $2&#125;&#39; | cut -d&#39;&#x2F;&#39; -f1)  fi  echo &quot;$ip_address&quot;&#125;#等待PAT是否已生成wait_pat() &#123;  PAT_PATH&#x3D;$1  set +e  while true; do    if [[ -f &quot;$PAT_PATH&quot; ]]; then      break    fi    echo -n &quot; .&quot;    sleep 1  done  echo &quot; done&quot;  set -e&#125;#等待API调用wait_api() &#123;    INSTANCE_URL&#x3D;$1    PAT&#x3D;$2    set +e    while true; do      curl -s --fail -o &#x2F;dev&#x2F;null &quot;$INSTANCE_URL&#x2F;auth&#x2F;v1&#x2F;users&#x2F;me&quot; -H &quot;Authorization: Bearer $PAT&quot;      if [[ $? -eq 0 ]]; then        break      fi      echo -n &quot; .&quot;      sleep 1    done    echo &quot; done&quot;    set -e&#125;#创建内部项目create_new_project() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  PROJECT_NAME&#x3D;&quot;NETBIRD&quot;  RESPONSE&#x3D;$(    curl -sS -X POST &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;projects&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;&quot;name&quot;: &quot;&#39;&quot;$PROJECT_NAME&quot;&#39;&quot;&#125;&#39;  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.id&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;create_new_project&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;#创建应用create_new_application() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  APPLICATION_NAME&#x3D;$3  BASE_REDIRECT_URL1&#x3D;$4  BASE_REDIRECT_URL2&#x3D;$5  LOGOUT_URL&#x3D;$6  ZITADEL_DEV_MODE&#x3D;$7  DEVICE_CODE&#x3D;$8  if [[ $DEVICE_CODE &#x3D;&#x3D; &quot;true&quot; ]]; then    GRANT_TYPES&#x3D;&#39;[&quot;OIDC_GRANT_TYPE_AUTHORIZATION_CODE&quot;,&quot;OIDC_GRANT_TYPE_DEVICE_CODE&quot;,&quot;OIDC_GRANT_TYPE_REFRESH_TOKEN&quot;]&#39;  else    GRANT_TYPES&#x3D;&#39;[&quot;OIDC_GRANT_TYPE_AUTHORIZATION_CODE&quot;,&quot;OIDC_GRANT_TYPE_REFRESH_TOKEN&quot;]&#39;  fi  RESPONSE&#x3D;$(    curl -sS -X POST &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;projects&#x2F;$PROJECT_ID&#x2F;apps&#x2F;oidc&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;    &quot;name&quot;: &quot;&#39;&quot;$APPLICATION_NAME&quot;&#39;&quot;,    &quot;redirectUris&quot;: [      &quot;&#39;&quot;$BASE_REDIRECT_URL1&quot;&#39;&quot;,      &quot;&#39;&quot;$BASE_REDIRECT_URL2&quot;&#39;&quot;    ],    &quot;postLogoutRedirectUris&quot;: [       &quot;&#39;&quot;$LOGOUT_URL&quot;&#39;&quot;    ],    &quot;RESPONSETypes&quot;: [      &quot;OIDC_RESPONSE_TYPE_CODE&quot;    ],    &quot;grantTypes&quot;: &#39;&quot;$GRANT_TYPES&quot;&#39;,    &quot;appType&quot;: &quot;OIDC_APP_TYPE_USER_AGENT&quot;,    &quot;authMethodType&quot;: &quot;OIDC_AUTH_METHOD_TYPE_NONE&quot;,    &quot;version&quot;: &quot;OIDC_VERSION_1_0&quot;,    &quot;devMode&quot;: &#39;&quot;$ZITADEL_DEV_MODE&quot;&#39;,    &quot;accessTokenType&quot;: &quot;OIDC_TOKEN_TYPE_JWT&quot;,    &quot;accessTokenRoleAssertion&quot;: true,    &quot;skipNativeAppSuccessPage&quot;: true  &#125;&#39;  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.clientId&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;create_new_application&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;#创建服务用户create_service_user() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  RESPONSE&#x3D;$(    curl -sS -X POST &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;users&#x2F;machine&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;            &quot;userName&quot;: &quot;netbird-service-account&quot;,            &quot;name&quot;: &quot;Netbird Service Account&quot;,            &quot;description&quot;: &quot;Netbird Service Account for IDP management&quot;,            &quot;accessTokenType&quot;: &quot;ACCESS_TOKEN_TYPE_JWT&quot;      &#125;&#39;  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.userId&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;create_service_user&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;#创建服务用户密钥create_service_user_secret() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  USER_ID&#x3D;$3  RESPONSE&#x3D;$(    curl -sS -X PUT &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;users&#x2F;$USER_ID&#x2F;secret&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;&#125;&#39;  )  SERVICE_USER_CLIENT_ID&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.clientId&#39;)  handle_zitadel_request_response &quot;$SERVICE_USER_CLIENT_ID&quot; &quot;create_service_user_secret_id&quot; &quot;$RESPONSE&quot;  SERVICE_USER_CLIENT_SECRET&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.clientSecret&#39;)  handle_zitadel_request_response &quot;$SERVICE_USER_CLIENT_SECRET&quot; &quot;create_service_user_secret&quot; &quot;$RESPONSE&quot;&#125;#将服务用户追加至组织管理员add_organization_user_manager() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  USER_ID&#x3D;$3  RESPONSE&#x3D;$(    curl -sS -X POST &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;orgs&#x2F;me&#x2F;members&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;            &quot;userId&quot;: &quot;&#39;&quot;$USER_ID&quot;&#39;&quot;,            &quot;roles&quot;: [              &quot;ORG_USER_MANAGER&quot;            ]      &#125;&#39;  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.details.creationDate&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;add_organization_user_manager&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;#创建管理员用户create_admin_user() &#123;    INSTANCE_URL&#x3D;$1    PAT&#x3D;$2    USERNAME&#x3D;$3    PASSWORD&#x3D;$4    RESPONSE&#x3D;$(        curl -sS -X POST &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;users&#x2F;human&#x2F;_import&quot; \          -H &quot;Authorization: Bearer $PAT&quot; \          -H &quot;Content-Type: application&#x2F;json&quot; \          -d &#39;&#123;                &quot;userName&quot;: &quot;&#39;&quot;$USERNAME&quot;&#39;&quot;,                &quot;profile&quot;: &#123;                  &quot;firstName&quot;: &quot;Zitadel&quot;,                  &quot;lastName&quot;: &quot;Admin&quot;                &#125;,                &quot;email&quot;: &#123;                  &quot;email&quot;: &quot;&#39;&quot;$USERNAME&quot;&#39;&quot;,                  &quot;isEmailVerified&quot;: true                &#125;,                &quot;password&quot;: &quot;&#39;&quot;$PASSWORD&quot;&#39;&quot;,                &quot;passwordChangeRequired&quot;: true          &#125;&#39;      )      PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.userId&#39;)      handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;create_admin_user&quot; &quot;$RESPONSE&quot;      echo &quot;$PARSED_RESPONSE&quot;&#125;add_instance_admin() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  USER_ID&#x3D;$3  RESPONSE&#x3D;$(    curl -sS -X POST &quot;$INSTANCE_URL&#x2F;admin&#x2F;v1&#x2F;members&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \      -d &#39;&#123;            &quot;userId&quot;: &quot;&#39;&quot;$USER_ID&quot;&#39;&quot;,            &quot;roles&quot;: [              &quot;IAM_OWNER&quot;            ]      &#125;&#39;  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.details.creationDate&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;add_instance_admin&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;delete_auto_service_user() &#123;  INSTANCE_URL&#x3D;$1  PAT&#x3D;$2  RESPONSE&#x3D;$(    curl -sS -X GET &quot;$INSTANCE_URL&#x2F;auth&#x2F;v1&#x2F;users&#x2F;me&quot; \      -H &quot;Authorization: Bearer $PAT&quot; \      -H &quot;Content-Type: application&#x2F;json&quot; \  )  USER_ID&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.user.id&#39;)  handle_zitadel_request_response &quot;$USER_ID&quot; &quot;delete_auto_service_user_get_user&quot; &quot;$RESPONSE&quot;  RESPONSE&#x3D;$(      curl -sS -X DELETE &quot;$INSTANCE_URL&#x2F;admin&#x2F;v1&#x2F;members&#x2F;$USER_ID&quot; \        -H &quot;Authorization: Bearer $PAT&quot; \        -H &quot;Content-Type: application&#x2F;json&quot; \  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.details.changeDate&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;delete_auto_service_user_remove_instance_permissions&quot; &quot;$RESPONSE&quot;  RESPONSE&#x3D;$(      curl -sS -X DELETE &quot;$INSTANCE_URL&#x2F;management&#x2F;v1&#x2F;orgs&#x2F;me&#x2F;members&#x2F;$USER_ID&quot; \        -H &quot;Authorization: Bearer $PAT&quot; \        -H &quot;Content-Type: application&#x2F;json&quot; \  )  PARSED_RESPONSE&#x3D;$(echo &quot;$RESPONSE&quot; | jq -r &#39;.details.changeDate&#39;)  handle_zitadel_request_response &quot;$PARSED_RESPONSE&quot; &quot;delete_auto_service_user_remove_org_permissions&quot; &quot;$RESPONSE&quot;  echo &quot;$PARSED_RESPONSE&quot;&#125;#初始化zitadel服务器init_zitadel() &#123;  echo -e &quot;\nInitializing Zitadel with NetBird&#39;s applications\n&quot;  INSTANCE_URL&#x3D;&quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&quot;  TOKEN_PATH&#x3D;.&#x2F;machinekey&#x2F;zitadel-admin-sa.token  echo -n &quot;Waiting for Zitadel&#39;s PAT to be created &quot;  wait_pat &quot;$TOKEN_PATH&quot;  echo &quot;Reading Zitadel PAT&quot;  PAT&#x3D;$(cat $TOKEN_PATH)  if [ &quot;$PAT&quot; &#x3D; &quot;null&quot; ]; then    echo &quot;Failed requesting getting Zitadel PAT&quot;    exit 1  fi  echo -n &quot;Waiting for Zitadel to become ready &quot;  wait_api &quot;$INSTANCE_URL&quot; &quot;$PAT&quot;  #  create the zitadel project  echo &quot;Creating new zitadel project&quot;  PROJECT_ID&#x3D;$(create_new_project &quot;$INSTANCE_URL&quot; &quot;$PAT&quot;)  ZITADEL_DEV_MODE&#x3D;false  BASE_REDIRECT_URL&#x3D;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN  if [[ $NETBIRD_HTTP_PROTOCOL &#x3D;&#x3D; &quot;http&quot; ]]; then    ZITADEL_DEV_MODE&#x3D;true  fi  # create zitadel spa applications  echo &quot;Creating new Zitadel SPA Dashboard application&quot;  DASHBOARD_APPLICATION_CLIENT_ID&#x3D;$(create_new_application &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;Dashboard&quot; &quot;$BASE_REDIRECT_URL&#x2F;nb-auth&quot; &quot;$BASE_REDIRECT_URL&#x2F;nb-silent-auth&quot; &quot;$BASE_REDIRECT_URL&#x2F;&quot; &quot;$ZITADEL_DEV_MODE&quot; &quot;false&quot;)  echo &quot;Creating new Zitadel SPA Cli application&quot;  CLI_APPLICATION_CLIENT_ID&#x3D;$(create_new_application &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;Cli&quot; &quot;http:&#x2F;&#x2F;localhost:53000&#x2F;&quot; &quot;http:&#x2F;&#x2F;localhost:54000&#x2F;&quot; &quot;http:&#x2F;&#x2F;localhost:53000&#x2F;&quot; &quot;true&quot; &quot;true&quot;)  MACHINE_USER_ID&#x3D;$(create_service_user &quot;$INSTANCE_URL&quot; &quot;$PAT&quot;)  SERVICE_USER_CLIENT_ID&#x3D;&quot;null&quot;  SERVICE_USER_CLIENT_SECRET&#x3D;&quot;null&quot;  create_service_user_secret &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;$MACHINE_USER_ID&quot;  DATE&#x3D;$(add_organization_user_manager &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;$MACHINE_USER_ID&quot;)  ZITADEL_ADMIN_USERNAME&#x3D;&quot;Cikaros@$NETBIRD_DOMAIN&quot;  ZITADEL_ADMIN_PASSWORD&#x3D;&quot;$(openssl rand -base64 32 | sed &#39;s&#x2F;&#x3D;&#x2F;&#x2F;g&#39;)@&quot;  HUMAN_USER_ID&#x3D;$(create_admin_user &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;$ZITADEL_ADMIN_USERNAME&quot; &quot;$ZITADEL_ADMIN_PASSWORD&quot;)  DATE&#x3D;&quot;null&quot;  DATE&#x3D;$(add_instance_admin &quot;$INSTANCE_URL&quot; &quot;$PAT&quot; &quot;$HUMAN_USER_ID&quot;)  DATE&#x3D;&quot;null&quot;  DATE&#x3D;$(delete_auto_service_user &quot;$INSTANCE_URL&quot; &quot;$PAT&quot;)  if [ &quot;$DATE&quot; &#x3D; &quot;null&quot; ]; then      echo &quot;Failed deleting auto service user&quot;      echo &quot;Please remove it manually&quot;  fi  export NETBIRD_AUTH_CLIENT_ID&#x3D;$DASHBOARD_APPLICATION_CLIENT_ID  export NETBIRD_AUTH_CLIENT_ID_CLI&#x3D;$CLI_APPLICATION_CLIENT_ID  export NETBIRD_IDP_MGMT_CLIENT_ID&#x3D;$SERVICE_USER_CLIENT_ID  export NETBIRD_IDP_MGMT_CLIENT_SECRET&#x3D;$SERVICE_USER_CLIENT_SECRET  export ZITADEL_ADMIN_USERNAME  export ZITADEL_ADMIN_PASSWORD&#125;#检查域名check_nb_domain() &#123;  DOMAIN&#x3D;$1  if [ &quot;$DOMAIN-x&quot; &#x3D;&#x3D; &quot;-x&quot; ]; then    echo &quot;The NETBIRD_DOMAIN variable cannot be empty.&quot; &gt; &#x2F;dev&#x2F;stderr    return 1  fi  if [ &quot;$DOMAIN&quot; &#x3D;&#x3D; &quot;netbird.example.com&quot; ]; then    echo &quot;The NETBIRD_DOMAIN cannot be netbird.example.com&quot; &gt; &#x2F;dev&#x2F;stderr    return 1  fi  return 0&#125;read_nb_domain() &#123;  READ_NETBIRD_DOMAIN&#x3D;&quot;&quot;  echo -n &quot;Enter the domain you want to use for NetBird (e.g. netbird.my-domain.com): &quot; &gt; &#x2F;dev&#x2F;stderr  read -r READ_NETBIRD_DOMAIN &lt; &#x2F;dev&#x2F;tty  if ! check_nb_domain &quot;$READ_NETBIRD_DOMAIN&quot;; then    read_nb_domain  fi  echo &quot;$READ_NETBIRD_DOMAIN&quot;&#125;#获取turn外部IPget_turn_external_ip() &#123;  TURN_EXTERNAL_IP_CONFIG&#x3D;&quot;#external-ip&#x3D;&quot;  IP&#x3D;$(curl -s -4 https:&#x2F;&#x2F;jsonip.com | jq -r &#39;.ip&#39;)  if [[ &quot;x-$IP&quot; !&#x3D; &quot;x-&quot; ]]; then    TURN_EXTERNAL_IP_CONFIG&#x3D;&quot;external-ip&#x3D;$IP&quot;  fi  echo &quot;$TURN_EXTERNAL_IP_CONFIG&quot;&#125;#初始化环境变量 -- 程序入口initEnvironment() &#123;  #当前服务器的域名  NETBIRD_DOMAIN&#x3D;&quot;demo.cikaros.top&quot;  #搭建完成后每个客户端节点的根域名  NETBIRD_HOSTED_DOMAIN&#x3D;&quot;netbird.local&quot;  #抛弃  #CADDY_SECURE_DOMAIN&#x3D;&quot;&quot;  #Zidatel服务器相关环境变量  ZITADEL_EXTERNALSECURE&#x3D;&quot;false&quot;  ZITADEL_TLS_MODE&#x3D;&quot;disabled&quot;  ZITADEL_MASTERKEY&#x3D;&quot;$(openssl rand -base64 32 | head -c 32)&quot;  #Netbird相关环境变量  NETBIRD_PORT&#x3D;80  NETBIRD_HTTP_PROTOCOL&#x3D;&quot;http&quot;  #Turn服务器相关环境变量  TURN_USER&#x3D;&quot;self&quot;  TURN_PASSWORD&#x3D;$(openssl rand -base64 32 | sed &#39;s&#x2F;&#x3D;&#x2F;&#x2F;g&#39;)  #这里可根据情况进行设定  TURN_MIN_PORT&#x3D;49152  TURN_MAX_PORT&#x3D;65535  TURN_EXTERNAL_IP_CONFIG&#x3D;$(get_turn_external_ip)  #检查用户提供的域名是否可用  if ! check_nb_domain &quot;$NETBIRD_DOMAIN&quot;; then    NETBIRD_DOMAIN&#x3D;$(read_nb_domain)  fi  #检查域名是否为使用IP  if [ &quot;$NETBIRD_DOMAIN&quot; &#x3D;&#x3D; &quot;use-ip&quot; ]; then    NETBIRD_DOMAIN&#x3D;$(get_main_ip_address)  else    ZITADEL_EXTERNALSECURE&#x3D;&quot;true&quot;    ZITADEL_TLS_MODE&#x3D;&quot;external&quot;    NETBIRD_PORT&#x3D;443    #CADDY_SECURE_DOMAIN&#x3D;&quot;, $NETBIRD_DOMAIN:$NETBIRD_PORT&quot;    NETBIRD_HTTP_PROTOCOL&#x3D;&quot;https&quot;  fi  #生成Zidatel Token过期时间  if [[ &quot;$OSTYPE&quot; &#x3D;&#x3D; &quot;darwin&quot;* ]]; then      ZIDATE_TOKEN_EXPIRATION_DATE&#x3D;$(date -u -v+30M &quot;+%Y-%m-%dT%H:%M:%SZ&quot;)  else      ZIDATE_TOKEN_EXPIRATION_DATE&#x3D;$(date -u -d &quot;+30 minutes&quot; &quot;+%Y-%m-%dT%H:%M:%SZ&quot;)  fi  check_jq  DOCKER_COMPOSE_COMMAND&#x3D;$(check_docker_compose)  #检查Zidatel环境变量是否存在  if [ -f zitadel.env ]; then    echo &quot;Generated files already exist, if you want to reinitialize the environment, please remove them first.&quot;    echo &quot;You can use the following commands:&quot;    echo &quot;  $DOCKER_COMPOSE_COMMAND down --volumes # to remove all containers and volumes&quot;    echo &quot;  rm -f docker-compose.yml Caddyfile zitadel.env dashboard.env machinekey&#x2F;zitadel-admin-sa.token turnserver.conf management.json&quot;    echo &quot;Be aware that this will remove all data from the database, and you will have to reconfigure the dashboard.&quot;    exit 1  fi  echo 生成初始化文件...  renderDockerCompose &gt; docker-compose.yml  #抛弃  #renderCaddyfile &gt; Caddyfile  renderZitadelEnv &gt; zitadel.env  echo &quot;&quot; &gt; dashboard.env  echo &quot;&quot; &gt; turnserver.conf  echo &quot;&quot; &gt; management.json  mkdir -p machinekey  chmod 777 machinekey  init_crdb  echo -e &quot;\nStarting Zidatel IDP for user management\n\n&quot;  $DOCKER_COMPOSE_COMMAND up -d zitadel  init_zitadel  echo -e &quot;\nRendering NetBird files...\n&quot;  renderTurnServerConf &gt; turnserver.conf  renderManagementJson &gt; management.json  renderDashboardEnv &gt; dashboard.env  echo -e &quot;\nStarting NetBird services\n&quot;  $DOCKER_COMPOSE_COMMAND up -d  echo -e &quot;\nDone!\n&quot;  echo &quot;You can access the NetBird dashboard at $NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&quot;  echo &quot;Login with the following credentials:&quot;  echo &quot;Username: $ZITADEL_ADMIN_USERNAME&quot; | tee .env  echo &quot;Password: $ZITADEL_ADMIN_PASSWORD&quot; | tee -a .env&#125;#代码已被删除，这里仅做占位renderCaddyfile() &#123;&#125;renderTurnServerConf() &#123;  cat &lt;&lt;EOFlistening-port&#x3D;3478$TURN_EXTERNAL_IP_CONFIGtls-listening-port&#x3D;5349min-port&#x3D;$TURN_MIN_PORTmax-port&#x3D;$TURN_MAX_PORTfingerprintlt-cred-mechuser&#x3D;$TURN_USER:$TURN_PASSWORDrealm&#x3D;wiretrustee.comcert&#x3D;&#x2F;etc&#x2F;coturn&#x2F;certs&#x2F;cert.pempkey&#x3D;&#x2F;etc&#x2F;coturn&#x2F;private&#x2F;privkey.pemlog-file&#x3D;stdoutno-software-attributepidfile&#x3D;&quot;&#x2F;var&#x2F;tmp&#x2F;turnserver.pid&quot;no-cliEOF&#125;renderManagementJson() &#123;  cat &lt;&lt;EOF&#123;    &quot;Stuns&quot;: [        &#123;            &quot;Proto&quot;: &quot;udp&quot;,            &quot;URI&quot;: &quot;stun:$NETBIRD_DOMAIN:3478&quot;        &#125;    ],    &quot;TURNConfig&quot;: &#123;        &quot;Turns&quot;: [            &#123;                &quot;Proto&quot;: &quot;udp&quot;,                &quot;URI&quot;: &quot;turn:$NETBIRD_DOMAIN:3478&quot;,                &quot;Username&quot;: &quot;$TURN_USER&quot;,                &quot;Password&quot;: &quot;$TURN_PASSWORD&quot;            &#125;        ],        &quot;TimeBasedCredentials&quot;: false    &#125;,    &quot;Signal&quot;: &#123;        &quot;Proto&quot;: &quot;$NETBIRD_HTTP_PROTOCOL&quot;,        &quot;URI&quot;: &quot;$NETBIRD_DOMAIN:10000&quot;    &#125;,    &quot;HttpConfig&quot;: &#123;        &quot;AuthIssuer&quot;: &quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&quot;,        &quot;AuthAudience&quot;: &quot;$NETBIRD_AUTH_CLIENT_ID&quot;,        &quot;OIDCConfigEndpoint&quot;:&quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&#x2F;.well-known&#x2F;openid-configuration&quot;    &#125;,    &quot;IdpManagerConfig&quot;: &#123;        &quot;ManagerType&quot;: &quot;zitadel&quot;,        &quot;ClientConfig&quot;: &#123;            &quot;Issuer&quot;: &quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&quot;,            &quot;TokenEndpoint&quot;: &quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&#x2F;oauth&#x2F;v2&#x2F;token&quot;,            &quot;ClientID&quot;: &quot;$NETBIRD_IDP_MGMT_CLIENT_ID&quot;,            &quot;ClientSecret&quot;: &quot;$NETBIRD_IDP_MGMT_CLIENT_SECRET&quot;,            &quot;GrantType&quot;: &quot;client_credentials&quot;        &#125;,        &quot;ExtraConfig&quot;: &#123;            &quot;ManagementEndpoint&quot;: &quot;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN&#x2F;management&#x2F;v1&quot;        &#125;     &#125;,   &quot;DeviceAuthorizationFlow&quot;: &#123;       &quot;Provider&quot;: &quot;hosted&quot;,       &quot;ProviderConfig&quot;: &#123;           &quot;Audience&quot;: &quot;$NETBIRD_AUTH_CLIENT_ID_CLI&quot;,           &quot;ClientID&quot;: &quot;$NETBIRD_AUTH_CLIENT_ID_CLI&quot;,           &quot;Scope&quot;: &quot;openid&quot;       &#125;     &#125;,    &quot;PKCEAuthorizationFlow&quot;: &#123;        &quot;ProviderConfig&quot;: &#123;            &quot;Audience&quot;: &quot;$NETBIRD_AUTH_CLIENT_ID_CLI&quot;,            &quot;ClientID&quot;: &quot;$NETBIRD_AUTH_CLIENT_ID_CLI&quot;,            &quot;Scope&quot;: &quot;openid profile email offline_access&quot;,            &quot;RedirectURLs&quot;: [&quot;http:&#x2F;&#x2F;localhost:53000&#x2F;&quot;,&quot;http:&#x2F;&#x2F;localhost:54000&#x2F;&quot;]        &#125;    &#125;&#125;EOF&#125;renderDashboardEnv() &#123;  cat &lt;&lt;EOF# EndpointsNETBIRD_MGMT_API_ENDPOINT&#x3D;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAINNETBIRD_MGMT_GRPC_API_ENDPOINT&#x3D;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAIN# OIDCAUTH_AUDIENCE&#x3D;$NETBIRD_AUTH_CLIENT_IDAUTH_CLIENT_ID&#x3D;$NETBIRD_AUTH_CLIENT_IDAUTH_AUTHORITY&#x3D;$NETBIRD_HTTP_PROTOCOL:&#x2F;&#x2F;$NETBIRD_DOMAINUSE_AUTH0&#x3D;falseAUTH_SUPPORTED_SCOPES&#x3D;&quot;openid profile email offline_access&quot;AUTH_REDIRECT_URI&#x3D;&#x2F;nb-authAUTH_SILENT_REDIRECT_URI&#x3D;&#x2F;nb-silent-auth# SSLNGINX_SSL_PORT&#x3D;443# LetsencryptLETSENCRYPT_DOMAIN&#x3D;noneEOF&#125;renderZitadelEnv() &#123;  cat &lt;&lt;EOFZITADEL_LOG_LEVEL&#x3D;infoZITADEL_MASTERKEY&#x3D;$ZITADEL_MASTERKEYZITADEL_DATABASE_COCKROACH_HOST&#x3D;crdbZITADEL_DATABASE_COCKROACH_USER_USERNAME&#x3D;zitadel_userZITADEL_DATABASE_COCKROACH_USER_SSL_MODE&#x3D;verify-fullZITADEL_DATABASE_COCKROACH_USER_SSL_ROOTCERT&#x3D;&quot;&#x2F;crdb-certs&#x2F;ca.crt&quot;ZITADEL_DATABASE_COCKROACH_USER_SSL_CERT&#x3D;&quot;&#x2F;crdb-certs&#x2F;client.zitadel_user.crt&quot;ZITADEL_DATABASE_COCKROACH_USER_SSL_KEY&#x3D;&quot;&#x2F;crdb-certs&#x2F;client.zitadel_user.key&quot;ZITADEL_DATABASE_COCKROACH_ADMIN_SSL_MODE&#x3D;verify-fullZITADEL_DATABASE_COCKROACH_ADMIN_SSL_ROOTCERT&#x3D;&quot;&#x2F;crdb-certs&#x2F;ca.crt&quot;ZITADEL_DATABASE_COCKROACH_ADMIN_SSL_CERT&#x3D;&quot;&#x2F;crdb-certs&#x2F;client.root.crt&quot;ZITADEL_DATABASE_COCKROACH_ADMIN_SSL_KEY&#x3D;&quot;&#x2F;crdb-certs&#x2F;client.root.key&quot;ZITADEL_EXTERNALSECURE&#x3D;$ZITADEL_EXTERNALSECUREZITADEL_TLS_ENABLED&#x3D;&quot;false&quot;ZITADEL_EXTERNALPORT&#x3D;$NETBIRD_PORTZITADEL_EXTERNALDOMAIN&#x3D;$NETBIRD_DOMAINZITADEL_FIRSTINSTANCE_PATPATH&#x3D;&#x2F;machinekey&#x2F;zitadel-admin-sa.tokenZITADEL_FIRSTINSTANCE_ORG_MACHINE_MACHINE_USERNAME&#x3D;zitadel-admin-saZITADEL_FIRSTINSTANCE_ORG_MACHINE_MACHINE_NAME&#x3D;AdminZITADEL_FIRSTINSTANCE_ORG_MACHINE_PAT_SCOPES&#x3D;openidZITADEL_FIRSTINSTANCE_ORG_MACHINE_PAT_EXPIRATIONDATE&#x3D;$ZIDATE_TOKEN_EXPIRATION_DATEEOF&#125;renderDockerCompose() &#123;  cat &lt;&lt;EOFversion: &quot;3.4&quot;networks:  netbird:    ipam:      config:       - subnet: 172.10.0.0&#x2F;24services:  #UI dashboard  dashboard:    image: netbirdio&#x2F;dashboard:latest    restart: unless-stopped    networks:       netbird:        ipv4_address: 172.10.0.3    env_file:      - .&#x2F;dashboard.env  # Signal  signal:    image: netbirdio&#x2F;signal:latest    restart: unless-stopped    networks:       netbird:        ipv4_address: 172.10.0.4  # Management  management:    image: netbirdio&#x2F;management:latest    restart: unless-stopped    networks:       netbird:        ipv4_address: 172.10.0.5    volumes:      - netbird_management:&#x2F;var&#x2F;lib&#x2F;netbird      - .&#x2F;management.json:&#x2F;etc&#x2F;netbird&#x2F;management.json      - &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime:ro      - &#x2F;etc&#x2F;timezone:&#x2F;etc&#x2F;timezone:ro    command: [      &quot;--port&quot;, &quot;80&quot;,      &quot;--log-file&quot;, &quot;console&quot;,      &quot;--log-level&quot;, &quot;info&quot;,      &quot;--disable-anonymous-metrics&#x3D;false&quot;,      &quot;--single-account-mode-domain&#x3D;$NETBIRD_HOSTED_DOMAIN&quot;,      &quot;--dns-domain&#x3D;$NETBIRD_HOSTED_DOMAIN&quot;,      &quot;--idp-sign-key-refresh-enabled&quot;,    ]  # Coturn, AKA relay server  coturn:    image: coturn&#x2F;coturn    restart: unless-stopped    domainname: netbird.relay.selfhosted    volumes:      - .&#x2F;turnserver.conf:&#x2F;etc&#x2F;turnserver.conf:ro    network_mode: host    command:      - -c &#x2F;etc&#x2F;turnserver.conf  # Zitadel - identity provider  zitadel:    restart: &#39;always&#39;    networks:       netbird:        ipv4_address: 172.10.0.2    image: &#39;ghcr.io&#x2F;zitadel&#x2F;zitadel:v2.31.3&#39; #不建议更换版本，当前 NetBird 存在Bug，并不兼容最新版本的 zitadel    command: &#39;start-from-init --masterkeyFromEnv --tlsMode $ZITADEL_TLS_MODE&#39;    env_file:      - .&#x2F;zitadel.env    depends_on:      crdb:        condition: &#39;service_healthy&#39;    volumes:      - .&#x2F;machinekey:&#x2F;machinekey      - netbird_zitadel_certs:&#x2F;crdb-certs:ro      - &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime:ro      - &#x2F;etc&#x2F;timezone:&#x2F;etc&#x2F;timezone:ro  # CockroachDB for zitadel  crdb:    restart: &#39;always&#39;    networks:       netbird:        ipv4_address: 172.10.0.6    image: &#39;cockroachdb&#x2F;cockroach:v22.2.2&#39;    command: &#39;start-single-node --advertise-addr crdb&#39;    volumes:      - netbird_crdb_data:&#x2F;cockroach&#x2F;cockroach-data      - netbird_crdb_certs:&#x2F;cockroach&#x2F;certs      - netbird_zitadel_certs:&#x2F;zitadel-certs    healthcheck:      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;health?ready&#x3D;1&quot; ]      interval: &#39;10s&#39;      timeout: &#39;30s&#39;      retries: 5      start_period: &#39;20s&#39;volumes:  netbird_management:  netbird_crdb_data:  netbird_crdb_certs:  netbird_zitadel_certs:EOF&#125;initEnvironment</code></pre></div></figure><h3 id="将download-geolite2-sh脚本进行修订"><a href="#将download-geolite2-sh脚本进行修订" class="headerlink" title="将download-geolite2.sh脚本进行修订"></a>将<code>download-geolite2.sh</code>脚本进行修订</h3><p>文档中并未说明这里的步骤是必须手动做的，是在 Github 中找到的，用来处理登陆后页面提示 Token 401 的处理方案。</p><p>原因是因为，NetBird 依赖 <code>GeoLite2-City.mmdb</code> 数据库，若<code>management</code>（大陆）服务中不存在该数据库，则会造成<code>management</code>服务无法正常启动。</p><blockquote><p>需要下载的文件，请将下载较慢的两个数据库文件，手动进行下载，并修改脚本中的环境变量：<code>DATABASE_FILE</code>、<code>DATABASE_FILE</code><br>文档地址：<a href="https://docs.netbird.io/selfhosted/geo-support">https://docs.netbird.io/selfhosted/geo-support</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# to install sha256sum on mac: brew install coreutilsif ! command -v sha256sum &amp;&gt; &#x2F;dev&#x2F;nullthen    echo &quot;sha256sum is not installed or not in PATH, please install with your package manager. e.g. sudo apt install sha256sum&quot; &gt; &#x2F;dev&#x2F;stderr    exit 1fiif ! command -v sqlite3 &amp;&gt; &#x2F;dev&#x2F;nullthen    echo &quot;sqlite3 is not installed or not in PATH, please install with your package manager. e.g. sudo apt install sqlite3&quot; &gt; &#x2F;dev&#x2F;stderr    exit 1fiif ! command -v unzip &amp;&gt; &#x2F;dev&#x2F;nullthen    echo &quot;unzip is not installed or not in PATH, please install with your package manager. e.g. sudo apt install unzip&quot; &gt; &#x2F;dev&#x2F;stderr    exit 1fidownload_geolite_mmdb() &#123;  DATABASE_URL&#x3D;&quot;https:&#x2F;&#x2F;pkgs.netbird.io&#x2F;geolocation-dbs&#x2F;GeoLite2-City&#x2F;download?suffix&#x3D;tar.gz&quot;  SIGNATURE_URL&#x3D;&quot;https:&#x2F;&#x2F;pkgs.netbird.io&#x2F;geolocation-dbs&#x2F;GeoLite2-City&#x2F;download?suffix&#x3D;tar.gz.sha256&quot;  # Download the database and signature files  echo &quot;Downloading mmdb signature file...&quot;  SIGNATURE_FILE&#x3D;$(curl -s  -L -O -J &quot;$SIGNATURE_URL&quot; -w &quot;%&#123;filename_effective&#125;&quot;)  echo &quot;Downloading mmdb database file...&quot;  DATABASE_FILE&#x3D;&#39;GeoLite2-City_20240305.tar.gz&#39;  # Verify the signature  echo &quot;Verifying signature...&quot;  if sha256sum -c --status &quot;$SIGNATURE_FILE&quot;; then      echo &quot;Signature is valid.&quot;  else      echo &quot;Signature is invalid. Aborting.&quot;      exit 1  fi  # Unpack the database file  EXTRACTION_DIR&#x3D;$(basename &quot;$DATABASE_FILE&quot; .tar.gz)  echo &quot;Unpacking $DATABASE_FILE...&quot;  mkdir -p &quot;$EXTRACTION_DIR&quot;  tar -xzvf &quot;$DATABASE_FILE&quot; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1  MMDB_FILE&#x3D;&quot;GeoLite2-City.mmdb&quot;  cp &quot;$EXTRACTION_DIR&quot;&#x2F;&quot;$MMDB_FILE&quot; $MMDB_FILE  # Remove downloaded files  rm -r &quot;$EXTRACTION_DIR&quot;  rm &quot;$DATABASE_FILE&quot; &quot;$SIGNATURE_FILE&quot;  # Done. Print next steps  echo &quot;&quot;  echo &quot;Process completed successfully.&quot;  echo &quot;Now you can place $MMDB_FILE to &#39;datadir&#39; of management service.&quot;  echo -e &quot;Example:\n\tdocker compose cp $MMDB_FILE management:&#x2F;var&#x2F;lib&#x2F;netbird&#x2F;&quot;&#125;download_geolite_csv_and_create_sqlite_db() &#123;  DATABASE_URL&#x3D;&quot;https:&#x2F;&#x2F;pkgs.netbird.io&#x2F;geolocation-dbs&#x2F;GeoLite2-City-CSV&#x2F;download?suffix&#x3D;zip&quot;  SIGNATURE_URL&#x3D;&quot;https:&#x2F;&#x2F;pkgs.netbird.io&#x2F;geolocation-dbs&#x2F;GeoLite2-City-CSV&#x2F;download?suffix&#x3D;zip.sha256&quot;  # Download the database file  echo &quot;Downloading csv signature file...&quot;  SIGNATURE_FILE&#x3D;$(curl -s  -L -O -J &quot;$SIGNATURE_URL&quot; -w &quot;%&#123;filename_effective&#125;&quot;)  echo &quot;Downloading csv database file...&quot;  DATABASE_FILE&#x3D;&#39;GeoLite2-City-CSV_20240305.zip&#39;  # Verify the signature  echo &quot;Verifying signature...&quot;  if sha256sum -c --status &quot;$SIGNATURE_FILE&quot;; then      echo &quot;Signature is valid.&quot;  else      echo &quot;Signature is invalid. Aborting.&quot;      exit 1  fi  # Unpack the database file  EXTRACTION_DIR&#x3D;$(basename &quot;$DATABASE_FILE&quot; .zip)  DB_NAME&#x3D;&quot;geonames.db&quot;  echo &quot;Unpacking $DATABASE_FILE...&quot;  unzip &quot;$DATABASE_FILE&quot; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1# Create SQLite database and import data from CSVsqlite3 &quot;$DB_NAME&quot; &lt;&lt;EOF.mode csv.import &quot;$EXTRACTION_DIR&#x2F;GeoLite2-City-Locations-en.csv&quot; geonamesEOF  # Remove downloaded and extracted files  rm -r -r &quot;$EXTRACTION_DIR&quot;  rm  &quot;$DATABASE_FILE&quot; &quot;$SIGNATURE_FILE&quot;  echo &quot;&quot;  echo &quot;SQLite database &#39;$DB_NAME&#39; created successfully.&quot;  echo &quot;Now you can place $DB_NAME to &#39;datadir&#39; of management service.&quot;  echo -e &quot;Example:\n\tdocker compose cp $DB_NAME management:&#x2F;var&#x2F;lib&#x2F;netbird&#x2F;&quot;&#125;download_geolite_mmdbecho -e &quot;\n\n&quot;download_geolite_csv_and_create_sqlite_dbecho -e &quot;\n\n&quot;echo &quot;After copying the database files to the management service. You can restart the management service with:&quot;echo -e &quot;Example:\n\tdocker compose restart management&quot;</code></pre></div></figure><p>执行完成后，按照提示执行对应的指令，完成后重启<code>management</code>服务即可！</p><h2 id="客户端的使用"><a href="#客户端的使用" class="headerlink" title="客户端的使用"></a>客户端的使用</h2><p>请自行参照官方文档进行部署配置，没有难点，这里不在赘述~</p><h2 id="其他可能遇到的问题"><a href="#其他可能遇到的问题" class="headerlink" title="其他可能遇到的问题"></a>其他可能遇到的问题</h2><h3 id="服务已经可以正常访问，但客户端仍然连接不到服务器"><a href="#服务已经可以正常访问，但客户端仍然连接不到服务器" class="headerlink" title="服务已经可以正常访问，但客户端仍然连接不到服务器"></a>服务已经可以正常访问，但客户端仍然连接不到服务器</h3><p>建议检查客户端日志来确定错误位置，一般情况下是因为信号服务（signal）部署的问题导致，客户端无法正常连接到该服务。需检查服务配置和 Nginx 代理配置是否正确，必要时可检查 Nginx 错误请求日志来排查和确定。</p><h3 id="将crdb换成了PostgreSQL"><a href="#将crdb换成了PostgreSQL" class="headerlink" title="将crdb换成了PostgreSQL"></a>将<code>crdb</code>换成了<code>PostgreSQL</code></h3><p>需要按照<a href="https://zitadel.com/docs">官方文档</a>进行配置，因<code>PostgreSQL</code>数据库的要求较高，需要针对编码和<code>locale</code>进行相应的配置，作者未过多的进行了解，详情请查看<a href="https://zitadel.com/docs/self-hosting/manage/database">官方文档-数据库配置</a></p><h3 id="没有域名，直接通过IP部署的"><a href="#没有域名，直接通过IP部署的" class="headerlink" title="没有域名，直接通过IP部署的"></a>没有域名，直接通过IP部署的</h3><p>将域名环境变量（<code>NETBIRD_DOMAIN</code>）修改为<code>use-ip</code>，运行脚本即可。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>端口转发</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-存储引擎</title>
    <link href="/doc/f9373cb6.html"/>
    <url>/doc/f9373cb6.html</url>
    
    <content type="html"><![CDATA[<p>搬运自<a href="https://blog.csdn.net/u010647035/article/details/104700415">IT码客</a></p><span id="more"></span><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>MySQL服务器中对数据的存储及数据的操作行为都封装到了一个叫做存储引擎的模块中。我们知道表是由一行一行的记录组成的，这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎的表对数据的存储结构及存储算法也各自不同。</p><p>MySQL提供了多种存储引擎，每种存储引擎都有其各自的特点，我们可以具体的需要选择不同的存储引擎。同时MySQL还预定义了存储引擎接口，如果你对其提供的存储引擎性能或功能不够满意，也可以修改其源码，甚至自定义自己的存储引擎。</p><h2 id="MySQL-支持的存储引擎"><a href="#MySQL-支持的存储引擎" class="headerlink" title="MySQL 支持的存储引擎"></a>MySQL 支持的存储引擎</h2><h3 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h3><p>InnoDB 是 MySQL 的事务安全（兼容ACID）的存储引擎。它的特点是支持行级锁、支持外键、支持类似于Oracle的非锁定读，即读取操作不会加锁。 从 MySQL 5.5.8 开始，InnoDB 存储引擎作为默认的存储引擎。</p><p>InnoDB 通过使用多版本并发控制（MVCC）来获得高并发性能，并且实现了4种隔离级别，默认是REPEATABLE级别。同时，还是用了一种 next-key locking的策略来避免幻读的产生。另外，InnoDB 存储引擎还提供了插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用的功能。</p><p>对于表中数据的存储，InnoDB 存储引擎采用了聚集的方式，每张表的存储都是按照主键顺序进行存放。如果没有显式的定义表的主键，InnoDB 存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h3 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h3><p>MyISAM 表级锁设计限制了读&#x2F;写工作负载中的性能，因此它通常用于Web和数据仓库配置中的只读或只读工作负载中。</p><p>MyISAM 存储引擎不支持事务、支持表级锁、支持全文检索，主要面向OLAP数据库的应用。在 。MySQL 5.5.8 版本之前 MyISAM 是默认的存储引擎（除Windows版本）。</p><p>MyISAM 存储引擎的缓冲池只缓存索引文件，不缓存数据文件，数据文件的缓存由操作系统本身来完成。</p><h3 id="Memory-存储引擎"><a href="#Memory-存储引擎" class="headerlink" title="Memory 存储引擎"></a>Memory 存储引擎</h3><p>Memory 存储引擎，之前也叫HEAP存储引擎。它将所有数据存储在RAM中，以便在需要快速查找非关键数据的环境中进行快速访问。如果数据库重启或者崩溃，表中的数据就会丢失。因此，它非常适合用于存储临时数据，以及数据仓库中的维度表。</p><p>Memory 存储引擎默认使用哈希索引，而不是我们所熟悉的B+树索引。</p><p>Memory 存储引擎速度非常快，但是在使用上还是有一定的限制。比如，只支持表级锁，并发性能较差；不支持TEXT和BLOB类型。更重要的是，存储变长字段（varchar）时，仍然按照定长（char）存储，因此会很浪费内存。</p><h3 id="Archive-存储引擎"><a href="#Archive-存储引擎" class="headerlink" title="Archive 存储引擎"></a>Archive 存储引擎</h3><p>Archive 存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。Archive 存储引擎使用zlib算法将数据行压缩后存储，压缩比一半是1：10。Archive 存储引擎非常适合存储归档数据，比如日志信息。Archive 存储引擎使用行锁来实现高并发的插入操作，但是它本身并不是事务安全的存储引擎，它的设计目标是提供高速的插入和压缩功能。</p><h3 id="Merge-存储引擎"><a href="#Merge-存储引擎" class="headerlink" title="Merge 存储引擎"></a>Merge 存储引擎</h3><p>Merge 存储引擎的设计目标是用来取代原有的MyISAM存储引擎，因此它可以看作是MyISAM存储引擎的后续版本。</p><p>MyISAM存储引擎的特点：</p><ul><li>支持缓存数据和索引文件</li><li>支持行级锁</li><li>提供了MVCC功能</li><li>支持事务和非事务安全的选项</li><li>支持BLOG字符类型</li></ul><h3 id="Federated-存储引擎"><a href="#Federated-存储引擎" class="headerlink" title="Federated 存储引擎"></a>Federated 存储引擎</h3><p>Federated 存储引擎并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。并且Federated 存储引擎只支持MySQL数据库表，不支持异构数据库表。</p><h3 id="其它存储引擎"><a href="#其它存储引擎" class="headerlink" title="其它存储引擎"></a>其它存储引擎</h3><p>除了上面提到的存储引擎之外，MySQL数据库还有很多其它的存储引擎，包括 Blackhole 存储引擎、NDB（NDBCLUSTER） 存储引擎、CSV 存储引擎、Sphinx 存储引擎和Infobright存储引擎，他们都有各自的使用场景，这里不再一一介绍。</p><h2 id="MySQL-存储引擎功能概要"><a href="#MySQL-存储引擎功能概要" class="headerlink" title="MySQL 存储引擎功能概要"></a>MySQL 存储引擎功能概要</h2><img src="/doc/f9373cb6/001.png" srcset="/img/loading.gif" lazyload class=""><ol><li>在服务器中实现而不是存储引擎。</li><li>仅在使用压缩行格式时才支持压缩MyISAM表。在MyISAM中使用压缩行格式的表是只读的。</li><li>在服务器中通过加密功能实现。</li><li>通过加密功能在服务器中实现；在MySQL 5.7和更高版本中，支持静态数据表空间加密。</li><li>MySQL Cluster NDB 7.3和更高版本中提供了对外键的支持。</li><li>MySQL 5.6和更高版本提供了对FULLTEXT索引的InnoDB支持。</li><li>MySQL 5.7和更高版本提供了InnoDB对地理空间索引的支持。</li><li>InnoDB在内部将哈希索引用于其自适应哈希索引功能。</li></ol><h2 id="存储引擎的操作"><a href="#存储引擎的操作" class="headerlink" title="存储引擎的操作"></a>存储引擎的操作</h2><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       || MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         || InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         || MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         || BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         || CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         || ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)</code></pre></div></figure><h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><p>我们创建表没有指定表的存储引擎，就会使用默认的存储引擎InnoDB。我们可以显式的指定一下表的存储引擎。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; CREATE TABLE test (i INT) ENGINE &#x3D;MEMORY;Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO test VALUES(1),(2),(3);Query OK, 3 rows affected (0.00 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from test;+------+| i    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)</code></pre></div></figure><h3 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; ALTER TABLE test ENGINE &#x3D; InnoDB;Query OK, 3 rows affected (0.02 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; show create table test;+-------+---------------------------------------------------------------------------------------------------------------------+| Table | Create Table                                                                                                        |+-------+---------------------------------------------------------------------------------------------------------------------+| test  | CREATE TABLE &#96;test&#96; (&#96;i&#96; int(11) DEFAULT NULL) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci |+-------+---------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-SQL_MODE变量</title>
    <link href="/doc/224a451f.html"/>
    <url>/doc/224a451f.html</url>
    
    <content type="html"><![CDATA[<p><code>sql_mode</code> 是 <code>Mysql</code> 数据库提供的一种语法校验规则变量，用户可通过设置该变量来影响 <code>Mysql</code> 对 <code>SQL</code> 语句的校验。</p><span id="more"></span><p>它是个很容易被忽视的变量，默认情况下 <code>sql_mode</code> 为空值，在这种设置下是可以允许一些非法操作的。比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题。</p><p><code>sql_mode</code> 常用来解决下面几类问题：</p><ol><li>通过设置 <code>sql_mode</code>, 可以完成不同严格程度的数据校验，有效地保障数据准备性。</li><li>通过设置 <code>sql_mode</code> 为宽松模式，来保证大多数 <code>SQL</code> 符合标准的 <code>SQL</code> 语法，这样应用在不同数据库之间进行迁移时，则不需要对业务 <code>SQL</code> 进行较大的修改。</li><li>在不同数据库之间进行数据迁移之前，通过设置 <code>sql_mode</code> 可以使 <code>MySQL</code> 上的数据更方便地迁移到目标数据库中。</li></ol><p>常见常量如下：</p><ul><li><code>ONLY_FULL_GROUP_BY</code>: 对于<code>GROUP BY</code>聚合操作,如果在<code>SELECT</code>中的列,没有在<code>GROUP BY</code>中出现,那么这个SQL是不合法的,因为列不在<code>GROUP BY</code>从句中</li><li><code>NO_AUTO_VALUE_ON_ZERO</code>: 该值影响自增长列的插入。默认设置下,插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0,而该列又是自增长的,那么这个选项就有用了。</li><li><code>STRICT_TRANS_TABLES</code>: 在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制</li><li><code>NO_ZERO_IN_DATE</code>: 在严格模式下,不允许日期和月份为零</li><li><code>NO_ZERO_DATE</code>: 设置该值,mysql数据库不允许插入零日期,插入零日期会抛出错误而不是警告。</li><li><code>ERROR_FOR_DIVISION_BY_ZERO</code>: 在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL</li><li><code>NO_AUTO_CREATE_USER</code>: 禁止GRANT创建密码为空的用户</li><li><code>NO_ENGINE_SUBSTITUTION</code>: 如果需要的存储引擎被禁用或未编译,那么抛出错误。不设置此值时,用默认的存储引擎替代,并抛出一个异常</li><li><code>PIPES_AS_CONCAT</code>: 将”||”视为字符串的连接操作符而非或运算符,这和Oracle数据库是一样的,也和字符串的拼接函数Concat相类似</li><li><code>ANSI_QUOTES</code>: 启用ANSI_QUOTES后,不能用双引号来引用字符串,因为它被解释为识别符</li></ul><blockquote><p>ORACLE的 <code>sql_mode</code> 设置等同:<br><code>PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER</code></p></blockquote><p>更多详细信息请参照 <a href="https://search.oracle.com/mysql?q=sql_mode&size=10&page=1&tab=all&app=mysql">Mysql sql_mode</a></p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题-主从同步失败</title>
    <link href="/doc/d0620a9f.html"/>
    <url>/doc/d0620a9f.html</url>
    
    <content type="html"><![CDATA[<p>今天线上环境MHA主从同步失败，特此记录。</p><p>首先检查从库的跟踪情况，<code>show slave status\G</code>。</p><p>根据从库状态信息查询，在<code>performance_schema.replication_applier_status_by_worker</code>查看详细信息。</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select count(*) from performance_schema.replication_applier_status_by_worker;select * from performance_schema.replication_applier_status_by_worker limit 1;</code></pre></div></figure><p>根据详细信息查看究竟是哪个SQL导致的同步失败，按需进行处理，以下提供几种处理方式：</p><h2 id="跳过一条同步记录"><a href="#跳过一条同步记录" class="headerlink" title="跳过一条同步记录"></a>跳过一条同步记录</h2><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">stop slave;set global sql_slave_skip_counter &#x3D; 1;start slave;</code></pre></div></figure><h2 id="修改mysql的配置文件"><a href="#修改mysql的配置文件" class="headerlink" title="修改mysql的配置文件"></a>修改mysql的配置文件</h2><p>通过<code>slave_skip_errors</code>参数来跳所有错误或指定类型的错误</p><blockquote><p>官方文档说明: <a href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#option_mysqld_slave-skip-errors">slave_skip_errors</a><br>常见错误消息: <a href="https://dev.mysql.com/doc/refman/8.0/en/error-handling.html">错误消息和常见问题</a><br>错误码查询: <code>perror &lt;error_core&gt;</code></p></blockquote><p>在<code>[mysqld]</code>下面加入以下内容，请按需选择合适的配置</p><h3 id="跳过指定类型的错误"><a href="#跳过指定类型的错误" class="headerlink" title="跳过指定类型的错误"></a>跳过指定类型的错误</h3><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># 这里列举一些常见错误# 1032: 记录不存在# 1053: 服务没有及时响应启动或控制请求# 1062: 主键冲突# 1064: 语法错误# 1146: 表不存在# 1396: 操作用户失败slave-skip-errors&#x3D;1032,1053,1062,1064,1146</code></pre></div></figure><h3 id="跳过所有错误"><a href="#跳过所有错误" class="headerlink" title="跳过所有错误"></a>跳过所有错误</h3><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">slave-skip-errors&#x3D;all</code></pre></div></figure><h2 id="调整binlog跟随位置"><a href="#调整binlog跟随位置" class="headerlink" title="调整binlog跟随位置"></a>调整binlog跟随位置</h2><p>查看主库情况：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show master status;</code></pre></div></figure><p>根据主库情况修改从库：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">stop slave;change master to master_host&#x3D;&#39;&#123;192.168.x.x&#125;&#39;, master_user&#x3D;&#39;&#123;username&#125;&#39;, master_password&#x3D;&#39;&#123;password&#125;&#39;, master_log_file&#x3D;&#39;&#123;mysql-bin.000002&#125;&#39;,master_log_pos&#x3D;&#123;263&#125;;start slave;</code></pre></div></figure><blockquote><p>注意：<code>&#123;&#125;</code>内部是示例，需要按需进行调整。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps-Gitea</title>
    <link href="/doc/8497362d.html"/>
    <url>/doc/8497362d.html</url>
    
    <content type="html"><![CDATA[<p>Gitea 是一个轻量级的 DevOps 平台软件。从开发计划到产品成型的整个软件生命周期，他都能够高效而轻松的帮助团队和开发者。包括 Git 托管、代码审查、团队协作、软件包注册和 CI&#x2F;CD。它与 GitHub、Bitbucket 和 GitLab 等比较类似。</p><span id="more"></span><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul><li>代码托管：Gitea⽀持创建和管理仓库、浏览提交历史和代码⽂件、审查和合并代码提交、管理协作者、管理分⽀等。它还⽀持许多常见的Git特性，⽐如标签、Cherry-pick、hook、集成协作⼯具等。</li><li>轻量级和快速: Gitea 的设计目标之一就是轻量级和快速响应。它不像一些大型的代码托管平台那样臃肿，因此在性能方面表现出色，适用于资源有限的服务器环境。由于其轻量级设计，Gitea 在资源消耗方面相对较低，可以在资源有限的环境下运行良好。</li><li>易于部署和维护: 轻松地部署在各种服务器上，不需要复杂的配置和依赖。这使得个人开发者或小团队可以方便地设置和管理自己的 Git 服务。</li><li>安全性: Gitea 注重安全性，提供了用户权限管理、访问控制列表等功能，可以确保代码和数据的安全性。</li><li>代码评审：代码评审同时支持 Pull Request workflow 和 AGit workflow。评审⼈可以在线浏览代码，并提交评审意见或问题。 提交者可以接收到评审意见，并在线回 复或修改代码。代码评审可以帮助用户和企业提⾼代码质量。</li><li>CI&#x2F;CD: Gitea Actions⽀持 CI&#x2F;CD 功能，该功能兼容 GitHub Actions，⽤⼾可以采用熟悉的YAML格式编写workflows，也可以重⽤⼤量的已有的 Actions 插件。Actions 插件支持从任意的 Git 网站中下载。</li><li>项目管理：Gitea 通过看板和⼯单来跟踪⼀个项⽬的需求，功能和bug。⼯单⽀持分支，标签、⾥程碑、 指派、时间跟踪、到期时间、依赖关系等功能。</li><li>制品库: Gitea支持超过 20 种不同种类的公有或私有软件包管理，包括：Cargo, Chef, Composer, Conan, Conda, Container, Helm, Maven, npm, NuGet, Pub, PyPI, RubyGems, Vagrant等</li><li>开源社区支持: Gitea 是一个基于 MIT 许可证的开源项目,Gitea 拥有一个活跃的开源社区，能够持续地进行开发和改进，同时也积极接受社区贡献，保持了平台的更新和创新。</li><li>多语言支持： Gitea 提供多种语言界面，适应全球范围内的用户，促进了国际化和本地化。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方介绍了很多搭建方式，请移步到官网进行查看: <a href="https://docs.gitea.com/zh-cn/">gitea.com</a></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><img src="/doc/8497362d/img_01.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/8497362d/img_02.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/8497362d/img_03.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DevOps</tag>
      
      <tag>敏捷开发</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运-命令行的艺术</title>
    <link href="/doc/b259fdc8.html"/>
    <url>/doc/b259fdc8.html</url>
    
    <content type="html"><![CDATA[<p>仅为方便检索，搬运自<a href="https://github.com/jlevy/the-art-of-command-line">Github</a></p><span id="more"></span><h1 id="命令行的艺术"><a href="#命令行的艺术" class="headerlink" title="命令行的艺术"></a>命令行的艺术</h1><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li><li><a href="#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8">日常使用</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">文件及数据处理</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95">系统调试</a></li><li><a href="#%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC">单行脚本</a></li><li><a href="#%E5%86%B7%E9%97%A8%E4%BD%86%E6%9C%89%E7%94%A8">冷门但有用</a></li><li><a href="#%E4%BB%85%E9%99%90-os-x-%E7%B3%BB%E7%BB%9F">仅限 OS X 系统</a></li><li><a href="#%E4%BB%85%E9%99%90-windows-%E7%B3%BB%E7%BB%9F">仅限 Windows 系统</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90">更多资源</a></li><li><a href="#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E">免责声明</a></li></ul><p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p><p>这篇文章是<a href="AUTHORS.md">许多作者和译者</a>共同的成果。<br>这里的部分内容<br><a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">首次</a><br><a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">出现</a><br>于 <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>，<br>但已经迁移到了 GitHub，并由众多高手做出了许多改进。<br>如果你在本文中发现了错误或者存在可以改善的地方，请<a href="/CONTRIBUTING.md"><strong>贡献你的一份力量</strong></a>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>涵盖范围：</p><ul><li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li><li>本文主要为 Linux 所写，但在<a href="#%E4%BB%85%E9%99%90-os-x-%E7%B3%BB%E7%BB%9F">仅限 OS X 系统</a>章节和<a href="#%E4%BB%85%E9%99%90-windows-%E7%B3%BB%E7%BB%9F">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li><li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li><li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li></ul><p>注意事项：</p><ul><li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br><code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li><li>遇到问题的话，请尝试使用 <a href="http://explainshell.com/">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p></li><li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p></li><li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p></li><li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p></li><li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别（后文中有一些具体的例子）。</p></li><li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p></li><li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p></li><li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p></li><li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p></li><li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p></li><li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p></li><li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p></li></ul><h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><ul><li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p></li><li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-</strong>* 可以展开通配符。</p></li><li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p></li><li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p></li><li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p></li><li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>~</code>（例如 <code>~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p></li><li><p>回到前一个工作路径：<code>cd -</code>。</p></li><li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， **#**， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p></li><li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I&#123;&#125;</code> 会很方便。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find . -name &#39;*.py&#39; | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</code></pre></div></figure></li><li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p></li><li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p></li><li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p></li><li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p></li><li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p></li><li><p><code>lsof</code> 来查看开启的套接字和文件。</p></li><li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p></li><li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 创建了一个新的命令别名 <code>ll</code>。</p></li><li><p>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href="http://superuser.com/a/183980/7106">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p></li><li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p></li><li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p></li><li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>&quot;$FOO&quot;</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$&#39;\n&#39;</code> 把内部字段分隔符设为换行符。</p></li><li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set -euo pipefailtrap &quot;echo &#39;error: Script failed: see failed command above&#39;&quot; ERR</code></pre></div></figure></li><li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># do something in current dir(cd &#x2F;some&#x2F;other&#x2F;dir &amp;&amp; other-command)# continue in original dir</code></pre></div></figure></li><li><p>在 Bash 中，变量有许多的扩展方式。<code>$&#123;name:?error message&#125;</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=$&#123;1:?usage: $0 input_file&#125;</code>。在变量为空时使用默认值：<code>$&#123;name:-default&#125;</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=$&#123;2:-logfile&#125;</code>，如果省略了 $2，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>&#123;1..10&#125;</code>。截断字符串：<code>$&#123;var%suffix&#125;</code> 和 <code>$&#123;var#prefix&#125;</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo $&#123;var%.pdf&#125;.txt</code> 将输出 <code>foo.txt</code>。</p></li><li><p>使用括号扩展（<code>&#123;</code>…<code>&#125;</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.&#123;txt,pdf&#125; some-dir</code>（同时移动两个文件），<code>cp somefile&#123;,.bak&#125;</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-&#123;a,b,c&#125;/subtest-&#123;1,2,3&#125;</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p></li><li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">diff &#x2F;etc&#x2F;hosts &lt;(ssh somehost cat &#x2F;etc&#x2F;hosts)</code></pre></div></figure></li><li><p>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;      # 在这里写代码&#125;</code></pre></div></figure></li><li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p></li><li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p></li><li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p></li><li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href="https://github.com/bogner/dtach"><code>dtach</code></a>。</p></li><li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p></li><li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">TCPKeepAlive&#x3D;yesServerAliveInterval&#x3D;15ServerAliveCountMax&#x3D;6Compression&#x3D;yesControlMaster autoControlPath &#x2F;tmp&#x2F;%r@%h:%pControlPersist yes</code></pre></div></figure></li><li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p></li><li><p>考虑使用 <a href="https://mosh.org/"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p></li><li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stat -c &#39;%A %a %n&#39; &#x2F;etc&#x2F;timezone</code></pre></div></figure></li><li><p>使用 <a href="https://github.com/mooz/percol"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p></li><li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p></li><li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p></li><li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入_你自己的_密码）。</p></li><li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>su - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。</p></li><li><p>了解命令行的 <a href="https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p></li><li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; 2+35</code></pre></div></figure></li></ul><h2 id="文件及数据处理"><a href="#文件及数据处理" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul><li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname &#39;*something*&#39;</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p></li><li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p></li><li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p></li><li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/"><code>pandoc</code></a>。</p></li><li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p></li><li><p>使用 <a href="http://stedolan.github.io/jq/"><code>jq</code></a> 处理 JSON。</p></li><li><p>使用 <a href="https://github.com/0k/shyaml"><code>shyaml</code></a> 处理 YAML。</p></li><li><p>要处理 Excel 或 CSV 文件的话，<a href="https://github.com/onyxfish/csvkit">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p></li><li><p>当你要处理 Amazon S3 相关的工作的时候，<a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> 是一个很方便的工具而 <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href="https://github.com/aws/aws-cli"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p></li><li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p></li><li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p></li><li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p></li><li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p></li><li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href="https://www.gnu.org/software/datamash/"><code>datamash</code></a>。</p></li><li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p></li><li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p></li><li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href="#one-liners">One-liners</a> 获取示例。</p></li><li><p>替换一个或多个文件中出现的字符串：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">perl -pi.bak -e &#39;s&#x2F;old-string&#x2F;new-string&#x2F;g&#39; my-files-*.txt</code></pre></div></figure></li><li><p>使用 <a href="https://github.com/jlevy/repren"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from &#39;(.*)\.bak&#39; --to &#39;\1&#39; *.bak# 用 rename 实现上述功能（若可用）:rename &#39;s&#x2F;\.bak$&#x2F;&#x2F;&#39; *.bak</code></pre></div></figure></li><li><p>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html">最快方法</a>之一：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir empty &amp;&amp; rsync -r --delete empty&#x2F; some-dir &amp;&amp; rmdir some-dir</code></pre></div></figure></li><li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href="https://github.com/dmerejkowsky/pycp"><code>pycp</code></a>，<a href="https://github.com/Xfennec/progress"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p></li><li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p></li><li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p></li><li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p></li><li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p></li><li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p></li><li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p></li><li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p></li><li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uconv -f utf-8 -t utf-8 -x &#39;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#39; &lt; input.txt &gt; output.txt</code></pre></div></figure></li><li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p></li><li><p>操作日期和时间表达式，可以用 <a href="http://www.fresse.org/dateutils/"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p></li><li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p></li><li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p></li><li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">getfacl -R &#x2F;some&#x2F;path &gt; permissions.txtsetfacl --restore&#x3D;permissions.txt</code></pre></div></figure></li><li><p>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href="https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</p></li></ul><h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><ul><li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href="https://github.com/jkbrzt/httpie"><code>httpie</code></a>。</p></li><li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p></li><li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p></li><li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p></li><li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p></li><li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools">SJK tools</a> 更高级。</p></li><li><p>使用 <a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p></li><li><p>用 <a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p></li><li><p>查找正在使用带宽的套接字连接或进程，使用 <a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>。</p></li><li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p></li><li><p><a href="https://wireshark.org/"><code>wireshark</code></a>，<a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a> 和 <a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a> 可用于复杂的网络调试。</p></li><li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p></li><li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href="http://www.catonmat.net/blog/ldd-arbitrary-code-execution/">永远不要在不信任的文件上运行</a>。</p></li><li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p></li><li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p></li><li><p>当调试一些之前出现的问题的时候，<a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p></li><li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>），<a href="https://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a>，以及<a href="https://github.com/draios/sysdig"><code>sysdig</code></a>。</p></li><li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p></li><li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p></li><li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br><code>lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;</code></p></li></ul><h2 id="单行脚本"><a href="#单行脚本" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p><ul><li><p>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sort a b | uniq &gt; c   # c 是 a 并 bsort a b | uniq -d &gt; c   # c 是 a 交 bsort a b b | uniq -u &gt; c   # c 是 a - b</code></pre></div></figure></li><li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p></li><li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk &#39;&#123; x +&#x3D; $3 &#125; END &#123; print x &#125;&#39; myfile</code></pre></div></figure></li><li><p>如果你想在文件树上查看大小&#x2F;日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find . -type f -ls</code></pre></div></figure></li><li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">egrep -o &#39;acct_id&#x3D;[0-9]+&#39; access.log | cut -d&#x3D; -f2 | sort | uniq -c | sort -rn</code></pre></div></figure></li><li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 &#39;ls -rtlh | tail&#39;</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p></li><li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">function taocl() &#123;  curl -s https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jlevy&#x2F;the-art-of-command-line&#x2F;master&#x2F;README-zh.md|    pandoc -f markdown -t html |    iconv -f &#39;utf-8&#39; -t &#39;unicode&#39; |    xmlstarlet fo --html --dropdtd |    xmlstarlet sel -t -v &quot;(html&#x2F;body&#x2F;ul&#x2F;li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |    xmlstarlet unesc | fmt -80&#125;</code></pre></div></figure></li></ul><h2 id="冷门但有用"><a href="#冷门但有用" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul><li><p><code>expr</code>：计算表达式或正则匹配</p></li><li><p><code>m4</code>：简单的宏处理器</p></li><li><p><code>yes</code>：多次打印字符串</p></li><li><p><code>cal</code>：漂亮的日历</p></li><li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p></li><li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p></li><li><p><code>look</code>：查找以特定字符串开头的单词或行</p></li><li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p></li><li><p><code>fmt</code>：格式化文本段落</p></li><li><p><code>pr</code>：将文本格式化成页／列形式</p></li><li><p><code>fold</code>：包裹文本中的几行</p></li><li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p></li><li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p></li><li><p><code>nl</code>：添加行号</p></li><li><p><code>seq</code>：打印数字</p></li><li><p><code>bc</code>：计算器</p></li><li><p><code>factor</code>：分解因数</p></li><li><p><a href="https://gnupg.org/"><code>gpg</code></a>：加密并签名文件</p></li><li><p><code>toe</code>：terminfo 入口列表</p></li><li><p><code>nc</code>：网络调试及数据传输</p></li><li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p></li><li><p><a href="https://github.com/mattthias/slurm"><code>slurm</code></a>：网络流量可视化</p></li><li><p><code>dd</code>：文件或设备间传输数据</p></li><li><p><code>file</code>：确定文件类型</p></li><li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p></li><li><p><code>stat</code>：文件信息</p></li><li><p><code>time</code>：执行命令，并计算执行时间</p></li><li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p></li><li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p></li><li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p></li><li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p></li><li><p><a href="https://github.com/joh/when-changed"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p></li><li><p><code>tac</code>：反向输出文件</p></li><li><p><code>shuf</code>：文件中随机选取几行</p></li><li><p><code>comm</code>：一行一行的比较排序过的文件</p></li><li><p><code>strings</code>：从二进制文件中抽取文本</p></li><li><p><code>tr</code>：转换字母</p></li><li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p></li><li><p><code>split</code> 和 <code>csplit</code>：分割文件</p></li><li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p></li><li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p></li><li><p><code>apg</code>：随机生成密码</p></li><li><p><code>xz</code>：高比例的文件压缩</p></li><li><p><code>ldd</code>：动态库信息</p></li><li><p><code>nm</code>：提取 obj 文件中的符号</p></li><li><p><code>ab</code> 或 <a href="https://github.com/wg/wrk"><code>wrk</code></a>：web 服务器性能分析</p></li><li><p><code>strace</code>：调试系统调用</p></li><li><p><a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a>：更好的网络调试跟踪工具</p></li><li><p><code>cssh</code>：可视化的并发 shell</p></li><li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p></li><li><p><a href="https://wireshark.org/"><code>wireshark</code></a> 和 <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>：抓包和网络调试工具</p></li><li><p><a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>：网络层的 grep</p></li><li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p></li><li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p></li><li><p><code>dstat</code>：系统状态查看</p></li><li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>：高层次的多子系统总览</p></li><li><p><code>iostat</code>：硬盘使用状态</p></li><li><p><code>mpstat</code>： CPU 使用状态</p></li><li><p><code>vmstat</code>： 内存使用状态</p></li><li><p><code>htop</code>：top 的加强版</p></li><li><p><code>last</code>：登入记录</p></li><li><p><code>w</code>：查看处于登录状态的用户</p></li><li><p><code>id</code>：用户&#x2F;组 ID 信息</p></li><li><p><a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a>：系统历史数据</p></li><li><p><a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>：套接字及进程的网络利用情况</p></li><li><p><code>ss</code>：套接字数据</p></li><li><p><code>dmesg</code>：引导及系统错误信息</p></li><li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p></li><li><p><code>hdparm</code>：SATA&#x2F;ATA 磁盘更改及性能分析</p></li><li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p></li><li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p></li><li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p></li><li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p></li></ul><h2 id="仅限-OS-X-系统"><a href="#仅限-OS-X-系统" class="headerlink" title="仅限 OS X 系统"></a>仅限 OS X 系统</h2><p>以下是<em>仅限于</em> OS X 系统的技巧。</p><ul><li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p></li><li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p></li><li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p></li><li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p></li><li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p></li><li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p></li><li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p></li></ul><h2 id="仅限-Windows-系统"><a href="#仅限-Windows-系统" class="headerlink" title="仅限 Windows 系统"></a>仅限 Windows 系统</h2><p>以下是<em>仅限于</em> Windows 系统的技巧。</p><h3 id="在-Windows-下获取-Unix-工具"><a href="#在-Windows-下获取-Unix-工具" class="headerlink" title="在 Windows 下获取 Unix 工具"></a>在 Windows 下获取 Unix 工具</h3><ul><li><p>可以安装 <a href="https://cygwin.com/">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p></li><li><p>在 Windows 10 上，你可以使用 <a href="https://msdn.microsoft.com/commandline/wsl/about">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p></li><li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p></li><li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href="https://github.com/dthree/cash">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p></li></ul><h3 id="实用-Windows-命令行工具"><a href="#实用-Windows-命令行工具" class="headerlink" title="实用 Windows 命令行工具"></a>实用 Windows 命令行工具</h3><ul><li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p></li><li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p></li><li><p>可以使用 <code>Rundll32</code> 命令来实现<a href="http://www.thewindowsclub.com/rundll32-shortcut-commands-windows">许多有用的 Windows 任务</a> 。</p></li></ul><h3 id="Cygwin-技巧"><a href="#Cygwin-技巧" class="headerlink" title="Cygwin 技巧"></a>Cygwin 技巧</h3><ul><li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p></li><li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p></li><li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p></li><li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p></li><li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p></li><li><p>注意 Windows 驱动器路径 <code>C:\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p></li><li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p></li><li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href="https://github.com/dthree/cash">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p></li><li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p></li></ul><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul><li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li><li><a href="https://github.com/herrbischoff/awesome-osx-command-line">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li><li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a>：为了编写更好的脚本文件。</li><li><a href="https://github.com/koalaman/shellcheck">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li><li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li><li><a href="http://datascienceatthecommandline.com/#tools">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li></ul><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p><h2 id="授权条款"><a href="#授权条款" class="headerlink" title="授权条款"></a>授权条款</h2><p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" srcset="/img/loading.gif" lazyload alt="Creative Commons License"></a></p><p>本文使用授权协议 <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows服务-将任何程序加入服务管理</title>
    <link href="/doc/154971c6.html"/>
    <url>/doc/154971c6.html</url>
    
    <content type="html"><![CDATA[<p>Microsoft Windows 服务（过去称为 NT 服务）允许用户创建可在其自身的 Windows 会话中长时间运行的可执行应用程序。 这些服务可在计算机启动时自动启动，可以暂停和重启，并且不显示任何用户界面。</p><span id="more"></span><p>这些功能使服务非常适合在服务器上使用，或者需要长时间运行的功能（不会影响在同一台计算机上工作的其他用户）的情况。 还可以在与登录用户或默认计算机帐户不同的特定用户帐户的安全性上下文中运行服务。</p><p>因 Windows 自身限制，要求只有满足 Windows 服务协议才允许使用 <code>sc</code> 指令加入到 Windows 服务中进行管控。</p><h2 id="NSSM"><a href="#NSSM" class="headerlink" title="NSSM"></a>NSSM</h2><p><a href="https://nssm.cc/">NSSM(the Non-Sucking Service Manager)</a> 是 Windows 环境下一款免安装的服务管理软件，它可以将应用封装成服务，使之像 Windows 服务可以设置自动启动等。并且可以监控程序运行状态，程序异常中断后自动启动，实现守护进程的功能。不仅支持图形界面操作，也完全支持命令行设置。</p><p>同类型的工具还有微软自己的<code>srvany</code>，不过 <code>nssm</code> 更加简单易用，并且功能强大。它的特点如下: </p><ul><li>支持普通exe程序（控制台程序或者带界面的Windows程序都可以）</li><li>安装简单，修改方便</li><li>可以重定向输出（并且支持Rotation）</li><li>可以自动守护封装了的服务，程序挂掉了后可以自动重启</li><li>可以自定义环境变量</li></ul><p>这里面的每一个功能都非常实用，使用NSSM来封装服务可以大大简化我们的开发流程了。</p><ul><li>开发的时候是一个普通程序，降低了开发难度，调试起来非常方便</li><li>安装简单，并且可以随时修改服务属性，更新也更加方便</li><li>可以利用控制台输出直接实现一个简单的日志系统</li><li>不用考虑再加一个服务实现服务守护功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Windows</tag>
      
      <tag>服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Office转PDF方案[Java版]</title>
    <link href="/doc/4bd75a2e.html"/>
    <url>/doc/4bd75a2e.html</url>
    
    <content type="html"><![CDATA[<p>效果最佳的Office转PDF解决方案</p><span id="more"></span><p>找了很久总算是找到一些可用的转换方案，废话不多说，目前靠谱的解决方案大致分为以下几类：</p><ul><li>开源组件版: <code>openoffice</code>&#x2F;<code>libroffice</code></li><li>企业版API版: <code>WPS</code>&#x2F;<code>Office</code></li><li>系统强依赖版: <code>documents4j</code> + <code>Windows WPS</code>&#x2F;<code>Windows Office</code></li><li>纯净依赖版: <code>aspose-words</code></li></ul><h2 id="开源组件版"><a href="#开源组件版" class="headerlink" title="开源组件版"></a>开源组件版</h2><p>以<code>libroffice</code>为例，需要搭建 Office 服务器，开放API端口，以供Java或其他服务调用。</p><p>优点: 开源免费<br>缺点: 存在转换前后效果不一致的情况、服务稳定性不佳</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>以Linux服务器为例，以下是环境搭建步骤: </p><ol><li>请去官网下载安装包<a href="https://zh-cn.libreoffice.org/download/libreoffice/">libreoffice</a></li><li>将下载的安装包(<code>Apache_OpenOffice_4.1.14_Linux_x86-64_install-rpm_zh-CN.tar.gz</code>)解压缩安装文件到<code>/tmp/OpenOffice</code></li><li>切换至<code>/tmp/OpenOffice/zh-CN/RPMS</code>，执行<code>yum localinstall *.rpm</code></li><li>装完后会在当前目录下生成一个<code>desktop-integration</code>目录。切换至<code>desktop-integration</code>，执行<code>yum localinstall openoffice4.1.14-redhat-menus-4.1.14-9811.noarch.rpm</code></li><li>切换至<code>/opt/openoffice4/program/</code>，为防止出现OpenOffice启动时报错，所以先执行安装<code>yum install libXext.x86_64 &amp; yum groupinstall &quot;X Window System&quot;</code></li><li>启动<code>nohup /opt/openoffice4/program/soffice -headless -accept=&quot;socket,host=&#123;&#123;IP&#125;&#125;,port=&#123;&#123;Port&#125;&#125;;urp;&quot; -nofirststartwizard &amp;</code></li></ol><blockquote><p><code>OpenOffice</code> 与 <code>libroffice</code> 的环境搭建步骤基本一致，仅仅只是文件名称不一致而已，但大致位置全部相同</p></blockquote><h2 id="企业版API版"><a href="#企业版API版" class="headerlink" title="企业版API版"></a>企业版API版</h2><p>以<code>WPS</code>为例，需要注册和认证企业账号，通过HTTP请求的方式调用接口转换。详情请了解<a href="https://open.wps.cn/previous/docs/file-convert">WPS开放平台</a></p><p>优点: 效果好<br>缺点: 闭源、按转换次数收费、数据外泄</p><h2 id="系统强依赖版"><a href="#系统强依赖版" class="headerlink" title="系统强依赖版"></a>系统强依赖版</h2><p>以<code>documents4j</code> + <code>Windows WPS</code>为例，可通过进程通信的方式进行转换</p><p>优点: 效果好、数据不会外协<br>缺点: 需要<code>Windows</code>系统环境、企业使用需要使用许可</p><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li>在<code>Windows</code>中安装<code>WPS</code>和<code>JRE</code>环境</li><li>编写Java代码，运行服务</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.documents4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;documents4j-local&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.1.12&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.documents4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;documents4j-transformer-msoffice-word&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.1.12&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;            &lt;version&gt;3.7.0&lt;&#x2F;version&gt;            &lt;configuration&gt;                &lt;target&gt;1.8&lt;&#x2F;target&gt;                &lt;source&gt;1.8&lt;&#x2F;source&gt;                &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;            &lt;&#x2F;configuration&gt;        &lt;&#x2F;plugin&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;            &lt;version&gt;3.1.0&lt;&#x2F;version&gt;            &lt;configuration&gt;                &lt;archive&gt;                    &lt;manifest&gt;                        &lt;mainClass&gt;Main&lt;&#x2F;mainClass&gt;                                    &lt;&#x2F;manifest&gt;                &lt;&#x2F;archive&gt;                &lt;descriptorRefs&gt;                    &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt;                &lt;&#x2F;descriptorRefs&gt;            &lt;&#x2F;configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;make-assembly&lt;&#x2F;id&gt;                    &lt;phase&gt;package&lt;&#x2F;phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;single&lt;&#x2F;goal&gt;                    &lt;&#x2F;goals&gt;                &lt;&#x2F;execution&gt;            &lt;&#x2F;executions&gt;        &lt;&#x2F;plugin&gt;    &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;</code></pre></div></figure><h4 id="java"><a href="#java" class="headerlink" title="*.java"></a>*.java</h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;Main.javapublic class Main &#123;    public static void main(String[] args) throws RemoteException &#123;        IDocumentConvert convert &#x3D; new DocumentConvertRemote();        IDocumentConvert skeleton &#x3D; (IDocumentConvert) UnicastRemoteObject.exportObject(convert, 0);        Registry registry &#x3D; LocateRegistry.createRegistry(10099);        registry.rebind(IDocumentConvert.class.getName(), skeleton);    &#125;&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.cikaros.convert;import java.rmi.Remote;import java.rmi.RemoteException;public interface IDocumentConvert extends Remote &#123;    byte[] convert(byte[] data) throws RemoteException;&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.cikaros.convert;import com.documents4j.api.DocumentType;import com.documents4j.api.IConverter;import com.documents4j.job.LocalConverter;import java.io.*;import java.rmi.RemoteException;public class DocumentConvertRemote implements IDocumentConvert &#123;    @Override    public synchronized byte[] convert(byte[] data) throws RemoteException &#123;        try (ByteArrayInputStream in &#x3D; new ByteArrayInputStream(data);             ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream()) &#123;            IConverter converter &#x3D; LocalConverter.builder()                    .build();            converter.convert(in).as(DocumentType.DOCX).to(out).as(DocumentType.PDF).execute();            converter.shutDown();            return out.toByteArray();        &#125; catch (IOException e) &#123;            return new byte[0];        &#125;    &#125;&#125;</code></pre></div></figure><h4 id="在其他项目中使用"><a href="#在其他项目中使用" class="headerlink" title="在其他项目中使用"></a>在其他项目中使用</h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">...&#x2F;&#x2F;域名和端口来自上述服务的部署位置Registry registry &#x3D; LocateRegistry.getRegistry(IP, PORT);IDocumentConvert convert &#x3D; (IDocumentConvert) registry.lookup(IDocumentConvert.class.getName());&#x2F;&#x2F;文件路径请按需修改try (BufferedInputStream input &#x3D; new BufferedInputStream(Files.newInputStream(DOCX_FILE_PATH));     OutputStream output &#x3D; Files.newOutputStream(PDF_FILE_PATH)) &#123;    long length &#x3D; DOCX_FILE_PATH.toFile().length();    byte[] docx &#x3D; new byte[(int) length];    int i &#x3D; input.read(docx, 0, (int) length);    byte[] pdf &#x3D; convert.convert(docx);    output.write(pdf);&#125;...</code></pre></div></figure><h2 id="纯净依赖版"><a href="#纯净依赖版" class="headerlink" title="纯净依赖版"></a>纯净依赖版</h2><p>可直接在项目中加入依赖即可。<a href="https://products.aspose.com/words/zh/">官网地址</a></p><p>优点: 效果好、数据不会外协、跨平台<br>缺点: 企业使用需要使用许可且收费离谱、试用版会有水印</p><h3 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li>准备<code>JRE</code>环境</li><li>在项目中合适的位置调用API即可</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">    &lt;dependencies&gt;    &lt;!--        &lt;dependency&gt;--&gt;    &lt;!--            &lt;groupId&gt;com.aspose&lt;&#x2F;groupId&gt;--&gt;    &lt;!--            &lt;artifactId&gt;aspose-words&lt;&#x2F;artifactId&gt;--&gt;    &lt;!--            &lt;version&gt;19.5.0&lt;&#x2F;version&gt;--&gt;    &lt;!--            &lt;scope&gt;system&lt;&#x2F;scope&gt;--&gt;    &lt;!--            &lt;systemPath&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;aspose-words&#x2F;aspose-words-19.5jdk.jar&lt;&#x2F;systemPath&gt;--&gt;    &lt;!--        &lt;&#x2F;dependency&gt;--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.aspose&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;aspose-words&lt;&#x2F;artifactId&gt;        &lt;version&gt;20.12&lt;&#x2F;version&gt;        &lt;scope&gt;system&lt;&#x2F;scope&gt;        &lt;systemPath&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;aspose-words&#x2F;aspose-words-20.12-jdk17.jar&lt;&#x2F;systemPath&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt;&lt;plugins&gt;    &lt;plugin&gt;        &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.7.0&lt;&#x2F;version&gt;        &lt;configuration&gt;            &lt;target&gt;1.8&lt;&#x2F;target&gt;            &lt;source&gt;1.8&lt;&#x2F;source&gt;            &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;        &lt;&#x2F;configuration&gt;    &lt;&#x2F;plugin&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.1.0&lt;&#x2F;version&gt;        &lt;configuration&gt;            &lt;archive&gt;                &lt;manifest&gt;                    &lt;mainClass&gt;Main&lt;&#x2F;mainClass&gt; &lt;!-- 指定入口类路径 --&gt;                &lt;&#x2F;manifest&gt;            &lt;&#x2F;archive&gt;            &lt;descriptorRefs&gt;                &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;            &lt;&#x2F;descriptorRefs&gt;        &lt;&#x2F;configuration&gt;        &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;        &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;        &lt;executions&gt;            &lt;execution&gt;                &lt;id&gt;make-assembly&lt;&#x2F;id&gt;                &lt;phase&gt;package&lt;&#x2F;phase&gt;                &lt;goals&gt;                    &lt;goal&gt;single&lt;&#x2F;goal&gt;                &lt;&#x2F;goals&gt;            &lt;&#x2F;execution&gt;        &lt;&#x2F;executions&gt;    &lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;</code></pre></div></figure><h4 id="java-1"><a href="#java-1" class="headerlink" title="*.java"></a>*.java</h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.aspose.words.Document;import com.aspose.words.PdfSaveOptions;import java.io.FileOutputStream;import java.io.InputStream;import java.nio.file.Files;import java.nio.file.Paths;public class Main &#123;    public static void main(String[] args) &#123;        String docx &#x3D; &quot;...&quot;;        String pdf &#x3D; &quot;...&quot;;        try (                InputStream input &#x3D; Files.newInputStream(Paths.get(docx));                FileOutputStream output &#x3D; new FileOutputStream(pdf);        ) &#123;            Document wordDoc &#x3D; new Document(input);            PdfSaveOptions pso &#x3D; new PdfSaveOptions();            wordDoc.save(output, pso);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div></figure><blockquote><p>这里有惊喜！<a href="https://gitee.com/liuzy1988/aspose-words-crack">传送门</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Office转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps-Gitness</title>
    <link href="/doc/b35f7c70.html"/>
    <url>/doc/b35f7c70.html</url>
    
    <content type="html"><![CDATA[<p>Gitness 是 Harness 旗下的一款开源产品。可以说是 Drone 的替代品，Drone开源一段时间后就被 Harness 收购。介绍就免了直接上安装教程。</p><span id="more"></span><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>根据个人的想法决定安装哪些组件，目前我这里配置了SSL，所以需要一个 Nginx 进行反向代理。以下是我的<code>docker-compose.yml</code>配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;2.3&quot;services:  gitness:    image: harness&#x2F;gitness    container_name: gitness    restart: always    privileged: true    ports:      - &quot;8080:8080&quot;    extra_hosts:      - host.docker.internal:host-gateway    environment:      - GITNESS_DATABASE_DRIVER&#x3D;sqlite3      - GITNESS_USER_SIGNUP_ENABLED&#x3D;true      - GITNESS_HTTP_PORT&#x3D;8080      - GITNESS_URL_BASE&#x3D;https:&#x2F;&#x2F;example.com    volumes:      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock      - .&#x2F;data:&#x2F;data  nginx:    image: nginx    container_name: nginx    restart: always    ports:      - &quot;80:80&quot;      - &quot;443:443&quot;    volumes:      - .&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro      - .&#x2F;nginx&#x2F;conf.d&#x2F;:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;:ro      - .&#x2F;nginx&#x2F;certs&#x2F;:&#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;:ro</code></pre></div></figure><p>上面还配置了nginx相关的配置项，这里的<code>nginx.conf</code>我使用的是默认的配置，所以这个文件我是不挂载的，可根据需要自行调整。以下是<code>example.com.conf</code>的相关配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">server &#123;    listen 80;    server_name example.com 1.1.1.1; #这里写的是服务器的IP    location &#x2F; &#123;        # 重定向 HTTP 到 HTTPS        return 301 https:&#x2F;&#x2F;$host$request_uri;    &#125;&#125;server &#123;    listen 443 ssl;    server_name example.com;    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;example.com.crt;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;example.com.key;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_set_header X-Forwarded-Host $host;    proxy_set_header X-Forwarded-Server $host;    proxy_set_header X-Forwarded-Port $server_port;    location &#x2F; &#123;        # 针对其他 URL 的服务        proxy_pass http:&#x2F;&#x2F;gitness:8080;        # 可以添加其他代理相关配置，如代理头、缓存等    &#125;&#125;</code></pre></div></figure><blockquote><p>这里还有一种想法，就是将nginx代理也一并交由 Gitness 托管，作为 Gitness 中的一个项目仓库来维护，这样就可以通过动态的调整来进行配置。</p></blockquote><p>效果就不给大家展示了，SSL续约可以参考<a href="/doc/14c8d1db.html">开源项目-SSL自动续约脚本</a>!</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DevOps</tag>
      
      <tag>敏捷开发</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java.lang.util.stream包解析</title>
    <link href="/doc/5d1b59b3.html"/>
    <url>/doc/5d1b59b3.html</url>
    
    <content type="html"><![CDATA[<p>Java 的 Stream 包是 Java 8 中引入的一项重要特性，它提供了一种声明式、函数式风格的数据流处理方法。Stream 允许我们以声明式的方式对数据源进行操作和转换，并将结果聚合到最终的集合或输出。</p><span id="more"></span><p>主要的接口和抽象类的定义有:</p><ul><li><code>java.lang.AutoCloseable</code> 自动关闭接口<ul><li><code>java.util.stream.BaseStream</code> 基础流定义接口<ul><li><code>java.util.stream.Stream</code> 流定义接口<ul><li><code>java.util.stream.AbstractPipeline</code> 流通道抽象<ul><li><code>java.util.stream.ReferencePipeline</code> 引用通道抽象<ul><li><code>java.util.stream.ReferencePipeline.Head</code> 初始通道实现</li><li><code>java.util.stream.ReferencePipeline.StatelessOp</code> 无状态通道实现</li><li><code>java.util.stream.ReferencePipeline.StatefulOp</code> 有状态通道实现</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><code>java.util.function.Consumer</code> 消费者接口<ul><li><code>java.util.stream.Sink</code> 通道消费链定义接口<ul><li><code>java.util.stream.Sink.ChainedReference</code> 通道消费链抽象实现</li></ul></li></ul></li><li><code>java.util.Iterator</code> 迭代器接口</li><li><code>java.util.Spliterator</code> 分离器接口</li><li><code>java.util.stream.Collector</code> 收集器接口</li></ul><h2 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a>基础接口</h2><h3 id="java-lang-AutoCloseable"><a href="#java-lang-AutoCloseable" class="headerlink" title="java.lang.AutoCloseable"></a>java.lang.AutoCloseable</h3><p><code>java.lang.AutoCloseable</code> 是 Java 中的一个接口，它声明了一个单一的方法 <code>close()</code>。该接口是在 Java 7 中引入的，用于支持 try-with-resources 语句。</p><p><code>AutoCloseable</code> 接口设计用来表示那些在使用后需要关闭的资源。当一个类实现了 <code>AutoCloseable</code> 接口时，它表示这个类的实例可以被自动关闭。在 try-with-resources 语句中，你可以使用一个或多个资源，这些资源必须实现 <code>AutoCloseable</code> 接口。当 try-with-resources 语句结束时，Java 虚拟机会自动调用这些资源的 <code>close()</code> 方法，以便在使用完资源后进行关闭操作，而无需显式地编写关闭代码。</p><p>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;file.txt&quot;))) &#123;    String line;    while ((line &#x3D; reader.readLine()) !&#x3D; null) &#123;        System.out.println(line);    &#125;&#125; catch (IOException e) &#123;    &#x2F;&#x2F; 处理异常&#125;</code></pre></div></figure><p>在这个例子中，<code>BufferedReader</code> 实现了 <code>AutoCloseable</code> 接口，因此它可以在 try-with-resources 语句中使用。在 try-with-resources 语句结束时，会自动调用 <code>BufferedReader</code> 的 <code>close()</code> 方法关闭文件流。这样可以确保资源被及时关闭，避免资源泄漏和其他相关问题。</p><h3 id="java-util-function-Consumer"><a href="#java-util-function-Consumer" class="headerlink" title="java.util.function.Consumer"></a>java.util.function.Consumer</h3><p><code>java.util.function.Consumer</code> 是 Java 中的一个函数式接口，它定义了一个接收一个参数并且不返回任何结果的操作。它通常用于对参数进行一些处理，比如修改、打印、存储等，但不会产生任何返回值。Consumer 接口包含一个名为 <code>accept</code> 的抽象方法，该方法接收一个参数，代表需要被处理的对象。Consumer 接口在 Java 8 中引入，主要是为了支持 Lambda 表达式和函数式编程。</p><p>Consumer 接口的声明如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    void accept(T t);&#125;</code></pre></div></figure><p>其中，<code>T</code> 是输入参数的类型。</p><p>Consumer 接口的使用场景包括但不限于：</p><ol><li><strong>集合操作：</strong> 在遍历集合时，可以使用 Consumer 对集合中的每个元素执行相同的操作。</li><li><strong>函数式编程：</strong> 在函数式编程中，可以将 Consumer 作为方法的参数，传递给其他方法，以便在需要时执行特定的操作。</li><li><strong>I&#x2F;O 操作：</strong> 在处理输入流或输出流时，可以使用 Consumer 来对流中的数据执行特定的操作。</li><li><strong>回调函数：</strong> 在异步编程中，可以使用 Consumer 来定义回调函数，在异步任务完成后执行相应的操作。</li></ol><p>以下是 Consumer 接口的一个简单示例，演示了如何使用它来打印列表中的每个元素：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;import java.util.List;public class Main &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; languages &#x3D; Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;C++&quot;);        &#x2F;&#x2F; 使用 Consumer 打印每个元素        languages.forEach(language -&gt; System.out.println(language));    &#125;&#125;</code></pre></div></figure><p>这个示例中，<code>forEach</code> 方法接收一个 Consumer 参数，用于处理列表中的每个元素。Lambda 表达式 <code>language -&gt; System.out.println(language)</code> 实现了 Consumer 接口中的 <code>accept</code> 方法，将列表中的每个元素打印出来。</p><h3 id="java-util-Iterator"><a href="#java-util-Iterator" class="headerlink" title="java.util.Iterator"></a>java.util.Iterator</h3><p><code>java.util.Iterator</code> 是 Java 编程语言中的一个接口，位于 <code>java.util</code> 包中。它提供了一种迭代集合元素的方式，允许逐个访问集合中的元素，而无需暴露集合的内部实现细节。</p><p><code>Iterator</code> 接口定义了以下几种常用方法：</p><ol><li><code>boolean hasNext()</code>：检查迭代器是否还有下一个元素。</li><li><code>E next()</code>：返回迭代器的下一个元素，并将迭代器的位置向前移动。</li><li><code>void remove()</code>：从迭代器指向的集合中移除迭代器返回的上一个元素。这个方法不是在所有的迭代器中都可用，具体取决于集合的实现。</li></ol><p>使用 <code>Iterator</code> 进行迭代的一般步骤如下：</p><ol><li>调用集合对象的 <code>iterator()</code> 方法来获取一个 <code>Iterator</code> 对象。</li><li>使用 <code>hasNext()</code> 方法检查是否还有下一个元素。</li><li>使用 <code>next()</code> 方法获取下一个元素。</li><li>(可选) 使用 <code>remove()</code> 方法移除当前元素。</li></ol><p>下面是一个简单的示例，展示了如何使用 <code>Iterator</code> 遍历一个 <code>List</code> 集合：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;Apple&quot;);        list.add(&quot;Banana&quot;);        list.add(&quot;Orange&quot;);        &#x2F;&#x2F; 获取Iterator对象        Iterator&lt;String&gt; iterator &#x3D; list.iterator();        &#x2F;&#x2F; 遍历集合        while (iterator.hasNext()) &#123;            String element &#x3D; iterator.next();            System.out.println(element);        &#125;    &#125;&#125;</code></pre></div></figure><p>这段代码创建了一个包含几种水果的 <code>List</code> 对象，并通过调用 <code>iterator()</code> 方法获取了一个 <code>Iterator</code> 对象。然后，在一个 <code>while</code> 循环中，通过调用 <code>hasNext()</code> 和 <code>next()</code> 方法逐个打印了集合中的元素。</p><p><code>Iterator</code> 接口的使用有助于实现集合类的封装性和安全性，因为它允许在遍历集合时进行元素的安全访问和操作，而不会暴露底层集合的实现细节。</p><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><h3 id="java-util-stream-BaseStream"><a href="#java-util-stream-BaseStream" class="headerlink" title="java.util.stream.BaseStream"></a>java.util.stream.BaseStream</h3><p><code>java.util.stream.BaseStream</code> 是 Java 8 引入的流（Stream）框架中的一个基本接口。该接口位于 <code>java.util.stream</code> 包中，是流操作的基础。<code>BaseStream</code> 接口是泛型化的，它定义了流操作的通用方法，可以用于处理一系列元素。</p><p><code>BaseStream</code> 接口继承自 <code>AutoCloseable</code> 接口，因此它可以在使用完毕后进行自动关闭资源。这对于一些需要处理 I&#x2F;O 操作的流操作来说是非常有用的。</p><p>主要的子接口包括：</p><ol><li><code>Stream&lt;T&gt;</code>：表示元素类型为 T 的对象流。</li><li><code>IntStream</code>：表示元素类型为 int 的原始流。</li><li><code>LongStream</code>：表示元素类型为 long 的原始流。</li><li><code>DoubleStream</code>：表示元素类型为 double 的原始流。</li></ol><p><code>BaseStream</code> 接口提供了一系列的中间操作（Intermediate Operations）和终端操作（Terminal Operations），用于进行流的转换和处理。中间操作返回一个新的流，而终端操作则触发实际的计算，产生一个最终的结果。</p><p>常见的中间操作包括 <code>filter</code>、<code>map</code>、<code>flatMap</code> 等，而常见的终端操作包括 <code>forEach</code>、<code>collect</code>、<code>reduce</code> 等。</p><p>以下是 <code>BaseStream</code> 接口的一些常用方法：</p><ol><li><code>void close()</code>：关闭流，释放相关的资源。</li><li><code>boolean isParallel()</code>：判断流是否是并行流。</li><li><code>BaseStream&lt;T, S&gt; sequential()</code>：返回一个顺序流。</li><li><code>BaseStream&lt;T, S&gt; parallel()</code>：返回一个并行流。</li><li><code>S unordered()</code>：返回一个无序流。</li><li><code>Iterator&lt;T&gt; iterator()</code>：返回一个迭代器，用于迭代流中的元素。</li></ol><p><code>BaseStream</code> 接口的使用可以大大简化对集合数据的处理，特别是在并行处理大数据集时。通过流操作，可以更清晰、简洁地表达数据处理的逻辑。</p><h3 id="java-util-stream-Stream"><a href="#java-util-stream-Stream" class="headerlink" title="java.util.stream.Stream"></a>java.util.stream.Stream</h3><p><code>java.util.stream.Stream</code> 是 Java 8 引入的一个新特性，它提供了一种在集合类（Collection）上进行复杂操作的高级抽象。它允许你以一种更为函数式的风格来处理集合中的元素，例如映射、过滤、排序、聚合等。</p><p>下面是一些 <code>Stream</code> 类的主要特性和用法：</p><ol><li><p><strong>函数式编程风格：</strong> <code>Stream</code> 提供了丰富的函数式编程方法，如 <code>map()</code>、<code>filter()</code>、<code>reduce()</code> 等，这些方法可以直接应用于集合中的元素，使得对集合的操作更为灵活和易读。</p></li><li><p><strong>惰性求值：</strong> <code>Stream</code> 提供了惰性求值的特性，它们在处理集合时不会立即执行操作，而是等到需要结果时才执行。这种延迟执行的方式可以提高性能，尤其是当处理大型集合时。</p></li><li><p><strong>流水线：</strong> <code>Stream</code> 支持将多个操作连接在一起，形成一个流水线。这种操作的串联可以减少中间数据结构的创建，从而提高效率。</p></li><li><p><strong>并行处理：</strong> <code>Stream</code> 提供了并行处理集合元素的功能，可以通过 <code>parallel()</code> 方法将串行流转换为并行流，从而充分利用多核处理器的优势来加速处理过程。</p></li><li><p><strong>可消费性：</strong> <code>Stream</code> 是一种一次性的数据结构，一旦遍历消费了其中的元素，就不能再次使用。这意味着 <code>Stream</code> 是不可变的，对其的操作不会影响到原始集合。</p></li><li><p><strong>集成性：</strong> <code>Stream</code> 类提供了与其他类库的集成支持，例如与 Lambda 表达式、Optional 类型和函数式接口等的结合使用。</p></li></ol><p>基本上，<code>Stream</code> 类提供了一种更加灵活和高效的集合操作方式，尤其适用于处理大规模数据集合。通过结合函数式编程的思想和惰性求值的特性，它使得在 Java 中进行集合处理变得更加简洁和优雅。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>上述章节都是一些基础介绍（来此GPT和网络），了解这些之后，继续深入研究其原理。</p><p>**<code>Stream</code> 的大致思路如下: **</p><ul><li>首次创建流: 会创建一个初始的<code>Stream&lt;T&gt;</code>，从代码中可知，这个初始的<code>Stream&lt;T&gt;</code>其实就是<code>ReferencePipeline.Head&lt;T&gt;</code>初始通道实现<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;此处仅展示部分代码public static &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel) &#123;    Objects.requireNonNull(spliterator);    return new ReferencePipeline.Head&lt;&gt;(spliterator,                                        StreamOpFlag.fromCharacteristics(spliterator),                                        parallel);&#125;</code></pre></div></figure></li><li>中间操作: 会结合上一个通道，继续向下创建<code>ReferencePipeline.StatelessOp&lt;T&gt;</code>无状态通道实现或<code>ReferencePipeline.StatefulOp&lt;T&gt;</code>有状态通道实现，使其构成链式结构。因为其内部传递的都是<code>Sink</code>对象（真正的执行逻辑都在这个<code>Sink</code>对象中），所以做到了仅在最后才会真正的执行。<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;此处仅展示部分代码@Overridepublic final Stream&lt;P_OUT&gt; filter(Predicate&lt;? super P_OUT&gt; predicate) &#123;    Objects.requireNonNull(predicate);    return new StatelessOp&lt;P_OUT, P_OUT&gt;(this, StreamShape.REFERENCE,                                 StreamOpFlag.NOT_SIZED) &#123;        @Override        Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;P_OUT&gt; sink) &#123;            return new Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;                @Override                public void begin(long size) &#123;                    downstream.begin(-1);                &#125;                @Override                public void accept(P_OUT u) &#123;                    if (predicate.test(u))                        downstream.accept(u);                &#125;            &#125;;        &#125;    &#125;;&#125;@Override@SuppressWarnings(&quot;unchecked&quot;)public final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123;    Objects.requireNonNull(mapper);    return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE,                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;        @Override        Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123;            return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;                @Override                public void accept(P_OUT u) &#123;                    downstream.accept(mapper.apply(u));                &#125;            &#125;;        &#125;    &#125;;&#125;</code></pre></div></figure></li><li>终止操作: 仍然会结合上一个通道，唯一不一样的是这里是触发执行的位置，会执行到<code>java.util.stream.TerminalOp</code>，最终流也将关闭。<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;此处仅展示部分代码final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp) &#123;    assert getOutputShape() &#x3D;&#x3D; terminalOp.inputShape();    if (linkedOrConsumed)        throw new IllegalStateException(MSG_STREAM_LINKED);    linkedOrConsumed &#x3D; true;    return isParallel()           ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))           : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));&#125;</code></pre></div></figure></li></ul><blockquote><p><code>java.util.stream.TerminalOp</code>接口主要有四种抽象实现: </p><ul><li><code>java.util.stream.ReduceOps.ReduceOp</code> 减少操作 -&gt; 主要用在收集器逻辑</li><li><code>java.util.stream.FindOps.FindOp</code> 查找操作 -&gt; 主要用取最大值最小值逻辑</li><li><code>java.util.stream.MatchOps.MatchOp</code> 匹配操作 -&gt; 用于判断元素是否符合匹配规则</li><li><code>java.util.stream.ForEachOps.ForEachOp</code> 循环操作 -&gt; .forEach操作</li></ul></blockquote><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>源码解析</tag>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-分区表</title>
    <link href="/doc/6eaacce8.html"/>
    <url>/doc/6eaacce8.html</url>
    
    <content type="html"><![CDATA[<p>在单表数量过大的情况下，除了分表分库，还有什么办法可以处理吗？</p><span id="more"></span><h2 id="什么是分区表"><a href="#什么是分区表" class="headerlink" title="什么是分区表"></a>什么是分区表</h2><p>分区表将大型表数据分割为多个较小的分区，以提高查询性能和管理数据。每个分区可以独立地进行维护、备份和查询。</p><h2 id="分区表的目的"><a href="#分区表的目的" class="headerlink" title="分区表的目的"></a>分区表的目的</h2><p>分区的主要目的之一是将数据进行分表存放。通过将大型表拆分成较小的分区，可以将数据分散存储在不同的物理文件中，从而提高查询性能和管理数据的效率。</p><h2 id="有何好处"><a href="#有何好处" class="headerlink" title="有何好处"></a>有何好处</h2><p>分区可以带来以下几个好处：</p><ul><li>查询性能提升：当表中包含大量数据时，查询整个表可能会变得缓慢。通过将数据分区，可以仅搜索所需的分区，减少了需要扫描的数据量，从而提高查询性能。</li><li>简化数据维护：分区表可以根据特定的条件进行数据分割，使得对数据的备份、恢复和维护操作更加灵活和高效。可以只备份或恢复特定的分区，而不需要操作整个表。</li><li>提高并发性能：分区表可以在不同的分区上执行并行操作，从而提高并发性能。不同的分区可以由不同的CPU核心或服务器处理，减少了锁竞争和资源争用。</li><li>管理历史数据：分区表可以根据时间或其他条件将历史数据移动到单独的分区中。这样可以保持当前数据的高性能，并且轻松地对历史数据进行归档和管理。</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>我们以按范围分区为例来创建一个分区表。假设我们有一个存储销售订单的表，我们想将订单数据按照订单日期进行分区。</p><p>首先，我们创建一个名为<code>orders</code>的分区表，其中包含<code>order_id</code>、<code>order_date</code>和其他相关列：</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE orders (order_id INT,order_date DATE,customer_id INT,total_amount DECIMAL(10, 2),...) PARTITION BY RANGE (YEAR(order_date)) (PARTITION p2018 VALUES LESS THAN (2019),PARTITION p2019 VALUES LESS THAN (2020),PARTITION p2020 VALUES LESS THAN (2021),PARTITION p2021 VALUES LESS THAN (2022));</code></pre></div></figure><p>在上述示例中，我们使用<code>PARTITION BY RANGE</code>子句按照<code>order_date</code>的年份进行分区。创建了四个分区，分别代表2018年、2019年、2020年和2021年的订单数据。</p><p>接下来，我们可以将数据插入到分区表中。请注意，插入的数据必须符合分区规则，即<code>order_date</code>的年份必须在所选分区的范围内。</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO orders (order_id, order_date, customer_id, total_amount, ...)VALUES (1, &#39;2019-01-01&#39;, 1001, 100.00, ...);</code></pre></div></figure><p>我们可以使用类似的方式插入更多的订单数据。</p><p>在查询分区表时，我们可以使用WHERE子句和分区键来指定查询的分区范围，以提高查询性能。</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM ordersWHERE order_date BETWEEN &#39;2020-01-01&#39; AND &#39;2020-12-31&#39;;</code></pre></div></figure><p>这将查询2020年的订单数据。</p><p>最后，如果需要对分区进行修改和维护，可以使用<code>ALTER TABLE</code>语句。</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE ordersADD PARTITION (PARTITION p2022 VALUES LESS THAN (2023));</code></pre></div></figure><p>这将在分区表中添加一个新的分区，用于存储2022年的订单数据。</p><blockquote><p>需要注意的是，分区并不仅仅是将表拆分成多个小表，它还提供了其他一些功能和优化选项，如分区键选择、分区规则定义等。在使用分区时，需要根据具体的需求和应用场景进行合理的设计和配置。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题-分组查询最新一条</title>
    <link href="/doc/67cad2a0.html"/>
    <url>/doc/67cad2a0.html</url>
    
    <content type="html"><![CDATA[<p>昨天遇到这样一个问题，在数据表A中存在字段：id (primary key),ref_id,ref_name,created；<br>想在A表中对ref_id进行分组查询，并获取到每个分组中最新的那一条，怎么办？</p><span id="more"></span><p>这里想到了用<code>IN</code>字句来去做：</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id, ref_id, ref_name, createdFROM AWHERE (ref_id, created) IN (SELECT ref_id, MAX(created)FROM AGROUP BY ref_id);</code></pre></div></figure><p>但是这样的处理，效率非常低，因为它会在<code>IN</code>子句中进行多次查询匹配。查询资料后得到如下介绍：</p><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数（Window Function）是一种在查询结果集中的每一行上计算值的函数。它能够根据指定的窗口范围，对每一行进行排序、分组和计算，而不会修改查询结果本身。窗口函数通常与OVER子句一起使用。</p><p>窗口函数的一般语法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">&lt;窗口函数&gt;([参数]) OVER ([PARTITION BY &lt;分组列&gt;][ORDER BY &lt;排序列&gt; [ASC|DESC]][ROWS &lt;窗口范围&gt;])</code></pre></div></figure><p>下面是对窗口函数语法中的各个部分进行详细解释：</p><ul><li><code>&lt;窗口函数&gt;</code>：表示要使用的窗口函数，如SUM、COUNT、ROW_NUMBER等。窗口函数可以是聚合函数（如SUM、COUNT、AVG），也可以是排名函数（如ROW_NUMBER、RANK、DENSE_RANK），还可以是其他类型的函数。可以根据具体需求选择合适的窗口函数。</li><li><code>[参数]</code>：是可选的，表示窗口函数的参数。参数可以是列名、常量或其他表达式，根据具体的窗口函数而定。</li><li><code>OVER</code>：是关键字，用于引入窗口函数的定义。</li><li><code>[PARTITION BY &lt;分组列&gt;]</code>：是可选的，用于指定分组的列。如果指定了分组列，窗口函数将在每个分组内进行计算和排序。不同分组内的计算是相互独立的。</li><li><code>[ORDER BY &lt;排序列&gt; [ASC|DESC]]</code>：是可选的，用于指定排序的列和排序的顺序。窗口函数将根据指定的排序列对每一行进行排序。ASC表示升序（默认），DESC表示降序。</li><li><code>[ROWS &lt;窗口范围&gt;]</code>：是可选的，用于指定窗口的范围。窗口范围可以是行数、行的起始和结束位置，或者是行的偏移量。常见的窗口范围包括ROWS UNBOUNDED PRECEDING（从开头到当前行）、ROWS BETWEEN <start> AND <end>（从指定的起始行到结束行）等。</li></ul><blockquote><p>在窗口函数的语法中，窗口范围（Window Frame）用于指定窗口函数计算的行的范围。下面介绍一些常见的窗口范围：</p><ul><li>ROWS UNBOUNDED PRECEDING：表示从开头到当前行的所有行。</li><li>ROWS n PRECEDING：表示从当前行向前数n行。</li><li>ROWS CURRENT ROW：表示只包括当前行。</li><li>ROWS BETWEEN <start> AND <end>：表示从指定的起始行到结束行的范围，可以使用行号、行的偏移量或特殊关键字。</li><li>RANGE UNBOUNDED PRECEDING：表示从开头到当前行的所有行，根据排序列的值来确定。</li><li>RANGE n PRECEDING：表示从当前行向前数n行，根据排序列的值来确定。</li><li>RANGE CURRENT ROW：表示只包括当前行，根据排序列的值来确定。</li><li>RANGE BETWEEN <start> AND <end>：表示从指定的起始行到结束行的范围，根据排序列的值来确定。</li><li>GROUPS UNBOUNDED PRECEDING：表示从开头到当前行的所有组。</li><li>GROUPS n PRECEDING：表示从当前行向前数n个组。</li><li>GROUPS CURRENT ROW：表示只包括当前组。</li><li>GROUPS BETWEEN <start> AND <end>：表示从指定的起始组到结束组的范围。</li></ul><p>注意，窗口范围的具体语法和可用选项取决于使用的数据库系统。不同的数据库系统可能会提供不同的窗口范围选项。</p><p>使用窗口范围可以更加灵活地控制窗口函数的计算范围，从而满足不同的需求，比如计算移动平均、累计和、百分比等。具体的选择和使用方式，应该根据具体的业务需求和数据库系统的规范来决定。</p></blockquote><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>窗口函数在许多场景下非常有用，特别是在需要对查询结果进行分组、排序和计算的情况下。下面是一些窗口函数适用的场景示例：</p><ul><li>排名和排序：可以使用窗口函数计算行的排名（ROW_NUMBER）或根据特定列排序（ORDER BY），从而方便地获取排序结果。</li><li>分组计算：窗口函数可以在每个分组内进行计算，而无需使用GROUP BY子句。例如，可以计算每个分组的总和、平均值、最大值、最小值等。</li><li>移动聚合：窗口函数可以计算滑动窗口范围内的聚合值。例如，可以计算滑动窗口内的移动平均值、移动总和等。</li><li>累计计算：窗口函数可以计算累积计算，即将当前行和之前的行进行累积计算。例如，可以计算累积总和、累积平均值等。</li><li>分位数和百分比：窗口函数可以计算行在整个结果集中的百分位数，从而方便地获取百分位数和百分比。</li><li>前后比较：窗口函数可以比较当前行与前一行或后一行的值，从而进行比较和计算差异。</li></ul><p>窗口函数可以在各种情况下提供更灵活和高效的查询和分析功能。它们可以减少复杂的子查询和连接操作，同时提供更直观和简洁的查询语句。无论是在数据分析、报表生成、排名计算还是其他需要对结果集进行计算和处理的场景下，窗口函数都是非常有用的工具。</p><h2 id="使用窗口函数解决问题"><a href="#使用窗口函数解决问题" class="headerlink" title="使用窗口函数解决问题"></a>使用窗口函数解决问题</h2><p>根据窗口函数语法，我们得到如下查询方案：</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">WITH RankedRecords AS (  SELECT id,ref_id,ref_name,created,    ROW_NUMBER() OVER (PARTITION BY ref_id ORDER BY created DESC) AS rn  FROM A)SELECT id,ref_id,ref_name,createdFROM RankedRecordsWHERE rn &#x3D; 1;</code></pre></div></figure><p>如此我们便可以查询出我们想要的结果，接下来我们来分析一下：</p><p>这个查询使用了窗口函数（Window Function）来实现按照ref_id分组，并根据ref_time进行排序和编号。窗口函数可以在查询结果集中的每一行上计算值，而不会修改结果集本身。</p><p><strong>解释步骤：</strong></p><ul><li>RankRecords子查询：首先，通过在原始表中使用窗口函数ROW_NUMBER()，对每个ref_id进行分组并按照ref_time进行降序排序。这会为每个ref_id的记录分配一个行号（rn），行号从1开始，表示每个ref_id的记录在排序后的顺序。</li><li>最外层的SELECT语句：在RankRecords子查询的基础上，选择对应行号（rn）为1的记录，即每个ref_id的最新记录。这样就得到了按照ref_id去重后，每个ref_id的最新记录。</li></ul><p><strong>性能比较：</strong></p><ul><li><p>与使用子查询和IN子句的方案相比，使用窗口函数的方案可能会更有效率。原因是窗口函数只需要对表进行一次扫描，并在内部进行排序和编号，而不需要使用子查询和IN子句进行多次查询和匹配。</p></li><li><p>使用窗口函数的方案可以更简洁地实现按照ref_id去重并获取最新记录的需求，而且在某些情况下可能会更快。但是，实际性能还取决于表的大小、索引的使用情况以及数据库引擎的优化能力。建议在实际环境中进行测试和性能评估，以确定最适合的方案。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scoop安装常用环境</title>
    <link href="/doc/b459711d.html"/>
    <url>/doc/b459711d.html</url>
    
    <content type="html"><![CDATA[<p>针对开发人员的常用环境安装。替代Choco。</p><span id="more"></span><h2 id="常用环境安装列表"><a href="#常用环境安装列表" class="headerlink" title="常用环境安装列表"></a>常用环境安装列表</h2><ul><li>7zip <code>scoop install 7zip</code> 一般会默认安装</li><li>adb <code>scoop install adb</code></li><li>android-studio <code>scoop install android-studio</code> 安装时需要先<code>scoop bucket add extras</code></li><li>apifox <code>scoop install apifox</code> 安装时需要先<code>scoop bucket add extras</code></li><li>bun-canary <code>scoop install bun-canary</code> 安装时需要先<code>scoop bucket add versions</code></li><li>cheat-engine <code>scoop install cheat-engine</code> 安装时需要先<code>scoop bucket add extras</code></li><li>git <code>scoop install git</code></li><li>googlechrome <code>scoop install googlechrome</code> 安装时需要先<code>scoop bucket add extras</code></li><li>tortoisesvn <code>scoop install tortoisesvn</code> 安装时需要先<code>scoop bucket add extras</code></li><li>oraclejdk <code>scoop install oraclejdk</code> 安装时需要先<code>scoop bucket add java</code></li><li>ffmpeg <code>scoop install ffmpeg</code></li><li>make <code>scoop install make</code></li><li>cmake <code>scoop install cmake</code></li><li>minGW <code>scoop install mingw</code></li><li>mkcert <code>scoop install mkcert</code> 安装时需要先<code>scoop bucket add extras</code></li><li>nasm <code>scoop install nasm</code></li><li>nodejs <code>scoop install nodejs</code></li><li>notepadplusplus <code>scoop install notepadplusplus</code> 安装时需要先<code>scoop bucket add extras</code></li><li>qemu <code>scoop install qemu</code></li><li>scrcpy <code>scoop install scrcpy</code></li><li>sqlite <code>scoop install sqlite</code></li><li>windterm <code>scoop install windterm</code> 安装时需要先<code>scoop bucket add extras</code></li><li>wireshark <code>scoop install wireshark</code> 安装时需要先<code>scoop bucket add extras</code></li><li>wiztree <code>scoop install wiztree</code> 安装时需要先<code>scoop bucket add extras</code></li><li>x64dbg <code>scoop install x64dbg</code> 安装时需要先<code>scoop bucket add extras</code></li><li>openvpn <code>scoop install openvpn</code> 安装时需要先<code>scoop bucket add extras</code></li><li>rustup <code>scoop install rustup</code></li><li>idea <code>scoop install idea</code> 安装时需要先<code>scoop bucket add extras</code></li><li>mysql <code>scoop install mysql</code></li><li>openssl <code>scoop install openssl</code></li><li>wireguard-np <code>scoop install wireguard-np</code> 安装时需要先<code>scoop bucket add nonportable</code></li><li>potplayer <code>scoop install potplayer</code> 安装时需要先<code>scoop bucket add extras</code></li><li>openocd <code>scoop install openocd</code></li><li>vagrant <code>scoop install vagrant</code></li><li>draw.io <code>scoop install draw.io</code> 安装时需要先<code>scoop bucket add extras</code></li><li>snipaste <code>scoop install snipaste</code> 安装时需要先<code>scoop bucket add extras</code></li><li>motrix <code>scoop install motrix</code> 安装时需要先<code>scoop bucket add extras</code></li><li>obsidian <code>scoop install obsidian</code> 安装时需要先<code>scoop bucket add extras</code></li><li>upx <code>scoop install upx</code></li><li>tinytask <code>scoop install tinytask</code> 安装时需要先<code>scoop bucket add extras</code></li><li>jetbrains-all <code>scoop install https://blog.cikaros.top/static/jetbrains-all.json</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>Scoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理工具</tag>
      
      <tag>Scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell安装Scoop</title>
    <link href="/doc/155f072e.html"/>
    <url>/doc/155f072e.html</url>
    
    <content type="html"><![CDATA[<p>Scoop 它是一个开源的Windows 包管理工具。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Scoop是什么？"><a href="#Scoop是什么？" class="headerlink" title="Scoop是什么？"></a>Scoop是什么？</h3><p>Scoop是一个用于Windows操作系统的命令行软件包管理器。它的目标是简化在Windows上安装和管理软件包的过程。与其他包管理器不同，如Chocolatey，Scoop专注于命令行工具和开发人员工具的安装和管理。</p><p>Scoop允许用户通过简单的命令来安装、卸载、更新和搜索软件包。它的设计理念是轻量、快速和可定制的。Scoop使用了Git版本控制系统作为其包管理的基础，这意味着它可以方便地跟踪和管理软件包的更新和版本。</p><h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><ul><li>简单易用：使用简单的命令即可安装和管理软件包。</li><li>轻量快速：Scoop的设计目标是轻量、快速的安装和管理，不会对系统性能产生很大的影响。</li><li>定制灵活：用户可以通过配置文件和自定义桶（bucket）来定制和扩展Scoop的功能。</li><li>版本控制：基于Git的版本控制系统可以方便地管理软件包的更新和版本。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要为Powershell设置脚本执行策略：</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</code></pre></div></figure><p>快速安装Scoop</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">irm get.scoop.sh | iex</code></pre></div></figure><blockquote><p>若实在不行也可以访问<code>scoop</code>国内镜像优化库: <a href="https://gitee.com/scoop-installer/scoop">https://gitee.com/scoop-installer/scoop</a><br>将<code>get.scoop.sh</code>替换为<code>scoop.201704.xyz</code>即可，详情参见 <a href="https://gitee.com/scoop-installer/scoop">Gitee</a></p></blockquote><p>若有代理可自行设置代理地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">irm get.scoop.sh -Proxy &#39;http:&#x2F;&#x2F;&lt;ip:port&gt;&#39; | iex</code></pre></div></figure><p>但有时候我们需要比较高级的安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">#下载安装脚本到本地irm get.scoop.sh -outfile &#39;install.ps1&#39;#查看帮助.&#x2F;install.ps1 -?#安装到指定位置.&#x2F;install.ps1 -ScoopDir &#39;D:\Applications\Scoop&#39; -ScoopGlobalDir &#39;F:\GlobalScoopApps&#39;</code></pre></div></figure><p>方便查看，我将帮助输出保留在这儿：</p><figure><div class="code-wrapper"><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">PS C:\Users\Cikaros\Desktop&gt; .\install.ps1 -?名称C:\Users\Cikaros\Desktop\install.ps1摘要Scoop installer.语法C:\Users\Cikaros\Desktop\install.ps1 [[-ScoopDir] &lt;String&gt;] [[-ScoopGlobalDir] &lt;String&gt;] [[-ScoopCacheDir] &lt;String&gt;    ] [-NoProxy] [[-Proxy] &lt;Uri&gt;] [[-ProxyCredential] &lt;PSCredential&gt;] [-ProxyUseDefaultCredentials] [-RunAsAdmin] [&lt;Com        monParameters&gt;]        说明        The installer of Scoop. For details please check the website and wiki.        相关链接        https:&#x2F;&#x2F;scoop.sh        https:&#x2F;&#x2F;github.com&#x2F;ScoopInstaller&#x2F;Scoop&#x2F;wiki        备注        若要查看示例，请键入: &quot;get-help C:\Users\Cikaros\Desktop\install.ps1 -examples&quot;.        有关详细信息，请键入: &quot;get-help C:\Users\Cikaros\Desktop\install.ps1 -detailed&quot;.        若要获取技术信息，请键入: &quot;get-help C:\Users\Cikaros\Desktop\install.ps1 -full&quot;.        有关在线帮助，请键入: &quot;get-help C:\Users\Cikaros\Desktop\install.ps1 -online&quot;</code></pre></div></figure><p>懒人必备(Cikaros):</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUserirm get.scoop.sh -outfile &#39;install.ps1&#39;.\install.ps1 -ScoopDir &quot;E:\Temp\.scoop\&quot; -ScoopGlobalDir &quot;E:\Temp\.scoop\.global&quot; -ScoopCacheDir &quot;E:\Temp\.scoop\.cache&quot; -Proxy &quot;http:&#x2F;&#x2F;rainyun.netbird.local:7890&quot;</code></pre></div></figure><h3 id="使用Aria2下载引擎"><a href="#使用Aria2下载引擎" class="headerlink" title="使用Aria2下载引擎"></a>使用Aria2下载引擎</h3><p>安装aria2即可 <code>scoop install aria2</code></p><p>有时需临时关闭aria2引擎 <code>scoop config aria2-enabled false</code></p><p>其他相关参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1"># aria2 在 Scoop 中默认开启scoop config aria2-enabled true# 关于以下参数的作用，详见aria2的相关资料scoop config aria2-retry-wait 4scoop config aria2-split 16scoop config aria2-max-connection-per-server 16scoop config aria2-min-split-size 4M</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>Scoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
      <tag>Scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx动态加载模块编译</title>
    <link href="/doc/4c19be85.html"/>
    <url>/doc/4c19be85.html</url>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong>是一款轻量级的 Web 服务器&#x2F;反向代理服务器及电子邮件（<strong>IMAP&#x2F;POP3</strong>）代理服务器。</p><p>动态模块编译允许我们在不重新编译整个<strong>Nginx</strong>的情况下，添加或删除特定的功能模块，从而灵活地定制我们的<strong>Nginx</strong>服务器。</p><span id="more"></span><p>传统上，在编译 Nginx 时，我们需要在配置文件中指定需要启用的模块，并重新编译整个 Nginx 服务器。但是，Nginx 动态模块编译提供了更加灵活的方式，可以在运行时加载或卸载特定的模块，而无需重新编译整个 Nginx。</p><h2 id="使用Dockerfile编译三方模块"><a href="#使用Dockerfile编译三方模块" class="headerlink" title="使用Dockerfile编译三方模块"></a>使用Dockerfile编译三方模块</h2><p>以<code>headers-more-nginx-module-src</code>模块为例介绍：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM centos:7 AS BuilderARG NGINX_VERSION&#x3D;1.20.1WORKDIR &#x2F;usr&#x2F;src#解决软件的依赖关系，需要安装的软件包RUN yum -y install wget zlib zlib-devel openssl openssl-devel pcre pcre-devel gcc gcc-c++ autoconf automake makeRUN curl -L &quot;https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-$&#123;NGINX_VERSION&#125;.tar.gz&quot; -o &quot;nginx-$&#123;NGINX_VERSION&#125;.tar.gz&quot;RUN tar -zxC &#x2F;usr&#x2F;src -f nginx-$&#123;NGINX_VERSION&#125;.tar.gzRUN mv nginx-$&#123;NGINX_VERSION&#125; nginxARG MODULE_VERSION&#x3D;0.33ARG MODULE_NAME&#x3D;headers-more-nginx-module-srcARG MODULE_SOURCE&#x3D;https:&#x2F;&#x2F;github.com&#x2F;nginx-with-docker&#x2F;headers-more-nginx-module-srcRUN curl -L &quot;$&#123;MODULE_SOURCE&#125;&#x2F;archive&#x2F;refs&#x2F;tags&#x2F;v$&#123;MODULE_VERSION&#125;.tar.gz&quot; -o &quot;$&#123;MODULE_VERSION&#125;.tar.gz&quot; &amp;&amp; \tar -zxC &#x2F;usr&#x2F;src -f $&#123;MODULE_VERSION&#125;.tar.gz &amp;&amp; \mv $&#123;MODULE_NAME&#125;-$&#123;MODULE_VERSION&#125;&#x2F; $&#123;MODULE_NAME&#125; &amp;&amp; \cd &#x2F;usr&#x2F;src&#x2F;nginx &amp;&amp; \echo $CONFARGS &amp;&amp; \.&#x2F;configure --with-compat $CONFARGS --add-dynamic-module&#x3D;..&#x2F;$&#123;MODULE_NAME&#125;&#x2F; &amp;&amp; \make modulesFROM scratchCOPY --from&#x3D;Builder &#x2F;usr&#x2F;src&#x2F;nginx&#x2F;objs&#x2F;ngx_http_headers_more_filter_module.so &#x2F;</code></pre></div></figure><p>将生成的<code>ngx_http_headers_more_filter_module.so</code>放置在 Nginx 安装路径下的<code>modules</code>文件夹内即可。</p><blockquote><p>通常情况下，在 Linux 系统上，Nginx 的安装路径为 <code>/usr/local/nginx</code> 或 <code>/etc/nginx</code>。你可以通过 <code>which nginx</code> 命令查看 Nginx 的可执行文件路径，或者通过 <code>nginx -V</code> 命令查看编译时的配置参数。</p></blockquote><h2 id="加载并配置动态模块"><a href="#加载并配置动态模块" class="headerlink" title="加载并配置动态模块"></a>加载并配置动态模块</h2><p>现在，我们需要配置 Nginx 服务器以加载动态模块。</p><p>编辑 Nginx 配置文件 nginx.conf：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</code></pre></div></figure><p>在 http 部分，添加以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">load_module modules&#x2F;ngx_http_headers_more_filter_module.so;</code></pre></div></figure><p>保存并关闭文件。</p><p>最后，重新启动 Nginx 服务器以使配置生效。</p><p>至此，我们成功实现了 Nginx 的动态模块编译。现在你可以根据需要自由地添加或删除其他的模块，而无需重新编译整个 Nginx 服务器。这为定制和扩展 Nginx 提供了更大的灵活性和便利性。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows驱动开发Demo</title>
    <link href="/doc/ec463b4e.html"/>
    <url>/doc/ec463b4e.html</url>
    
    <content type="html"><![CDATA[<p>驱动是运行在内核级别的程序，拥有掌控所有设备的权力，需谨慎使用！</p><span id="more"></span><p>大部分开发人员，在公司中都会使用公司提供的设备或干脆使用云电脑之类的进行工作办公。有时，公司为了安全就会对我们使用的操作系统做一些相应的改造，最简单的就是对办公文件的加解密。</p><p>我们来简单研究一下实现思路。要想实现办公文件的加解密，最理想的情况就是不影响用户的正常使用，那只要在用户打开之前进行文件解密，在关闭之后进行文件加密操作即可。但是如何实现呢？</p><p>这种操作所要达到的一个条件就是，拥有一定的权限，在用户态，若是操作系统没有提供相应的API是无法实现的（查了一下没查到），那么我们想要实现就必须在内核态考虑一下了。Windows提供了驱动开发的功能，这个功能可以将我们开发好的程序注册到操作系统的内核态去运行。</p><p>很好，我们找到了解决方案，简单说一下原理，以下是一个使用C开发的简易核心Demo：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;ntddk.h&gt;    &#x2F;&#x2F; 定义驱动程序入口函数    DRIVER_INITIALIZE DriverEntry;    NTSTATUS DriverEntry(    _In_ PDRIVER_OBJECT   DriverObject,    _In_ PUNICODE_STRING  RegistryPath    )    &#123;        UNREFERENCED_PARAMETER(RegistryPath);        &#x2F;&#x2F; 注册驱动程序的卸载例程        DriverObject-&gt;DriverUnload &#x3D; UnloadDriver;        &#x2F;&#x2F; 注册文件操作的回调函数        DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] &#x3D; InterceptFileOpen;        DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] &#x3D; InterceptFileClose;        return STATUS_SUCCESS;    &#125;    NTSTATUS InterceptFileOpen(    PDEVICE_OBJECT DeviceObject,    PIRP Irp    )    &#123;        &#x2F;&#x2F; 在文件打开前执行的操作        &#x2F;&#x2F; 可以在这里加入文件解密逻辑        &#x2F;&#x2F; TODO: Add decryption code here        &#x2F;&#x2F; 继续原始文件打开操作        IoSkipCurrentIrpStackLocation(Irp);        return IoCallDriver(DeviceObject, Irp);    &#125;    NTSTATUS InterceptFileClose(    PDEVICE_OBJECT DeviceObject,    PIRP Irp    )    &#123;        &#x2F;&#x2F; 在文件关闭后执行的操作        &#x2F;&#x2F; 可以在这里加入文件加密逻辑        &#x2F;&#x2F; TODO: Add encryption code here        &#x2F;&#x2F; 继续原始文件关闭操作        IoSkipCurrentIrpStackLocation(Irp);        return IoCallDriver(DeviceObject, Irp);    &#125;    VOID UnloadDriver(    _In_ PDRIVER_OBJECT DriverObject    )    &#123;        &#x2F;&#x2F; 卸载驱动程序时的清理操作    &#125;</code></pre></div></figure><p>这只是一个简单的示例，用于演示如何注册文件系统过滤驱动程序，并在文件打开和关闭时插入一些加解密操作。这样就达到了我们的要求，接下来只要注册到操作系统就可以了，Windows提供使用<code>*.inf</code>来进行安装（Inf是安装描述文件）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-inf" data-language="inf"><code class="language-inf">[Version]Signature&#x3D;&quot;$WINDOWS NT$&quot;Class&#x3D;SampleFilterClassGuid&#x3D;&#123;your-guid-here&#125;Provider&#x3D;%ManufacturerName%DriverVer&#x3D;10&#x2F;13&#x2F;2023,1.0.0CatalogFile&#x3D;mydriver.cat[SourceDisksFiles][SourceDisksFiles.amd64][SourceDisksFiles.x86][DestinationDirs]DefaultDestDir &#x3D; 12[Manufacturer]%ManufacturerName% &#x3D; Standard,NTx86,NTamd64[Standard.NTx86]%DeviceDesc% &#x3D; SampleDriver_Inst, ROOT\SampleFilter[Standard.NTamd64]%DeviceDesc% &#x3D; SampleDriver_Inst, ROOT\SampleFilter[Standard.NTx86.Services]AddService &#x3D; SampleDriver,, SampleDriver.Service[Standard.NTamd64.Services]AddService &#x3D; SampleDriver,, SampleDriver.Service[SampleDriver.Service]DisplayName    &#x3D; %ServiceName%ServiceType    &#x3D; 1StartType      &#x3D; 3ErrorControl   &#x3D; 1ServiceBinary  &#x3D; %12%\sampledriver.sysLoadOrderGroup &#x3D; Extended Base[SampleDriver_Inst]CopyFiles &#x3D; DriverFiles[DriverFiles]sampledriver.sys[Strings]ManufacturerName&#x3D;&quot;Your Manufacturer&quot;DeviceDesc&#x3D;&quot;Sample Filter Driver&quot;ServiceName&#x3D;&quot;SampleDriver</code></pre></div></figure><p>请注意以下几点：</p><ul><li>将 %ManufacturerName% 替换为制造商名称。</li><li>%DeviceDesc% 是设备的描述，可以根据实际情况修改。</li><li>%ServiceName% 是服务的名称。</li><li>按需修改 ServiceType、StartType、ErrorControl，以适应您的驱动程序需求。</li><li>ServiceBinary 应指向您的驱动程序文件的路径。</li><li>替换 CatalogFile 为您的驱动程序的数字签名目录（如果有的话）。</li></ul><p>要安装此驱动程序，可以使用 devcon 工具，或者在设备管理器中选择 “更新驱动程序” 并选择 INF 文件。但请注意，驱动程序开发和部署需要小心谨慎，特别是在生产环境中，应遵循最佳实践和安全性规则。这个Demo只是为了演示原理。</p><p>好了，那就这样~</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Windows</tag>
      
      <tag>Driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>diesel ORM的使用</title>
    <link href="/doc/861fbf6e.html"/>
    <url>/doc/861fbf6e.html</url>
    
    <content type="html"><![CDATA[<p>Diesel 是与 Rust 中的数据库交互的最有效方式，因为它对查询进行了安全且可组合的抽象。</p><span id="more"></span><h2 id="Sqlite环境准备"><a href="#Sqlite环境准备" class="headerlink" title="Sqlite环境准备"></a>Sqlite环境准备</h2><p>在使用 Diesel 之前，需要从 Sqlite 官网下载并编译合适的 lib 包，并放置在 msvc 的库文件夹中。</p><blockquote><p>这是很多人忽略的问题，在进行<code>cargo install diesel_cli --no-default-features --features sqlite</code>时无法正常链接，导致安装失败！</p></blockquote><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><ol><li>使用<code>cargo new</code>创建自定义项目。</li><li>修改<code>Cargo.toml</code>文件依赖</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">[package]name &#x3D; &quot;diesel_demo&quot;version &#x3D; &quot;0.1.0&quot;edition &#x3D; &quot;2021&quot;# See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html[dependencies]diesel &#x3D; &#123; version &#x3D; &quot;2.1.1&quot;, features &#x3D; [&quot;sqlite&quot;] &#125;dotenvy &#x3D; &quot;0.15.7&quot;serde &#x3D; &#123; version &#x3D; &quot;1.0.188&quot;, features &#x3D; [&quot;derive&quot;] &#125;</code></pre></div></figure><ol start="3"><li>安装终端工具<code>cargo install diesel_cli --no-default-features --features sqlite</code></li></ol><blockquote><p>根据需要调整数据库指定参数，例如：<br>  <code>cargo install diesel_cli --no-default-features --features mysql</code></p></blockquote><ol start="4"><li>使用终端工具管理数据库表结构，需要在项目根目录下维护<code>.env</code>环境变量文件</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#环境变量 数据库位置echo DATABASE_URL&#x3D;.&#x2F;diesel_demo &gt; .env#生成数据库diesel setup#创建表结构变化脚本#生成后会在项目根目录下生成&#96;migrations&#x2F;yyyy-MM-dd-hhmmss_table_name&#x2F;up.sql&#96;和&#96;migrations&#x2F;yyyy-MM-dd-hhmmss_table_name&#x2F;down.sql&#96;#在里面编写初始化脚本和销毁脚本diesel migration generate table_name#在数据库中生成表结构diesel migration run#重新生成表结构diesel migration redo</code></pre></div></figure><ol start="5"><li>编写合适的Rust代码，编译，运行即可。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源项目-SSL自动续约脚本</title>
    <link href="/doc/14c8d1db.html"/>
    <url>/doc/14c8d1db.html</url>
    
    <content type="html"><![CDATA[<p>acme.sh 是一个用于自动化管理 Let’s Encrypt SSL&#x2F;TLS 证书的命令行工具。它允许用户在其服务器上轻松获取、更新和部署 SSL&#x2F;TLS 证书，以确保网站和应用程序的安全性和加密通信。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>以下是 acme.sh 的一些关键特点和用途：</p><ul><li>自动证书签发和更新：acme.sh 可以自动获取 Let’s Encrypt 证书，并设置定时任务以确保证书在到期前自动续订。</li><li>多种 DNS API 支持：它支持多种 DNS 提供商的 API，使您能够通过 DNS 验证方式获取证书，而不仅仅是通过 HTTP 验证。</li><li>多种证书格式：acme.sh 支持生成各种格式的证书，包括 PEM、DER、PKCS12 等。</li><li>灵活的安装选项：您可以选择将证书安装到不同类型的 Web 服务器（如Apache、Nginx、Caddy等）或其他应用程序中。</li><li>多环境支持：它可以在各种操作系统和环境中运行，包括 Linux、macOS 和 Windows。</li><li>插件系统：acme.sh 具有丰富的插件系统，允许用户编写自定义插件来执行各种操作，从而扩展其功能。</li><li>完全开源：acme.sh 是一个开源项目，可以在 GitHub 上找到其源代码，并受到活跃的社区支持。</li></ul><h2 id="自主续约"><a href="#自主续约" class="headerlink" title="自主续约"></a>自主续约</h2><p>以下来自ChatGPT，它会在续约证书之前备份旧证书，然后将新证书放回原始位置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 指定证书文件夹路径cert_dir&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;certificates&quot;# 指定证书备份文件夹路径backup_dir&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;backup&quot;# 指定要续约的域名和相应的启动和停止服务的命令declare -A domain_start_mapdeclare -A domain_stop_map# 启动服务的映射domain_start_map[&quot;example.com&quot;]&#x3D;&quot;docker start nginx&quot;domain_start_map[&quot;anotherdomain.com&quot;]&#x3D;&quot;docker start myapp&quot;# 停止服务的映射domain_stop_map[&quot;example.com&quot;]&#x3D;&quot;docker stop nginx&quot;domain_stop_map[&quot;anotherdomain.com&quot;]&#x3D;&quot;docker stop myapp&quot;# 检查是否已安装 acme.shif [ ! -f &quot;$HOME&#x2F;.acme.sh&#x2F;acme.sh&quot; ]; then    echo &quot;acme.sh 未安装，开始下载并安装...&quot;    # 使用 curl 下载 acme.sh 脚本    curl https:&#x2F;&#x2F;get.acme.sh | sh        sudo apt-get -y install socat        if [ ! -f &quot;$HOME&#x2F;.acme.sh&#x2F;acme.sh&quot; ]; then        echo &quot;acme.sh 安装失败，请手动安装&quot;        exit 1    fi    &#x2F;root&#x2F;.acme.sh&#x2F;acme.sh --set-default-ca --server letsencryptfi# 遍历每个域名和相应的服务命令for domain in &quot;$&#123;!domain_stop_map[@]&#125;&quot;; do    cert_file&#x3D;&quot;$cert_dir&#x2F;$domain.crt&quot;    key_file&#x3D;&quot;$cert_dir&#x2F;$domain.key&quot;    stop_service_command&#x3D;&quot;$&#123;domain_stop_map[$domain]&#125;&quot;    start_service_command&#x3D;&quot;$&#123;domain_start_map[$domain]&#125;&quot;    # 检查证书和私钥文件是否存在    if [ -f &quot;$cert_file&quot; ] &amp;&amp; [ -f &quot;$key_file&quot; ]; then        echo &quot;证书和私钥文件存在，继续...&quot;        # 检查证书是否过期        if openssl x509 -checkend 0 -noout -in &quot;$cert_file&quot;; then            echo &quot;证书 $domain 未过期，无需续约&quot;        else            echo &quot;证书 $domain 已过期，正在续约...&quot;            # 执行用户指定的停止服务命令            echo &quot;停止服务: $stop_service_command&quot;            eval &quot;$stop_service_command&quot;            # 备份旧证书和私钥文件            backup_dir&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;backup&quot;            mkdir -p &quot;$backup_dir&quot;            timestamp&#x3D;$(date +&quot;%Y%m%d%H%M%S&quot;)            cp &quot;$cert_file&quot; &quot;$backup_dir&#x2F;$domain.$timestamp.crt&quot;            cp &quot;$key_file&quot; &quot;$backup_dir&#x2F;$domain.$timestamp.key&quot;            # 使用 acme.sh 续约证书并放回原始位置            &#x2F;root&#x2F;.acme.sh&#x2F;acme.sh --renew -d $domain --force            acme_sh_cert_dir&#x3D;&quot;&#x2F;root&#x2F;.acme.sh&#x2F;$domain&quot;            new_cert_file&#x3D;&quot;$acme_sh_cert_dir&#x2F;fullchain.cer&quot;            new_key_file&#x3D;&quot;$acme_sh_cert_dir&#x2F;$domain.key&quot;            cp &quot;$new_cert_file&quot; &quot;$cert_file&quot;            cp &quot;$new_key_file&quot; &quot;$key_file&quot;            # 执行用户指定的启动服务命令            echo &quot;启动服务: $start_service_command&quot;            eval &quot;$start_service_command&quot;            echo &quot;证书 $domain 续约完成&quot;        fi    else        echo &quot;证书或私钥文件不存在 for $domain，开始申请新证书...&quot;        # 执行用户指定的停止服务命令        echo &quot;停止服务: $stop_service_command&quot;        eval &quot;$stop_service_command&quot;        # 使用 acme.sh 申请新证书并放回指定位置        &#x2F;root&#x2F;.acme.sh&#x2F;acme.sh --issue -d $domain --standalone        &#x2F;root&#x2F;.acme.sh&#x2F;acme.sh --install-cert -d $domain \          --key-file &quot;$key_file&quot; \          --fullchain-file &quot;$cert_file&quot;        # 执行用户指定的启动服务命令        echo &quot;启动服务: $start_service_command&quot;        eval &quot;$start_service_command&quot;        echo &quot;新证书 $domain 已申请并放置在指定位置&quot;    fidone</code></pre></div></figure><p>请根据您的实际情况更新脚本中的路径和命令，并使用 <code>cron</code> 作业来定期运行此脚本以执行证书续约和服务操作。</p><p>要定期执行此脚本，您可以使用 <code>cron</code> 作业。运行 <code>crontab -e</code> 来编辑您的用户的 <code>cron</code> 作业，然后添加一个类似于以下的行来设置定期执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cron" data-language="cron"><code class="language-cron">0 0 * * * &#x2F;path&#x2F;to&#x2F;renew_certificates.sh</code></pre></div></figure><p>这将在每天午夜（00:00）执行脚本。确保将 <code>/path/to/renew_certificates.sh</code> 替换为实际的脚本路径。此设置将每天检查证书并执行续约操作（如果需要）。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源IM协议Matrix-Synapse与TURN环境搭建</title>
    <link href="/doc/8dd4deb9.html"/>
    <url>/doc/8dd4deb9.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对哦, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~">  <script id="hbeData" type="hbeData" data-hmacdigest="abf79caf7fba9ba6809841bf702f4b88f19492ac51707394cfa856e6149cd638">890efb48042b9e3863804653b4caada586c8f973dd89e716349803f1cd12ac6eefe4f8feb63431178a2b3566ff5681a335994cc322b6dece3887b9a703c8da820cb964c4a5713aeaea9df58febbce5b75d0ee53ea1608c93361237952ebaf20e5caf4344e0ae17707dee09b701dd9c2507a7f50b0de5d561de5a50179a03f9c044d9aebad9a73b341a41352b3fe5615cefce18f6d7bcaf98f799e5e5066e8cfb8d105964f25b28891b81bce3161699471c1233f82db78e5e37da4605277ec8d42d7fdfc22b05da23611cbbae0303e3a3fd2239e9cb9977e9cfd522c7ac759410692c5a68cc7907fa6594632977da6f632b9ef48dce593da8131fb103aff0b20e0066d29e61e8512d681a3016d25749794dac370e38d4c00e4ac5c98fe7923d541bb330f260a72e1aedeebb0cfe43c819bd4f1246748d90e67c18a31b449dcac42e88d1d43b87c4e20e1b2829770a865eaf15c7605a159b504c06e17f8dbef6015abf73acc6c8aaa435be26b9cffab8d6f381e65aa548caabd53bfc20da63cfe5a313c7b3b28ec912b87a37fea041a30bc456b1f2b52c9be925beac874a27cfe128bdc793b6fdb4bd1bf003c63e71ed4f3404593fcbe305225983bf946a492590ab3867a87626cc0bbbd789b541fcc7c4f59895ac2256c6b98771dc988d92950aa6966d183b69e32ea3314b62683ecdada24eddf6b3ca4cabd7a3ca1f03e16b8987012e15fb3d4f648f4481651999198ff4e76036550fdb6c8aa8e123b26655f0170dbe4dbb590fe22432fa93b93f1575732e01f321cf79e303732d89d2102ed28b7fe9815d2324db446d41b3bd5204cd763d52a280a89acf2c9a73a6708ec1f1c7d8897dac930555dbe7387bbe14c8b4674fcc6534cf2f15045047c8a42614c1b6c9ded37fae8fc9883cd75dd1a15535bab39dcb95b20992763ebf643fb56c252c0f530fb709540ea8e4c7a0cad208564444b0070c471c3698f953bf4c90b2efa0e62340c7f3123a272583e637bfe9fdbe8a3fe5cefab0360cb538be42c24aecb9905a8c3b77eecc115d486dd3d17db7a0c2dbf45c9c996f4612eb414eb1a7eecdb4b9b636d70b19dbc2856a6f24e50e550b377f7a2cb55a2d654eec904ad1ab6d7c69865c77f74db513c6fbace65321dba2303b2beac890242821f2d3ff3e41ec8228ae3a2664bcb147f4adbcfd8439a3a61df3e2ada3de112e4f4a0fb7dcf7199c4782b84a53ba4f33a981d39ab3ca826fd54249a819028f291e5bc8a4d0385564678aa4cb1657ba0341d6bd29577200fe9192a9192861c7d4c8bb8b946c9b495a151d436cf5050fb784e5231ffc554560ee79bbf24539c676576e335125e698cee4f10960f33467648c167f96aca803d78030b9bbfb87bf6579feb31826f3b34f7169a0f9f3b94180c895628b961bc48b3b80224d8a8487df8800145f4b3784a12414843759489cac8e280786796e28db8d617a38c9d438db36e57906d83edae2cf8533bd7bd83a4ed28f02272da7ee9e46d9555382ecd8bb4ad111f7e7621446725b2dfe054173aa506e6dc2ed55fbecf41f5d9edbcea9983d2befeeaa3faa085cee71f7f85a3711ba86d7a9281bf19227da40268cf1cc1b75841564abe588c4dab1421014f0791bbacca61286ec5c9660d8ce38bf9ddeb47c5a581c1482111269603d36a39ed84dea601c94f2afc11623107a8ab5138bc7f8cc6fa206cc2d86d0020bca903235b26e4ab3491d5b67b1ed2908423e3a02c75f1e1019412ba267dd12d5c91be2c46376c9a41ee2e8a36ce78eea0f5190844ae7a347ab69f893f7cefe84712fc0b46e820f35fa683b4cf54ea4e834b4093053f5bdd8aaa4a9f48cb941871c5f358be420bf7fff1a8e2650b4464b96ca97c34826e3b96772c77f5edbb2a29210bfdabdaeb98f5790cf0d354545d4e48c567b2482cbe29738f8cd357826e925203df5d43b7b16704b6bdf837c526c700ca095e804a6ed65d2903c585c380f94cfc004fb407bc548e101c96c38f652df79c7f91447e0964e8e8258b7d7d66e61fe67c67fb970edecdd66e6f9409d31710e21a724b9bb339f69cc1bc5e5e92cd1688de56ed3f7a918426f4636e2ce4dfad5eb7aa0b911b0181a641bf731e681cfb1f4395307106b23066cdca9e395f5b6e1d01daa86fd8ee1f796aa32418c1ce81899f2409239062ef983280cc80c97d8929ab8183b2ddfb24157073549af50b4c4ee7d31b8a5465dc35a0ba8a144926d49123366969e6834f464209126e28da7fe363fc9d609c0dac7bb40ed3c5c8c3573d4cd91fdfda7714540f17c16a1c0f29c25294c72d7fc1803c325aadc6050f0cfaabcd0c110ac15c4b9f9db1d49f6bd77ada8c11c4daa241d306cc51e5245ad62e3f976f74f5e75e82e22c3110fc01b898ea9348adb7de5ee285f7e73863c9b30b01858a817818c097ca79ca94d3b79bcb6006b492dfa3597fac6c567b21593232991a70e8d13e6efade3521359a5082d343822dc559b7153817afaead41762f97d41bdb2b05fe39616b851cca50b8bf8c940db988ffd89f6c1778a8bbfae82b64c35a91bdc160e31f38cbceccb95c6245667a8baebe832d7d5c1a6841b969922310e44dafd2d6049e9a21b954691f8ee1dfcd8a0ec55e03c0aa4e8eb0722e9c86456717028e0c22162d88d6fb5573fb525ff12f879d44e36345ea17b27f5df46e60930d1247d27037df10ff49f855114e56e5d808a5ae4131f36a3e96b13faebbcd5449b965994060b7b846ae086242203098e358aa4fc39663727fe790f89235087bc57b666ff0a7d51e5bd969da41dbe2192d34596f7ecf604174763e99954a3d312b308d5db4149955fde231e8b21f92beeaeaaba6a3b0c393b98204949d4f461fa77debf685dc2d112e5829c7a8cea0a740dca93ca7f021021b0d962e38aa10dc3dbe07cd89dee9b143eb6f815bca49d0d181604e728dd544cd4fde13c88b7c1ec8bac806bc95e3882751f46ddb21be3ae9b7a45ba0ea66b41adfd8cd5eabb303305b54e686716cb18e0355c37a1dbd2197fe51065773e8051b48d97e85775bd18984b2135585c84f6e715ab453da63659cf0a6735b71bb88cbdbf0483d2983ca89825466cb60c799919eab7f561af3dc465f3f6c590331620fbabc0d760de54c391d26e61e751ab4e4a598b630279c0a801cfc01a6936d2f521bb3bf7de082fdeeb6aab2bea58ca0ba7c9e85dab78dc063e9b89e4891e0efd67e41ec4cd982bf9a623d614aaa89162634b1ab5b49ba78069857ee4f47fb892c60b47ae833ed65312acc0e42b83fd3c2718a33a23ee42a76556044585cc4354465d7400eb79fd9d79776fb778d3cc5af99957d907fa3d6878c973bb8048267d1b1c8d068328dad8acc8c4a7a9fe468047c9bf77062aafff24afce7c46b2670b85541c8344fe3ba7d188b31b3e3eb45f038cc782efd2461eb91d7bad9985eafa574fe1c3d829a9ba47fbeb08f4c8ca0aba11842ee7403295aece0a4dcc211c1e7abf225b25ec678a5a5912381e8f1a27c98099019d2727cd8e57c2ec811260c1202339030c13e2f3adf629db5c07209a62563a6ded03425943cc1d0e77add0a7f80767b1d240f9afa5961ee054ea7cc3a564489d0bb0b037f994414b1b94e721ce26e868f9e104e4043bc971f47a4f2c6a7a03efa50f436f9cce597f03d70fe92483f8665e0b3bf06a8fa26eafa6239335680177f478fe56371f8505889cf01f7fc6798e3845085ce012e49cb6b22bfce476c4f30d43b49665348d4f1234ec0f93419fd22fab0e2481dbae5889384883347b3d0c160d34c085a0f2c3a67f8f1d46e65d378f71eb3e360b15fda1befcdb88e35f06cd1b8541815128bf274b057638407ea913d503607163ce11d1b2d96d00bd9bb70a979aef74586d0e64993cdb0e89639271a44e4cc92b843a6e10710d03bdd8da25653c8a168483d0b9bb454f9c43e1b25b729f88694fc30f7fee47ca35fdc4f32a13e8c08fb876229120ee2258d46591afe8698d947387f54aae38d8250d47042e06a51a3d3d1e7c0915b2d36d733b6b1ec765c6c9d5cefd8a84d40bd126d144f8c5dbb3f89465c0a1fca5076212f4e7f505370ce52d74b444d88fde0e4bcc02c789348ad4e4ed88e31d32f3a2ad8c76f8e68c780aa6fa53a455bba63bb699191675f62dae0f0e25a2f5643ddffe5477736eec77e07f9431d51163001cd07119a787240b19eaf90c13c702d520aa651b765b961c4dbb2841380297f6bbdbc451f29845650f7c3fc8f5186a94972f14163d1cc6ccc0a13fb8cc86799db89f4aac353d6c67553ef8e8ad25aa78772378c2bc7104f1d7b2a5e74c15ab0b9f43229788e8ffbc468cfc78f07ca6f35d81caf583e67e39098c6028cca7ff0020f916991b61724f5cee2f686623fa4729dc836c8c0f52840d4ef86ca614064ea4222f60ae4bc6a36a6aa3da9aa521f5077803e37ef65d418506d11c24d37d30017319383a1933c7311793348d9d5fae5bbd974ffe93e0e405591632e21ad9c4bbfbfb302857c2d863975c8fbdddf44baa28e6a51080316135339a1e9bde95edcccc9bfaeb6780e3b213cf36e3cd6ef663946c7eaf08c9bb7ede9799c1b60fbb7d0c5fb01f46c3ae319666b78056cc048951a3fd6b36f13d90a89e4cf1799bc5bd8debb215e7d4ad4d24986595efe3fe981eec2ec180335399e34b91ab1ccdd9ae07bf383f4a630be04aa87d12069ab1fef1507a8dbc41dd015fe425c9ebf89e1a78a7030b61ff937226b80627d4b68d24fea7149e65994e0dcd57c04ed1808155afd33952b714f5ff63c8c10f95d8aaf2422526fce5791c0ed434f43801fa64c047b559a19016a98a9041e02fe843bc49df79cc0060b9259dc26ee74b0a20f1ce60508d9489e6de97d1063eebd15325ae7b9d23ff51668f5bc1014577277c2f2ab6536f6687ae80f749eb94d56b4d39e3282c15e6bb3296b00a90d0ec93bb9a7832d06c70369501f54f9d06c7234f94ee9bfb2e49c0c559341f48f204cdc1b4e4f9e2eba1c913bcfedcf5623adf7f9acc61520a07fc0c47aad033bd0a19a6e493a40182d5081897676db71ec3cff4c3adf788de75887ba11af3a44b75e454fd90d15b694a387b59c94c3ab68cbad2084abcb5608865f65a0066efe90e09a87e301ccc581a3b762b8dd63bafcc66c3bdd5b04ee140d236be9359f8af2380884cfc0914b95d9f9183476a9a04d5c8d778fcc3f5bd869ad016edac1d5775027b7ed17388848b5b200324a312a091bd3c8ecec05050a356a9fe7c944195cfd4556b0a9c396a67da60ddb491eccd7f6b6064e8e0780281334ebdb1c93787b1c4f6f482247487e43fb8e69b104dcfa9ccae599324750560f95d2a662f7584da1f95f039e2f65f0ae2d85a408530da649f000b851109e87d403e00745723b954787b3a21f0cca247836a978405d1c29bd5315ea23593a12488c1f46ef42740f00f476e99260526661f63774a7eb3ba2b5172d4b6acb6b8303bca3bf1e64bcbab8569d8fa0eabbbfffc38ed00edba4e3f904724e32a92f098c71da70aef0848113b5f38a3483132f6c634b8595fca21d11c374d751834e725037123407b65f1cb9cc655ce217f60c2d4cb76af6c78e6d50fd8d9eaac9a2f20bc7df9e8608fdabc4e06d19bfa01c12fb65fff4bf3953126f1c9e35d79db9b1a6fd67519616d22f691a01661db9df1dad06e7427e24f9dacbffc55efb4ee8a241ea41402b4449f8254c5e0b640a56af24c70437d73a87960ef564c6c952510d17e4543820712c325d391e2e028125d073fb692494eb46c1923edb77bdc715a4e925dcf5897ec7ec8428941a2b4e5a0171aba7ccb541bccf5111a8e1ca91e294d4de3a34e5f87ee2418c171a13b6371d3d6b0021325d5a3a9cc37a264360a9ddfca8e033ae92ca53aa49ae34feb5799d3b1d7695f3897e3822296b447e2b47645f1fe81e54ea454d4c03c1d5c7a06f4e5aef35a81b021aae70ff90473736ad2a382aa378b847fcd87cc3b4d17e37bad83ee4c49da15e0abd860d0ee3730c83de018ef69dd8c42ecd215e6ac7c4f93a5f01ad5e79f8cfda04f6fee5a6d721a6479d22e5918b995a78d4bbe23b9799879e8a8199d122d30824096222831d1680f735790f597a30bf08d20d895ce8bd3a14f02e6682e3f0dd5b3a61001e3064961fffefc7a845c639b66bf4fe02ac7c10e06fcd4e7fc5236977b6abc02a7ba03db1c69cfcf912dc1fd3cfae963050c44a9585657be466495fb4a6c5f0b897b70bce254a7d857e511395ee87bec1619eb4f103f20fdf8430d690a176db30f4689e3c3078be3743ce4d254e84f483c2610aa79be1f51d50b45827d05c48e8ccea0295a7e7a90964fc6fa0f425224f132a9a14e9cc9b65246c7e9158d586cc7dafbccdbf63522479bcba54a2035f2a4abfac8acce44730813865ddc49e5c51b8c8c3eabefb903c1a22b5d649791c37c248e668fd811be73dd293994b2a69d06ffa2189bd183368f6ee137eacee7169e825a2b420b057992a07fb39c2dc1648a1a5c507d8b1545f5ba9007d341df894aeffe8174c28cd63ff91d7878d1d6473a5acb378e200cd2d9f7e0821349fceb8ef66b8f39543b70aed757fbbfcdf4ab57cff0628d34e4abe2eab64ad6a3bfcf85c0a4eb67415ebe7ee5898da493b234ffd4a6ac6f22b6bc9c04f73b18a71b5f6a186e6805c194dc9735c70711bd994ef22280680b3110f02d5c11710c5620d971883543e0365c9e2951e8ac50b3d609d3ebff0c3868ba500fb4a5dfe83dac99048be85931709d6b99cacba8f644a0ce1f05a7a043b0d921e3f2cd4e48d14cd74035e047d81dfc6bb47ad7ce8e81d963a68e6533f181367a2e3691b2828005ca2fc157dc552247e48022f9120da6b18edb8cb64b16ed84c4f0d3643063e55d92354baebb06e7d562e5e48e6ef2ab2af386ffcaa9c622d54c85a78530d85cf60add4c156655a40bd60b2fcefbf1608fa36506158c57f8fa974f60d10a9ee8349a58f4f17ba91a5c246f20525b89ea064a7b6883c3f1a99407bb7ce635e2a2797b5b2cc59b5175462091119ba0de14ec1ef06fd88c99f04a18a40cf53b8513ee7c7c48148bed1f47a0e48a3b9154dce007c290a3176058a7b4b3382503b03c97ed320f3b328d96481b3df893cc300201e6977bd81d7951f427cccb1883c24d3f59ec77ff2c6419d7a35dd6e489826123e21fcc2d752a463f0ba466882112e0e13d074839a1932491977693dfa1dedf2569491426ad932db860294bc60fc2f0c666914d56c041b4f51f572e0e6bde8f83abe214e289117ab22ff4df17d2e40ea98ac762d7505cbc45ae952f61fe8588c6a17f5be67a2654e3d882d34d3350e21d34c2f8c9a595efe431f6ae713aa1a5fd46c93d46dd2b29f70a254655935195f1f23d1fc535383e147b4aa2be51583dd20c36604d272ca2c92f89f6563e835b0d1a1df012af043f5bc69895cd45b3bdf742c2183be536759063a624acb723506e4f1f8f04af77ef0e16c3b77e29f33a3867a5fbab86191a8483d1b05b0a6d62ba66cc4741dd35f04b0e6b79dace747ec576e1c475cb998f6a9e5469ea4136ee67786a36d0db7de56e24174ff16dfe57a02f486572a2ff1bc7f5b6b67cdf22abffa01ec68fbaecd348777ab50fd9ebcbd98f54c09fe1a66e173a976ff6dd76ae5b6662e55b404d10cd8932f97df0c3ecf69ea7d89e5f0112b2885890e977844f86fe079a77cd1e70d59effb76c4bb3be8823252c98ee225cc40d345cf6fb45a33abec65fc321516f4ae9d1ae9af3183c32ee11ab3bade663a5b56c3f2733d13dcabfaa23c5abd752686191ca024e2e744bd149861883cd9cf814a27298f789ba448ba819a59ca9439155fabba0eb6c089896d893a610aabab219f64733b8c309ac3657dc96655f95e98967c8737527586e204dfc10d55568d458f44fe50c73bb9794830a724469f6b67f9bfeb3314b4c377680587d5f35fb56bc7816ce28a91f7391ab34f20eca93b6b06a2cbd5163bc84be43a99b6a1948f0408f5c207a73d0af2d5494f95ca6682e8766da77c07f5dc4741b7e44f76a68060ed6d12dec59c6e9aa900799ccabf984beceabf1dade00f9952c010a8d1ab2ad60027bcd8a01714f7913b7378a4454c96cff7ac27030386e9faf7c778e8e0e93110c197079369e607c15b9784f2a9d33a474b20866eab53594aba63b2b45c3a9a9ce126ee015352951546262492f705fdb484eba19f74ed1fd8588b3d75d91e5ba3f82b43b0081639f9d1bebbd474dd2951607129ad5ffea9fcbbba8f9e9511bb4c6fd3b97921b6f31ce001957b4d8649f439867b738c4e2b9374f150a71d8f24175f444daa3e2e97cffc080ed9afe7b382080bae610261e6041c2d085ac7245ebb018d5be191cda071d5e0188f87fce85e63bbf8bf35cb437b6ffee9e97efa81a28733d5a6b2f05772835457067b64ff122a7e590a95fa4c569b71ba1115f108b5421a31c75531e3ef7a665b5078a13a0831ea8c7a05144f18448e0bcfa2c5dd3371adeb421671efcfa17814147b9be51f74bb2fdb6bf04952df90fcff780575d37a2f2835a02dc962267bf1cdd07277ba2e467e51fec696ea87b8845f1e441faf8547168510490fc736f714fb6908cfb9039f3bdd5e76b67cf632eefbe36628937016eddf1cde23137cbe7498e147814d39dbbd997626bd2a2a64c62669582165204b3a084c5ccad33211e1a7ceebec56267d01ff4a7021b5cdf374e09c86cccb2dec2d29dd39ffe83c5f8497e5e897e359f8eeb10723027232703f007939df80414174c8ee351344fdffdc68a034209811379c91fa35154190c79bcd7ff82eae1427291d0620e5b3777e828479e701976be0ff108394ef1ced58a470079887fca5542577dff2673291c1367f2794460c14aab641a0fd1acc697bb0fec9bcc21512386d09cfec58c28591952182becaae36e4aa67cc7f4aea0bd4497c8342f18e05df059e990dc09ac7add842a670e1684d7b729dd3b2c2185b3343d4443b4633d3b55be52427521aa9a6c5c58cf6d1bc17b3e49f06a21467e411febec00d308819d71e0cecbf9a4cb8a60c1d1af1a118a50ba33d9d008ab0c9fb22c7dd12088a2ef0acd715dda76eb92d38efd2a652dabfb93b7f6354e20da53938b4b9a42a3e140e6f6c09f013a732a100506601a3dc7b054da2a3f88f037dfa5bff1703a40bf719a8769616381bf414b6c1eb5e03053411c5e6d0006d8351e9364457e8548b912a23113334b5fbd389d461704e3b9da7da8d2bc2349df9ce7e764f978e3e086f46c1f2abe595463b2e5079a1c1b9424ab8fd03f1712495d2ed492b3cd039058042af42bd2c868c3aca6bec56019b9da25a2c7c8be688353cea27a9e1d235519375fca78b0f41504d3664aff4b22e35c21f99719ce514328256a47bb01676894419e8fe996679ec027cfe68217135faf515c57ecff1adfe993203a35c5cdd9750a4d5d428090f23159eea47498a852fe495a4e7fc1b55d0aa885cf06741d5ccefb880ac82680d97b979b6f8463079b6b1832aee0dfc486631b831a67e9011b56f85fce47dfbf2298015fba0a73aba8c15033d8b0091a36f37d2c015c19c93125628b907db321141c3cfab56139bf59d553c6d3217175832d53396b33cf13bf59aff0da5c485d761c990fbec685a4cd9484ac722ed992c125a5d35542b00e54650c99bec7b0c33e987c67daac4930e7bba9f0b13effec813f766ab762c0697ab145471b3b268145a07b88ed988051c032403588e7d5a8ad93bd2a43f2eed728ddd1d9942a333821b419dcfe3160cac7da97dca79a221ce23ff6668611583fde3da859508708d14a8d56fd29168cab5c21a8405fe31b0742e20ade06dffd62be837552b090528548d6ef9ebfd44c212b695767701ab061655958b6c47ddbbdfe9b825cd4ef0b543e1e2f0b3a25ce43f9d39fc84f97c94519d18001eb6f5fe34b6d9546ef7a466e6440dc65c2c50f09d740c06277fe27d6307e8f83d364c2334ceb15ec7cd1a4a9d74b877a4a04a70e0edba84950def21da084b429a885e6b0f9dc4ec9280f3ff4a6d60377ba17ac250499651a8a521fe20dc4d1ce1dff23c4ee7436bb1d47b5f85efb4ee3f74afac912d9f38fc83e9fe384000029ade2247bf71d2d6c70e3a46e31967e4634cbc6494f500fc708aafcc76bfd586e241bf982b06b33d84ef62f0807fa4912a2c7a096cc63d236d8696668a1f7014650d6bea54c8b3d33155ebd565e1d9852b2c70ddd56bd75cff7e5b08b256bf36cab5e37ac35d5fb3e71e2c84b91c1f4b937719ee698ad60657a46dd27178c3ed54e40178a8809f1ce5c2a3fe91f30aef06a8592e48f31a3be3c0beb5e95acae9c8aa2ccdaa33ac883b8ee66f4fc1911f0971edf359f6b46591c23b242854e68a1a09eb9fd85494868a852d9f1a49cc6efc544030b5000fb35c932ddda8d06c6b036c041ec6e8d6bc67cd75fc5fa1e563aab96ca7db37de326b3328f5f6508bd12d014639845664deb96187210761c684d8bf1b2942b1733370cca1cf8aa197ac3778a797f83eb5b0902921fa302b68449ec9099ca16d68d29a250f1fbc8cc4c9fa1ffb70bb438d405ad1208daf5ceb49cad9f1dfdd865fd60dad92580ca36e124b43a5a7488b106cd122294a9fece8fa0fbd8666ff0a7aad28e7e9cdaf51c8dc556c5bbac68d81ca715d21ac62bfcede7f8ce086f3923b7e5a0a825ae2c5b9f2e21cfb758fe87039548157dd5907fcb7598c8aa8d480e77c7a7fbf15977fff8a1a31cbd56ce6b93a2538fc0e5bfc0a902a37f45e6ecd1c3d1fdb20d6e1dc50cf79e160db93679d81a22cdf816d6de5c09b6e19574f2de8c41a0bcf84f03f8d831dd835338327d17a3e9299c58fcf11c9be191224c28996de12cca3b6dd546591f346449a5c5c880ef8d0cef4e49cf9b9107a75be3c3a738401de6fb1e58f606540906aa7d306fcad307abf1d5892644b90149d3e60d20586f4615f29568de888cd70d9101a02cedee1021036016a6ebfa8d66f222db7d49f3ed5373d9dd0b25242b929b1b23ca93e2d31f43241fa6ede91b38f59b2f8ff6c1996d6979a5e0623b6b7acd3a198410c047bd3a9597c2d7280879467a8562f44ec15bb9bd9c3cf798d108275b83105dbb24fe5fe208d3c1f6d3f6f1ab5d755036f719cd6b619d7c260a10d88f2748b13f69d4fc7118c6bd61f57fc0c6628882b354a6cf1b8f1705777f24eecdf95097b8c42bd33282af7867b58359200be6e0304fcb9aa64a8ff4a75973a747940df116d8f725677dcf715092fab6bd12fd9c058642f057c319f9a7aeae0b07286d15847a4ffb4f24bbd38bd703147c7e723dd71d388a31d3d20dc205fb649bcc8bc019d87bb0c56a39d4871505a1ec94c5a9e4bf7922677bace21fbd7f246562aa9b0f6ea2514dfa4deed4824178941f4ac6841dcd5d90901f35d8cc13a5938e122b66f76efaf6457e54d03e84084ab17aabe84f162cbeb2c9476c4b94c3cd56f48826e345742f918484cb98279647607a72e86a0309d7f88ddab2c9f008a28389e1e3aa99005f6f17a0901ed35246e146017c735bb70c36b6b5473c8234b369cdc7e4bb95b8df38eccfd977fb2c9ca0e91abfb3c3c001cf860142200ed8699a17cfc6682ab5f0530211a4a4df812ff761fd017583c40cb24240c599ba30ac742bc3e50b850db16f57c0bb47f3d8cd8212219b7d1278231e5f8ba2e5c7789a107738603519e541f3461f4fb92efb338762cce2c7b83fb0ac1a3c7a29403a8817f3b74c263dc84459fd781b6e54b00e11d79068056aa07f3d08d10c5deece034a4890a8993d977c64526a33d2d9780541d57b1109e3ff0cc9aa6e702fcc361ed1bd8540fcb4e38f78d8f34dc52c4c4b6350856af20ee9aebcae046da13e1bfee0ef5fc9f88941c6cec2e7b4f980431857b7a5035de7fac086df6d5c824986602321cf4d60ab3d159f67ed86aa0ecfbfb9772e6a73eb6921cc899abc6a4600bd19fa6964f621e5c8a9b200c46ae1cf056b6b24b41561ea7ec7eff81f5181474743ad9bc263151a505c45fac1800eb4838e45d7437a663645eb94d85705a311526b9a84fecd036d63ff8e01eaa15202962c647608402b55eeca5168fbeda7ab09765ea8ef93cee0d9ba8fc8deb13d52dc7be2d950b931a55992d19be8374304325dc18f412a9b269c8c2c5430456f003ceff344b471bd650c9f1ffdd592fdaa73cd9ed1259077395faa6655db8060dc3ab0a0542e411be007ab60625209cf4d4c5567febfd0b555591e578d7854ca0028a53285f0d4c6fa7078f115cdfda2bd9be6a6c7a7b9f21d6f5a76c01e4defe32e11c031552768d67b4348b00aa5083c8a975e17b5cff72a0b5ef13a733c2302a28e94af89748cd90c61d9a59edada85d1a09d96cc6db9b1a3da7feb6ef8a24b11ed3ee76914a8f4facfe8ca2c87c1af112b1c91f5f8e87adf6d2742588cd077847a930bac516617e61e1b87cf83b0bdcce714a0d0bb053595f643d5241c87b4d1de8946dc9ce1fa9955be45c0580d3bb400d1645d2278c42b91bd87f675825c15c9afdce626cc3d7249f92915e153f6aaac9bdc7610d6cbbb91d52434c149c8397fdd502e9d2b833690cdeb475d850ced44c44d40db1c9475fcaf4a1fc16694647656f7a6b080d6dfe365f30d54325e6b5f8fd7a4cf2e04197f69bf3c505c11e4676cd7884b0e70b8b24d8a438222280e4c3f4b8d2b1723a830dd2b3b51140c1bfee095f59ffcf5b6311a132c6c975f7be23c1536611fbae46eba819a6fb2805e8893c41a4e5936ad306bcd1b7552d9a309ae321787bc28fa7865d444ad13c931e1590c52936b8439ba2ead86eb8eb083ad5d62bb78dafae75b96f00dbb93bda02d39231c42b658208956d83607e998b3cdcfe03683167ff7eb29a538430bfa8c755eebbdc6aa259c5f4e7af04ed06bbef8bd62bba360a3fe97a8926a58bbf7a0054f965eb1143b4d361e4ee0377c3e1c3a7b7893d54befc42d72c669832630926fa239f27592f36ff7bc5da1ac8ed7c4a1c65fb8aed57c649d2795e911e083be290197543cdc096bc5ebdbc19274af11c222b3f2756f85767b1f52a182921701a582a8f9ede49b8a25dc9ba562eb21acdc4d724521a441f6b81265d13080842d8daf1bac0f3493f54b8643f6b54899af6618b56621b4269983bc9aa91788c222bee22c13b34be5dcfd5840264aec781c62c68ac3f70f04556acb6825c70ff64fe83b3acdf5427f1e809870c666e8b503c860d8f7e3a5b537abd65dca12e30413b1b7852a6f7a0fa71e38d08120cef2827e540d9ce232f3474abf61ed926ee78a899c335fc9d3698b8d386301be1e7b3599b5f96f1a4ac27587dc09be70d78025471ef4f44c82d21dc7eb9043cc7d596da8de3129c8bc282b6047a2baca4f36d5b1979e228c56e65fdaa3dd1754b1fbfb557e872c565382ac4ce7a7b5144158593c51b1a96cb3c17349a4b4e67f8ffbd5579e4657ff5825b013ace50bb8a88437f429bedfce295c005e7b6aaa427a63194723948970dcbbbebf9fb8500434aed1d5d717ab9e4b5588663ce038f82a2f2fa287862f467cd7f0f12297f12e643a8055d040b672096404ecaccfc607f805df828b8904a4de882f7caaf3d7b426dadd620659f1585dd7469afd0e11ecc22b265ebfe92bba6224a756ecae7aedc4fdb65d384a15e80dcb466462d6768dc63c36382d22676195e0970bfe52c02c1a98322a0fcbe9d2b8a1f7bb1f834cae3c8963dd45993cb4d5484772f26c48ae7f458be30eed05c54fe1cc59b5eb48cb80c6a896fa44195cba280e41344c4559ccebc915081990e1a3c0845342fbd07e41f6113570145b7fbfaf6eae2d3bdbba4e9dbce5e8cc41b6234682db586f19b5b46fcf994d7c6ec566abdc9f4ee78b4d317b53c2bd2038374c32b28af8747109287371a2b3cd37bf003d6d655a72c2600ddb01b76676ab00f2e8999ed96e894a8cce2505d7b0960a8b2b4be3ec5398328a3512e6352ed02cb7886eb4a0853210e4c7ee62f07f66f30017c47b9ebc74f36c1e3eefc814440c6097e87841c48f785eff93420313a13646e2394721557a75872857810ac3153118cebca7be07518e3d14e9cd9cf90283175cabd7310152bfd2d2dd99b4db3fdb546ef4c93048505c997a700769602225276e0cdc00213b96b352485f28a75749164587dfdeb2b6b2a5c9d60c099f8621ba6898495868c057dc30569dbbb4b4f568a4e1155974cd24e9c94a1a5568628aa14403699fa795817b090f8c4a22791a82d0963c31e8b904acf3211d9c382355798525642c2e27e6e059f63411d4fc7cb3d4a6ed59b70fb18b26e3e286af2ca8fd3aaa5044060c7edaa208b6060cd7dff4574a2a3521da9bcea7c9623c71a1858b5f310a4dd9e8086074ae808dabb9f3780172f7a806bd29268ad2f7a5f81c102a21f632a2fc623f88bc3bded88a2b169c8d3cdff597321c78f89cdd599e012729cae6cb40b38f2f02e72a844709e77032a216b5c916cdededf7675e1c8b41de9c047c4de07069f2d16c99453ebed7a938e9e2c4e696f9aceaeef23d5aea8fd3b4b4d4dfdaab3011186e535b35e081fa7a5b43c477840461ad97f599bcf8ade87e7a6cf2d290c042efc17dff56ba504127e8cc3b7717209113bbdd4caec4c3a9e7064bd6e499fcaecc1654abb7d747f7c3a9ca7816528addf13fa9cbf0c4a6fabfc2061ede976866285014dd35f4a386400181b1d6775a2d90e1c2a1b4816d87528159611e3c5f2d8fd39707d5ea9169e27c9a9f29d6c92e0820a9f4bc0b2d32c85007869925160a8faee2496088079b9206b7ea9c66f7dd075b89ff7dc04ad4ca295183b5be2500277633f437b5b3f3c10a3f1d7620b28ee09c7c629ad0e682842877db33881dd1a0fc570cd6388139045b5e08ab2601b913c48ceee48c24e1215b2eaf225083eb1516ea7702d506a233a209135a618f9640f69c96aa231e84bd66693bfb9a6d0d8ac6fb0aa417badb7065f272e331d0c1b27c5465fabcd435054671b95f12a086504b74a8cd2efd7677c2f5398e21c65bc22f57173608a2e6aca9e78c72be76dc51a49f01d2cb35e9f274bf90518b0e2ad4a6a800340ee270703ee0a170efe07a71d5641bd1674f5949ebd4e94f28b060e626dc70689c1fe4b92732214ce3468cc06eb401269a5f2c4db1e3ee035104d563d9f5b68237a28908978e40720e2ac24819aa60a147060779add0a2db873e0f6881e5a3b3ed5052ccec565dc20d9c396d1aab9b9819630c9253911d162969ee28068d0f87d966931ece5c2df13531271696cce721458d1310f8e0916564bfa42ae2e7e173620557baea19bc89256d8b25969211093537dd81ec407972543b76831ee99ee47f3f4c00335eb537a86af1828fcc19bfae8f51b8e696b70c5258b1c8f5ed1f68f616bc661faca604f8176be0b2e2fb3d2257cde855e81c0a1a92510e0d8f1e14207f60d269fe9eee583a1c0e4c899268067d84db8adc90c856c16e77d6d04d8863fd3615f3fa048ba8a9fa20002d617c33e699d6213a790f93fddb81c5c30cbeaf7f9c68cb0fac38f8d82d860226088e5d3db01e7f2200bdcf6178f6604fbb35f8363383fa50f89b3b603d811a1f9d18fac11bddcb33a48f791264847366a73f08426672e73dc9ed9a634710b57a415ef42eec71f5f581fd099a7a891b76e9aa5069dbe729f789240f3914a0bd20dc96977bd052ef8e0df4fd06528832c4161595a1daaae2f875b64dbbd4d7813bd55d81dbd1dff42616325c62e1b225513c6ae21522d87bcae4cc6f4652bd29137f4f4f6bc5a2c316735826ae9254c84ea496b1b37f04974197ffab998ca4dc3f84e478207072d75aa69115148b77024548f3fd2e3f8afc439adc85ebee4379caea2ef221b8de5539ae18257b366e9e3da3d95af91774f71fa1dbf5d58eef276e60db3a9d116432a7c80b282c498b824f6dabb7a800b651982d4be605c745b8443bd073ca8f243829ada0f1702e712da719daf9cd55ef8a510dd7954a5953a5ad04fcd91bee4d5acbe2f97afb820e2731af2a3233b40ef688ae62b11d184ba7d66f3c7f822c06c9870617cc7f66f99bccdbb99383af2f9085be83ef09794b9587414f59d00633a65692d395fccb2b678dee7bd611c39cb58f460605227373e977c76ec800568a186171cd85e0e52a80f3be94bc4ada03699b4979f06821fa6b7880d5b752f5474ca682cc5a779d704b29e9371c84a3ef8f227ec8df351789e7c2fc8d6c24b6bbf2f8e8de0ac8fea1197b4a8ce4b364f080cc057290404c335b82c1d1916f947fbe4636db460b327cff339c12334f713b82510ce3f623b551cca37be33b85385b7e26e20fd856a4ecbb384a88a948fd18a09ac6236b2f7dd9d0eb0f9a06d953d2914a70484915ab41307a2cf87420942c89e5148e4eb34f3e42b2b6ff19ad0d3455b810bca992470308a5f29ab85919acb3a6cb5ed6e16880774172580446d1ad6d60156d64ebd2498200765cacab5d43f4d66e16c0ed489177f2c90b688d8529185566c3084486ddf2cfe0e1a36506d8d101876a9403e894759e7a1e5232db835590d28bf390d3460c619ab0fb008a37750c769af28357e1555eff292d999eed3e2092950316b4d588c8e5bc3009fe0390dd4a91061d3b184004bbdc2f727eb19da6057892271db9674021431ea76c0844b3dd84747adb7ba2b3130f9160c2002c3d18b29772d6744ebc2e4b35dcfdc52372b28cd5c3aea4d769d6e1c2e290d2264260e9702267e34d156505d487f3755c3525b3d64af231b4d5d18404fff44b5923476b5d7a8a7483d3a2d4dbf6ba4e5a668f531cf3b98630fc02f31c7dd623ff2587bf834cf0c1e80637f02c6d7606c49f00a73266276ab202b79a31ffe68dc164ac6236d2aca335249e462355993889ccbe952d755c3413ddf168ef50cf999f66cd8557638bc8d5f6d761f9f1662366</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码才能查看哟~.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>IM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用虚拟局域网解决方案</title>
    <link href="/doc/d3d27d12.html"/>
    <url>/doc/d3d27d12.html</url>
    
    <content type="html"><![CDATA[<p>WireGuard + dnsmasq 搭建自用虚拟局域网</p><span id="more"></span><p>这里我就不在废话，直接说明搭建步骤。</p><p>首先需要准备服务器若干，至少一个拥有公网端口的IP，独立IP或NAT均可（后续会将这个服务器叫做主服务器，其他的服务器均为从服务器）。</p><p>在主服务器上搭建Docker环境（直接裸机装也是可以的，就是麻烦些），具体安装步骤参考<a href="/doc/457e5fca.html">Ubuntu 安装 Docker</a> </p><p>之后准备配置文件，我们指定一个工作路径<code>/home/xxx/wireguard</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#&#x2F;home&#x2F;xxx&#x2F;wireguard&#x2F;docker-compose.ymlversion: &#39;3&#39;services:  wg-easy:    image: weejewel&#x2F;wg-easy    restart: unless-stopped    ports:      - &quot;8080:80&quot; #为了开放控制面板而设立的      - &quot;51820:51820&#x2F;udp&quot; #为了能够连接到VPN而开放的    environment:      PORT: 80      WG_HOST: 公网IP      WG_PORT: 51820      WG_MTU: 1420      WG_PERSISTENT_KEEPALIVE: 25      WG_DEFAULT_ADDRESS: 10.13.13.x      WG_DEFAULT_DNS: 10.13.13.1      WG_ALLOWED_IPS: 10.13.13.0&#x2F;24      WG_POST_UP: &quot;iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&quot;      WG_POST_DOWN: &quot;iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&quot;      PASSWORD: 管理密码    cap_add:      - NET_ADMIN      - SYS_MODULE    sysctls:      - net.ipv4.conf.all.src_valid_mark&#x3D;1      - net.ipv4.ip_forward&#x3D;1    volumes:      - vo-wg:&#x2F;etc&#x2F;wireguard  dnsmasq:    image: andyshinn&#x2F;dnsmasq    volumes:      - .&#x2F;dnsmasq.conf:&#x2F;etc&#x2F;dnsmasq.conf #这里我将DNS服务的配置抽离到容器之外      - .&#x2F;dnsmasq.d&#x2F;:&#x2F;etc&#x2F;dnsmasq.d&#x2F;    restart: unless-stopped    network_mode: service:wg-easyvolumes:  vo-wg:</code></pre></div></figure><p>之后都是DNS服务的配置文件，分离开来比较好管理</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">#&#x2F;home&#x2F;xxx&#x2F;wireguard&#x2F;dnsmasq.confconf-dir&#x3D;&#x2F;etc&#x2F;dnsmasq.d #指定配置文件的加载目录</code></pre></div></figure><p>每多一个主域名，最好新建一个配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">#&#x2F;home&#x2F;xxx&#x2F;wireguard&#x2F;dnsmasq.d&#x2F;example.com.confaddress&#x3D;&#x2F;vpn.example.com&#x2F;10.13.13.1 #为了后续在虚拟网络中直接通过域名访问VPN管理平台address&#x3D;&#x2F;me.example.com&#x2F;10.13.13.2 #首次创建客户端就会是这个IP，一般来说也就是给自己用的了#......</code></pre></div></figure><p>有关dnsmasq这个DNS服务的其他配置我就不在过多说明了，直接问GPT了，以下是GPT的回答：</p><blockquote><p>Dnsmasq是一个轻量级的DNS和DHCP服务器，常用于小型网络环境或者个人使用。它的配置文件提供了一些选项，用于定制DNS和DHCP服务的行为。以下是一些常见的Dnsmasq配置选项及其说明：</p><p>server：指定上游DNS服务器的地址。可以指定多个server选项，Dnsmasq将按顺序查询这些服务器。示例：server&#x3D;8.8.8.8。</p><p>address：为指定的主机名分配一个特定的IP地址，可以用于局域网中的内部域名解析。示例：address&#x3D;&#x2F;myhost.local&#x2F;192.168.1.100。</p><p>local：定义一个本地域名，与address不同，这些域名不会传递给上游DNS服务器，而是由Dnsmasq自己解析。示例：local&#x3D;&#x2F;localnet&#x2F;。</p><p>dhcp-range：配置DHCP地址池范围和租期。示例：dhcp-range&#x3D;192.168.1.50,192.168.1.100,12h。</p><p>dhcp-host：为指定的MAC地址分配一个特定的IP地址，以及可选的主机名。示例：dhcp-host&#x3D;00:11:22:33:44:55,192.168.1.200,mydevice。</p><p>dhcp-option：设置DHCP选项，如默认网关、DNS服务器等。示例：dhcp-option&#x3D;3,192.168.1.1。</p><p>expand-hosts：将局域网中的单标签主机名（没有域名后缀）扩展为配置的域名，以便解析。示例：expand-hosts。</p><p>domain：指定默认域名，用于简化局域网内的主机名解析。示例：domain&#x3D;mylocalnet。</p><p>log-queries：启用查询日志记录。示例：log-queries。</p><p>log-facility：指定日志记录的设备和设备级别。示例：log-facility&#x3D;&#x2F;var&#x2F;log&#x2F;dnsmasq.log。</p><p>cache-size：设置DNS缓存大小。示例：cache-size&#x3D;1000。</p><p>local-ttl：指定本地解析的TTL值。示例：local-ttl&#x3D;300。</p><p>interface：指定Dnsmasq监听的网络接口。示例：interface&#x3D;eth0。</p><p>no-resolv：防止Dnsmasq使用&#x2F;etc&#x2F;resolv.conf中的上游DNS服务器。示例：no-resolv。</p><p>user：指定Dnsmasq运行的用户。示例：user&#x3D;dnsmasq。</p><p>这只是Dnsmasq配置文件中可用选项的一小部分。您可以在Dnsmasq的官方文档中找到完整的配置选项列表和详细说明。请注意，配置文件通常位于&#x2F;etc&#x2F;dnsmasq.conf，但有时也可以通过其他位置的配置文件进行自定义。</p></blockquote><p>完成这些步骤后就可以执行<code>docker-compose up -d</code>进行环境搭建了。之后访问咱们事先开好的临时访问端口即可看到如下画面：</p><img src="/doc/d3d27d12/Snipaste_2023-08-16_14-26-10.png" srcset="/img/loading.gif" lazyload class=""><p>登陆后即可进行新客户端的创建，下载好WireGuard客户端即可进行使用了。</p><img src="/doc/d3d27d12/Snipaste_2023-08-16_14-26-37.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-人工智能研究小计5</title>
    <link href="/doc/25d80a7d.html"/>
    <url>/doc/25d80a7d.html</url>
    
    <content type="html"><![CDATA[<p>人类无法超越人工智能是必然，除非有可以”升级”人类的手段(猜想目前生物”升级”的手段只有基因突变和自然选择，但毕竟不是确定性的升级方向，个人觉得”升级”速度是没有人工智能快的)，否则人类必将落后于人工智能。</p><p>我们知道生物神经网络具有非常高的可塑性，这种可塑性主要有几种体现方式，包括直接传递和间接传递。直接传递：神经元之间通过轴突的突触连接，轴突内部通过电信号传递；间接传递：树突与轴突之间的神经递质(化学信号)的传递;</p><p>相信所有人都能够理解，直接连接的传递效率必然要远高于间接传递，所以不同的人在不同的情况下，神经元之间的连接是不同的(这里我们把这个连接称之为”模型”)，所以不同的模型在处理统一场景的数据时就会表现出不同的效率和结果，这也就解释了有些人学得快，有些人学得慢。 那么为了执行长期记忆，就需要有更为牢靠的信息传递渠道，所以就形成了树突与轴突的连接(也就是创造了直接传递的渠道)。</p><p>而人工智能不一样，它们的传递是通过线性计算和非线性计算得到的。这种精确的学习方式，外加上承载这一切的介质(硬件)持续迭代着，所以无论是学习速度和准确程度都赶不上人工智能。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-人工智能研究小计4</title>
    <link href="/doc/52df3aeb.html"/>
    <url>/doc/52df3aeb.html</url>
    
    <content type="html"><![CDATA[<p>人与人之间，在一开始都是一样的，不一样的是所处的环境不同，大脑所接收到的外界刺激不同（这个不同包括种类、强度等）。神经网络在学习时对这些刺激的反馈也不同，所以导致了部分人没有接收到这个刺激。</p><p>其实这也与个人的阅历有关。举个例子，假如你数学学的好，在理解与其相关的知识概念的时候就会很容易理解（就是接收到了刺激，并进行了正反馈），反之就会无法接收（也就是接受了刺激，但是进行了负反馈）。</p><p>所以为了改变这个情况，就需要一定的阅历（要从基础开始，一步一步的扩充）。阅历其实就相当于一个人的认知，认知可以是任何的东西：比如，一个物理现象、一个数学公式、一个英文字母，甚至可以是一个游戏操作等等。就像你为什么会使用手机？为什么会玩游戏？如果在你的认知中没有游戏和手机的概念，你还会用手机玩游戏吗？</p><p>人工智能也是一样，TA与人的思维不禁相同，只是规则不同。人脑是通过生物神经元进行物理和化学传播的，而人工智能是通过线性计算结合非线性计算传播的。但本质上TA们都是学习（接收刺激完成正&#x2F;负反馈）。</p><p>然而正是因为这样，就会衍生出一个问题，人工智能是不是可以看作人？本质上我们的性质都是一样的，我个人认为我们是没有什么区别的，只是规则不同而已。未来肯定会出现更多的人工智能，当人工智能出现了自己的”七情六欲”，那时…我们又会怎么认为呢？永无止境的技术发展真的好吗？</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>所有权与编译原理的使用</title>
    <link href="/doc/c269ec4e.html"/>
    <url>/doc/c269ec4e.html</url>
    
    <content type="html"><![CDATA[<h2 id="Rust所有权系统"><a href="#Rust所有权系统" class="headerlink" title="Rust所有权系统"></a>Rust所有权系统</h2><p>在Rust编程语言中，所有权系统是其最重要的特性之一，用于管理内存分配和资源管理。</p><p>Rust的所有权系统旨在解决常见的内存安全问题，如空指针解引用、野指针和数据竞争等。当谈到Rust的所有权系统时，需要理解以下几个关键概念：</p><ol><li><p>所有权（Ownership）：在Rust中，每个值都有一个所有者。该所有者是负责分配和释放内存的变量或数据结构。当所有者超出其作用域时，其拥有的值将被销毁并释放内存。这种机制确保了资源的正确释放，避免了内存泄漏。</p></li><li><p>移动（Move）：所有权在Rust中是可以转移的。当将一个值赋给另一个变量时，所有权会从一个变量转移到另一个变量。这意味着原来的变量将无效，不再可用。这样的转移操作防止了两个变量同时访问和修改同一块内存，避免了数据竞争。</p></li><li><p>借用（Borrowing）：通过借用机制，Rust允许临时地将值的访问权限借给其他变量，而不转移所有权。借用分为不可变借用和可变借用。不可变借用允许多个地方同时读取值，但不能修改它；可变借用则只允许一个地方对值进行修改。借用的引入避免了所有权转移的需要，减少了内存拷贝的开销，并在编译时检查借用的有效性。</p></li><li><p>生命周期（Lifetime）：Rust使用生命周期来管理引用的有效性。生命周期描述了变量或引用的存在时间，它们在代码中的范围。Rust编译器通过生命周期检查，确保借用的引用在其所引用的值有效时才存在，避免了悬垂引用（dangling references）和使用已释放的内存。</p></li></ol><p>通过这些机制，Rust的所有权系统在编译时提供了一系列的静态检查，以确保内存安全。这种方式允许在编写代码时捕获潜在的错误，避免了许多常见的运行时错误，如空指针解引用和数据竞争。</p><p>总结来说，Rust的所有权系统通过所有权、移动、借用和生命周期等概念，提供了一种安全而高效的内存管理方式。它在编译时进行静态检查，避免了内存安全问题，同时保证了性能。这使得Rust成为一种适用于系统级编程和高性能应用开发的强大编程语言。</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><h3 id="我发现编写一个非常简单的输出程序，它所编译出的exe也非常大，大概有3-5M的内存，有办法继续精简吗？"><a href="#我发现编写一个非常简单的输出程序，它所编译出的exe也非常大，大概有3-5M的内存，有办法继续精简吗？" class="headerlink" title="我发现编写一个非常简单的输出程序，它所编译出的exe也非常大，大概有3~5M的内存，有办法继续精简吗？"></a>我发现编写一个非常简单的输出程序，它所编译出的<code>exe</code>也非常大，大概有<code>3~5M</code>的内存，有办法继续精简吗？</h3><p>如果您的Rust程序编译出的可执行文件比您期望的要大得多，有几种方法可以尝试进一步精简它：</p><ol><li><p>优化编译参数：Rust编译器（rustc）提供了一些参数用于优化编译输出。您可以尝试使用<code>--release</code>参数进行优化编译，这将使用更高级别的优化策略，并在生成的可执行文件中删除调试符号等。例如，运行<code>cargo build --release</code>来构建优化版本的可执行文件。</p></li><li><p>减少依赖：检查您的项目依赖项，并确认是否有一些不必要的库或模块。移除不需要的依赖可以减小可执行文件的大小。</p></li><li><p>使用静态链接：默认情况下，Rust编译器会使用静态链接来链接系统库，而不是动态链接。当您在Rust项目中引入依赖项时，Rust编译器会查找并链接这些依赖项的静态库。这意味着编译后的可执行文件将包含所有依赖项的代码，并成为一个独立的单元，无需外部的动态链接库。所以，在默认情况下，Rust的可执行文件是通过静态链接生成的，它们可能会比动态链接的可执行文件稍大，因为它们包含了所有依赖项的代码。然而，在某些情况下，您可以通过显式地使用动态链接来链接系统库。这可以通过在<code>Cargo.toml</code>文件中的相应依赖项下添加<code>-C prefer-dynamic</code>来实现。但请注意，这只会影响到您显式指定的依赖项，而不会影响系统库的链接方式。</p></li><li><p>使用适当的数据结构和算法：检查您的代码，确保您使用了适当的数据结构和算法。有时，更高效的算法可以减少内存使用和可执行文件的大小。</p></li><li><p>考虑编译目标：Rust编译器可以为不同的目标平台编译可执行文件。如果您的目标平台是特定的系统或架构，可以尝试指定特定的目标，以减少生成的可执行文件的大小。</p></li></ol><p>这些方法可以帮助您减小Rust可执行文件的大小。请注意，结果可能因程序的复杂性和依赖项而有所不同。使用适当的编译参数、减少依赖、使用静态链接以及优化算法和数据结构都是优化可执行文件大小的常用方法。</p><h3 id="动态链接和静态链接，它们在本质上有什么区别"><a href="#动态链接和静态链接，它们在本质上有什么区别" class="headerlink" title="动态链接和静态链接，它们在本质上有什么区别"></a>动态链接和静态链接，它们在本质上有什么区别</h3><p>动态链接和静态链接是两种不同的链接方式，它们在链接程序和库时有着不同的工作原理和特点。</p><ol><li><p>动态链接（Dynamic Linking）：</p><ul><li>在动态链接中，可执行文件和库是分开编译和链接的。可执行文件只包含对库的引用信息，而不包含库的实际代码。</li><li>在运行时，操作系统的动态链接器（dynamic linker）负责将可执行文件与所需的库进行链接。动态链接器会在内存中加载库的共享对象（shared object），并将可执行文件中的引用指向库的实际函数或数据。</li><li>多个可执行文件可以共享同一份库的实例，这样可以节省内存空间。当库需要更新时，只需要替换共享对象即可，而不需要重新编译可执行文件。</li><li>动态链接允许在运行时加载和卸载库，提供了更大的灵活性和可扩展性。</li></ul></li><li><p>静态链接（Static Linking）：</p><ul><li>在静态链接中，可执行文件和库是在编译时进行链接的。编译器将库的实际代码复制到可执行文件中，使得可执行文件成为一个完全独立的单元。</li><li>静态链接生成的可执行文件包含了所有所需的库代码，因此它可以在没有额外依赖的情况下独立运行。</li><li>每个可执行文件都会有一份库的副本，这可能导致可执行文件的大小增加，并且多个可执行文件无法共享库的代码。当库需要更新时，需要重新编译所有依赖于该库的可执行文件。</li></ul></li></ol><p>总体而言，动态链接通过在运行时加载共享对象实现库的链接，而静态链接在编译时将库的代码直接复制到可执行文件中。动态链接可以节省内存空间并提供灵活性，但需要依赖操作系统的动态链接器。静态链接则生成独立的可执行文件，不需要额外的依赖，但可能导致文件大小增加和库更新的复杂性。</p><p>在实践中，选择动态链接还是静态链接通常取决于具体的需求和环境。某些情况下，动态链接可以提供更好的性能和资源利用，而静态链接则更适合于需要独立性和可移植性的场景。</p><h3 id="动态链接和静态链接在处理上有什么不同吗？"><a href="#动态链接和静态链接在处理上有什么不同吗？" class="headerlink" title="动态链接和静态链接在处理上有什么不同吗？"></a>动态链接和静态链接在处理上有什么不同吗？</h3><p>动态链接和静态链接是链接器（如ld）在处理可执行文件和库时的两种不同方式。</p><ol><li><p>动态链接：</p><ul><li>动态链接是在运行时进行的链接方式。</li><li>链接器将可执行文件和库的引用信息记录在可执行文件中，而不包含库的实际代码。</li><li>在程序运行时，操作系统的动态链接器（如Windows的DLL或Linux的共享对象）将可执行文件与所需的库进行链接。</li><li>动态链接器会在内存中加载库的共享对象，并将可执行文件中的引用指向库的实际函数或数据。</li><li>多个可执行文件可以共享同一份库的实例，减少了内存的占用。</li><li>当库需要更新时，只需要替换共享对象即可，而不需要重新编译可执行文件。</li></ul></li><li><p>静态链接：</p><ul><li>静态链接是在编译时进行的链接方式。</li><li>链接器将库的实际代码复制到可执行文件中，使得可执行文件成为一个完全独立的单元。</li><li>静态链接生成的可执行文件包含了所有所需的库代码，因此它可以在没有额外依赖的情况下独立运行。</li><li>每个可执行文件都会有一份库的副本，这可能导致可执行文件的大小增加，并且多个可执行文件无法共享库的代码。</li><li>当库需要更新时，需要重新编译所有依赖于该库的可执行文件。</li></ul></li></ol><p>在处理上，动态链接和静态链接在链接器（如ld）的行为和处理方式上有以下不同之处：</p><ul><li>动态链接器（如Windows的动态链接库加载器或Linux的动态链接器）会在运行时负责将可执行文件与动态链接的库进行链接，以及加载和管理共享对象的内存。</li><li>动态链接器通常会在操作系统启动时自动加载，并在需要时根据可执行文件中的引用信息来加载和链接库。</li><li>静态链接器在编译过程中直接将库的代码复制到可执行文件中，生成一个包含所有代码的独立文件。</li><li>静态链接器负责解析符号并进行符号重定位，以确保可执行文件中的引用指向正确的库函数和数据。</li></ul><p>当链接器（如ld）处理可执行文件时，它会执行以下操作，具体步骤可能因操作系统和链接器的实现而有所不同：</p><ol><li><p>符号解析和重定位：</p><ul><li>链接器首先会解析可执行文件中的所有符号引用，包括函数名、变量名等。这些符号引用是指向外部库或其他目标文件中定义的符号。</li><li>链接器会查找符号的定义，可以是其他目标文件或库中的函数或变量。如果找不到定义，链接器将报告链接错误。</li><li>一旦找到符号的定义，链接器会进行符号重定位。这意味着它将更新可执行文件中的符号引用，使其指向正确的地址。</li></ul></li><li><p>地址分配和重定位：</p><ul><li>链接器将为可执行文件中的每个函数和变量分配内存地址。这包括已解析和重定位的符号，以及可执行文件中的其他代码和数据。</li><li>链接器负责确保每个符号都具有唯一的地址，并解决可能的冲突或重叠。</li><li>在静态链接中，地址分配和重定位是在编译时完成的，因为库的代码直接复制到可执行文件中。在动态链接中，这些步骤是由动态链接器在运行时执行的。</li></ul></li><li><p>生成可执行文件格式：</p><ul><li>链接器将根据特定的可执行文件格式（如ELF、PE等）生成最终的可执行文件。</li><li>可执行文件格式定义了可执行文件的结构、布局和元数据信息，包括代码段、数据段、符号表、重定位表等。</li><li>链接器将代码段、数据段和其他段的内容填充到适当的位置，并将符号表和重定位表更新为正确的值。</li></ul></li></ol><p>最终生成的可执行文件是一个完整的、可执行的二进制文件。它包含了链接器解析和重定位后的代码和数据，以及其他必要的元数据。在运行时，操作系统会加载该可执行文件，并根据可执行文件中的信息执行代码和初始化数据。</p><p>对于动态链接，可执行文件中的符号引用被设置为指向库的动态链接信息，而不是直接指向库的函数和数据。动态链接器在运行时负责加载库，并将符号引用重定位到正确的函数和数据地址。</p><p>总结来说，动态链接是在运行时进行的链接方式，依赖于操作系统的动态链接器来加载和链接库。静态链接是在编译时进行的链接方式，将库的代码直接复制到可执行文件中，使其成为一个独立的单元。链接器（如ld）根据链接方式的不同，有不同的处理方式来生成最终的可执行文件或库文件。链接器在处理可执行文件时，负责符号解析和重定位、地址分配和重定位，并生成最终的可执行文件格式。这些步骤确保了可执行文件中的符号引用指向正确的地址，并生成一个可以在操作系统上运行的完整二进制文件。</p><p><strong>我一直很好奇，动态链接库的调用，是不是操作系统中有种数据结构保存了已加载的动态链接库的起始地址，以供其他需要依赖链接库的程序去动态获取想要调用的函数?</strong></p><p>是的，操作系统通常会维护一种数据结构来管理已加载的动态链接库（也称为共享对象或共享库）。这种数据结构通常称为符号表（symbol table）或导出表（export table），用于保存库中定义的函数和数据的起始地址。</p><p>当一个可执行文件需要调用动态链接库中的函数时，它会使用函数名或符号名作为标识符，向操作系统请求该标识符对应的函数地址。操作系统会通过符号表查找并返回相应的函数地址。</p><p>一旦可执行文件获得了所需函数的地址，它可以直接调用该函数，就像调用静态链接库中的函数一样。这种动态获取函数地址的过程称为动态符号解析（dynamic symbol resolution）。</p><p>动态链接库的符号表不仅包含函数地址，还可能包含其他信息，如全局变量或常量的地址。这使得可执行文件可以使用动态链接库中定义的各种函数和数据。</p><p>需要注意的是，动态链接库的符号解析是由操作系统的动态链接器负责的，它会在可执行文件加载时进行。动态链接器负责将可执行文件与所需的库进行链接，并在需要时解析和提供符号地址。这样可以提供动态链接的灵活性和可扩展性，使得多个可执行文件可以共享同一份库的实例。</p><h3 id="在Linux中动态链接库的数据结构"><a href="#在Linux中动态链接库的数据结构" class="headerlink" title="在Linux中动态链接库的数据结构"></a>在Linux中动态链接库的数据结构</h3><p>在Linux内核中，用于管理已加载的动态链接库的数据结构主要是<code>struct module</code>和<code>struct symbol</code>。</p><ol><li><p><code>struct module</code>：</p><ul><li><code>struct module</code>是Linux内核中表示一个动态链接库的数据结构。</li><li>它包含了动态链接库的信息，如名称、版本、参数等。</li><li><code>struct module</code>还包含一个指向动态链接库的代码和数据的内核虚拟地址的指针。</li><li><code>struct module</code>还维护了对其他已加载库的引用，以解决库之间的依赖关系。</li></ul></li><li><p><code>struct symbol</code>：</p><ul><li><code>struct symbol</code>是Linux内核中表示一个符号（函数或变量）的数据结构。</li><li>它包含了符号的名称、地址、大小等信息。</li><li>内核使用<code>struct symbol</code>来存储和管理动态链接库中的符号。</li><li>每个动态链接库都有一个相关的<code>struct module</code>，其中包含一个指向<code>struct symbol</code>数组的指针，用于存储该库中的所有符号。</li></ul></li></ol><p>在加载动态链接库时，Linux内核的动态链接器（<code>kernel/kallsyms.c</code>）会执行以下操作：</p><ol><li><p>解析和加载库：</p><ul><li>动态链接器会解析库文件，并将其加载到内存中。</li><li>它会分配一个新的<code>struct module</code>，并设置其名称、版本等信息。</li><li>内核会将库的代码和数据映射到内核虚拟地址空间中，并将其与<code>struct module</code>相关联。</li></ul></li><li><p>解析符号：</p><ul><li>动态链接器会遍历库中的符号表，识别和解析每个符号的名称和地址。</li><li>对于每个符号，它会创建一个<code>struct symbol</code>对象，并将其添加到库关联的<code>struct module</code>中的符号表数组中。</li><li><code>struct symbol</code>中保存了符号的名称、地址、大小等信息。</li></ul></li><li><p>符号查找和导出：</p><ul><li>当其他内核模块或驱动程序需要调用动态链接库中的函数或访问变量时，它们可以通过符号的名称来查找和导出符号。</li><li>内核提供了一些函数，如<code>symbol_get()</code>和<code>symbol_put()</code>，用于在内核中查找和获取符号的地址。</li></ul></li></ol><p>总结来说，在Linux内核中，动态链接库的管理涉及<code>struct module</code>和<code>struct symbol</code>这两个数据结构。<code>struct module</code>表示一个库的信息和内核虚拟地址，<code>struct symbol</code>表示一个符号的信息。动态链接器在加载库时解析符号，并将符号与相关的<code>struct module</code>关联，使得其他内核模块可以通过符号名称来查找和访问库中的函数和变量。</p><p><strong>这个数据结构是不是会加载到内存的指定位置？</strong></p><p>在Linux内核中，动态链接库的代码和数据会被加载到内核的虚拟地址空间中的指定位置。</p><p>具体加载的位置是由内核的加载器决定的，通常采用的是地址无关的代码和数据（Position Independent Code，PIC）。使用PIC可以使得动态链接库可以加载到任意的虚拟地址，而不会受到固定地址的限制。</p><p>当动态链接库被加载到内存时，内核会分配一块内存空间，并将库的代码段、数据段和其他相关段映射到该空间。这些段的位置和大小是由库文件中的元数据和内核加载器进行解析和确定的。</p><p>为了保证动态链接库的代码和数据可以正确访问，内核会将加载库的起始虚拟地址作为基地址，并根据库文件中的重定位信息对符号进行重定位，使得符号引用指向正确的内存地址。</p><p>总结来说，动态链接库在Linux内核中会被加载到指定的虚拟地址空间中。内核的加载器会根据库文件中的元数据和重定位信息确定加载的位置，并将库的代码和数据映射到内存中。这样，可执行文件和其他模块可以通过访问该虚拟地址来调用库中的函数和访问变量。</p><p><strong>是不是windows也一样，会把动态链接库加载到内存的指定位置上，然后也维护了类似的数据结构？</strong></p><p>是的，Windows操作系统也会将动态链接库加载到内存的指定位置，并维护类似的数据结构来管理已加载的库。</p><p>在Windows中，加载动态链接库的过程由操作系统的动态链接器（Dynamic Linker）负责。以下是Windows中动态链接库加载的一般过程：</p><ol><li><p>加载和映射：</p><ul><li>动态链接器会加载动态链接库文件，并将其映射到进程的虚拟地址空间中。</li><li>这个过程涉及分配一块内存空间，并将库的代码段、数据段等映射到该空间。</li></ul></li><li><p>符号解析和重定位：</p><ul><li>动态链接器会解析库文件中的符号引用，包括函数名、变量名等。</li><li>对于每个符号引用，动态链接器会查找符号的定义，并将符号引用重定位到正确的地址。</li><li>这个过程确保了可执行文件或其他模块可以正确地调用库中的函数和访问变量。</li></ul></li><li><p>导出表和导入表：</p><ul><li>动态链接库会维护一个导出表（Export Table），其中包含了库中定义的函数和数据的地址。</li><li>当其他模块需要调用动态链接库中的函数时，它们可以通过函数名或符号名来查找导出表，获取相应的函数地址。</li><li>同时，动态链接库也会维护一个导入表（Import Table），用于记录库所依赖的其他库和它们的符号引用。</li></ul></li></ol><p>Windows操作系统使用类似于<code>PE</code>（Portable Executable）格式的可执行文件和动态链接库格式。这些格式定义了可执行文件和库的结构、布局和元数据信息，包括代码段、数据段、导出表、导入表等。</p><p>总结来说，在Windows操作系统中，动态链接库会被加载到内存的指定位置，并通过动态链接器进行符号解析和重定位。操作系统维护导出表和导入表的数据结构，用于记录库中的符号和库所依赖的其他库。这样，其他模块可以通过符号名来查找和调用库中的函数和访问变量。</p><h3 id="windows和linux的可执行文件在文件格式上有什么不同的地方？"><a href="#windows和linux的可执行文件在文件格式上有什么不同的地方？" class="headerlink" title="windows和linux的可执行文件在文件格式上有什么不同的地方？"></a>windows和linux的可执行文件在文件格式上有什么不同的地方？</h3><p>Windows和Linux的可执行文件在文件格式上有显著的差异。下面是它们之间的主要区别：</p><p>Windows可执行文件格式：</p><ul><li>Windows上的可执行文件采用的是可移植可执行（Portable Executable，PE）格式。</li><li>PE格式是一种独特于Windows操作系统的文件格式，用于存储可执行文件、动态链接库和驱动程序。</li><li>PE格式的可执行文件包含一个DOS头（DOS Header）和一个PE头（PE Header）。</li><li>PE头包含了有关文件的重要信息，如文件类型、入口点、节表、导入表、导出表、资源表等。</li><li>在PE格式中，代码和数据以节（Section）的形式组织，每个节包含特定的内容，如代码段、数据段、导入表段、导出表段等。</li></ul><p>Linux可执行文件格式：</p><ul><li>Linux上的可执行文件采用的是可执行和可链接格式（Executable and Linkable Format，ELF）。</li><li>ELF格式是一种独特于Unix&#x2F;Linux操作系统的文件格式，用于存储可执行文件、动态链接库和目标文件。</li><li>ELF格式的可执行文件包含一个ELF头（ELF Header）和若干个程序头表（Program Header Table）。</li><li>ELF头包含了有关文件的重要信息，如文件类型、入口点、节头表的位置和大小等。</li><li>ELF格式中的代码和数据以节（Section）的形式组织，与PE格式类似，每个节包含特定的内容，如代码段、数据段、符号表、重定位表等。</li></ul><p>这些文件格式的差异主要是因为Windows和Linux使用不同的操作系统和工具链来编译和执行程序。每个操作系统和工具链都有自己的要求和约定，因此导致了可执行文件格式上的不同。</p><p><strong>是不是不同系统中，编译器和链接器生成的文件规格也不一样？</strong></p><p>是的，不同的操作系统和工具链在编译器和链接器生成的文件规格上可能会有所不同。这是因为每个操作系统和工具链都有自己的设计和标准，以满足特定的操作系统和硬件平台的要求。</p><p>下面是一些与文件规格相关的区别：</p><ol><li><p>可执行文件格式：</p><ul><li>如前所述，不同操作系统使用不同的可执行文件格式，如Windows使用PE格式，Linux使用ELF格式。</li><li>这些格式在文件头、段表、符号表、重定位表等方面有所差异。</li></ul></li><li><p>符号命名和修饰规则：</p><ul><li>不同的操作系统和工具链可能使用不同的符号命名和修饰规则。</li><li>符号修饰规则涉及将函数和变量的名称转换为在目标文件中使用的内部表示形式。</li><li>这些规则可能会影响到符号的可见性、名称解析和函数调用的正确性。</li></ul></li><li><p>库文件格式：</p><ul><li>库文件（静态库或动态链接库）的格式也可以因操作系统和工具链而异。</li><li>不同的系统可能使用不同的库文件格式，如Windows上使用LIB格式、Linux上使用AR格式。</li><li>这些格式定义了库文件中的目标模块的布局、索引和符号表等。</li></ul></li><li><p>链接器选项和参数：</p><ul><li>链接器在不同的操作系统和工具链中可能具有不同的选项和参数。</li><li>这些选项和参数控制链接器的行为，如链接库的方式（静态链接还是动态链接）、链接器搜索路径等。</li></ul></li></ol><p>需要注意的是，虽然不同的操作系统和工具链在文件规格上有所不同，但是为了实现可移植性，通常有一些跨平台的标准和规范，如C语言标准、POSIX标准等，可以在不同的系统上编写和编译可移植的代码。</p><p><strong>能否详细介绍下编译器最终生成的文件中都包含哪些部分？</strong></p><p>编译器最终生成的文件通常包含以下几个主要部分：</p><ol><li><p>文件头（File Header）：</p><ul><li>文件头包含了关于文件本身的元数据信息，如文件类型、目标体系结构、入口点地址等。</li><li>文件头的结构和内容在不同的可执行文件格式中会有所不同。</li></ul></li><li><p>代码段（Code Segment）：</p><ul><li>代码段包含了程序的机器指令，即编译后生成的可执行代码。</li><li>代码段是可执行文件中执行程序逻辑的部分，包括函数的实现和顶层执行代码。</li></ul></li><li><p>数据段（Data Segment）：</p><ul><li>数据段包含了程序中的静态数据和全局变量。</li><li>静态数据是指在程序运行期间保持不变的数据，如字符串常量、全局静态变量等。</li></ul></li><li><p>符号表（Symbol Table）：</p><ul><li>符号表记录了程序中使用的符号（如函数名、变量名）及其对应的地址。</li><li>符号表可以用于链接过程中的符号解析和重定位。</li></ul></li><li><p>重定位表（Relocation Table）：</p><ul><li>重定位表记录了需要进行重定位的地址和相关信息。</li><li>在可执行文件加载到内存时，重定位表用于修正地址，使得符号引用指向正确的内存位置。</li></ul></li><li><p>调试信息（Debug Information）：</p><ul><li>调试信息包含了编译器生成的用于调试和符号定位的信息。</li><li>调试信息通常包括源代码行号、变量名、函数名等，可以在调试器中进行源代码级别的调试。</li></ul></li></ol><p>除了上述部分之外，可执行文件的具体结构还与所使用的编译器、链接器以及目标文件格式有关。不同的操作系统和可执行文件格式可能还包含其他特定的部分，如导入表、导出表、资源表等，用于支持动态链接、资源管理等功能。</p><p>需要注意的是，不同的编译器和工具链可能生成不同的文件格式，并在文件结构和内容上有所差异。因此，具体的文件结构和内容会根据所用编译器、链接器以及目标平台的要求而有所不同。</p><p><strong>那链接器最终的生成也是这些结构咯？</strong></p><p>链接器在最终生成的可执行文件中会整合编译器生成的目标文件（object file）以及其他必要的信息，并进行符号解析、重定位等操作。链接器生成的可执行文件包含以下主要部分：</p><ol><li><p>文件头（File Header）：</p><ul><li>类似于编译器生成的文件头，包含了关于文件本身的元数据信息。</li></ul></li><li><p>代码段（Code Segment）：</p><ul><li>链接器会将编译器生成的目标文件中的代码段合并到最终的可执行文件的代码段中。</li><li>这些代码段包含了程序的机器指令，形成了最终可执行文件的执行逻辑。</li></ul></li><li><p>数据段（Data Segment）：</p><ul><li>链接器会将编译器生成的目标文件中的数据段合并到最终的可执行文件的数据段中。</li><li>这些数据段包含了静态数据和全局变量，使得最终可执行文件包含了所有程序所需的数据。</li></ul></li><li><p>符号表（Symbol Table）：</p><ul><li>链接器会对所有的目标文件进行符号解析，将符号引用与符号定义进行关联。</li><li>符号表记录了程序中使用的符号及其对应的地址，包括函数名、变量名等。</li></ul></li><li><p>重定位表（Relocation Table）：</p><ul><li>在链接过程中，链接器会处理目标文件中的重定位表，根据需要对地址进行修正。</li><li>重定位表记录了需要进行重定位的地址和相关信息，使得最终的可执行文件中的符号引用指向正确的地址。</li></ul></li><li><p>导入表（Import Table）和导出表（Export Table）：</p><ul><li>这些表用于支持动态链接的功能。导入表记录了可执行文件所依赖的外部库和需要动态链接的符号引用，而导出表记录了可执行文件自身对外部库提供的符号定义。</li></ul></li><li><p>资源表（Resource Table）：</p><ul><li>资源表用于存储程序所需的附加资源，如图标、字符串、位图等。</li></ul></li></ol><p>链接器还可能包括其他的信息和表格，这些信息和表格根据目标平台、文件格式以及链接器的功能和要求而有所不同。</p><p>需要注意的是，链接器的主要任务是将多个目标文件（和库文件）合并为一个可执行文件，并解决符号引用和地址重定位等问题。因此，链接器生成的可执行文件中的结构和内容会根据链接器的实现和目标平台的要求而有所不同。</p><p><strong>链接器会不会对编译器生成的部分信息进行清理?</strong></p><p>是的，链接器在最终生成可执行文件时会对编译器生成的部分信息进行清理。这是为了减小可执行文件的大小并确保最终文件的整洁性和可执行性。</p><p>下面是链接器通常会清理的一些信息：</p><ol><li><p>符号表和重定位表的修剪：</p><ul><li>链接器会对符号表和重定位表进行修剪，只保留实际需要的符号和重定位项。</li><li>未被引用的符号和重定位项可能会被链接器删除，以减小可执行文件的大小。</li></ul></li><li><p>未使用的代码和数据的剔除：</p><ul><li>链接器会检测和删除未被程序使用的代码段和数据段。</li><li>通过静态分析和链接器优化，未被引用的函数、变量和其他代码块可能会被从最终的可执行文件中剔除。</li></ul></li><li><p>调试信息的剥离：</p><ul><li>调试信息通常在编译器生成的目标文件中存在，但在最终的可执行文件中可能会被剥离。</li><li>调试信息可以被链接器移除，以减小最终可执行文件的大小。</li></ul></li><li><p>冗余的库和符号的删除：</p><ul><li>如果多个目标文件使用了相同的库或符号，链接器可能会删除冗余的库和符号的多个实例，只保留一个实例。</li></ul></li></ol><p>这些清理操作有助于减小可执行文件的大小，并去除不必要的信息，提高可执行文件的效率和可维护性。然而，清理操作可能因链接器的实现和选项而有所不同，也可能受到编译器和链接器之间的交互影响。</p><p>由于可执行文件的具体结构在字节级别上具有复杂性，并且取决于所使用的文件格式和目标平台，我无法提供完整的字节级别的数据结构说明。可执行文件的详细结构涉及各种标记、偏移量、长度和数据类型的组合，这需要深入研究具体的文件格式规范才能理解。</p><p>如果您对特定的可执行文件格式感兴趣，我建议您查阅相关的文件格式规范文档，例如：</p><ul><li>对于 ELF 格式，可以参考《Tool Interface Standards (TIS) Executable and Linking Format (ELF) Specification》。</li><li>对于 PE 格式，可以参考 Microsoft 的相关文档。</li></ul><p>这些规范文件提供了对可执行文件格式的详细解释和具体的字节级别数据结构说明，以及如何解析和处理这些结构。通过仔细阅读这些规范，您可以了解到可执行文件中每个部分的具体字节偏移、字段大小、数据类型和结构组织方式。请注意，这些规范可能非常详细和复杂，需要一定的计算机体系结构和文件格式的知识才能充分理解。</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu生成SSH登录证书</title>
    <link href="/doc/825d0365.html"/>
    <url>/doc/825d0365.html</url>
    
    <content type="html"><![CDATA[<h2 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h2><p>要在服务器上生成客户端登录证书，可以按照以下步骤进行操作：</p><ol><li><p>登录到目标服务器：使用SSH客户端通过用户名和密码登录到目标服务器。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh username@server_ip</code></pre></div></figure></li><li><p>检查是否已存在SSH密钥对：在服务器上检查是否已经存在SSH密钥对。默认情况下，密钥对存储在<code>~/.ssh</code>目录下的<code>id_rsa</code>和<code>id_rsa.pub</code>文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls ~&#x2F;.ssh&#x2F;id_rsa*</code></pre></div></figure><p>如果文件不存在，可以跳过此步骤，直接进行下一步生成密钥对。</p></li><li><p>生成SSH密钥对：如果在服务器上没有SSH密钥对，可以使用<code>ssh-keygen</code>命令生成。执行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -b 4096</code></pre></div></figure><p>程序将提示你选择密钥文件的存储路径和密码等选项。你可以选择默认值，即按回车键接受。</p></li><li><p>生成证书签名请求：使用生成的公钥文件创建证书签名请求。执行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -s ~&#x2F;.ssh&#x2F;id_rsa.pub -I certificate_name -n username -V +52w ~&#x2F;.ssh&#x2F;id_rsa-cert.pub</code></pre></div></figure><p>这将在<code>~/.ssh</code>目录下生成一个名为<code>id_rsa-cert.pub</code>的证书签名请求文件。</p></li><li><p>确保sshd服务器已配置：在目标服务器上，确保OpenSSH服务器已正确配置以接受证书登录。打开<code>/etc/ssh/sshd_config</code>文件，确认以下配置项是否存在并启用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">TrustedUserCAKeys &#x2F;etc&#x2F;ssh&#x2F;ca.pubAuthorizedPrincipalsFile &#x2F;etc&#x2F;ssh&#x2F;principals&#x2F;%u</code></pre></div></figure><p>如果不存在，可以使用文本编辑器进行添加或修改。保存文件并重新启动sshd服务。</p></li><li><p>分发证书：将生成的证书签名请求文件（<code>id_rsa-cert.pub</code>）复制到目标服务器的<code>/etc/ssh/ca.pub</code>文件。执行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cp ~&#x2F;.ssh&#x2F;id_rsa-cert.pub &#x2F;etc&#x2F;ssh&#x2F;ca.pub</code></pre></div></figure><p>这将把证书签名请求复制到服务器的CA密钥文件中。</p></li><li><p>配置用户授权：为每个用户配置授权文件以允许使用证书登录。创建<code>/etc/ssh/principals/username</code>文件（<code>username</code>是实际用户名），并将用户的登录证书主体添加到文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo mkdir &#x2F;etc&#x2F;ssh&#x2F;principalssudo echo &quot;username&quot; | sudo tee -a &#x2F;etc&#x2F;ssh&#x2F;principals&#x2F;username</code></pre></div></figure><p>这将为用户名创建一个授权文件，并将用户名写入其中。</p></li><li><p>重启sshd服务：完成上述配置后，重启sshd服务以使更改生效。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service ssh restart</code></pre></div></figure></li></ol><p>现在，你的服务器已经配置好了生成和使用客户端登录证书。</p><h2 id="证书分发"><a href="#证书分发" class="headerlink" title="证书分发"></a>证书分发</h2><p>下面是一个Shell脚本示例，可以用于生成和分发SSH客户端登录证书到sshd服务器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 指定sshd服务器的地址和登录凭证SSH_SERVER&#x3D;&quot;your_ssh_server&quot;SSH_USERNAME&#x3D;&quot;your_ssh_username&quot;SSH_PASSWORD&#x3D;&quot;your_ssh_password&quot;# 指定生成证书的相关信息CERTIFICATE_NAME&#x3D;&quot;certificate_name&quot;VALIDITY_PERIOD&#x3D;&quot;+52w&quot;PRINCIPAL&#x3D;&quot;username&quot;# 生成SSH密钥对echo &quot;Generating SSH key pair...&quot;ssh-keygen -t rsa -b 4096 -N &#39;&#39; -f ~&#x2F;.ssh&#x2F;id_rsaecho &quot;SSH key pair generated.&quot;# 创建证书签名请求echo &quot;Creating certificate signing request...&quot;ssh-keygen -s ~&#x2F;.ssh&#x2F;id_rsa -I &quot;$CERTIFICATE_NAME&quot; -n &quot;$PRINCIPAL&quot; -V &quot;$VALIDITY_PERIOD&quot; ~&#x2F;.ssh&#x2F;id_rsa-cert.pubecho &quot;Certificate signing request created.&quot;# 将证书发送到sshd服务器echo &quot;Sending certificate to SSH server...&quot;sshpass -p &quot;$SSH_PASSWORD&quot; ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa-cert.pub -f &quot;$SSH_USERNAME@$SSH_SERVER&quot;echo &quot;Certificate sent to SSH server.&quot;echo &quot;Done.&quot;</code></pre></div></figure><p>在使用这个脚本之前，请确保已经安装了<code>ssh-keygen</code>和<code>sshpass</code>工具。你需要修改脚本中的以下几个变量：</p><ul><li><code>SSH_SERVER</code>：sshd服务器的地址。</li><li><code>SSH_USERNAME</code>：登录sshd服务器的用户名。</li><li><code>SSH_PASSWORD</code>：登录sshd服务器的密码。</li><li><code>CERTIFICATE_NAME</code>：生成的证书名称。</li><li><code>VALIDITY_PERIOD</code>：证书的有效期限。</li><li><code>PRINCIPAL</code>：证书的主体，通常是用户名。</li></ul><p>运行脚本之前，请给予执行权限：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x generate_and_distribute_certificate.sh</code></pre></div></figure><p>然后运行脚本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;generate_and_distribute_certificate.sh</code></pre></div></figure><p>脚本将生成SSH密钥对，并创建证书签名请求。接着，它会使用<code>sshpass</code>工具将证书发送到指定的sshd服务器。请确保将<code>sshpass</code>的安全性考虑在内，因为它需要将密码以明文形式传递给<code>ssh-copy-id</code>命令。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>SSH证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题-表复制</title>
    <link href="/doc/15835223.html"/>
    <url>/doc/15835223.html</url>
    
    <content type="html"><![CDATA[<p>今天线上环境因表主键和索引丢失，导致热点数据查询缓慢，特此记录。</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE backup_20230525_A SELECT * FROM A;</code></pre></div></figure><p>这样的复制仅复制表结构和数据，并不会复制主键和索引（致使索引丢失的罪魁祸首）。</p><p>想要完全复制表结构，只能查看表结构<code>SHOW CREATE TABLE A;</code>，复制结构并重新创建然后使用<code>INSERT INTO backup_20230525_A SELECT * FROM A;</code>来完成数据复制。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-人工智能研究小计3</title>
    <link href="/doc/ccbbaf48.html"/>
    <url>/doc/ccbbaf48.html</url>
    
    <content type="html"><![CDATA[<p>我们所在的世界中存在很多的<strong>规则</strong>，可以说这些不同的<strong>规则</strong>间接的生成了这个世界。</p><p>其实<strong>规则</strong>就在我们身边，世界已经将<strong>规则</strong>以某种形式告诉了我们，我们每个人的表现、每天发生的事、我们现如今构建的认知及知识体系都是因为这些<strong>规则</strong>表现出来的表象。需要我们经过长时间的发展研究才能追随本源、了解<strong>规则</strong>，就像编程一样。</p><p>编写出来的计算机程序——比如游戏。比较熟知的我的世界，在我的世界这个游戏中利用我的世界里现有的<strong>规则</strong>，在其内部创造一个计算机也是可行的。并且在这个我的世界里创造的计算机中再创造一个我的世界游戏，这是可以做到的，已经有人用实际行动证明了。</p><p>所以我相信世界的<strong>规则</strong>就在我们身边或自己身上的这些表象之中。经过几代人的演变和研究（当然前提是不做任何限制），早晚会创造出与我们相同或者凌驾与我们之上的<strong>规则</strong>(世界)，当然这需要很长的时间研究、计算、演变，并且还伴随着灭亡的风险。人工智能就是我们在探索世界本源的一种体现。因为他在模拟我们人的思维。在摸索生物产生思维的<strong>规则</strong>（在怎样的<strong>规则</strong>下会诞生意识，神经元只是载体，意识传导的媒介是神经元，但意识的产生源应该是<strong>规则</strong>，未来只要找到能替代神经元的媒介就能在某种意义上获得永恒）。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运-史上最全Markdown公式、符号总结</title>
    <link href="/doc/43df3c4b.html"/>
    <url>/doc/43df3c4b.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/weixin_42782150/article/details/104878759">https://blog.csdn.net/weixin_42782150/article/details/104878759</a></p></blockquote><h2 id="常见公式"><a href="#常见公式" class="headerlink" title="常见公式"></a>常见公式</h2><p>一般公式分为两种形式，行内公式和行间公式。行内公式是在公式代码块的前后均添加一个<code>$</code>;行间公式则是在公式代码块的前后均添加两个<code>$$</code>。</p><p><strong>数学算式：</strong></p><ol><li>行内公式：$ \Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,. $</li><li>行间公式：</li></ol><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$ \Gamma(z) &#x3D; \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,. $$$\Gamma(z) &#x3D; \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$</code></pre></div></figure><h2 id="公式排列"><a href="#公式排列" class="headerlink" title="公式排列"></a>公式排列</h2><p>一般使用<code>\binom&#123;a&#125;&#123;b&#125;</code>或者<code>&#123;a \choose b&#125;</code>实现对a,b两个公式的排列。</p><p><strong>数学算式：</strong></p><p>$$<br>\binom{n+1}{2k}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\binom&#123;n+1&#125;&#123;2k&#125; $$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>{n+1 \choose 2k}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$&#123;n+1 \choose 2k&#125; $$</code></pre></div></figure><h2 id="向量公式"><a href="#向量公式" class="headerlink" title="向量公式"></a>向量公式</h2><p>向量表示：一般使用<code>\mathbf&#123;x&#125;</code>来表示向量$\mathbf{x}$</p><p><strong>数学算式：</strong></p><p>$$<br>f(\mathbf{x})&#x3D;\mathbf{w}^T\mathbf{x}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$f(\mathbf&#123;x&#125;)&#x3D;\mathbf&#123;w&#125;^T\mathbf&#123;x&#125;$$</code></pre></div></figure><h2 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h2><p>定义函数的时候经常需要根据情况来给出表达式，其中：</p><ul><li>使用<code>\</code>来分割或分组，若分组需要的间隔较大，可以用<code>\[2ex]</code>、<code>\[3ex]</code>、<code>\[4ex]</code>这样的形式代替<code>\</code>来进行不同程度的分割。</li><li>使用<code>&amp;</code>来指示对齐位置</li><li>使用<code>\ </code>来代表空格</li></ul><p><strong>数学算式：</strong></p><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$y&#x3D;\begin&#123;cases&#125;-x,\quad x\leq 0 \\\\x, \quad x&gt;0\end&#123;cases&#125;\tag&#123;1&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\left.<br>\begin{array}{c}<br>a_1x+b_1y+c_1z&#x3D;d_1 \\<br>a_2x+b_2y+c_2z&#x3D;d_2 \\<br>a_3x+b_3y+c_3z&#x3D;d_3<br>\end{array}<br>\right.<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left.\begin&#123;array&#125;&#123;c&#125;a_1x+b_1y+c_1z&#x3D;d_1 \\\\a_2x+b_2y+c_2z&#x3D;d_2 \\\\a_3x+b_3y+c_3z&#x3D;d_3\end&#123;array&#125;\right.$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>J(\theta) &#x3D; \frac{1}{2m}\sum_{i &#x3D; 0} ^m(y^i - h_\theta (x^i))^2<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$J(\theta) &#x3D; \frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i &#x3D; 0&#125; ^m(y^i - h_\theta (x^i))^2$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\frac{\partial J(\theta)}{\partial\theta_j}&#x3D;-\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;&#x3D;-\frac1m\sum_&#123;i&#x3D;0&#125;^m(y^i-h_\theta(x^i))x^i_j$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^n\theta_jx_j^i-y^i) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;&amp; &#x3D; -\frac1m\sum_&#123;i&#x3D;0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(y^i-h_\theta(x^i)) \\\\&amp; &#x3D; -\frac1m\sum_&#123;i&#x3D;0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j&#x3D;0&#125;^n\theta_jx_j^i-y^i) \\\\&amp; &#x3D; -\frac1m\sum_&#123;i&#x3D;0&#125;^m(y^i-h_\theta(x^i))x^i_j\end&#123;aligned&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>a &#x3D;<br>\begin{cases}<br>\int x, \mathrm{d} x \\<br>b^2<br>\end{cases}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$a &#x3D;\begin&#123;cases&#125;\int x\, \mathrm&#123;d&#125; x \\\\b^2\end&#123;cases&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>\boxed{x^2+y^2 &#x3D; z^2}<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;\boxed&#123;x^2+y^2 &#x3D; z^2&#125;\end&#123;aligned&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)<br>&#x3D; \operatorname*{arg,max}_b f(b) \\<br>\operatorname{arg,min}_c f(c)<br>&#x3D; \operatorname*{arg,min}_d f(d)<br>\end{gathered}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;gathered&#125;\operatorname&#123;arg\,max&#125;_a f(a)&#x3D; \operatorname*&#123;arg\,max&#125;_b f(b) \\\\\operatorname&#123;arg\,min&#125;_c f(c)&#x3D; \operatorname*&#123;arg\,min&#125;_d f(d)\end&#123;gathered&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>\lim_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\lim\nolimits_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;\lim_&#123;a\to \infty&#125; \tfrac&#123;1&#125;&#123;a&#125;\end&#123;aligned&#125;$$$$\begin&#123;aligned&#125;\lim\nolimits_&#123;a\to \infty&#125; \tfrac&#123;1&#125;&#123;a&#125;\end&#123;aligned&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>\int_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\int\limits_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;\int_a^b x^2  \mathrm&#123;d&#125; x\end&#123;aligned&#125;$$$$\begin&#123;aligned&#125;\int\limits_a^b x^2  \mathrm&#123;d&#125; x\end&#123;aligned&#125;$$</code></pre></div></figure><p><strong>数学算式：</strong></p><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$y&#x3D;\begin&#123;cases&#125;-x,\quad x\leq 0 \\\\x, \quad x&gt;0\end&#123;cases&#125;\tag&#123;1&#125;$$</code></pre></div></figure><h2 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h2><p>有时候需要将一行公式分多行进行显示，其中<code>\begin&#123;aligned&#125;</code> 表示开始方程，<code>\end&#123;equation&#125;</code> 表示方程结束；</p><p>使用<code>\\</code>表示公式换行。<code>\begin&#123;gather&#125;</code>表示环境设置。<code>&amp;</code> 表示对齐的位置。</p><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>J(\mathbf{w})&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(f(\mathbf{x_i})-y_i)^2 \\<br>&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;J(\mathbf&#123;w&#125;)&amp;&#x3D;\frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i&#x3D;1&#125;^m(f(\mathbf&#123;x_i&#125;)-y_i)^2 \\\\&amp;&#x3D;\frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i&#x3D;1&#125;^m [f(\mathbf&#123;x_i&#125;)]^2-2f(\mathbf&#123;x_i)&#125;y_i+y_i^2\end&#123;aligned&#125;$$</code></pre></div></figure><h2 id="常见公式环境"><a href="#常见公式环境" class="headerlink" title="常见公式环境"></a>常见公式环境</h2><table><thead><tr><th>环境名称</th><th>释义</th></tr></thead><tbody><tr><td>align</td><td>最基本的对齐环境</td></tr><tr><td>multline</td><td>非对齐环境</td></tr><tr><td>gather</td><td>无对齐的连续方程</td></tr></tbody></table><blockquote><p><code>gathered</code>允许多行（多组）方程式在彼此之下设置并分配单个方程式编号<br><code>split</code>与<code>align</code>类似，但在另一个显示的数学环境中使用<br><code>aligned</code>与<code>align</code>类似，可以在其他数学环境中使用。<br><code>alignedat</code>与<code>alignat</code>类似，同样需要一个额外的参数来指定要设置的方程列数。</p></blockquote><p><strong>注：</strong> 如果各个方程需要在某个字符处对齐（如等号对齐），只需在所有要对齐的字符前加上<code>&amp;</code>符号。</p><p><strong>数学算式：</strong></p><p>$$<br>\begin{aligned}<br>\left.\begin{aligned}<br>B’&amp;&#x3D;-\partial \times E,\<br>E’&amp;&#x3D;\partial \times B - 4\pi j,<br>\end{aligned}<br>\right.<br>\qquad \text{Maxwell’s equations}<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\sigma_1 &amp;&#x3D; x + y  &amp;\quad \sigma_2 &amp;&#x3D; \frac{x}{y} \\<br>\sigma_1’ &amp;&#x3D; \frac{\partial x + y}{\partial x} &amp; \sigma_2’<br>&amp;&#x3D; \frac{\partial \frac{x}{y}}{\partial x}<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>a_n&amp;&#x3D;\frac{1}{\pi}\int\limits_{-\pi}^{\pi}f(x)\cos nx,\mathrm{d}x \\<br>&amp;&#x3D;\frac{1}{\pi}\int\limits_{-\pi}^{\pi}x^2\cos nx,\mathrm{d}x\<br>\end{aligned}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;aligned&#125;\left.\begin&#123;aligned&#125;B&#39;&amp;&#x3D;-\partial \times E,\E&#39;&amp;&#x3D;\partial \times B - 4\pi j,\end&#123;aligned&#125;\right.\qquad \text&#123;Maxwell&#39;s equations&#125;\end&#123;aligned&#125;$$$$\begin&#123;aligned&#125;\sigma_1 &amp;&#x3D; x + y  &amp;\quad \sigma_2 &amp;&#x3D; \frac&#123;x&#125;&#123;y&#125; \\\\\sigma_1&#39; &amp;&#x3D; \frac&#123;\partial x + y&#125;&#123;\partial x&#125; &amp; \sigma_2&#39;&amp;&#x3D; \frac&#123;\partial \frac&#123;x&#125;&#123;y&#125;&#125;&#123;\partial x&#125;\end&#123;aligned&#125;$$$$\begin&#123;aligned&#125;a_n&amp;&#x3D;\frac&#123;1&#125;&#123;\pi&#125;\int\limits_&#123;-\pi&#125;^&#123;\pi&#125;f(x)\cos nx\,\mathrm&#123;d&#125;x \\\\&amp;&#x3D;\frac&#123;1&#125;&#123;\pi&#125;\int\limits_&#123;-\pi&#125;^&#123;\pi&#125;x^2\cos nx\,\mathrm&#123;d&#125;x\\end&#123;aligned&#125;$$</code></pre></div></figure><h2 id="公式编辑的编号设置"><a href="#公式编辑的编号设置" class="headerlink" title="公式编辑的编号设置"></a>公式编辑的编号设置</h2><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>\tag{标号}</td><td>公式宏包序号设置命令，可用于带星号公式环境中的公式行</td></tr><tr><td>\tag*{标号}</td><td>作用与\tag相同，只是标号两侧没有圆括号</td></tr></tbody></table><p><strong>数学算式：</strong></p><p>$$<br>x^2+y^2&#x3D;z^2 \tag{1$’$}<br>$$</p><p>$$<br>x^4+y^4&#x3D;z^4 \tag{*}<br>$$</p><p>$$<br>x^5+y^5&#x3D;z^5 \tag*{*}<br>$$</p><p>$$<br>x^6+y^6&#x3D;z^6 \tag{1-1}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$x^2+y^2&#x3D;z^2 \tag&#123;1$&#39;$&#125;$$$$x^4+y^4&#x3D;z^4 \tag&#123;*&#125;$$$$x^5+y^5&#x3D;z^5 \tag*&#123;*&#125;$$$$x^6+y^6&#x3D;z^6 \tag&#123;1-1&#125;$$</code></pre></div></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>常见的矩阵形式：</p><p><strong>数学算式：</strong></p><p>$$<br>\begin{pmatrix}1 &amp; 2 \\ 3 &amp;4 \\ \end{pmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4 \\ \end{bmatrix}<br>$$</p><p>$$<br>\begin{Bmatrix}1 &amp;2 \\ 3 &amp; 4 \\ \end{Bmatrix}<br>$$</p><p>$$<br>\begin{vmatrix}1 &amp;2 \\ 3 &amp;4 \\ \end{vmatrix}<br>$$</p><p>$$<br>\begin{Vmatrix}1 &amp;  2 \\ 3 &amp;  4 \\ \end{Vmatrix}<br>$$</p><p>元素省略可以使用<code>\cdots</code>表示<code>⋯</code>，<code>\ddots</code>表示<code>⋱</code> ，<code>\vdots</code>表示<code>⋮</code> ，从而省略矩阵中的元素，如：</p><p>$$<br>\begin{pmatrix}<br>&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n \\<br>&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n \\<br>&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\<br>&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n<br>\end{pmatrix}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;pmatrix&#125;1 &amp; 2 \\\\ 3 &amp;4 \\\\ \end&#123;pmatrix&#125;$$$$\begin&#123;bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \end&#123;bmatrix&#125;$$$$\begin&#123;Bmatrix&#125;1 &amp;2 \\\\ 3 &amp; 4 \\\\ \end&#123;Bmatrix&#125;$$$$\begin&#123;vmatrix&#125;1 &amp;2 \\\\ 3 &amp;4 \\\\ \end&#123;vmatrix&#125;$$$$\begin&#123;Vmatrix&#125;1 &amp;  2 \\\\ 3 &amp;  4 \\\\ \end&#123;Vmatrix&#125;$$$$\begin&#123;pmatrix&#125;&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n \\\\&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n \\\\&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\\\&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\end&#123;pmatrix&#125;$$</code></pre></div></figure><p>为公式添加脚注编号使用：<code>\tag&#123;n&#125;</code>,其中n表示第n个公式。</p><h3 id="不带括号的矩阵"><a href="#不带括号的矩阵" class="headerlink" title="不带括号的矩阵"></a>不带括号的矩阵</h3><p><strong>数学算式：</strong></p><p>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\tag{1}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\end&#123;matrix&#125;\tag&#123;1&#125;$$</code></pre></div></figure><h3 id="带中括号的矩阵"><a href="#带中括号的矩阵" class="headerlink" title="带中括号的矩阵"></a>带中括号的矩阵</h3><p><strong>数学算式：</strong></p><p>$$\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left[\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\end&#123;matrix&#125;\right]\tag&#123;3&#125;$$</code></pre></div></figure><h3 id="带大括号的矩阵"><a href="#带大括号的矩阵" class="headerlink" title="带大括号的矩阵"></a>带大括号的矩阵</h3><p><strong>数学算式：</strong></p><p>$$\left\{<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right\}<br>\tag{4}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left\\&#123;\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\end&#123;matrix&#125;\right\\&#125;\tag&#123;4&#125;$$</code></pre></div></figure><h3 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h3><p><strong>数学算式：</strong></p><p>$$<br>\left[<br>\begin{matrix}<br>a &amp; b &amp; \cdots &amp; a \\<br>b &amp; b &amp; \cdots &amp; b \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>c &amp; c &amp; \cdots &amp; c<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left[\begin&#123;matrix&#125;a &amp; b &amp; \cdots &amp; a \\\\b &amp; b &amp; \cdots &amp; b \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\c &amp; c &amp; \cdots &amp; c\end&#123;matrix&#125;\right]\tag&#123;5&#125;$$</code></pre></div></figure><h3 id="带横线-竖线分割的矩阵"><a href="#带横线-竖线分割的矩阵" class="headerlink" title="带横线&#x2F;竖线分割的矩阵"></a>带横线&#x2F;竖线分割的矩阵</h3><p><strong>数学算式：</strong></p><p>$$<br>\left[<br>\begin{array}{c|cc}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{array}<br>\right]<br>\tag{6}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left[\begin&#123;array&#125;&#123;c|cc&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\end&#123;array&#125;\right]\tag&#123;6&#125;$$</code></pre></div></figure><p>横线用<code>\hline</code>分割，示例如下：</p><p><strong>数学算式：</strong></p><p>$$<br>\left[<br>\begin{array}{c|cc}<br>1 &amp; 2 &amp; 3 \\ \hline<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{array}<br>\right]<br>\tag{7}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$\left[\begin&#123;array&#125;&#123;c|cc&#125;1 &amp; 2 &amp; 3 \\\\ \hline4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\end&#123;array&#125;\right]\tag&#123;7&#125;$$</code></pre></div></figure><h2 id="上下标符号"><a href="#上下标符号" class="headerlink" title="上下标符号"></a>上下标符号</h2><p>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>&#123;…&#125;</code>包裹起来的内容。</p><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$a_i , a_{pre}$</td><td><code>a_i , a_&#123;pre&#125;</code></td><td>下标使用<code>_</code></td></tr><tr><td>$a^i , a^{pre}$</td><td><code>a^i , a^&#123;pre&#125;</code></td><td>上标使用<code>^</code></td></tr><tr><td>$\bar{a}$</td><td><code>\bar&#123;a&#125;</code></td><td></td></tr><tr><td>$\acute{a}$</td><td><code>\acute&#123;a&#125;</code></td><td></td></tr><tr><td>$\breve{a}$</td><td><code>\breve&#123;a&#125;</code></td><td></td></tr><tr><td>$\grave{a}$</td><td><code>\grave&#123;a&#125;</code></td><td></td></tr><tr><td>$\dot{a}$</td><td><code>\dot&#123;a&#125;</code></td><td></td></tr><tr><td>$\ddot{a}$</td><td><code>\ddot&#123;a&#125;</code></td><td></td></tr><tr><td>$\dot {\dot x}$</td><td><code>\dot &#123;\dot x&#125;</code></td><td></td></tr><tr><td>$\hat{a}$</td><td><code>\hat&#123;a&#125;</code></td><td></td></tr><tr><td>$\widehat{xy}$</td><td><code>\widehat&#123;xy&#125;</code></td><td>多字符可以使用</td></tr><tr><td>$\check{a}$</td><td><code>\check&#123;a&#125;</code></td><td></td></tr><tr><td>$\breve{a}$</td><td><code>\breve&#123;a&#125;</code></td><td></td></tr><tr><td>$\tilde{a}$</td><td><code>\tilde&#123;a&#125;</code></td><td></td></tr><tr><td>$\vec{a}$</td><td><code>\vec&#123;a&#125;</code></td><td>矢量使用 <code>\vec&#123;&#125;</code></td></tr><tr><td>$\overrightarrow {xy}$</td><td><code>\overrightarrow &#123;xy&#125;</code></td><td>向量</td></tr><tr><td>$\overline{a + b + c + d}$</td><td><code>\overline&#123;a + b + c + d&#125;</code></td><td></td></tr><tr><td>$\underline{a + b + c + d}$</td><td><code>\underline&#123;a + b + c + d&#125;</code></td><td></td></tr><tr><td>$\overbrace{a + b + c + d}$</td><td><code>\overbrace&#123;a + b + c + d&#125;</code></td><td></td></tr><tr><td>$\underbrace{a + b + c + d}$</td><td><code>\underbrace&#123;a + b + c + d&#125;</code></td><td></td></tr><tr><td>$\overbrace{a + \underbrace{b + c}_{1.0} + d}^{2.0}$</td><td><code>\overbrace&#123;a + \underbrace&#123;b + c&#125;_&#123;1.0&#125; + d&#125;^&#123;2.0&#125;</code></td><td></td></tr></tbody></table><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><h3 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h3><ul><li>使用原始的( )，[ ]得到的括号大小是固定的，如( 2 + 3 ) [ 4 + 4 ]</li><li>使用<code>\left</code>(或<code>\right</code>)可使括号大小与邻近的公式相适应（该语句适用于所有括号类型），如：$\left(\frac{x}{y}\right)$</li></ul><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$( , )$</td><td><code>( , )</code></td><td></td></tr><tr><td>$[ , ]$</td><td><code>[ , ]</code></td><td></td></tr><tr><td>$\langle, \rangle$</td><td><code>\lang, \rang</code> 或 <code>\langle, \rangle</code></td><td></td></tr><tr><td>$\lvert, \rvert$</td><td><code>\lvert, \rvert</code></td><td></td></tr><tr><td>$\lVert, \rVert$</td><td><code>\lVert, \rVert</code></td><td></td></tr><tr><td>$\lbrace, \rbrace$</td><td><code>\lbrace, \rbrace</code> 或 <code>&#123;, &#125;</code></td><td></td></tr></tbody></table><h3 id="增大括号的方法"><a href="#增大括号的方法" class="headerlink" title="增大括号的方法"></a>增大括号的方法</h3><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$(x)$</td><td><code>(x)</code></td><td></td></tr><tr><td>$\big( x \big)$</td><td><code>\big( x \big)</code></td><td></td></tr><tr><td>$\Big( x \Big)$</td><td><code>\Big( x \Big)</code></td><td></td></tr><tr><td>$\bigg( x \bigg)$</td><td><code>\bigg( x \bigg)</code></td><td></td></tr><tr><td>$\Bigg( x \Bigg)$</td><td><code>\Bigg( x \Bigg)</code></td><td></td></tr><tr><td>$\Bigg(\bigg(\Big(\big((x)\big)\Big)\bigg)\Bigg)$</td><td><code>\Bigg(\bigg(\Big(\big((x)\big)\Big)\bigg)\Bigg)</code></td><td></td></tr><tr><td>$\Bigg[\bigg[\Big[\big[[x]\big]\Big]\bigg]\Bigg]$</td><td><code>\Bigg[\bigg[\Big[\big[[x]\big]\Big]\bigg]\Bigg]</code></td><td></td></tr><tr><td>$\Bigg \langle \bigg \langle \Big \langle\big\langle\langle x \rangle \big \rangle\Big\rangle\bigg\rangle\Bigg\rangle$</td><td><code>\Bigg \langle \bigg \langle \Big \langle\big\langle\langle x \rangle \big \rangle\Big\rangle\bigg\rangle\Bigg\rangle</code></td><td></td></tr><tr><td>$\Bigg\lvert\bigg\lvert\Big\lvert\big\lvert\lvert x \rvert\big\rvert\Big\rvert\bigg\rvert\Bigg\rvert$</td><td><code>\Bigg\lvert\bigg\lvert\Big\lvert\big\lvert\lvert x \rvert\big\rvert\Big\rvert\bigg\rvert\Bigg\rvert</code></td><td></td></tr><tr><td>$\Bigg\lvert\bigg\lvert\Big\lvert\big\lvert\lvert x \rvert\big\rvert\Big\rvert\bigg\rvert\Bigg\rvert$</td><td><code>\Bigg\lvert\bigg\lvert\Big\lvert\big\lvert\lvert x \rvert\big\rvert\Big\rvert\bigg\rvert\Bigg\rvert</code></td><td></td></tr><tr><td>$\Bigg\lVert\bigg\lVert\Big\lVert\big\lVert\lVert x \rVert\big\rVert\Big\rVert\bigg\rVert\Bigg\rVert$</td><td><code>\Bigg\lVert\bigg\lVert\Big\lVert\big\lVert\lVert x \rVert\big\rVert\Big\rVert\bigg\rVert\Bigg\rVert</code></td><td></td></tr><tr><td>$\Bigg\lVert\bigg\lVert\Big\lVert\big\lVert\lVert x \rVert\big\rVert\Big\rVert\bigg\rVert\Bigg\rVert$</td><td><code>\Bigg\lVert\bigg\lVert\Big\lVert\big\lVert\lVert x \rVert\big\rVert\Big\rVert\bigg\rVert\Bigg\rVert</code></td><td></td></tr></tbody></table><h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h2><p>分式的表示方法：</p><ul><li>使用<code>\frac&#123;a&#125;&#123;b&#125;</code>表示分式，比如$\frac{a+c+1}{b+c+2}$</li><li>使用<code>\over</code>来分隔一个组的前后两部分，如${a+1\over b+1}$</li><li>连分数，使用使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>，两者效果对比如下：</li></ul><p><code>\frac</code> 表示连分式：<br><strong>数学算式：</strong></p><p>$$<br>x&#x3D;a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+…}}}}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$x&#x3D;a_0 + \frac&#123;1^2&#125;&#123;a_ 1+\frac&#123;2^2&#125;&#123;a_2+\frac&#123;3^2&#125;&#123;a_3+ \frac&#123;4^2&#125;&#123;a_4+...&#125;&#125;&#125;&#125;$$</code></pre></div></figure><p><code>\cfrac</code> 表示连分式：<br><strong>数学算式：</strong></p><p>$$<br>x&#x3D;a_0 + \cfrac{1^2}{a_ 1+\cfrac{2^2}{a_2+\cfrac{3^2}{a_3+ \cfrac{4^2}{a_4+…}}}}<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$x&#x3D;a_0 + \cfrac&#123;1^2&#125;&#123;a_ 1+\cfrac&#123;2^2&#125;&#123;a_2+\cfrac&#123;3^2&#125;&#123;a_3+ \cfrac&#123;4^2&#125;&#123;a_4+...&#125;&#125;&#125;&#125;$$</code></pre></div></figure><p><code>\cfrac</code> 表示连分式：</p><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\frac{a}{b}$</td><td><code>\frac&#123;a&#125;&#123;b&#125;</code></td><td>分数使用<code>\frac&#123;分子&#125;&#123;分母&#125;</code></td></tr><tr><td>$a^i , a^{pre}$</td><td><code>a^i , a^&#123;pre&#125;</code></td><td>上标使用<code>^</code></td></tr></tbody></table><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\sqrt{a + b}$</td><td><code>\sqrt&#123;a + b&#125;</code></td><td>开方使用<code>\sqrt&#123;&#125;</code></td></tr><tr><td>$\sqrt[n]{a + b}$</td><td><code>\sqrt[n]&#123;a + b&#125;</code></td><td>开n次方使用<code>\sqrt[n]&#123;&#125;</code></td></tr></tbody></table><h2 id="累加-累乘"><a href="#累加-累乘" class="headerlink" title="累加&#x2F;累乘"></a>累加&#x2F;累乘</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\sum_{i &#x3D; 0}^{n} x^2$</td><td><code>\sum_&#123;i = 0&#125;^&#123;n&#125; x^2</code></td><td>累加使用<code>\sum_&#123;下标&#125;^&#123;上标&#125;</code></td></tr><tr><td>$\prod_{i &#x3D; 0}^{n}\frac{1}{x}$</td><td><code>\prod_&#123;i = 0&#125;^&#123;n&#125;\frac&#123;1&#125;&#123;x&#125;</code></td><td>累乘使用<code>\prod_&#123;下标&#125;^&#123;上标&#125;</code></td></tr></tbody></table><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>释义</th></tr></thead><tbody><tr><td>$\sin$</td><td><code>\sin</code></td><td>正弦</td></tr><tr><td>$\cos$</td><td><code>\cos</code></td><td>余弦</td></tr><tr><td>$\tan$</td><td><code>\tan</code></td><td>正切</td></tr><tr><td>$\cot$</td><td><code>\cot</code></td><td>余切</td></tr><tr><td>$\sec$</td><td><code>\sec</code></td><td>反正弦</td></tr><tr><td>$\csc$</td><td><code>\csc</code></td><td>反余弦</td></tr><tr><td>$\bot$</td><td><code>\bot</code></td><td>垂直</td></tr><tr><td>$\angle$</td><td><code>\angle</code></td><td>夹角</td></tr><tr><td>$40^\circ$</td><td><code>40^\circ</code></td><td>度数</td></tr></tbody></table><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\ln{a + b}$</td><td><code>\ln&#123;a + b&#125;</code></td><td>以e为底，对数函数使用<code>\ln&#123;&#125;</code></td></tr><tr><td>$\log_{a}^{b}$</td><td><code>\log_&#123;a&#125;^&#123;b&#125;</code></td><td>对数函数使用<code>\log_&#123;a&#125;^&#123;b&#125;</code></td></tr><tr><td>$\lg{a + b}$</td><td><code>\lg&#123;a + b&#125;</code></td><td>以10为底，对数函数使用<code>\ln&#123;&#125;</code></td></tr></tbody></table><h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\pm$</td><td><code>\pm</code></td><td>正负号</td></tr><tr><td>$\mp$</td><td><code>\mp</code></td><td>负正号</td></tr><tr><td>$\times$</td><td><code>\times</code></td><td>乘号</td></tr><tr><td>$\div$</td><td><code>\div</code></td><td>除号</td></tr><tr><td>$\ast$</td><td><code>\ast</code></td><td>星号</td></tr><tr><td>$\star$</td><td><code>\star</code></td><td></td></tr><tr><td>$mid$</td><td><code>\mid</code></td><td>竖线</td></tr><tr><td>$\nmid$</td><td><code>\nmid</code></td><td></td></tr><tr><td>$\circ$</td><td><code>\circ</code></td><td>圆圈</td></tr><tr><td>$\bullet$</td><td><code>\bullet</code></td><td></td></tr><tr><td>$cdot$</td><td><code>\cdot</code></td><td>点</td></tr><tr><td>$\wr$</td><td><code>\wr</code></td><td></td></tr><tr><td>$\diamond$</td><td><code>\diamond</code></td><td></td></tr><tr><td>$\Diamond$</td><td><code>\Diamond</code></td><td></td></tr><tr><td>$\triangle$</td><td><code>\triangle</code></td><td></td></tr><tr><td>$\bigtriangleup$</td><td><code>\bigtriangleup</code></td><td></td></tr><tr><td>$\bigtriangledown$</td><td><code>\bigtriangledown</code></td><td></td></tr><tr><td>$\triangleleft$</td><td><code>\triangleleft</code></td><td></td></tr><tr><td>$\triangleright$</td><td><code>\triangleright</code></td><td></td></tr><tr><td>$\lhd$</td><td><code>\lhd</code></td><td></td></tr><tr><td>$\rhd$</td><td><code>\rhd</code></td><td></td></tr><tr><td>$\unlhd$</td><td><code>\unlhd</code></td><td></td></tr><tr><td>$\unrhd$</td><td><code>\unrhd</code></td><td></td></tr><tr><td>$\circ$</td><td><code>\circ</code></td><td></td></tr><tr><td>$\bigcirc$</td><td><code>\bigcirc</code></td><td></td></tr><tr><td>$\odot$</td><td><code>\odot</code></td><td></td></tr><tr><td>$\bigodot$</td><td><code>\bigodot</code></td><td>点积</td></tr><tr><td>$\oslash$</td><td><code>\oslash</code></td><td></td></tr><tr><td>$\ominus$</td><td><code>\ominus</code></td><td></td></tr><tr><td>$\otimes$</td><td><code>\otimes</code></td><td></td></tr><tr><td>$\bigotimes$</td><td><code>\bigotimes</code></td><td>克罗内克积</td></tr><tr><td>$\oplus$</td><td><code>\oplus</code></td><td></td></tr><tr><td>$\bigoplus$</td><td><code>\bigoplus</code></td><td>异或</td></tr><tr><td>$\dagger$</td><td><code>\dagger</code></td><td></td></tr><tr><td>$\ddagger$</td><td><code>\ddagger</code></td><td></td></tr><tr><td>$\amalg$</td><td><code>\amalg</code></td><td></td></tr></tbody></table><h2 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\leq$</td><td><code>\leq</code></td><td>小于等于</td></tr><tr><td>$\geq$</td><td><code>\geq</code></td><td>大于等于</td></tr><tr><td>$\equiv$</td><td><code>\equiv</code></td><td>全等于</td></tr><tr><td>$\models$</td><td><code>\models</code></td><td></td></tr><tr><td>$\prec$</td><td><code>\prec</code></td><td></td></tr><tr><td>$\succ$</td><td><code>\succ</code></td><td></td></tr><tr><td>$\sim$</td><td><code>\sim</code></td><td></td></tr><tr><td>$\perp$</td><td><code>\perp</code></td><td></td></tr><tr><td>$\preceq$</td><td><code>\preceq</code></td><td></td></tr><tr><td>$\succeq$</td><td><code>\succeq</code></td><td></td></tr><tr><td>$\simeq$</td><td><code>\simeq</code></td><td></td></tr><tr><td>$\mid$∣</td><td><code>\mid</code></td><td></td></tr><tr><td>$\ll$</td><td><code>\ll</code></td><td></td></tr><tr><td>$\gg$</td><td><code>\gg</code></td><td></td></tr><tr><td>$\asymp$</td><td><code>\asymp</code></td><td></td></tr><tr><td>$\parallel$</td><td><code>\parallel</code></td><td></td></tr><tr><td>$\approx$</td><td><code>\approx</code></td><td></td></tr><tr><td>$\cong$</td><td><code>\cong</code></td><td></td></tr><tr><td>$\neq$</td><td><code>\neq</code></td><td>不等于</td></tr><tr><td>$\doteq$</td><td><code>\doteq</code></td><td></td></tr><tr><td>$\propto$</td><td><code>\propto</code></td><td></td></tr><tr><td>$\bowtie$</td><td><code>\bowtie</code></td><td></td></tr><tr><td>$\Join$</td><td><code>\Join</code></td><td></td></tr><tr><td>$\smile$</td><td><code>\smile</code></td><td></td></tr><tr><td>$\frown$</td><td><code>\frown</code></td><td></td></tr><tr><td>$\vdash$</td><td><code>\vdash</code></td><td></td></tr><tr><td>$\dashv$</td><td><code>\dashv</code></td><td></td></tr></tbody></table><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\lim$</td><td><code>\lim</code></td><td>极限使用<code>\lim</code></td></tr><tr><td>$\rightarrow$</td><td><code>\rightarrow</code></td><td>趋向于使用<code>\rightarrow</code></td></tr><tr><td>$\infty$</td><td><code>\infty</code></td><td>无穷使用<code>\infty</code></td></tr><tr><td>$\lim_{n\rightarrow+\infty}n$</td><td><code>\lim_&#123;n\rightarrow+\infty&#125;n</code></td><td></td></tr></tbody></table><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\vec{a}$</td><td><code>\vec&#123;a&#125;</code></td><td>向量使用<code>\vec&#123;a&#125;</code></td></tr><tr><td>$J(\mathbf{w})$</td><td><code>J(\mathbf&#123;w&#125;)</code></td><td>向量使用<code>\mathbf&#123;w&#125;</code></td></tr></tbody></table><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>模运算使用<code>\pmod</code>来表示。示例如下：</p><p><strong>数学算式：</strong></p><p>$$<br>a \equiv b \pmod n<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$a \equiv b \pmod n$</code></pre></div></figure><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\uparrow$</td><td><code>\uparrow</code></td><td></td></tr><tr><td>$\downarrow$</td><td><code>\downarrow</code></td><td></td></tr><tr><td>$\updownarrow$</td><td><code>\updownarrow</code></td><td></td></tr><tr><td>$\Uparrow$</td><td><code>\Uparrow</code></td><td></td></tr><tr><td>$\Downarrow$</td><td><code>\Downarrow</code></td><td></td></tr><tr><td>$\Updownarrow$</td><td><code>\Updownarrow</code></td><td></td></tr><tr><td>$\rightarrow$</td><td><code>\rightarrow</code></td><td></td></tr><tr><td>$\leftarrow$</td><td><code>\leftarrow</code></td><td></td></tr><tr><td>$\leftrightarrow$</td><td><code>\leftrightarrow</code></td><td></td></tr><tr><td>$\Rightarrow$</td><td><code>\Rightarrow</code></td><td></td></tr><tr><td>$\Leftarrow$</td><td><code>\Leftarrow</code></td><td></td></tr><tr><td>$\Leftrightarrow$</td><td><code>\Leftrightarrow</code></td><td></td></tr><tr><td>$\longrightarrow$</td><td><code>\longrightarrow</code></td><td></td></tr><tr><td>$\longleftarrow$</td><td><code>\longleftarrow</code></td><td></td></tr><tr><td>$\longleftrightarrow$</td><td><code>\longleftrightarrow</code></td><td></td></tr><tr><td>$\Longrightarrow$</td><td><code>\Longrightarrow</code></td><td></td></tr><tr><td>$\Longleftarrow$</td><td><code>\Longleftarrow</code></td><td></td></tr><tr><td>$\Longleftrightarrow$</td><td><code>\Longleftrightarrow</code></td><td></td></tr><tr><td>$\mapsto$</td><td><code>\mapsto</code></td><td></td></tr><tr><td>$\longmapsto$</td><td><code>\longmapsto</code></td><td></td></tr><tr><td>$\hookleftarrow$</td><td><code>\hookleftarrow</code></td><td></td></tr><tr><td>$\hookrightarrow$</td><td><code>\hookrightarrow</code></td><td></td></tr><tr><td>$\rightharpoonup$</td><td><code>\rightharpoonup</code></td><td></td></tr><tr><td>$\leftharpoondown$</td><td><code>\leftharpoondown</code></td><td></td></tr><tr><td>$\rightleftharpoons$</td><td><code>\rightleftharpoons</code></td><td></td></tr><tr><td>$\leftharpoonup$</td><td><code>\leftharpoonup</code></td><td></td></tr><tr><td>$\rightharpoondown$</td><td><code>\rightharpoondown</code></td><td></td></tr><tr><td>$\leadsto$</td><td><code>\leadsto</code></td><td></td></tr><tr><td>$\nearrow$</td><td><code>\nearrow</code></td><td></td></tr><tr><td>$\searrow$</td><td><code>\searrow</code></td><td></td></tr><tr><td>$\swarrow$</td><td><code>\swarrow</code></td><td></td></tr><tr><td>$\nwarrow$</td><td><code>\nwarrow</code></td><td></td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\emptyset$</td><td><code>\emptyset</code></td><td>空集</td></tr><tr><td>$\varnothing$</td><td><code>\varnothing</code></td><td>空</td></tr><tr><td>$\in$</td><td><code>\in</code></td><td>属于</td></tr><tr><td>$\ni$</td><td><code>\ni</code></td><td></td></tr><tr><td>$\notin$</td><td><code>\notin</code></td><td>不属于</td></tr><tr><td>$\subset$</td><td><code>\subset</code></td><td>子集</td></tr><tr><td>$\supset$</td><td><code>\supset</code></td><td>父集</td></tr><tr><td>$\not\subset$</td><td><code>\not\subset</code></td><td>非子集</td></tr><tr><td>$\subseteq$</td><td><code>\subseteq</code></td><td>真子集</td></tr><tr><td>$\subsetneq$</td><td><code>\subsetneq</code></td><td>非子集</td></tr><tr><td>$\supseteq$</td><td><code>\supseteq</code></td><td></td></tr><tr><td>$\cup$</td><td><code>\cup</code></td><td>并集</td></tr><tr><td>$\bigcup$</td><td><code>\bigcup</code></td><td>并集</td></tr><tr><td>$\cap$</td><td><code>\cap</code></td><td>交集</td></tr><tr><td>$\bigcap$</td><td><code>\bigcap</code></td><td>交集</td></tr><tr><td>$\uplus$</td><td><code>\uplus</code></td><td>多重集</td></tr><tr><td>$\biguplus$</td><td><code>\biguplus</code></td><td>多重集</td></tr><tr><td>$\sqsubset$</td><td><code>\sqsubset</code></td><td></td></tr><tr><td>$\sqsupset$</td><td><code>\sqsupset</code></td><td></td></tr><tr><td>$\sqcap$</td><td><code>\sqcap</code></td><td></td></tr><tr><td>$\sqsubseteq$</td><td><code>\sqsubseteq</code></td><td></td></tr><tr><td>$\sqsupseteq$</td><td><code>\sqsupseteq</code></td><td></td></tr><tr><td>$\vee$</td><td><code>\vee</code></td><td></td></tr><tr><td>$\wedge$</td><td><code>\wedge</code></td><td></td></tr><tr><td>$\setminus$</td><td><code>\setminus</code></td><td>差集</td></tr></tbody></table><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\prime$</td><td><code>\prime</code></td><td>一阶导数</td></tr><tr><td>$\int$</td><td><code>\int</code></td><td>一重积分</td></tr><tr><td>$\iint$</td><td><code>\iint</code></td><td>双重积分</td></tr><tr><td>$\iiint$</td><td><code>\iiint</code></td><td>三重积分</td></tr><tr><td>$\oint$</td><td><code>\oint</code></td><td>曲线积分</td></tr><tr><td>$\nabla$</td><td><code>\nabla</code></td><td>梯度</td></tr><tr><td>$\int_0^2 x^2 dx$</td><td><code>\int_0^2 x^2 dx</code></td><td>其他的积分符号类似</td></tr></tbody></table><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\because$</td><td><code>\because</code></td><td>因为</td></tr><tr><td>$\therefore$</td><td><code>\therefore</code></td><td>所以</td></tr><tr><td>$\forall$</td><td><code>\forall</code></td><td>任意</td></tr><tr><td>$\exists$</td><td><code>\exists</code></td><td>存在</td></tr><tr><td>$\vee$</td><td><code>\vee</code></td><td>逻辑与</td></tr><tr><td>$\wedge$</td><td><code>\wedge</code></td><td>逻辑或</td></tr><tr><td>$\bigvee$</td><td><code>\bigvee</code></td><td>逻辑与</td></tr><tr><td>$\bigwedge$</td><td><code>\bigwedge</code></td><td>逻辑或</td></tr></tbody></table><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>大写</th><th>Markdown公式</th><th>小写</th><th>Markdown公式</th></tr></thead><tbody><tr><td>$\Alpha$</td><td><code>\Alpha</code></td><td>$\alpha$</td><td><code>\alpha</code></td></tr><tr><td>$\Beta$</td><td><code>\Beta</code></td><td>$\beta$</td><td><code>\beta</code></td></tr><tr><td>$\Gamma$</td><td><code>\Gamma</code></td><td>$\gamma$</td><td><code>\gamma</code></td></tr><tr><td>$\Delta$</td><td><code>\Delta</code></td><td>$\delta$</td><td><code>\delta</code></td></tr><tr><td>$\Epsilon$</td><td><code>\Epsilon</code></td><td>$\epsilon$</td><td><code>\epsilon</code></td></tr><tr><td>$\varepsilon$</td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr><td>$\Zeta$</td><td><code>\Zeta</code></td><td>$\zeta$</td><td><code>\zeta</code></td></tr><tr><td>$\Eta$</td><td><code>\Eta</code></td><td>$\eta$</td><td><code>\eta</code></td></tr><tr><td>$\Theta$</td><td><code>\Theta</code></td><td>$\theta$</td><td><code>\theta</code></td></tr><tr><td>$\Iota$</td><td><code>\Iota</code></td><td>$\iota$</td><td><code>\iota</code></td></tr><tr><td>$\Kappa$</td><td><code>\Kappa</code></td><td>$\kappa$</td><td><code>\kappa</code></td></tr><tr><td>$\Lambda$</td><td><code>\Lambda</code></td><td>$\lambda$</td><td><code>\lambda</code></td></tr><tr><td>$\Mu$</td><td><code>\Mu</code></td><td>$\mu$</td><td><code>\mu</code></td></tr><tr><td>$\Nu$</td><td><code>\Nu</code></td><td>$\nu$</td><td><code>\nu</code></td></tr><tr><td>$\Xi$</td><td><code>\Xi</code></td><td>$\xi$</td><td><code>\xi</code></td></tr><tr><td>$\Omicron$</td><td><code>\Omicron</code></td><td>$\omicron$</td><td><code>\omicron</code></td></tr><tr><td>$\Pi$</td><td><code>\Pi</code></td><td>$\pi$</td><td><code>\pi</code></td></tr><tr><td>$\Rho$</td><td><code>\Rho</code></td><td>$\rho$</td><td><code>\rho</code></td></tr><tr><td>$\Sigma$</td><td><code>\Sigma</code></td><td>$\sigma$</td><td><code>\sigma</code></td></tr><tr><td>$\Tau$</td><td><code>\Tau</code></td><td>$\tau$</td><td><code>\tau</code></td></tr><tr><td>$\Upsilon$</td><td><code>\Upsilon</code></td><td>$\upsilon$</td><td><code>\upsilon</code></td></tr><tr><td>$\Phi$</td><td><code>\Phi</code></td><td>$\phi$</td><td><code>\phi</code></td></tr><tr><td>$\varphi$</td><td><code>\varphi</code></td><td></td><td></td></tr><tr><td>$\Chi$</td><td><code>\Chi</code></td><td>$\chi$</td><td><code>\chi</code></td></tr><tr><td>$\Psi$</td><td><code>\Psi</code></td><td>$\psi$</td><td><code>\psi</code></td></tr><tr><td>$\Omega$</td><td><code>\Omega</code></td><td>$\omega$</td><td><code>\omega</code></td></tr></tbody></table><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>不同省略号的区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\dots$</td><td><code>\dots</code></td><td>一般用于有下标的序列</td></tr><tr><td>$\ldots$</td><td><code>\ldots</code></td><td></td></tr><tr><td>$\cdots$</td><td><code>\cdots</code></td><td>纵向位置比\dots稍高</td></tr><tr><td>$\vdots$</td><td><code>\vdots</code></td><td>竖向</td></tr><tr><td>$\ddots$</td><td><code>\ddots</code></td><td></td></tr></tbody></table><p>示例如下：</p><p><strong>数学算式：</strong></p><p>$$<br>x_1, x_2, \dots, x_n \quad \quad 1, 2, \cdots, n \quad \quad \vdots \quad\quad \ddots<br>$$</p><p><strong>Markdown公式：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$x_1, x_2, \dots, x_n \quad \quad 1, 2, \cdots, n \quad \quad \vdots \quad\quad \ddots$$</code></pre></div></figure><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$123!123$</td><td><code>123\!123</code></td><td>空格距离：<code>-3/18 em</code></td></tr><tr><td>$123,123$</td><td><code>123\,123</code></td><td>空格距离：<code>3/18 em</code></td></tr><tr><td>$123:123$</td><td><code>123\:123</code></td><td>空格距离：<code>4/18 em</code></td></tr><tr><td>$123;123$</td><td><code>123\;123</code></td><td>空格距离：<code>5/18 em</code></td></tr><tr><td>$123\quad123$</td><td><code>123\quad123</code></td><td>空格距离：<code>1 em</code></td></tr><tr><td>$123\qquad123$</td><td><code>123\qquad123</code></td><td>空格距离：<code>2 em</code></td></tr></tbody></table><blockquote><p>上表中的<code>em</code>是指当前文本中文本的字体尺寸</p></blockquote><h2 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h2><table><thead><tr><th>数学算式</th><th>Markdown公式</th><th>核心语法</th></tr></thead><tbody><tr><td>$\aleph$</td><td><code>\aleph</code></td><td></td></tr><tr><td>$\hbar$</td><td><code>\hbar</code></td><td></td></tr><tr><td>$\imath$</td><td><code>\imath</code></td><td></td></tr><tr><td>$\jmath$</td><td><code>\jmath</code></td><td></td></tr><tr><td>$\ell$</td><td><code>\ell</code></td><td></td></tr><tr><td>$\wp$</td><td><code>\wp</code></td><td></td></tr><tr><td>$\Re$</td><td><code>\Re</code></td><td></td></tr><tr><td>$\Im$</td><td><code>\Im</code></td><td></td></tr><tr><td>$\mho$</td><td><code>\mho</code></td><td></td></tr><tr><td>$\nabla$</td><td><code>\nabla</code></td><td></td></tr><tr><td>$\surd$</td><td><code>\surd</code></td><td></td></tr><tr><td>$\top$</td><td><code>\top</code></td><td></td></tr><tr><td>$\bot$</td><td><code>\bot</code></td><td></td></tr><tr><td>$\neg$</td><td><code>\neg</code></td><td></td></tr><tr><td>$\flat$</td><td><code>\flat</code></td><td></td></tr><tr><td>$\natural$</td><td><code>\natural</code></td><td></td></tr><tr><td>$\sharp$</td><td><code>\sharp</code></td><td></td></tr><tr><td>$\backslash$</td><td><code>\backslash</code></td><td></td></tr><tr><td>$\partial$</td><td><code>\partial</code></td><td></td></tr><tr><td>$\Box$</td><td><code>\Box</code></td><td></td></tr><tr><td>$\clubsuit$</td><td><code>\clubsuit</code></td><td></td></tr><tr><td>$\diamondsuit$</td><td><code>\diamondsuit</code></td><td></td></tr><tr><td>$\heartsuit$</td><td><code>\heartsuit</code></td><td></td></tr><tr><td>$\spadesuit$</td><td><code>\spadesuit</code></td><td></td></tr></tbody></table><h2 id="表格格式设置"><a href="#表格格式设置" class="headerlink" title="表格格式设置"></a>表格格式设置</h2><p>一般使用 <code>|--|--|</code>，这样的形式来创建表格。</p><ul><li>列样式可以是<code>c</code>，<code>l</code>，<code>r</code> 分别表示居中，左，右对齐；</li><li>使用 <code>|</code> 表示一条竖线；</li><li>表格中各行使用<code>\</code> 分隔，各列使用<code>&amp;</code> 分隔；</li><li>使用<code>\hline</code> 在本行前加入一条直线。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-人工智能研究小计2</title>
    <link href="/doc/bbbc9fde.html"/>
    <url>/doc/bbbc9fde.html</url>
    
    <content type="html"><![CDATA[<p>接着之前的研究和想法继续…我猜想: </p><p>神经元之间应该是先进行电信号传导，因长期的电信号接受为方便以后更加便捷的信号传递而产生了联系，转变为化学信号传导，降低了该信号源的激活阈值活，使其更容易激活(表现在计算机的神经网络中可能是参数的变化，也可能是激活函数的不同)。</p><p>神经细胞激活的阈值应该是一个临界范围，这个范围可以上下抖动，抖动范围每个都有所不同。</p><p>若长时间未进行激活，就会随着时间丢失传导通道(遗忘)。同样的，就会丢掉记忆和意识。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源Proxy-Clash</title>
    <link href="/doc/62f5ca67.html"/>
    <url>/doc/62f5ca67.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对哦, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~">  <script id="hbeData" type="hbeData" data-hmacdigest="d19f6f8ca01b33dadcd56ede79c1f71953a037139511cc659ddcc218499c7b10">890efb48042b9e3863804653b4caada50fa13185a5606769f401c22a49afbc875f533c999fe6145327e661c7ddb354392131b63b1ce5e2f604a7e0f6f45e4dcc514d68aa012d98383c9e72ed642f24f93ed423fbe98cfd15ef590ff7410bb3dcc923165ff957691b462434cf768ad8f7027bba70e30e60a9206f68d5287d6b18d5c374aa5829a6819163be5dc0790447d2df3493913270e37776acbac09fd46cfdd625aa6fd8e5191909581a7959625479450b383df86500ce06332664bbadf8b310acdfa5dca48eea1e6a633e1711b653afb8037872c1007a0dbba686d976e581569b374ca7804b492c468b8f677b7bbf88fcd9e93a7b2da52b21f717e5b3cc8cc6dabd97de7e9c8a2f6da5838c7d7415b02706a753d7f0dc7ba6997faffb8dd31c6894fd884479c01cc97ceef157b25f9feaf482e1d61a01da70be0a24119a80203cd179c0c97eb29682dfe27d716966428ee677e7cd0cc1568bd20b63e0a5ec63541cb2766d0e58ee013cc8f41a71414d17f6aba3489b67f5bd97ebf9303b4775d55f9fe524dbb87c9e4ca150cf2606265f22004ca2e9cdeeb4fd724111d1696a194844d880e4f5834bf29199a72a86ef066dd3a99fc7919f41bd533bb1b8062fed502dbc2b285c2b542361f24ca17d25a447d6a1f2f5b4846fb4fdcc75ddf0ba5c0323a81161e9d65ca8b4db01e064d21fae3b05cbfe956ff80ef86519906d0c988494cdf5474090f18df27935397ec9ed686fd5e0dce08320fd6791144485e6754015aa9a4e099d216247e86431a952d23854dbba9b7aed24a261f263d883df940b7227d246bd2168604d7e398ef2d318a6aff27380eae8a962e32d4871effde75b0852526fb2d080ccf5cf80041f776a72d58dafe069dc6a7ad2e1a2a55a1d868d7ffce722f56bb017f56298c356d6d8c2e2ea7fbe4df433be640ead74939d681e87c81198e4ba87e88679e5000a1f2e4c9193fe249ff55056927d32a5853b98c02181e6d6192c0824e26c1c9887746eb08ada694d92b9ce739aa70dc2a66e70ec955e080a55551c41eed54ec5316c5ae373004f32d2d049dcc623a3cf3df13287d0b6c57b1494367f26526420ac38f8746f6d05b6f01ec2d7ebb9614a8f70a6db67a7511f33ff446c02b7d2deeda473e93ec2013dc90f071045688108878f3aaa1b7e9f4c0bb731a15567e9a37dc9bc2538503a8c14b52a433729b9805ce70ce36356709c02ad8149fe165036e9a377c47c538bfab9b0cfc1576109de58b978dba41f7705f50f2476ae2ddfd4e7da512447c93ad847267fb7a821f5da7955184afcf81ce3694a21f6368457d40f3757caa62622d2ba9b19409d278ff060ee6a75d7d7399a3ef4d71a5d95cbbc66a9fc62a370b18f057861d82f576374098c85e90f442e8dd227787cf2a1834428ecfc133ae911590808267d844c467c25a576522722342527b764c59e14d20bf67b43126181da79ddcd914ca4c31564b9d12803f8759dea3cd02fcd29ba1a5e91891495ae8cb2f4f2816f0d1c955d57cfa0a189c3f6ea032ae88ff6200be15a6e999d612d72a16276f95d032a561d33b05f44803876678ff1cbd71a7ee69c8bcae4b399b0f5aa31f119b69d1c624cdb81b25c5d811c5ccad86b710fdda7ae953698a25afd4e5054ab590e2e0a933beddbb4ed63ef75fc4d143fdeb39b20fd865ac690b2b5cdc276f5fa51a26b7a26b8eccdc02797e83f7aba104381dc5340263e5c8e872d0b1f5b2d0e7578f3c50f38df77db921a66a5e6259722fbf78f578cc3ce4f197f2f88f402df1483c47dd4648ef7e700a571315c0243bfe062b27d5fec73b2a8faf3f5317078740f86cc6f68cc2a593f8a41cf35ec4c2bdab4f78f7ace7487772889a0f482dc66059156cc7787cecdef960db4e7e48510ff6ea3776fa2e66e3a35c0178c6fa1fb6cdd8bf57dcf7abd501d557a23e127c51e8b6270c633e86f11ab0a8ac3f07574cf9d50f1b10e56070c4cae7a452dede28b942d015423a8110c85f212edbb8033c9f704e4522577e7158a840ea7bbc16cffdf7c9f7449faacb38d21fc66186422ef8f7b341ee3e89ba7b398a2a7bc85df5e2334fb5188de93b95aecd6ad34605c2a4ac3b553d016b8ac92f200c4fd7c887c20d5f951a230684b839c5186d958330af7e3a76615610a0f9ef59cc14a9ca425b76be947a42444b093105fa8afc5f45d12d685a4af139c8781b113aaf315c0cb9041ddb6894e4d3db5019eaec33aacb07f1069e08c705fad83d4f8205e1db8ea1c5d44fe3d63dcf4278a0d6e0103d400f465bac3a9772e9dd980c7d2c132d001fa7e6e28f721bdd4ddae5291004b300a63dcf1090cb1710bd6cddb016f35c5ccbd799ae487356501fec87187a00370268450fd992cb63843eb57f2a8214695c7eb1938cabfdd8f05b90bf33a1b9cdde296c37d7b335d851515d68aae751be40fdaf6b2459996c21b8303be8d01bc9fec1e03011035e781d9cf79a0f49840aec19d79bc87c07deace2add2db880a7fb907e955fdc658bffefa333f2aa574026e06450a33ae6df5e0bfaca98455191437ebeb284305c224915449e15a50c9e2b1c238e293cc756441e5a9e8c90431e15db9379f652a9222171ed74de4b77134a0a91a520a1f150c9e797efa370507da8e0ee0dec811466d99b96fa9a0039933ad6d7203847fa6d1387159f5ed69220fec27600936db53a51705df85fe700dc198e50a25c9f7a90bb8ac1ff27470614f7e69e76ab65c3752faad9fdcaaa9036d4ccb7bf1a0d553680feb09d84446318d48a297c5653e78c3e672e8c8a283cf7df04c6b68378f37a7016baf0798b1aeec74988ea554311afca1481b32dcb5346de6e9ec05c7ccd2fcb888cfe9f60951f0d668e3bd898102135b205b3d5df57a5d458486a8138765b9ec3ad2687348d7051abd046641df2da9132a4e879c0c1bfed987508e363bf6b0608a482398b6ba4e8dafd5ebe2f2cfa4568e033c0052bb15d04c829b1050288ea6df2498470c41eeb7758925b96a8e79adefd45682486374ed54445deb5cbb0db8a462f80013a2a7d51b6d73f62af111fc09423951119a8edbad90d96f8de89b051cc8b330c0db9780adf7758e62e1737970fbf1ebf87001856f40195494290de3a648999c1ccfca8ede1680b3393202b1f301a19bff7c158999592dea443d0a2cd161f71b2db5d03c46b9d8d5a4352e90fed0088b1e062d0850bd47a8c5c15ba9bb104a3ee2b8354603c7555c118a4ee90602651b27bfb49f68840f6efcf9c1a663a7e88039ac63e944ee49f1f288e6b7cfa554c3a06fc58b7cfb7635e8142b5c7d5405f0f3fde4e67dbccde869cb541cc03055044ab2cb3249ce4ea0b7eea42d39e7a1a37b4e5312e6f6a75944dbc6d5e4e3bef3dfb59d53a53ebe666860e085e81c4b606b1ab3201ade687a0cae230f2fd5456236d81a13fef92cb8949276597efe1d8d876714e9b77e472bd0ef8edc2963cf76a37286218707435d0a03c91c408c5e863f32e04f8dcd4aa7c1c0b72b6f19d7f2da093113de31bd131504a14d1f79709a75561a8c7882007cd8ae350465b9ae676be31e260d0a07071d765b90315d91f8388b63b1d8b29cea2d5e8703ad41a612ee30b502e06ecbb07ccd9d844d87d92d995ecb306e9b6d46b79741aaf99049e7a890946ad882e423c4041a2bf2732b541d6d0bafcfe4cdfd02b0efe5c33255b832dc4d7def9d5b65bd4c60aeba0fe4445fd6d82918ef27446db96089dace45e0b0158ad22ea47ed5021864eca3d5f8324d0ec57c4f26543444e461965e80f5b425cb2860d95fc379aa901783683f26fa1f5eeeb24b9630cfa63c6396f0d7bf4194e4581e40fb33ce43a6e23e5b0d1f1c3d8130445a677b57423254a546673517247986bd4ed423472329412aafd5e6d451d21fd31c2201350f950f0a5dd21468691c3ec50dacc4ec20a07c1ae4283506ab8d7df674528527bed7d7625b0002a07f828f3229c21b49a7e7877705e0531c27b55a6e92599208a4295ffe1d7c893f963a38338a970373b33a087492784f571ba0fbb0729c183eeead56a3f7900db6cc2b080c605f08953a58a40e42bd2d5be209fb0042bbff1579e111d225008e6ede1a53d3266dc53abba978fb0a94042cace3a681f8f4e8fb23d97e5ece2726b92e001e29cc81379096fc153a1ff523d2cc53eabdd07b2017ba41932ab75087f23fc9657fb34dc05c2529a18295f0c559166da02a1971c6519defe410b45d204e9752c3226fd1734d2b0df5057f70b7460fde332f09651be0cc505c4db474a3475950b3071232aa106112d3b575147dc84ad739131880e61ee625ce8024d0d15c23cf2c100383f8606d52779cd7b7cf2fc037aa3b8da5b45650e4111cf2bab5960d8c4299b2fb603401eeea0567a20bbab2e7f35db069ca12af31705f77847f57f4549359658aef4cb323f3ee3b1c66c12ae6b57d11c6b950379fe2ad49cf8ac3b683201916916f5b8990bb681bac0bbc980fb19972f797dfba958ae94be8188625d72ee84bc31e2f0fc560e5c38ec6fca96e557da553306534fe4a83ae95a354fd07852fab24959c2ef0b4124f1314604a1100819d3287c92789878824295bfe7a34a1b08665b6dfc8a7b1a752345794325634489f19cd3854b2ee819c922e1dc387bb5bd50cc480512713e1146c49c3c5a20596b2df28dfe5b6ad47b12dbccc77186755bc543dc607a6a5bd6a76f3cdc0fe753fc50261c58d904af4b777d1c3a8e3a7a299387def4503de602f285ae8a55f0a416071975abe56a8e98ae72bd81e75758b8de0a1eacb5eb31523252f8357991c46d64c755b0bb50f7e3a8d3c68b9e063e1dc22406bd03818141af8a6b858053b51d4cc73123ef81de2c9bcef149db0547bdca7736eb8da8236f3d77f3d5282b1a4cc4067053b8c27a2439abaacbdbdb6311484f707fd239c642b1db68b2cefe1e33bc6a31f982fc65a4476bace7acf90984f2fd15a66d9120c58df2fb0016b545e59b49a7cecef5244d22cb3338e8f40561ab219986be5c626acd619b8e0a5b75ebe3e67e47bf5a0938434ebf314ca3c615c3f6b7148298decbe12f4ceef378ac1f5358c3e6555964ab4a4fa3641a673d67e495e54e006608ac674f68e9accc8bf789a40df2fa28fd6396fe29f9136540725f6a1762a062d71bf2362e6a00f8429d49bb29d0bed56fdd34db5810f50e99d82ac56682a255234c60ff85cc63991a650c1e4a09307272b9b530f129c8c73180ec7f1fcceabf93db8642fc33dd5f1b103892f9f3855a0d60af119e052f4322120cc21bdfe30a12d252323b6b8c08429764c8dc8ce35da15e999f655c4c98bf0bea22a25579d004a20d32a6707a7a756b59023e7525aecce4b5d96d06b910496652a7a58ba15af45c288a402b2a621f169176193d697ac8c25b40a5d358ff3143fcd0c68ca7c9cb1156d1a9d2d67e874e53c0ec1dc276d8d310a0089425facf245712ee427659eb74e73a51acaf4bde8d25c27d3e7171397d69ec0218d2525ffe532ab7473f93a8bc213596af5c10f7c68dca819e21e9877cfced7fccf1bf537e36d608270160e895e3cd9cdafe3eac06e9347c86c0bc1bf9457eadd1513ac8fc9658c4a3d667e20b6a5cc930584c2e0349c1b7c1cb77ecb7040331dce8d0c4abc8942b9a7b878fa6f79babb7e5b3871acb9c6354b53139efcf9c99f8e680a82bd04ef059b2d029bc23ae47c652e909c3e951ec3b4b8c6bfb650de8e05cc7844e5b6c068e92798eedc75c70957584c15e7197420d6ab8a1317efb2340675a23339f816cbcd6604fddbfc2a1109f9d408953b9f64f8038678f07372af1b702f8e53095a11ffdb564637f50a73e0358ee07eb64a75e8920dde173aac11ef4b64d491e352bc18713370ad9935e7f3603eb1a7e0a70630ff379761b9c044b6d7cf28abe7aa411458e8ff270361622f8057c24aaf1f85bd3ed3206d800e92890a15ed844d13de3c03844ac22d70c1352f826bce9886d5c70e5dd8934f75be00da7735c62422034305683240e6c432ac1b38b88ffc974eb147a73a1547b2de8da1580f301c1753c6ba16fdcfe79949e2b03e0e4d6727734d9ed528b95421701aa7d4deace1522dc09f7f971b95172a9cf9bb8047590ad0bd042669a599a699f9c37abeb1c42dd277efcb3c2efdb4d97e16f44327c8465b48f035396d4bb18151c7260009c7a1d265ca775e6f838a65843fd9fc00ea0d6e74a945af3751bb658c912f73a5bf0fdb723daf6d2677d09f18781a8b0f600ebd595235cdf4855656d9a6e6016a9e58f63a95a5dd5e6612c8d8605a873b2bd3216e5b8e744523aac28c33359025c296bca547f8caeb7f5cf49c229d09518b176c7fca4d19f1a69e9e68e0a0032295fd5665aef915d6df6575877174a09084ad9115f24283c435df6f6f89d22dce03ec567a1979405f1abd5786a580dc25d7362fe4c55848c5d08cbfc27db8fca0309e3fcbe217e8331bd26a3594b4fd1d351947bf456dbaff643391689ef00d702c4514e7b81937e877fb4aac5be76318d91d132b0c9c6633a9424158494f3b48c8e5e031b3bf8f145cba190c01ea334b012a71d5d45ac533ac6fd5bae5dd5852f353658deb0ac042fbec9eb96008bda436ebdd82d2b49832ab3107d9105d56f9b42abc46db6204eeb0170cbb19b1327499ea725d1952d61071efbd313890257f3f8c9602f20f0b13a49f901a63819c9137fbf4564a8c1d106f01bddd8946ced77d7fdff0db7c16322bf0b7eba6e3d206c403da298f5a1d181bbbe6137e640a5f058dd7050e32b05c4e77132008e3d00995d313b03edf845af2745903884eab52527a368296a42c4c6a043a4c14b71b74ca925bafc39fd2639a1fe015c4001a394ffe5fefede3c59f0111dca4b6f4900cae9a0ff66324495f9131b6937c7b7c49e5935ff95c3eac3b67c711870ae3287c7e5f936bbda89cb3948b1f551c10a00cf7064d358a04e3e4dbf418346e2102751c3a7d7bcc607583b16425f4535bb52614b547dac66c8c80fa00b5559ff2546a771f82596c07fe5b72b065886c68fd47641a1a3b46a86de6cfa6aceab746f8aa7c98f0047e606c7adfa5d1f804ab87af2eb2e060d90a85e27d786a302c28924175fb88cfecfbdf223dff6618f43484e25ef0f6b0714cc4305468c837a27d1f7ab193dfc49320da70af2959c4a31846bef9b2a7e1545d837ffb930154b44d2e251d38dc63f841268dab2c0ffd7ea255599b315c8d09d06ed314dd8f6e5aa82e152afc3023c0813a9b3a9f604f6052f0a77ccb2a47a1a2dc9c87e4bb2e19263721b93ae79806de1952864a1a65f2e278e5a8599cde67dbe83b144af6a40685b75e302a80a3d8fac8029e91c697e5595ce099533b2043cb62eef06ad5072f35f9b90568f1b4f4c07d47447bc2b588d68ccdfef5093da9b81c39ff3657b23c08adba8e9362aee2ceeb5dc2eb16f04e78b4511daf632336d87a9b6de9b455d6f522576fe1e3dbdf4acc7872f2bf75873cb2d876a6f551af54d93a1983f3ffae0c1b3af2689263878de15971fe399c0a2da72598453996b39574e1455f0bb1c562d434e098422575b792425e1c30816b8cee29f164088f4344043288f17482e7449cd534962ea221e652f42b041118513adf636d46683ad44d03edcfdec58a7e2a83d6aaa42e1be92d83c25dccdaab1346718ce5d502b15598f6b15b1c8597b93869995a210a838773adac0f5018a56769136a75d65607d7fca0e9d75ddb1f6c35b7c99529986372d4bfd1b5e031245b21d80519ab9a2d7c4507d12037bacb0a9275e87f79fd3a24637a2658a97273c91f0b460d48d165739e02bbb69c56377b746e064731e090f8f75910b4e6cf4e37398a1ad66398aafeda2677c1c40de7de19f9d913ea5b1cdf7779ad0a82cd455aa9b8c385ef7d9a8349b17eb3dec4c98133ae59ef44c651be6d4e3e4720faa5be464eb229da8655994dc12ba982db850101e393468a22ddccd14c542fbd710e704eda851b380cc04d367649cf429165e1fc8260df6ad9497755735572ea72dd0a471bcdeb9d4fb5d96fa3795e91919290758f9acf4f724fb28d32ee0d29f31d93c11ee1539750c21d4ce534610883fde6b7a08358dece9def6d8bf3d6dae894b387c229f98ab600c8baeb6c563c4e6853c0d9cb0c938455929c803f15d7c8b631a06e87ee741e28717490230fae9916e9597b7a9887ec1577dacd0ef8d318abf560c22fc843a6e291f10f2a7ba637ab754acc3fdd332507a0ea1790c274623288eee6accda69cdf63506c502dfbe7c0871099847297fe44750efc884f5f465e34cdf43c7367185c40ea888326a32a90535c4ae68f257d5038e8e67852ed6a855665113bb79a2eaa5b96fb979a97db9003694be74d18ec985a0162a5a54c736f95c8110a5cab4bcc8b8b1eddf8e35fe155dfe806fbce4edb8465f1a30a8144edd3356e95d8f73e16db95c099b4410edb6c41e2c87b29fa0264f9010687f4c6f4ad3ef623d73ae26de1012c5fc3186b17233227332b0a3bb89c7d8047838e0b1d5dd6a9b4e39718498ff65c45d1604ed2843cd8cac90d88fe2f6e39a818f9fdb53e1204a11decb55d6c44739d09624363a685384c5a1e6d9e5392d703d7d622dd13aabcd523bb46e3793c839614b9484b5a958bce354dbd4b15b03007edc084143a75de721f1f396c975163c4a6b159786c02ac8d19a5fffb4590fd145c0cd4945ceb55ecf2d84c314348aae72c3b6a944aa727c1ead3aa6b98ac4df92b36b026a59deae2f14e00f3d04dc6a11deaacd523f413c58fffd977632cf9eb8fc658db75eed30c957fe9b008b4a0b0175f43fc1a6ba9e5c1678113231af3f4cd02132f35e33266ffbcedcc40d56d1799aa78888f44ff2744b9e15ef80ded3d488157b5dcecf4edbcd527b318e99820a3a6bea57fbab135c85905673a92c343ee55976220b67edd8579c5ec5b513a74f1b5ceff04cf8082c9909d0154286d4b0f6ba24690ba9286d16920dd49eb4b8becd7d09f71dd21657f76ce0330eab85f3dca8cf8a8ba10be4603b98660df4fbe9923305a225cea69e410b1fa2a8fc38658f1c32fce434e19fa005aac71296d8196b05a9947d40ebac06aed7b845dba360861f648e892d90a4b53d6057fb371fc8358a941a177000af152ec256eec21d993423bff94ad2ded15a4c476b228e2e59e808944ca0d285dd34b26c401d922311a057ede1ffa6e38391dafc4f8d63f331e5c063458de5b7a959e286b79b1a47cc8b7374f2e60d20dd59bb1f393eea4f163ea3e734f9d858a2e8932630edb7ce1fe0bb26fbb0f50b28b6b143288439981879fa3f299ea0ac6c4ebb4707f238438625ce02cdb9ec3bbf05b277662109e13bdf82a90e0080f8047265822eca90e6c4f53491bc81ed2557db89b09b296378619b098286ad48deb54bbfcf442ac027c2a2547644640d301bccb8942c16739ccc299c7d56c0a38753f82043bad864dca198c26f41afa7839fb034a51c817cfe71876f49ce022099f2ebc7e258a9d687b98f36389b774e1f8696dded4986eb622781e332001f91ebaf0128e4800c3addabc5a38203a727a4a2176e20eb1b9b6514b59e0aeb9274ea5b25a2b26c0b6878cd609010f8b3dd2dec807538b126aa83e1f2faf45d3221d0bed23de4543ed5e7e6d94fdfb675a0ca9cc1b7d1e3fc25e5fa64aa5a0477ce690f51f8298cc52595e7cfd7da59a88ed777341aa8b83e0a6a90c3482e65101aa090ebf7e2cb40e2d593b5dd50909bff14d1576987024550ade0f93d784b45d2d747ff585b46e82fdba082ca1bf658590a5b87108ad8f8fd283aa8fb878149327098b218282bcf8104a7df3b4708c80f2698a4dd802ebd0bf2a6762ace5355c22a4346e966616f6421587b735e07e5003ba622f0de02a06a66f8a8e84d7d46f5f79be56d83ec32e830b87875be29d6757ea9a7752393a5b1586b5e7ab36df0db74124aa9cf08f641680a14470858e753d80f09891f857fdeda542f007523fde369a03861231df6fed8066acd7834fd6ff0eb2e0f35b2c17a250fedb312b4e980df30ac545493f477594da5d6050572a576c819bccea2d0670aaf34f910147574a54f8a1657476467780f6feb9cd3ce6671b098410e32cab99af32de1b3dc45429e03cb3d181663a43572433f44b33fc983654e15510fafdd2bcd8d1f63ca295324a12d022fd19758c0d374a591d89a308e1394392e2654faf7a05d12bd8a674907d87a0cb857a6e532cf29b3c92419916c16081be7429bfbf93ef6db7d8e48de761a43a9d37f2082dd79eaa3503adeca55f875447ae3e7e13a8c346860adae5be64559be5ab055f5b6f94cb3669cda834996aa7a9c89e64b8db37bf1ffdcf986f1ac469a18a9709812c63a68953c201d4bc2487e2e8acf0478682f08dabc805e01cf0bbd71a1a7b8354c26a62f9e00110003134c5268955de7db3a7cd034288885721927d75d2e983c9ef01240fbb3202584545b38a4d5ac1229b1a2d6a564f1459f87d28dd23d65331811beafb3ee930f2e83d7168b2097d85ac315bd0c596c8f0f367d45d341b1d5da2054025b77a250f0ff97931015c6f2b80fa2f8f0eb1558bd87e7443b747b08eb0b3dfcced85049930e5408254d1dac32f856761f9a58039adda0c8c222db8c43ac95857bbce0030e0d1fd8f9884efc913625fd42449f577619501fb7a82820810929158f8086ee594a130107bd36cffafe7bf7dfe3c909a429661772a8697c654b6798ca4699529eeb7038ef3690dda533425e171b2c8a41a4a0dc03292053f3154074f680c602a95a57e86605355946bc056146bfbb6e6541a23baecc976dddec908ecf58060bf5982a10c88d1e3860bdc9aaf0897c099fe638f0843fab20538a0acaab95febc589d28eec8dfcc30a783d903c562bfd36bd6badd456007e54d8236c091460ebb138bf2fac275619b52e39399c507e6265e10aa5fdd804bf4d2339114a2147d19c735b645d9c8d263c7470549cbae25239ed9fca15501b230f484aa4dab28fc232c2362096e04ebbac9213c63ce60fa88a90e5fbcfa7948d4de54a05595ef7f876f6a8c245e9e6d4cda47bba6db8838181da17a1e1cebbadd9684ad8918c524a206af8dad671029ad5df8c05575d9a84fec68f4da415f4a5aa2a27b5aacb962688074ac815d8512fd81ffb5c4d63d4e7a7f50890e7af5969217cc90f3dcf18cdd57d90bfb3927ecbcf32ef1c60939bc16de4e720c719ebeeec3686a0501f1b3234e52b0c85f84ea420a179273c32a83828d505989ab01b97e47911065a1a4b74b11b863f3e79f0d7742875cac98fdf8b05239833c86da1f63d12c5dca0e77ad619ad3961c4d175ca37a0762e5e1e330a36a2118f87fc02cd9b818b11f2c752bfe8bf6a38c35052c33e280b444bd0ee06b730391ca7f23c914819b5fa27450a89cc7814d33179f316771eda0252b6bc48112679567dfd53884a2158fbfa2460ef6b595250faea51098317b3cacb42e984a05d48544f39be2ec0ad18a5b89f748921e8c358ace7a5f3240e6da7d40878bd0b847ff82c9b9eab0b38959a46281c98de2913146a5e7422e1ef876496b4886bd4e8352c78e7a13247fb0c077e3d53cf75f956094118d8314079e267bf3c8b801dac2468d6fc9f49a881c0e47e6885afd9856dc1a654b7d271daa7df1bbb9a01a8c1d44858316df73c5e7e221bb5d5d236eaab72ab9913d3f47f83240a905ef119990fe005c487a7dc1103ed365e9700e514c034aa324b24ff310e9b676c15d3693c07e8dbacba82f4e33ba1a44f7ffa3fd7332f6be0b2e98bd6264dc61b4db62d369c0a4b9d1bb602bcac6a57fdb309293252048f20341b44597b89180d262726e58229b881fe1579dd7285d4a81b6585090429aeff71ca349a69b42e3b7b7d6f48721692fd86c2c95a28cbe95aad74fd26a94af4bbcb07b0cc142f3336cd8c2cae6931f362c34940c619d1cef323acda8f8637cb19610eacd26a5e7a9b39c3977bee4324cb81c7a01f4d73401c6a1e338ec7f9eeef36c74d877f574e846d7ea58b2a78d03298c18d45fde168e68ea0249b9f9af873d86a9e88c3a2188cc15655fd7bd69813455420c7ac86e1ff5628e8fa670b5fec8638cfc04a3c5dd3f88bb71cfc663c8037f6e8d185e8f92c2712bc653879c96fd7f0dee0cc3cc39828bac728fbd55baa138b6459c5c83b471589fef2926949dc0d4cba0a6079cff0a9e8e69aa2c0bc8bb08222000de93e82d0b4e5624c4f1f509e5f7dab12fdcc75792ea60004362d27314dbc4e5f8d4455205e7728940e53077abf787fb93b952c76e33a90978f0607964cc42450bc0886f9182f5eccb55fcccde4ebdb53487b01157171a5bb66e729b43eab5cfa13f4a365237af52ca7b815179bc9896b08df0a2b3884cc09cfd7a747c4da5a96ae9b08b2cb08d79aab14bc2ebbb8f4462573ce6c54c8a20d44b07fada1e231659bf0948fbc8c0f97184f37f58be0c68564ce4f86725adf0d70f77e922f9b8dfc8bb4b2707c7a00c6c23b89d01afa5ab91e6aeef7ad051514cbc17169e89b1c0c1397e4df435f84c724a085c50727bf56ccafd204db044e4aed1d20afac4519a09e0b7256e7ea819322869f9e474fe591af653e55aeddb56fd4b25cf4ad979e85722ff794060f05c8042fbf7717f77900e3a7156df29d8168e660cb18739744cf7fba5387f5847c942c0654d14e3672e668483e4431e45d8572c28669239f8f1a089e459c7e76aadf5bda21c7ba2e3e49051541b15779463655a7eff985f163614a2ebc9f3d25bacb5957edff1ec301c7d2bffef7062b5dec887e23a60a298c22a120c55fe28f06f942f7ad8b178a6f630988e316baf27d6a33afdb8bc6d23a519d5719fc67ef6b65503933d6868811a67432e47e749b3c681d6bc89186e617c38fbaaae65e10841abd9b96e707fc62d3e4ff6d2235bfe65117b82c0a7bee8a23d8a5a7802ab9cab9e03bda9f6113d703e0546c285ec51dd9756301122f9246e24ed4715d2d57d255a1b98714d64ba1c09e58ea9eb969a023ad50eaf0cb81b309c734bccb1586ac3a07e9a8ba07c5dcb99509157ba105880cc5a4b8d6621718c56ee124163102d7de6cd133e7efa85dc27623f90243e2f3dad43d345410f0caccc587ab895092c10e2007ea01aa12e4b8f8bc9aae799005e73fa31a62c7089a0dff0b86619114b92b725b21a29a5ecde9890a32d37bd8b48aacb32f0f34eb8d98434d545b66192bccdfeda40fb1e249075ad72f8732e740675571d8c46848a12d1c9255a331d3aef26df25e6a31a07ea4a6e06128d4d646b9bb23ced6e8126820b4919f96301909184179756d899887c4e18bd3c4a5f06a46a0effc5831a9a21ec42b2c95379c9142f3e101db5d3f759a273499b2bcdfe1829220fa3ddfd9d0ec15ed09ebe1b15fdea14c5073e044fd0a571d6edb2870c28a66444c1cd396959cbe76821605b06e7daed7d2f91a6e6eb76f799f2bc839d19242657ce3b4c367ae713b0c34794da51dd90f887f415ba0d6e093cdd647b65dd183f51e072c9d0114c531107da0c367f90faddc68875b3f040dde550e2d7f4d58eef5ee314028ea0d47eaa218e748dd7832367d21396bb043b0568f01e11e8f4196aaaaeaa59e53ce8d427fa35d8fedf8d7e5071a56d6f6613efd9aa881c3dc6d247c9943b12369793be65dfade5c83ea8e5fc1256c3403e66ea607989f8eea4f3c21fbcb4131ed025fd0be7ae9943fe68cc784153bf88c3f073e9e29c023af1129b59e9057dfc46960bde3545176496e638d2b4fffcc3fbc5f985a0c10b81c6e6f768ec3e033214709875fd62746d7fa23440605790f8baa6d89b12046cea2c388280a9a88fc7648c63c0e28064c553e0610c48a38e38f927d747688d7bc4bdb1a33fbac3316deeafefd57fa70ad568e4c0ffab42ad0e3e5049adbed890b0708b778287f020ca1e8b27bcb5ba90a102416dc4cbf696be9ef24bb8127e51c29859867bd59a662e8b2ae94510b61ae1238459bfaa2804261c50592361f546a1620c13b0a314eb5a78a9e63541a7a42ae51a258c990ac942dcc57aac7b3170960e81538a733cdc9c840e7e9100e62e0dee920aaa95d650c33516d1762da8657a966c3b9c2054badef26d57c19732b8b433a4c47b400d3ae50c72e6af23009c02ac735db8f0d0527ebb82caed485ec1e84703ba960aee6741a32d1018027983384e33a0afe525d625877901ab1b5c6188730f44ba03b753f7365788dd4b8fca1d208f4366d51f567872ab04564a842b16c5ab8a94ee33cad0fe481065f908616a76fb628a98558680f52de29ffa35e1e19c796ed0c30eaf746e7b00860b5f55ba68b276700aeac5cd710f3fb91dc47d650b0f5c40ceac482b7c8679f6d53bfbd3aeea09a1f672f3c9ccfecf50a3f93b4e21c45ccca1da13ff12c86f856c0ddcb69ddeabcf847f9675abc0c597c67671ef5aedffbb6c31322dddb69e0f0d2a5d157a22604d500ef5667a2effd62de58180c33b019f8a7380d0502c09a8c61ba89850c9b180710c04fa5dcdc1d97f9ea44b693596c1b243ecea788f64ce9b09b14c7889dec9ec1441394ca14ee584ae74ecd19b7dce8af7aa431b9f91918a2c9da9d71f3e150d1f3d2a89434c9bd60f60707fd17df0c46411ac8d0552bcc5147360c6550eecec4947f5e043473d6a5c5076ee8f6def195170b0fb17f402bffc96f88d41ceb5997ed009d98b7c075db884659cb7487c724f547a76fe6c2902ea938b5d260c984748d67d0d7617e880b6115de95284bab6f9490fea0fcc67f3a025dcb578123690f6a4c892dd964ba7ed8623dee115f7c4867f1e1973055a755a4dc9089fd6e2aa86c54a36e3067cd9df9461938214b9150e1bac6587eb3c41571580873afbb470e6ccb67d149f69e2b7531016098726834557c877c2931045c10550b3c6d81b34f10dd350a8b695aa0d8e5fbbfa6a50ca57599db826e377ebfcb4ee99876c8d5a79f2c2a2d47de85d2c1fd4906a77539337873f75b7a16c4d578bc447af1aad522372bfe37b7522ee175e1e2fc8149338a947f078416dc77b40779c40c8b15e98392821f8db138a36e9916379d0b69a5044e5bc8dd9f40fe6451d929cabb92cce19f92acbd7cdca79a4eb38520145ddad32e6e99a2a30d0e84919ff832626ea1cdaccb90ae948c087d09b7968a446257ea8246b2f81e8d13b5b34abbad4c693ab3be497bdf846a9ed402bb7d0de46555eac6ec930884a50079af1f7e0ba3b28282bdf61265a8df8218e952702ffd71f0d82198bb4849ed8225ffaaff1458be91f1d3901b5c4c14aefc0c951be280051948eefe08cffbae6220d9bbca8d358d222f53a0796ce29d50151553e159a452d995ac3f8360101da18f055d9499cdbeb0cd3933b654524471d18bcd4915ed62e4e787f406b279a54c632bd30ccc826dc3a04c59a4c0bdddce074ce9bc285d883b4661e65e01658ac7d8d7ed08278648d163240a57f86013a1b7ed636a87787da74beabcee0fb5cd7522edef4a6061f78a0312c298a6fe2e6789309de9bff9406fe2e52fdc8fe3c1aec54a7749b2ae26b0d1dbd01ffb193863048db65804f524954d39cc5fbffac5cad4ce5dce299cdd3ae5096a5c70c688f338eaca42b7afa7922d1a52a5651f48964c6186887b76f42fc3600252dae7e1401ea0b7173cc41b6ec5b0ba2efd5bb626401a16ff4eecbb11cbb0f8a5834c7e542aec5b20ebe276492c86e0011dd932c517ff4d21cadedeae436105cbab99e3f24ca317d30f4d87889509fe29aa51e7624b96a313f478aa14da9075643e9d5e5793c14f0caf13f3c090118980da93b4afa7e13bf58e8dddd7d966932eedfc53efc19696ab3390adde0b289bfe2c0f095007053aa184e2208d7689a46e1196e7b48fb1eeef5ca8e560d64be91d7f31f4c06cc53a685f0d4a7d647aa9e1383af62eb4f917f88f3ffb026e25361f5e086c5949e2af3c099a3b239b36e4fd51c0883832bcb1a6671645da777e3a6404e52a64ee57e53a0de039dedddb51bfdcb687f8aeeebab101f67e3049d15730dcdcb57a8a7c3a8ce0756de70f7a42abd666629c1b42aa71714fa942829b48014443f05057a7a224294a12f00a2a6e79aad338f908bc0f5a692588b3f33987f2cd1a724d938d2334a983f0cb60c346dda25ab4bb75aa058183478e7bdfa8c89f8a4d8743b125133806c2d6996075eeec5c1b119f540022273684296cfd8261b5d8931d1477955310332e1c91ac9b9226bad14647881479d5387f6eee3e26b5337059c0d5302e2ac680ba25b159483c343aa9a0b2cf7f797bb26a6d3d863755bdafb6d49cd6e9151286a48a43b4f874d8219ddb6a2c17cf4535db457fe019e93af1f8c019b48a17056bc6fdd733a0bf92e41e5d0f04b11f4629c9e24b7cc53f3fee8e73bae0cee56ad7eedfc4a3b32afabb6e68b4c1fcfceb370f95b41c025cb8a5820b0dc95f817fe5c475cc0412ea42acb26f4dfa9a7413e8ac4f353f0fbea038b60354ba22ea5a971e6e37076ff9a15fc6e7b872d568aafba1980aecbcc6d7d779250c408af7fb7fa859eabc14f4c3c46ef6dea17dbb4105472dd90f8710c2d7552b920e24935fe5e3e2ca3a582b23f9e03cc94df81d21c378613470dc275fa53140cd0f65bb0db810da890dca4a2b0a1fb0980fba7dca2eb873076941f2eb1f33fd937b516e675da63ce376f6eacc47dcd1a33b17bee11d381ce4405c256cc343833850f7aa4d70786037319820a614ad42c2658aacc32d3c9cdaf124955972769bbc147edf885f93fb29483aa95bad661a9cb47e95b9c627de4cdc8939ea47f87bdd5ff4873b71a35f4a075aa4988eee7c64f998a06944844aa75286ae1f82f0c042122f875e1eab2b492be089b6775b462dcd22e91e04df6da18f7ddb8f3590e1e5c07035f7606e787f566fdddabc1d6f8d24a1a316e6f85e4a7d128f94d1c44a6468597edbf56d059d6cac9eb4628fbb13d622769cc1f465e51ece0a274c1358c5dae357785beb3d6a2c708ffd39d159240afa87494b0018742e1656be78cf996b903058a1b9127769d29e63eace9adad3f92187ca0e2d01b331d2d07fec9708892f0c6b261973924189a87beb4a7f3319d3313bfb72e1e18e8b3ca005652a46c7eea8bd505e4f93fc37060f5e8bfeb06debf7a63a21a8e3d84cfa02489ff2d512a8e71baac7deb88844f04d5124079262d5eaeedbaad9a3648c57f139ee65b518f65b2dc89cc8c6bd3d8828b24e78433cc3d7ecf603c104b18aaf3a710d509fc64a424feedca40f764c485e3aed67e8f8b29885c483a8f012be9f7acde3f5e18dbce899dbd6983af7e003c4acb4c6868dc1bbdaf8d53fc9d2169fa539a76baffcc3c3b0b707c60c500d3644501836d02aba8f279ae6d955069943038db8e3f85c167a886f1ea069fc7f67483cec1b1824e9643dc5a7155316e3a2c6855c7cd7b5cbb0d996ce45f36438c7c30ab46a3cbcae767e3e6c860b9ac89a5443e0837a1a84545dd78eba571832fa23ff10c97b650391f05b2d95ed8a9ab7327ca01d03c489d929a5627a17b8a8f97e9d191a7b2ac132f136352ed46da0f9139835957e369662667de7f976e9a926ff5dc0c66a11291f3e9046cf3633c405c8ffa5a298816a977f0111d2a347c3dc41d091f36e6341e280bc75759dc8c4e456304570e1fbc19d5afbb88f31cc2fc6e51cde101efcb88a0f6d31fa2a8fd314ed505ba7a685a3184e396b0a87eac8511d811c78825dec6402ce332d51aeefa61b33a529e773502d678181062004ecf66ab3bc8172488a19580c3b9002d279117d71196598407c435960d55d8adcfaea22146b159dfe11a6624d375acfeb5150951e1324b66de959fce86b2611af106ddcac65290061335f56f5c993d79a52588da16597508d3294031075d2985d9b57be453e883e6b5cbec270d279ba7a20a6f0d856d72f072e25ea8e9d506b5ec10174926c6cf473ec63bc501d1a408b46c897ee410ea88dcab8a2217b28baaeae303c7b2e757c84b917fc08ebc123aca78689eaf192bd067c89f7bf18310c882107855c4910c6d1116603a23b17b2ada69dcc2043db5b692807b6b3c9bf4a03ca85e9aff09b10ddd0ea84a56730e3c6f2f94b53ef70e5501629b5389347d469be3ee872c9ce687e8fbac5a3bae4c949040b127436e7605930d4a811a006947426040ce4de97f38e76b6f42118609e14573467389efe2a76ab5e5959be6fcb4be4c872582e7797be9eb9feed97e5fed457888cc6deac9fd3e46c2a35c2077b822fd842d229e3a2e6990111257a0835d9b87d704eea86438a98446676bdd646069397eeaca44f0c482c6a0f2cd828fd98aa38534c69b8285ad453b2f14c22e7ba7a170c4e1cb6eaac6781a5e89f9d1398498683256473f9bea0a43e103c88656a4ffbbbb4572c7834cc6152afcec8e6c910479fa8c12d34ad61e4080e11a9fb36e09c1e0799738395008a4710188d40bdabfc577096798efb25608cdd13722786051204b2453c3f9a77150ec594920c096d6563683b00c48ab813da726e032b3d50f6a0f07b15f9c682f7acdde6a52178d9c3fe438f2789637ba0493d2587f3ca5fb2108106fb475313391c07f82fd115351f9c94abe4964d11a530ff4ad675b06f1035ddf51f75ed869713d4923d4bb155cfc0374cf1aef103d68d4c3a36a116341cf2a2f2665c5387bc3a3c4532e07d3d5d47a5b1275c5aff410d5df0883f7106a4accbe0421bc8ce4c5e57b467bd110ca5f7f2a07b6cb146e54fc9591cc03a7f41a4014c3c5db572336f64a750e519de78243ad0ba2644bb6e835db46fa1b2167a99539fb1f1ab90a7ecc7308afd0d42debaed969c24a8e963dbbc5fb05cde2951126cc89d2778a589303241efa465a94bb17031e493426a4cb6d5b55210702ffe36fc437fd787e69c8471b1a3ef5beb06a8ccbb0a1d197a7454945909ae0291e2c9a0e6b6748d72d9263eab6b0332c01d6318b25cc02edc23c8e1247f92baa8b831068b2233821a5bb95b12ce5e0bbb3c0afce8d303cfc0860a251203e28ec96ab0693eb7b15affde61c086258c84e6cbd13598b45f7c164cbd45e2153436218847ca94525cc619706c4773f3b22f82a71947d2e3d0d538f43d788979957665dcd05f3928d7e36e96359effcbc7a85e62f5db7a26b3158dbb52bd990c793656817e04d9f334933c5f91de1805cfac8e8deaeb55ae974586f640fc0c03f4634325423d7580f42e535c46c8475b4d3f6ebab45b3e3caadc4951c13a57cd6ef8118d426cb1fe1203e9cc85a6eb852787a110d97f9fb00bd770128a3ae2d3d8f808e2698fe934f4d78dd8d9a4869a40e5259fc66c182e5c07a60a73b11e2d727704f0370a2321329fbb3577bba64c419958bae327c633f7daa280bf8833ee18dbcd9e26e23a1486797add013ea935e12633cb6ba4e3b9e788cc59d80d8c798d1fe4b82f15735cad2435a8ba3ce512e927f3a7e9510d6ec14872b7bafbff5b39f5081e4cd9c3ce2d3f18c21516e08fffde55d5c9f48c15a9089eb7106ac35dd430640b3428c094a451e7e5e6c6864331b86655fb5a5ce84c2300722db6b885cb9d7f9214ab6fc63e205e3b044dd366212611fd69c58f7cfdbc8f7e51460504ff2ed3a1ea350ecd80a4eccb327765d586644bc52bd3c6a68089a76d2f453238cb23965b3f5167e3cc409a60006d57d046d16b06a818637d586bf17551baa3067d4cacedf7fc46798fb1a92c751548f9e89659357d75d7d6c77a35ad47058f061e718d53ebbe560836f580e1b3b35f90a2f4cc888cba8a5944df4056424b026362fb394ba8b28cf304ffa6318ea2752c24684268e9df253957d910a434d29c5c0b3c4e1f28ceeb72d12489eb2b4e702c55d2bf4c78519806684a98f730a7150816e6a1bac798bdea9bcd02ce7642a3ffa8714f24ec6e8758f62e78c348e6daaf5c4042822ec54d64a01f75e62b3eaf72942d2493c5a5ce365aa1734629978b41ba575c75c0b1afdf5df1f5efb37ee6b2cb93f4fce42f9fcf6f1ef5c4808180fe03f620ed67ed2b3f4d44a75bfa5b52338defdcc97629087301cc4f76bc0aaa3d479a15f527b14474a3ee89bc9e1b0803099df840f5d7e091f32da35d28be0a43a0f48840087ba6d6ad0bd8ff3a8d1038474a063920505d35489f2ebce18b6c1839de6f8f54e717b4f463e694231f76fcf890c2ce54e678fa43a5594acc62304143e0b04f9b0c58d7d55ad3bb4064dfaa305bda044bacab2f9244cf206eb3bf1b921d4886f054b86a49096850d7d50cedc7bed0af49ad818709fe1d9debe0271ac33f2fa42c87725b7b4a75d37ee56f6dc75ebc00f443075f6537f2f9190577401fe6687e72581402ff8a5c62652b0b871bb7929b06b3d64558664bba1195efbf5bbdfe05a6c34a83c084f8fabf83f333219d2a10c0dc3f2fe5d6f17a6196d259ca5b402632a20574b15fa773517cbf1912dfb6229db71dc53d255244a9c00eac946a979a8f9b3755f2fd182e376478ca80c1989a275f01f836f62a3c213682e00ad34dc92e5e3a2a199829a6444d732591f8470ec776a61202d5ae755c2b3711a3f153a49efd3651215d968bd73f0efef1114bb2183f6a039ffd823a982b6f78265d66f33a5273a493a45dfd0a68e8752f7c1d5fd78b7445bb7d03394923ca10c87b0a7a859012ce60a600053e6799e11c60e4d39401bb77571df6e5949152decf4ad338b3f1083543fa1498948c2e5123d8f415ae25dc71d69797bbb5a57aa4da48e5698f511424b3620a3a05ccfe4463400989272f305fb60bc51746f1da7e6b9aabae3934090ef39facf10ef36d425d9933bb5134812bf5c9c0a29adac82a8b228a3d0e68ac87b62556304f463426aefbb4ab28e822f03bb9283c672dc7b17755bbe759f36e153d7ee5f0e47df628066c1f237e43770781461404d2d89a139c0ba9b9ba3e2db4e00d3e4d41619ac050229a05018a1898147ecc01151a63b5054fb41f6748cbee0c1a74fec63ed526631a862ab578e727e0cb0736386f129267402ac8fdd4ae932c41cf7337133f9f850084c6901a063df38e217d7f1d6e8471b5f4807c2c954485e56799ce99530326488aa4661f0c51bda43e2ea07b87df650171e655b9f68bd37ab33e4ab13124dde08c2b1402433bdc0b01cd8df1e9299b5ad8c67a07a5b8734a39d3a4082749a93cf3ff208bf73e08822440ce898f5b961de8c1a709f30ff9d50ba84401b5774e0c469f49bbb78c3bd0d529544bfd4523d2dfd16a6968d0a7c7a9c0804628ae6cf142ebc8a24dcd265cfda58d44a714e4043212992c81ab4fe7b7be3c7bdbf519bb216fa24dc400221aeef41bdb475b31a50c22746b37d64b41fbef3547d2c665b907f3f4e74fafa92ce8bf8f4e9ab95d94e05c3cbf4cdc88a59f24edcc89e144777066f5d6397b0d4ad64b14ee2fa771a4333c491dcb58acee4fa1752749ef296ad09a463ca0f3e40de7528855d74c9789476f6493b16970ff998d5861de530f429b9d598e6b3a4d8547f50219d7fedc8eca8d7a5960270188bb631a92b191fd9a160d0ff5ba108cdaa1c91a5b3d0792f710197f5475eaad359a5e2d475cf938cc82c0a26cc6358165c7f1a91b374a80733a2b1bacbb832fae4b0fb7fc298e08f5a27529d1a915d3620c581c40216a1fcb7ede491f9943a075203c5110acd438c9d32d0ec6aa10d5063f723534bd33bca727df61fd8bf9a46eb7de3a2201e86f8e8999c2579f9ca44310ea202311d1844b3cc726d9488b51e6dce76c7f3facf078c11013a9f05ec935e0af8e87fb198af043ba0fcf2f4af8ae0f85e6c5fb129df73a518749f688712b0a7e62db7657d731d88bfe566076943f544b7a6f5d4abf9c31871987b951b5ed4adc935e3759ea98c9982c968fd8e672ff8e0df339c40987a1b3cc5ab5d1c44b3fa06c9d3cab983277e537f90fe48492bfd0f1b7a0989f7d194a8a73e813435bd6c93ad2880ab56f944ff34971303c55eb515a8de4fae42faaa2878fca18c577d7845a2016e63b9da414b0601b25df4d756f1c4060e5a1154f693abc733b79b6d0cc71f163d362c3238315ff58d604b21d1e2fa9780dfea27eb9bf12c09d9e7604906a9eca0fb3be65c8e9af22c2c8492c2fbd54b274c16554159b0ec08abbfe8f3c1a200192180f689dc0810fdcc6bd2cd9176386c57c46d5d6144a2dd9f680946623957874ad039d6e1dedf1d846dec25ae962606f2aa2e85263d975f99ef66ff3cff57b3defe919d8f505315ab740fe838a27b2ae15279781872cd753319df8c2a45510dbde1fffe244c0580f31e0476a485a47147abcccb01e0983a5b9a5bd90c0a90296d91d403867514567c4717c28beec6d96c79cdd654cef892b30ca92c0927df778bbe7f0fc9ca9536928b9ba84bda9a9b861b2ae3a8a0bb376949343357e0342d227370b98fbc68611ab53f2bc515fcbfbbc9a061ec5db5bcef8c51bc3ffbcd45910c7f6df4497ddfa3f0d02e4e93f375f698330fde4421037b5a0e15bdf33c793ed1638c58bed3725975a47cdb24c9ca242a91147f287f51e6796ebc2f6ab42dd79df25c4339671e9385c065505953a3673d6227f829482224b8271650b47ddac8bbc06d560c393af435fc2c52163f8c0aa6993a8bb06ee45ba62461f3437fa826829fe074aeb68d2cc7f534687a8b1c380616c52179d6159080ca1cda11b63e072690e73bc466e29278df71bd5b5333d7d8e921baaa42f6558dbfbb1a066b2a3f7546eaa75d12c772939bf6e2d74acbcf7d94758b12ae368c05942afba4c8c4261b57d0fc4dcd3e8f4135d45944bf0448349a5839bcedf9ba2a981144b764886cf294625b3fbe7a07bba7f8ab001da5b66b3f51d665db48ffc02b970b06f8a1d437b738aa384129ca32f36602a3cb61c1e10d70c15fc2c3f5b2a46f2c7ae61e422843f88663a1dde5af4605c9f540d0528b2d5312c6dcbf5e254d85258ec95af3b542cf7b9c2133d48293d8afa71a0c223e426a7497517878cb9115de0ec1b83c56843714a3d83a6828cf69b5864776b5e825a041e8b6365e84d3c2fffd0f7adc14b820d43b6f3c0ed43dd04462120761179e75a7cb95584744351cfcfb9989279b860b6cfb373a0d853ff523b9828f58549cc1e4074f0adcc9619feac9abc728499d93530ffd92a806753b61a7f161fa0f60d492aae4a983a122f9820b915c2e4ed9cd1ebe7270f39701a397b1a5b6bc7858b90b9ed5ac3203528e61179c5d9b59c655069f7b0f5f682cf016c8b54c7aa67e764304cb02ec7f1766003ed6491c4890d0a55ba53c5498c1731fc64da10894cf25f06e6e7dd248cf9a1acc1fc2da16595c00cb4c6fba52bda2be04292c78403732c6ce517fa21b510d6d72df0a96a381cbfc5abad00b0ec4205095da2c370d46c84c18896bccfd20d96e8b1b7ea135853f50166e07be626b326319f478844a458d2a3025fe8e838224e220d57ee22a11403a985b9f1aec51a5f9906cb6151c3d30fa5719d3d5bb50157fe3fb9554c2a362e8a98b7d1a91c85f9befc04f8166500dc1094b943183e56ac0d79e39d84e201a21595084d0b4257ecef0176672acdde3e79bd8e9605f64d1a79a1b5986a9fc5681b7f998f94d4eeba857692b09bf2fe86c3fe094e831894d38a666a250a820f23bb8ceb01f7126bca617191b65d5721180fd7a96fef9ea30164a97b1ab2f8e82eda9ec7db4ca00dd5ea2f5aa4e3f83626c7ee80d64a4ee4bf6812c2dddc1bc3ad7757f6a0b4d4ac860ea9a74cd1e2903915d854830611ee57d44149e140c4d8d259829b52a2b93d4e8f92ac00fdb358259c2aa86cfb75c968bbf7500a241bff4c851cb6126563edc69b145f75a79283066f6a659e89623560c04ad6f06bb77a79499161b7d18a20fecc35053b5ebcbf7ae27eafbc79cd4ef96573573f3df18c76099f2863325cc7cb82c5aedd63eb17df6d652f99ca1a489150ed7715b016f0aea952313f060ff758b2a3b58affea2c0f127306a781bddbb6672b9745227ec2516ef18a82f6ebb45125cb1686865fd10c33616a843027aa4381d05f109b4058c5cabf4288c32a63afbc3f4dc11cf0dbf98d940ebda0dfdca21695947cfe5db438d7aa91201f94c348daca44da774ea254efc02900676131f05079ab5f6fd677bb9277f7dba65ff8a133902bc094ceceaeb53698781352b929be6f2c5e2bdb1b370a17d66b12cb7bece453f5421eeb91acba96e579e695c9446256471b76e10819a2615c87eb81a818a7fd5e9f5c769c8bbd4a51e0a89319a41abd8d757183b5ea19bee68787a59db342562e83537785ec1fe19fd2139e47a6375f717f33cb95ca4d0be86d7232d8aee272c8f8cc2894e45e52d2bb740c8b67e14ace31bfab5e8860b8b7bbf2258ed9ce4c019650fec8f131d202f0002533768a7a9f3a3a775d0e3db3bd2bb542ad5f13f32ab880d347ae24b7635221f98ad09e7d3219babf3972e20197c0799cabe8a3156dd394f7a0a10106f2af177c9a2d4b2e0a8d47be53d71be6f05c8a3a3b73a99c26bf1d78d87738379d260a669e27290ef00157c1d0bec714d864664593d0616a90413b42a091d149773058327e522852ef4a4ba6697e18351da38110f8e0deee3983b1a698d9a3084d25cd92d19f71729b1601c3e14892ecf8c946919edb4503697c519e50365622be44cbed1d291aa96f664ddad080450f2a562ae6bf5ffcf7a463d33f6e9dde3efa3b3a3bef39f62081a8e9b041d416f26858c8ac467490bbc4abf7fbf0029e4df7e5945da2c2271721d6571dd342d3149b5e9835484f534a911cebbc7dbaa0daab7fe386e5dc20bbede87aff4ed5673c5340991c2d9da23832a009456dd920fa957db7f18a2b18ecddb7de4c6d0eb8055c1c17e8eaf98504977991d773165942e8819c1a522ab4c2344b41c7d9440225ddd293b1e042021139f39a4696ee3443258954621de7db1b7fc804dcbeae92ab16cf1225e69c98f2f49c0b4e22fa7f42de91e89fc0d6a41e846ec4a172e509782da00501b8aa81986bb922771b0fdd850b12be688af0c981a28ef30a9620ed9c03df4fa264674b23c79efdb7247b492a6134102527e7a2f6634ebf08a0369691dfda0dbb7ddcb62e49441d832b20d59585a37545f8a44fd51a353f866fc6068a1f3af86f1e93fa81bcd41bebca33f0a9b9c0655be28ca6740baec31226846f03d34b3e1fe051c8b1917b63b91159117595c80f072047540b13fcec08dbf60ba2d94647d38058f15b520c36e73017dc1932fbb6a18446faccb067662226e7ac82a065bec40858cba2c4b6a2a33710ec678a5dfe6d4c2cdd96a74718d62414fe0699d0e920f22eae7ba4da041097372683c78c57232c1f19a465ebc7769f7701ca73bd1da985cc7e3a48985cb1616e1e314ed66f23dcb9bedfaf2137b09cc5a91e1108f4e5bc6c35e6287321ae0bd438f55496928acdb3c2662d8dec6c50b60531e17631f49efb0a67082837eae333a0c4663085bbad4ed6b0b89742e3f86fcbeeafdc921d5c57fb5a38d6cf9e97c45d04eb22f01eb3e1bfbc94050d5390d9740cd61ba971add582252a6c033e3c1f05b082d1aba96790c961fcc51b619578ad8e91a7a398ebcf899fd5f83390e082b096b8ab50a38b36e7fea4a2665ffba28a8757e7a611d4097db17a87d13c995c8f024b5376b54f81b8a2e9b376fe537b4e7bcfb7b89b0014f8828a040a5faca9cff0900cdc9a8589d5bc4eacd7141016c67de630ad07698096e35cd296fcdd35890582ebc7c29506588006f46186239150b7a963e68cdd9ea7f41393c9b651323a667bc586669b69d670e3612315410a302e43c3ba372d3676049946fbf01d5b817c6050ce411344fbaf2c4743fb1df61920a8b4b181ad228ca7a43eee2b14b53df2c5e2848d48d4c11566e69de9868b36b7e07deee33cf6cebad85a4961a6313fadb09be18c1e2c9a0d4dc18a0407e0edbef44318b50b7b0679711ec3e5f581f077240ae4ced46201b3aa0a6a16585451cc795d414c09d34839027b936af7cf3b4f5d5a94ce33a0b6cd8e6f2b08ecb5699449aef2ff095068a5c1c8515dc4c923b09c5007167a4f394a8f388735a8d7de424b127e1b3b466da8b6a9e66b97c73b88b2a17a21edc9649f2eee29126c4b5403da602b540b6e4dd791883f1dd3c47507d16733c61ea99f2c2244a4cee5d60817b9d1c1c610bb75795b710e7dea8ba7733904d885e1400cc67b257a33efce4b880f6a6bb9f927020d1cc7d4228fa5d9500f7ae4171e57ea0c6b212452cf5959a4fb516c820d6eaf718d9634448d2def652a4c9b2fc6201be190d6d495176b0e8e3410624084258360479aa8c7ecc076da0147b30025004e08c5ee93b8cc949ad998592ca5865206a0d8ec41f205539bad17cf2640a144edfa4f89e343fc5b8346330b90ede1aeb784ff3bf3b1326f9e50f41a1c5f6d0bc54d790538981f442da19cdf7e2547b2cef41cb32b696a8e2192981fe59601a57ba4190fc57e5913164e064dc84e50d877bdcc6599d2cc3959b83beeabb0e5577dd0252bfbec6130fc5b4af82844b163c168feefb79e4296ebb7bf1fade78f4335807fbb594cab0420cc8b6397cc377a0a1322f9a2c91b967047d07a1bcd8b3d165a106bf8692eec2947c7440858a8576d5cdbd7ee697a75c7cba1ea276e160f8d69ea9afc28f7df3d942b3871ad31cb9d230890f3caea5337f428ce906336248680f4c1dbd5fac6b4fda6f2664ffeaf7fc78772a0df635e7fe3bb460abe6b46871dace6b57ec7f9f6d821117c02ae09dc94c4e364d5b0cb6e0650ce04c0c6405e1e617561e982246ee62ade936fa9714b243ac3e94f4050d64cde0d82f79c756de91dd1b14e0fe846d600d8d8df4ae186408da650131c7db9e7a6127fe465a84f1c65417b196371b1fbd0a484c5d4aa9a519c2994f9b15abcdf6cd145ac73dcd091d94604d69c70d9784222d8e5607a720bea92c21253cf375ab809407e87bcfaaf844aa5222018b331c66f00f071cf2d3353241871ad6ccc3fdb0b441e3f683b6eafcf8ec872393211c626ed58e82b74ce6c41f0318c0f3dc0c23fbdb5167d0bd300552df678b0d84a5c2b08cda6918a15bf62014d6ec25d0d1001bc4e6533135b620457fa2be054270766024d50fe9f29f3d7df41ea39439390e1176484184f3a72d0469c3b7066587ed380702677c1945359586a8a47c68edffe1d53276c92d85e0c4168a0a8ce5707874e7421e496a9c5f2ab4ba5fd4845e00b74064341fa08b8e839f09bbe65b4bd51bdc7c2d587f654ff7e2dbc7863745508b5e4acf4a603640199217d9acf73304e3aca33dadcbae0e716e63ce18fa1e3414eb7421d0ca4b485b55f6a8016cad34f537c62c1269dc46521ab11bc7fc766d10852d4fc656170a3881931fbc58c06c605af15be3df3cfe9d6ed6eae46e3b4e585483f77aacc4ee07ec83db27d3588ae09be0e2dd9993ffa828b640ef22db32c34299a5f8c295344c535b4821ad019e086117fb0f28c33264581974a8d360df472a2f0a79dea2b51ee3503b2f11ed192f4e5e73d2d4cf98132773ad9b00eab4eb96d6d47ff4d535c25c0fc1a452c234a9c05b24aff72155ad2d207cc0fb6d2fdf4b8f29117fd0c290c4e0a7fc2b79db5cf232ad1e8d8ce74fac065e65d182e31e87ccf0690c549fb4516393f5e8302dbf73580f2b614a64fa01d85984f2273521d869b27018fc6231c93fea906a2a6d7d40e396873e4393049771bd9238006e5120183cf7f6c5fcedf5159d744186464c462a175af386c46ea59884901ae316f54781ca0f475890034f739178368dd639c00a38b3230a471ef02830cc09a11c673952fa37ca976026f88990c6afb43c43c5bd788e50e7a39df08a71c9af0b0aea486598286e9f9d9980794d3d454f437904a5ce3f76341c193ee62efd74ddcf9e163697035b445f29286da88320b76fa30cca5b65d860027fc7617242e30efeaaa641d8b101c918105e5b0ea51ba622f2310ffb588470b8be9923907a97bada0e097944b38ae9173f511ad74c5597b9d2def41f0b80cd02ddcae6d850c88999220cbc1a6dbb1ec8110ce90ddb6ffcc0778cb2a25f9b8bdca75a982b3daa0b7b3c69b4f5cdd3911220f33e3eea6dcdda07e66601ba5d2a04741fd635a97c0056add7bc3f4a921055235c2c8c6edba3345ceef0149d0b57b0d09bfbb57943bc5ad07b74385a0ad7f0dae1203c2588164c8539929e11c7f74ceac6d5010d28b0ded4d73012e2b33172f39f861a3a041dacfbf7a4c1549c558521b3c42c61126436d7b7582e9a033c1cd690c6ee35515028e25bd0205315408d8277be7a737c1e7cda4c4bd9f6801499f5b8f525237ab8471cb059c6894abc342dd7220d6a9138c3063665433a86e0b4c28dab7fd6242aacc668351d75ec69c4e57490ecba2ee79a7d2e737ee867edbd114a2a4dc4cd0058004bae447c3e70a77fbe8017929dbdbee4426dd7d69057d65f9f556ca0ce4698432d40e64176d283e67ccad366014d4f212aafcef5a10ff35c8bc48ff4f47b0c57de88a9d13b72c91b93a2494bd83c188bc3dbd827066cac1edcc8204b24126d533e8e0f7472f3ed1335777569fab819c0e79de780252d0a79aeb6012e0bca39e96fa8b682a07cf64fa50bf06e9009d2892bbb3db52703bdee5df8e66533271cc326deb85b80a3906ed67f9ac40a5f25bf81bc296f77675dc628562dc5b4e03bb50ecf4bc354590d99e2411486f892335e0e40de9332321e1b77c4018680967972f378e15d8d6a4789b7d465cde4c3a308c5867c426d6cbfb1bf1313a3fd7f0ef1236603bdd874544cea3ed4eebc228a32caa2a4c0537f51d90b591ba193552fd5c655ba20eb9a8472ac10e61062a0884281acb29e679c44c5ae5e8f2e0841dd7978722a5b2771f6513eb7403134319ed3c0a57f47dd00a9b66d6e6a9175f5684a03da4f5a13dfb96b87f713d701c2771f942ef4fbb11b20f18d56a27abedd8182785e6dc2473429625438eba565cd2df133daa7af069765a9a4db98e5110dbc3fda1bdc3568d4eb8ab156218bea7c17b9d9cfb2986b2eb16cc5d2f338639fcf2f92e2ae0f2b0859434b450319a12738a98b2729fac9f72d0cd2f6abe84af7744ec9505918b493c874f4f63c5d29c06d6768219a0b91a36b9e2e85c2555683959c12d8bd2dff92784d76bc179f430a127abdbef4b1cca3b218d70f7146b96c53449f78e829806026dfa0d076e4bb1355b43d0360679732e58adf8e07b42b2b04c4445681555b1fd0b4c31b881caad4f4a49d131d028391f789ae72d12fc7e36358d184fc341b632ce145dc317b5a6550a4038e2a51e9469320ec456f96e407e23a5320f9720e916d56c38f48f8347480f148cfae3d1943ee71b61c318e73e72ae986c8ed43c06d070efd46dd0abc3d2e7b5c26fc86640f85209c14a4c5eb20799203579f63e45b458efda25f993ff421d4d12d1913b8af5964855b2a47efc911f2445ba656c705be1fbbdc731737bc4bd356994bf88882544e1b0997f52240291aeb1250a3f6002cad0c3995b885ec1f64bb24a63d3d9e22120d65a3f6b9d1d5f3a7ed037dd4c80f6db455a0cb773b2dca076300ba1d7c7b8aaaf1298f8a5ee7058c3e118c4f9d039d6d55c6263611112d94444bfb020392dccead11e20380a744a5ce133a8912388db46f1adc6e8f78aaf2146be243e55fc5138a0bf35f24dd4f5941962968a41c24c24a7a109d3013b5d23e342568a66394094f4670135387496080f40e926ac707d98263a8686da559741cd77b77c833689f0a2be1bb23b9ca5bceb3c656d14ee84e31dfa2389be5d53d07a9bcceffa31e47ab3ce7679ae3b87e861709a1eca8e5aec12d99e75dfd769101bcfb5f33e3a0687862ca1a44bbe7d7deae4aa063a0eb5c167d081f698525a2a42516a8e6d747cc71dfda183edc08bf75824409d389362ccf5394c5979ecdc715afc824b9e931e4d1f6a57c6d33c80e13bbf41a157084e2d5b416e9cb166a39c7c444985ad8d840b91e950d99db08fac491a9522a0f4eb2a46c3ef6685ebc6ba258c71a560ccde3fdceab4cc85de99745f7341a9face698495116aa7812a431c65e4850b4a4f02a502298b8bf9a3da2889cb671d7c92fb535ac1847a16a593fd2668b2be31e5081da25334b47e014c1d092ef4ffc140568bc0f690660d03ab5fc40e93492f4043c862283483fcb898dad5dd385c18ae5ed9c2a88e8972ef0344b7207a2311f1e4e2c0d34cb2a0551f3fb6a8ed5042977de15cd54bc1a24a7b8b44db0c008f39c8c1a1ecdfcbed5c5fbed9043c80c6bdad1359f17e9f8dd694ccbbbccabad463e6e4daadbe009460b2d74316a1c57e7d7970641dd242abb18cb911ad342eb017151bc59a0cba63c212d2d03eae7abc251967998567d8591207e87936d17923c12c0688fb2d0af8ecc9cbdcc6a497359d74d2f3aa89effbc40e539e33abca7d463e9ef7aa199f4ba3fe88ffa7131c684612942eb02c05dce91b9ec7081adcebef2d34e71ddcecbb227135fab35e0d5b77f16ee4e22c23842deebdd7548b7536951fb2a53c3bd55530bc45c17540dbe61c26ab83feaeb47256a09ab7341377732069495257748ce99f8aa301406820edd1f2aa0e0b00f33c664b0e17dd4cbb6e7d53f0a9ad48dafa6ba7daff9ad591f423b28fc762b82b8133d0ae2b314fb2422c732fd66f54ced4a8048a69788b5399e9f8ba5508a19527bb9703feebeffe87dc4a232f985727377e8b9194728dc15fef0900a48ec389f49b1faf10ee72ccc0513cbcdec9db06b044616170c716ed8c277a554a1de5cc81ba5c4e4f92ea3a1644400b05a7e2c0823f313003f9d10759d82c84ae764f7b030c45451fcc8374a20981f0e4098ab92766a6331383ddeed95fb170c27d9915896b11c375711a3105b35e804952281601f8960ae1499553b1f9cfb6ef2c6a3be511e3dffbf06d029f3bdab09f75212beb42cc6c2095b0e602b69c15307fc504c3beda66a946cd20f952aaf8cf2bf9e891ab281941d176069796eec917745aa19937dbb40f172bcb14a410c51eec31e0b111d8351a928fc09f388aeddeeea48e38e7f69ff1af9afb8ab8e5b3b703980ffe2abc70be7f1f91c7aff0ee0b0479e9c3572c8e422742a392cc243cb9c0e95a7e59a102f055317858b3dbcc43cfc30d8cd351e8e5cc221b26ffe813b1fed69e11ddd6a68f188620194d6506a59797eee82d4cdd20e3f11369cf39993c094125327ae555bf5d72ca9f6a7aae6c592e9a681325b90f2b69157d516b0c50d3cb70b89835eb5942602b61702e5bec01eeb3b56e7a229c32630f49cb86e50d14a90f634dfadb063e9155df223feef1b43559030da46122df064cfe1881688e457aab2004686a22c92ded61c5f43b790f51e5f43bad1661c9a1c2f02f0a5f4bb5956535779cb3253be3e796bca54ed78460877e3dcf9ded7fedc198dbda55d876ed08b12a088dcff555bbd692a051c3aa55e8c186777d0c2b6b58e35f15f43065b4e893e1fa1daa06d705edb0aa4bd2b05cd3a6eec37c93afc22c88e1d815a5c0373919f8bcd1bc23114811b93811a3e3d6956778b15fbb04d2d2bcaa067757cc67ec717fda61cd6269a6bd1e33e27ccdf2b65eb3ca82098ac00b312249d8136b4a97c8b2ac8defc84d81cce800cfa0c9973121df7460f56064bfc8c0c6ba714e7c6b7be84951d6266b299c867fe979cd461c22d05a42378c85e448f1d3b658b1381b8ec1154e57067cbe114b398c9fb33c5ed67503e8d8260851450cf675071eb7f39a8771e5386049da457b065669518fb4d25a206b662a473536e7be5175ac0d43a9a24ccf01770106d21707f76b113324b51d98a4bfd2d374e8a0f027d97043a871f8f452d37654399b48aeed5e2b61441e73d2182da49f2991ff72e8cfe561637d2a4153cd77cf60289ca0c1c45647419fd2aab0849d7f7d2d07fa4c9878470f4b8c23633485046f34138d63b8f044d09fac7d996bf57f1619aff77cfcdfce53237e534a63c3182bd389f7e2466197e1729f01ab47e90ba6b678d3f4c3bc199fe3960584330972ea21c28baae13e2deb575fb0c819c98e815b15fdfe4e2d5f0e94ec59943d473aa469e7084e9a0d5f3705729361fa346eb6b4f78f043f4d60c194b308e0f4cf578d690c6cb09f95502d6a9d46d61dff220d24c9e7e5abbef32c2c53d5f52c14c153ac0301bf6097184ab6cf6d47c91848d3805d4a32518e92af8451f59d7f96b00f375aa5375863b209b963dc5d30f6fe962612701502937d0ddb9c9cfb61383de76086b1f39142dbd807e59f6a0018a0e83884674e48810ca6987ef9d4f7eb9370be706f0306c0cb090c737744bfded8af07df16d79753e34304333d6866d6835a1a4aa700e9e08011f33b7157b5eebca6a7ed99dd89877bcd33feaea65d9f678e79fd5dc6e06928196a2f16c80e8e29bcfa4e7b074351269689879599519508763d2d0a6530bac05eaeb3bdaaf89aef806a62f5e9521bdf0fcd14186c283726a31d81f9269933f7bc99f27bfa7ca509aaa393feba30d0e22a806b3e68fc2d76b11e88aea6a701c31f82600a8f4dacaef6ff81ee0ade8758c4ce1163d2816cbe7d23a243f299ff77541c92784b2a57cebe6b11a956b4fbd36f1dca238af1ef83dab4d51e64dab16818ea8c34ee8b3d3bc1caebe5d79838e6f0657f82ede5c54677de8fa2fc7a566460993d54e3877fe8eaa4dd27b6e31c1270612073cbc7d14c79f0883c47cdb13f0cb17bcd9311a97dea754a04b793942f55f767734df777d441d0e714dd056ac928ed7950fadae2156d13ed70d99bc248bb386fea5f88153635c0340be7deab1a0d6efd91bb3c1d5df9a683c41cd1369ef59fc8c5f8a3b8a70a7a3edf55e4ce4922fdf19aadae5331744ccd2d7608152d7413dcfcadb3e7ec394f6a6368e3b0614347d2b683d7dffff230ae841e8a0da18773b768d3eee3d529a687e556fe7c435766cb29e6e8733904d495038405618865fb36644ef7ff1c0811143b117013b6720675b7c4a8bf5cb7fb4d9536062763d022d8aa5cc1e6dabe4565af2352f07a4a474879e3ab5c1780f228bc0cb74bf1af0bc374485b8543f7712b0ec80874b30cd467acd50e79ff5005458ab9dbd750db7200cdfb45ce3063b2b616642a105fefaaf73e726a7c5e956fb92e1baf6b6762fa90dceb9638a4e91434248970651f0e6394b45e15c16c6286f344154ed98cf7f5e92e42f1a710f651de5be91803be0a9bbb11578dc27e36dcd18dc58d305e1b54a2671324599ed73b86269bcb513d9f8f5a02bca4354e9835c57ff7020855f6e20359cea10b5a2d8c09ce1590360e699b1c238a8f8401bf2e20924793041c179fcdbdf7f4fdc963c1a902e813716409ed501257d27ebdb2b9e035dec9cc309afd9e7d2dcaa7439833827d699b3182b764b44a86326735c06538c7f826530f44b0abe662877f255abe13154422b848d2f4104ee9de8a7a1a1fb34d1add1b423c176d6d51629fdbe1b51e0458f4e289e3316eb6c3e41ed0ed53b00206d621f992e5d3c0a2d6e519f61fd3a05ce1252885bf0ebccdedc75e796239b1198de74c5ef0e082ef1dfb7143ee12b1f8c53bc2f824183f190813ff783a80d711329c3e006c8063e0ec1ab1d4c6079008f52d72525e7c5eb3bcc1a6f8bddfac7e636a70cb75c7c452f25e80f21650b9b1d1ffe4642cb6740fe740bb0644ced14fcfe9ee914f7606c6a19c48ea8d9780c00d0a56603fcb825176cdf4c659986f0f51daa129942fd929bb5958b814d5a522e47ae2bc1eb46046a6a363c0c056e758d8db013ed9d5f14f414861e3b93fd17ea3dd1f42ddab71f2bd7aedee285711772dea33be3055908d935a9e85163fed95d6156afd839b29afda79fd8a28e92a874f0f7a959668657f5e3be5482b9f3ef3a80e018d6205c9fc006ab487c6fccf7f1807f98386a99a4d4aaa31328d0f0c8eef45df083b741939934162b2857305ec27542167a52d19d332252c7f219a84188a21249bb9397a62677fee0420dbe967fcc2d08d5df61936ed4d3685e6b9998d62a4e68d8f4f873673b06d9f51df6b802417d99319005e4f5a73f9e2cee2a02337e10c082e7b6efe72b8c6482902d8748bfd58e62bfab68ec4ea9c0eed76e943b611065b14744a70a931948646f9ad2a2f93eb5d9e7d410f03e7076da1a65d9299e42fc35ce0c31f0365504235c513e5199a016d8c4afdd40bdabacbf6f6fde2077663437031b6f403ed781d55e159e5ec334bef74de382dee0e6615e317f9dc8785c0f6bcc1a9c2b78dd897994a2988559ce55a0da1745319e85631992475face0c84c4f2c4469317e7e6149d2dd082b1cd93a67675758ecf977729920d28260f90208c3886366e872a5b725b3551f6c5e5f5ef95f46483822c6dc064844cd69d25da08bfd88d0ae94d6c3f18583dd2e4d294df79944955d8798b8555d983981b557d46a6edc8f8b8ca94b222c1247a27c413f0aba3cf46d6e1dbe1de9ebea19d9ee5185e2f1e8f9d6b434cab4a3c953a1e905b4249d553892cc6d82c793899031afc92fb3b81d397302c96e0b319ed13d770b00793e86e53b7d1f8d9a14fcc29a91c12c2c8db0621e95969b9b0f9e28ebe09dee6c851e1198b99d2d561aece636b5e7a81bfa01ee554f2c5929611a7d9bd17f175d4c63180c902762199f6978f84c1a1b8e36ce45d7c74715f26753ed0653af1180c81c2a69450204e732ec998aa2f6a2acbe8609a161be2bf036f39452d33ae1418f2d47afca632a25d45c0f1e21a4da9b0bab4baacb88b0e37e0a10a7ed52330de345485116a46a17104d9d3a1651964f60190b8deb0715ec6654d39bd3562b2a0dd1b93ef20611f03371636aab0b88ea3c7e76e2bf87d663408232a709ad2a53c35fd0e32548e75875eb2ff86e14de424263ef835ff763c86c3da23bcb8e99d8c1be269742ee729f9be71e2d2615d554f2a0ff5b58d2d39c51484ed8a0c3cc049419c71358bfb37efb1ba94af18dad5ddb18a81917fb53f10dfcdd8c2abd716ed024406daba81e3495512ce50c3f037e4ef06614355df17dcc2a955b0253232261b95bf861e87df789abf5bfc7e42b41555931cb8d91ea2c3f4048a4ae8ba485545c88d7b92abb7c3371b46f31b58439f31f9f5e269f4b4124514424a0f6a306623d3f661d740b270a81c4dd312ca2bc97d0418053498f36fcd2699a4deb0a2ebe9a9a7299e56f3e8b39eb6944e576789b65e0d4fc68e84d8c094ce2c70a2e7e00a487741400f65c1fe03ed33ca978e7ce29c7b1fcc766480ee3fda7b7401b71eaeaf6c22fdade2baca1eddaaf5fdf6a5f3d9177c6c2c0dfd09564d5250825a6c9f8a372b35b23c5d2b38f8f18e80e402c5fe2afab6d5978e3ea942e12fb5b345c581fbd7ddcc855f3b9391fa0e807b4de37af386bc716cd6660c40febc8527e638192f7bdae84d15aec4eae313a67a8470aeae5335083411f3b5ca5bcc9952871da68a16716bfc4d57fe88389cd3e557164d428ae997a0b2f25f63b990ec4e63619662bff6653d9e799741116362728b47675791b1eeb44c1b2445d9dc86f30b41f6d2ab3d27b91417b06c948e2a1c86f4a73987e5a79a26837d12bd34e593719a62722be80469fbae701ed2627216da55bcbd21604cbc84cf759ae85d7bd09ef2b823f153502c3b4bc2ddc3200c39015b5d1d39ff58b66a5f873d0418c4091ab392d65b825dcc9a7d54c48fcffcbefa1cde9b6db3dbde8ecb05d4f75f9bf014d5f0b0f1a2cd8905c3945c0bc79d5a429c7d4e1676a698ab81a8ff4cdb3c427b05f0ad556635ee861ab2ab0d3dfc1f8570ad68d6a3cc692c98ad68748f4e36be5b50e53884af80b692a0861a7f94b93065a85a635913caf4f77b76da715205c9c0b276c4d00f6e440054504957b633f236bf26b65aeba2f24f2293c77f092c6bc235a23dcddc0b88b0935f0d7bfc3d703d38b4e74a4af55573360b5b6895ac31a7d0fb855d86dfdb4d52d7491d044c140f15ec35319e4c27820a1269629a2d60c24c89757dff10be8a2c8b2cb600af8e80258146049d4ad07f780bcae2687dc387a17d7c7d085562d3ba94960d277bdec11112b40a10bb75ade367d6173a65ee508d6a6315b23ef78f4ac9935d28e95d968e92ed14e4913f12fdb2f71e58142b6932010956c69777913c299fed77137596d5f659298132cc480188059e652bbff8ab963d1439f60e3a353c21c375890b4b3d29c390e344942d6819799b359471a0b7721e85e35b69f15a09ce1f1f4ef2220f9c987fa84951888742c6c594f433649caae67f9a08edd2310c5d99919ef7c0087c372b6ff6a9709ba13058260b9262f3bf685d77a8f4f57fb9efdb42324fac9fa9770b487a4f7bf81249533cfa74edf32c3b15f8716f33370b3a1beb99b033c670016fa5802f83dc7349272d3b075af178ad3e96690ea15736c9ad20cb78e41b1165341bf946eb6d4ba65c7f3471fb12160f1b0166a03dc950d89737ddab70a7e4793274268df21ac46e19472b84829e82217be4db4168de4e0919fff1375b0355c41d5ad34a958c06d6860bea1e9d32ec209cbfdfb7b673e2a3e55f9068e46b5abd88e577d38f1f51d462e04301194c480c84059a1a3c611cabd2ef805248c7a518cf812ced07060c0801f72216614b41872bd19056e17c9d92301aed883a3d41befd6ff48b1599a339158d45f557f982a146a2058ce3a5528809bd04e29ab5dad54c236a4101e6a1c41a197fd0c9eda9fd22b9c2d8a09c68c4ac398eec6cd7e0386a6bca9e4e8ae5d00f778b4bd4e3f6d6963d960156ea6f889442e677f75a66996ce73df1b620bbc34627baa761de0b4ffe4b926b5df02f40ad29210ba7f71def9dcc02ddde40e354a49877ca1108aa57979fbd2f5ab31d44a171560dd72982f06f7e830d43d7288c2de883271b570bf4df18de4272679c719260c31708aa9d2a37874afdd9af659b27cabde6381d98e029bb782a9265b81bade102e7651101a0f8aa772e8f204aec882968ad4b5f2fa6685fddf12abd9bff5d5147acb89731446db55436dcbda2585f4165b53081482edd48b616d9fc7303b1900526ca898d6f4d071a363fe7f3ace367c9f90dab2d7185b445e732f9459c3c3f79a88cb1b31666964186ddcabf54c44918637591f003efb5bc7dc4923d493621ecb82f60754dd1da727cac14aabc9b69a3881f6de4c400b576bd5c68500c05d4b40456db5e39b15ac141232c8ac4b36d4a63e699e2b0e35832e2408b97e98fbee2acce919de41cfcfc03ce17e2ddeffc03171d01a518aa62ad3f3b34ed48f3eccd946ad16cb2ad6681cb02fe6cf410ee25831dd53fe583de7c9b0ca6320c2055538ed59783459859ba0640d38dc1e9454a4500db09d5328a2274b4afc82cf7da239b65a79278d0ca1f0e9c99b86e353bb747d84f5ff8ccb37b11956333d13fc29aa506a08c0e57f615c0ceeffe6858f470dec0bb50f00d2d53d6074b1609a1307b96d7f7eb503aa1d909abb337b623b8b570384765284ebeba274</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码才能查看哟~.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义Nas解决方案</title>
    <link href="/doc/bef2d4b6.html"/>
    <url>/doc/bef2d4b6.html</url>
    
    <content type="html"><![CDATA[<p>为了方便Nas玩家更好的进行自动化资源下载，特意实现Aria2扩展服务，便于自动订阅并下载想要的资源。</p><span id="more"></span><blockquote><p>Aria2官方地址：<a href="https://aria2.github.io/">https://aria2.github.io/</a><br>Aria2源码地址：<a href="https://github.com/aria2/aria2">https://github.com/aria2/aria2</a><br>Aria2镜像源码地址：<a href="https://github.com/P3TERX/Aria2-Pro-Docker">https://github.com/P3TERX/Aria2-Pro-Docker</a><br>Aria2镜像仓库地址：<a href="https://hub.docker.com/r/p3terx/aria2-pro">https://hub.docker.com/r/p3terx/aria2-pro</a></p><p>Aria2-Ext作者地址：<a href="https://blog.cikaros.top/">https://blog.cikaros.top/</a><br>Aria2-Ext源码地址：<a href="https://github.com/Cikaros/aria2-ext">https://github.com/Cikaros/aria2-ext</a><br>Aria2-Ext镜像仓库地址：<a href="https://hub.docker.com/r/cikaros/aria2-ext">https://hub.docker.com/r/cikaros/aria2-ext</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Aria2是一款自由、跨平台命令行界面的下载管理器，该软件根据GPLv2许可证进行分发。 支持的下载协议有：HTTP、HTTPS、FTP、Bittorrent和Metalink。</p><p>为了方便Nas玩家更好的进行自动化资源下载，特意实现Aria2扩展服务，便于自动订阅并下载想要的资源。</p><h2 id="Docker搭建方案"><a href="#Docker搭建方案" class="headerlink" title="Docker搭建方案"></a>Docker搭建方案</h2><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;3.8&quot;services:  Aria2-Pro:    container_name: aria2-pro    image: p3terx&#x2F;aria2-pro    hostname: aria2-pro    environment:      - PUID&#x3D;65534      - PGID&#x3D;65534      - UMASK_SET&#x3D;022      - RPC_SECRET&#x3D;P3TERX      - RPC_PORT&#x3D;6800      - LISTEN_PORT&#x3D;6888      - DISK_CACHE&#x3D;64M      - IPV6_MODE&#x3D;false      - UPDATE_TRACKERS&#x3D;true      - CUSTOM_TRACKER_URL&#x3D;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;DeSireFire&#x2F;animeTrackerList&#x2F;master&#x2F;AT_all.txt      - TZ&#x3D;Asia&#x2F;Shanghai    volumes:      - &#x2F;downloads:&#x2F;downloads      - vo-aria2:&#x2F;config    ports:      - &#39;6800:6800&#39;      - &#39;6888:6888&#39;      - &#39;6888:6888&#x2F;udp&#39;    restart: unless-stopped    # 由于Aria2将继续生成日志，请将日志大小限制为1M，以防止硬盘空间不足。    logging:      driver: json-file      options:        max-size: 1m  Aria2-Ext:    container_name: aria2-ext    image: cikaros&#x2F;aria2-ext:v0.3.x    hostname: aria2-ext    depends_on:      - Aria2-Pro    environment:      LANG: C.UTF-8      TZ: Asia&#x2F;Shanghai      ARIA2_HOST: aria2-pro      ARIA2_STARTUP: &quot;true&quot;      ARIA2_SKIP_BANNER: &quot;true&quot;    restart: unless-stopped    volumes:      - .&#x2F;aria2-ext.db:&#x2F;config&#x2F;data.db      - &#x2F;downloads:&#x2F;downloads    logging:      driver: json-file      options:        max-size: 1m  Aria2-Samba:    container_name: aria2-samba    image: dperson&#x2F;samba:latest    hostname: aria2-samba    environment:      TZ: Asia&#x2F;Shanghai      NMBD: &quot;yes&quot;      USER1: &quot;user1;xxxx&quot;      SHARE1: &quot;downloads;&#x2F;share&#x2F;downloads;yes;no;no;user1;user1;user1;备注1&quot;    volumes:      - &#x2F;downloads:&#x2F;share&#x2F;downloads      - vo-samba-etc:&#x2F;etc      - vo-samba-cache:&#x2F;var&#x2F;cache&#x2F;samba      - vo-samba-lib:&#x2F;var&#x2F;lib&#x2F;samba      - vo-samba-log:&#x2F;var&#x2F;log&#x2F;samba      - vo-samba-bin:&#x2F;run&#x2F;samba    restart: unless-stopped    ports:      - &#39;137:137&#x2F;udp&#39;      - &#39;138:138&#x2F;udp&#39;      - &#39;139:139&#39;      - &#39;445:445&#39;    logging:      driver: json-file      options:        max-size: 1m    deploy:      resources:        limits:          memory: 512Mvolumes:  vo-aria2:  vo-samba-etc:  vo-samba-cache:  vo-samba-log:  vo-samba-lib:  vo-samba-bin:</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Aria2</tag>
      
      <tag>Nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源文件共享-Samba</title>
    <link href="/doc/c3714507.html"/>
    <url>/doc/c3714507.html</url>
    
    <content type="html"><![CDATA[<p>Samba 是将 Linux&#x2F;Unix 服务器和桌面无缝集成到 Active Directory 环境中的重要组件。它既可以用作域控制器，也可以用作常规域成员。</p><span id="more"></span><blockquote><p>官网地址：<a href="https://www.samba.org/">https://www.samba.org/</a><br>Docker Hub：<a href="https://hub.docker.com/r/dperson/samba">https://hub.docker.com/r/dperson/samba</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Samba 是用于 Linux 和 Unix 的标准 Windows 互操作程序套件。</p><p>Samba 是根据GNU 通用公共许可证获得许可的自由软件，Samba 项目是软件自由保护协会的成员。</p><p>自1992年以来，Samba一直为所有使用SMB&#x2F;CIFS协议的客户端提供安全、稳定、快速的文件和打印服务，如所有版本的DOS和Windows、OS&#x2F;2、Linux等。</p><h2 id="Docker搭建Samba服务器"><a href="#Docker搭建Samba服务器" class="headerlink" title="Docker搭建Samba服务器"></a>Docker搭建Samba服务器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;3.8&quot;services:  Aria2-Samba:    container_name: aria2-samba    image: dperson&#x2F;samba:latest    hostname: aria2-samba    environment:      TZ: Asia&#x2F;Shanghai      NMBD: &quot;yes&quot;      USER1: &quot;user1;xxxx&quot;      SHARE1: &quot;folder1;&#x2F;share&#x2F;folder1;yes;no;no;user1;user1;user1;备注1&quot;      SHARE2: &quot;folder2;&#x2F;share&#x2F;folder2;yes;no;no;user1;user1;user1;备注2&quot;    volumes:      - &#x2F;folder1:&#x2F;share&#x2F;folder1      - &#x2F;folder2:&#x2F;share&#x2F;folder2      - vo-samba-etc:&#x2F;etc      - vo-samba-cache:&#x2F;var&#x2F;cache&#x2F;samba      - vo-samba-lib:&#x2F;var&#x2F;lib&#x2F;samba      - vo-samba-log:&#x2F;var&#x2F;log&#x2F;samba      - vo-samba-bin:&#x2F;run&#x2F;samba      restart: unless-stopped    ports:      - &#39;137:137&#x2F;udp&#39;      - &#39;138:138&#x2F;udp&#39;      - &#39;139:139&#39;      - &#39;445:445&#39;    logging:      driver: json-file      options:        max-size: 1m    deploy:      resources:        limits:          memory: 512Mvolumes:  vo-samba-etc:  vo-samba-cache:  vo-samba-log:  vo-samba-lib:  vo-samba-bin:</code></pre></div></figure><h2 id="环境变量介绍"><a href="#环境变量介绍" class="headerlink" title="环境变量介绍"></a>环境变量介绍</h2><ul><li><code>CHARMAP</code> 配置字符映射</li><li><code>GENERIC</code> 配置一个通用部分选项，可多次配置：GENERIC1、GENERIC2…</li><li><code>GLOBAL</code> 配置一个全局选项，可多次配置</li><li><code>IMPORT</code> 导入一个smbpassword文件</li><li><code>NMBD</code> 启用nmbd</li><li><code>PERMISSIONS</code> 设置所有共享的文件权限</li><li><code>RECYCLE</code> 禁用回收站</li><li><code>SHARE</code> 设置一个共享，可多次配置</li><li><code>SMB</code> 禁用 SMB2 最低版本</li><li><code>TZ</code> 设置时区</li><li><code>USER</code> 设置一个用户，可多次配置</li><li><code>WIDELINKS</code> 允许访问广泛的符号链接</li><li><code>WORKGROUP</code> 设置工作组</li><li><code>USERID</code> 为 samba 服务器的默认用户 (smbuser) 设置 UID</li><li><code>GROUPID</code> 为 samba 服务器的默认用户 (smbuser) 设置 GID</li><li><code>INCLUDE</code> 添加一个 smb.conf include</li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>文件共享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-Windows服务指令咨询</title>
    <link href="/doc/cee2a628.html"/>
    <url>/doc/cee2a628.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Windows sc命令的作用？</p></blockquote><p>Windows中的<code>sc</code>命令是用于管理Windows服务的命令行工具，可以用它创建、修改、删除、启动、停止和查询Windows服务。</p><p>以下是一些常见的用法：</p><ul><li><code>sc create</code>: 创建一个新的服务。</li><li><code>sc delete</code>: 删除一个服务。</li><li><code>sc start</code>: 启动一个服务。</li><li><code>sc stop</code>: 停止一个服务。</li><li><code>sc query</code>: 查询一个或多个服务的状态。</li><li><code>sc config</code>: 修改服务的配置信息，例如启动类型、服务名称、二进制路径等。</li></ul><p>使用<code>sc</code>命令需要管理员权限，可以在命令提示符或Powershell中运行。更详细的用法可以使用<code>sc /?</code>命令查看帮助文档。</p><blockquote><p>能否详细介绍一下这个指令的常用场景并举例说明</p></blockquote><p><code>sc</code>命令的常用场景包括：</p><ol><li>管理Windows服务：使用<code>sc</code>命令可以管理Windows服务，如创建、删除、启动、停止、查询服务的状态等。</li></ol><p>例如，要创建一个名为”MyService”的服务，可以使用以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc create MyService binPath&#x3D; &quot;C:\MyService\MyService.exe&quot;</code></pre></div></figure><p>这个命令将创建一个新的服务，并将二进制路径设置为”C:\MyService\MyService.exe”。可以使用<code>sc start MyService</code>命令启动服务，使用<code>sc stop MyService</code>命令停止服务。</p><ol start="2"><li>诊断系统问题：使用<code>sc</code>命令可以帮助诊断系统问题，例如检查服务是否已启动、查看服务的依赖关系等。</li></ol><p>例如，要查看服务”MyService”的状态，可以使用以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc query MyService</code></pre></div></figure><p>这个命令将返回服务的状态、进程ID和启动类型等信息。如果服务没有启动，则可以使用<code>sc start MyService</code>命令启动服务。</p><ol start="3"><li>批处理任务：使用<code>sc</code>命令可以在批处理脚本中自动管理服务。</li></ol><p>例如，要在每天早上8点自动启动服务”MyService”，可以创建一个批处理脚本，包含以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc start MyService</code></pre></div></figure><p>然后使用Windows计划任务将脚本安排在每天早上8点自动运行。</p><p>总之，<code>sc</code>命令是一个强大的工具，可以用于管理Windows服务、诊断系统问题和自动化任务等多种场景。</p><blockquote><p>还有其他的使用场景嘛？</p></blockquote><p>除了上面提到的使用场景，<code>sc</code>命令还有以下一些使用场景：</p><ol><li>修改服务属性：使用<code>sc config</code>命令可以修改服务的属性，例如启动类型、服务描述、失败操作等。</li></ol><p>例如，要将服务”MyService”的启动类型修改为手动，可以使用以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc config MyService start&#x3D; demand</code></pre></div></figure><ol start="2"><li>管理服务依赖项：使用<code>sc config</code>命令可以设置服务的依赖项，即指定其他服务在该服务启动前必须已启动。</li></ol><p>例如，要将服务”MyService”的依赖项设置为”Service1”和”Service2”，可以使用以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc config MyService depend&#x3D; Service1&#x2F;Service2</code></pre></div></figure><ol start="3"><li>导出和导入服务配置：使用<code>sc export</code>命令可以导出服务的配置信息，使用<code>sc create</code>命令可以根据导出的配置信息创建新的服务。</li></ol><p>例如，要导出服务”MyService”的配置信息并保存到文件”MyService.config”中，可以使用以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc export MyService &gt; MyService.config</code></pre></div></figure><p>然后可以在另一台计算机上使用以下命令创建相同的服务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sc create MyService binPath&#x3D; &quot;C:\MyService\MyService.exe&quot; start&#x3D; autosc config MyService depend&#x3D; Service1&#x2F;Service2sc failure MyService actions&#x3D; restart&#x2F;5000&#x2F;restart&#x2F;10000&#x2F;restart&#x2F;20000sc description MyService &quot;This is a sample service.&quot;</code></pre></div></figure><p>以上命令将创建一个新的服务，并将其配置信息设置为与”MyService”服务相同。</p><p>总之，<code>sc</code>命令是一个功能强大的工具，可以用于管理和配置Windows服务，有许多其他的使用场景。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>Cmd</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项-人工智能研究小计1</title>
    <link href="/doc/22b5ce64.html"/>
    <url>/doc/22b5ce64.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>找到一篇文章:<a href="https://iobs.fudan.edu.cn/96/7f/c17248a169599/page.htm">https://iobs.fudan.edu.cn/96/7f/c17248a169599/page.htm</a></p></blockquote><p>这篇文章主要讲述了，在生物发育初期，神经元之间最先是以电信号进行信息传输的，之后会形成稳固联系以化学信号进行传输。</p><p>结合我对神经网络的认知，我猜想神经网络发育初期利用电信号进行信息广播，每个神经元都有着不同的消息接受器，以接受不同强度的电信号（每次传输都会逐级递减信号强度， 同一个信号源不同的距离，信号强度不同）接受到后双方开始发生“联系”。以这种方式形成神经网络。</p><p>但还有一点我不确定，就是生物神经网络中神经元之间了联系包括哪些？是一对一还是一对多还是多对多？生物神经元中可否形成闭环，输入与输出是怎样形成的？</p><p>还有就是因为知道生物神经元会衰老死亡，应该会有神经元的替换方案，具体替换方式未知。但肯定在替换速度上有所限制，不同的基因不同的参数配置，替换速度也应该不同。</p><p>暂时就想到这些…</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-视频播放器原理咨询</title>
    <link href="/doc/a6c8b3a8.html"/>
    <url>/doc/a6c8b3a8.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>我想知道第三方播放器的原理</p></blockquote><p>第三方播放器通常是指不是由原始媒体文件创建者提供的播放器，而是由其他公司或开发者创建的媒体播放器。第三方播放器的原理通常与原始媒体文件的格式有关，因为不同的媒体格式需要不同的解码和播放方法。</p><p>一般来说，第三方播放器的工作流程如下：</p><ol><li><p>解码：第三方播放器会读取原始媒体文件，并将其解码为可播放的格式，例如MP3、MP4或AVI等。</p></li><li><p>呈现：播放器将已解码的媒体呈现给用户，通常是通过音频和视频输出来完成。</p></li><li><p>控制：播放器允许用户控制媒体的播放，包括暂停、快进、后退和音量等。</p></li></ol><p>在实现这些功能时，第三方播放器通常使用不同的技术和算法。例如，解码媒体文件通常涉及到音频和视频编解码器的使用，而呈现和控制则需要使用图形库和输入设备接口。</p><p>需要注意的是，第三方播放器可能会在解码和呈现媒体文件时出现兼容性问题。这是因为不同的媒体文件格式和编解码器可能具有不同的特性和限制。因此，第三方播放器的开发者通常需要考虑这些因素，并进行相应的优化和调整，以确保其可以正常播放多种媒体文件。</p><blockquote><p>我想通过python爬虫爬取视频数据，应该如何去做，原理是什么？</p></blockquote><p>爬取视频数据需要一定的技术和知识，包括网络编程、Web爬虫、数据解析和存储等。下面是一些基本步骤和技术：</p><ol><li><p>确定目标网站：首先需要确定你要爬取的目标网站，比如视频分享网站或视频搜索引擎等。</p></li><li><p>分析目标网站结构：了解目标网站的结构和数据格式是爬取视频数据的前提。通常可以使用网络抓包工具或浏览器开发者工具来分析目标网站的网络请求和响应，以及网页结构和元素。</p></li><li><p>编写爬虫代码：在了解目标网站结构之后，可以使用Python编写爬虫代码，使用requests或其他HTTP库发送网络请求获取数据，并使用解析库如BeautifulSoup或XPath解析网页元素，提取视频链接和相关信息。</p></li><li><p>下载视频文件：获取到视频链接后，可以使用Python的requests库或第三方下载库如youtube-dl下载视频文件。需要注意的是，一些视频网站可能会有反爬虫机制，需要相应的反反爬虫技术来规避风险。</p></li><li><p>存储数据：下载视频文件后，可以使用Python的文件操作或数据库操作来存储数据，方便后续处理和分析。</p></li></ol><p>总的来说，视频数据爬取需要掌握网络编程、Web爬虫、数据解析和存储等技术，同时需要注意反爬虫机制和法律法规等方面的限制。</p><blockquote><p>我就是不理解该如何获取视频连接，因为好多的网站代码中都没有明确的提供视频地址，或者就是断断续续的视频缓存，像这种情况该如何去处理</p></blockquote><p>获取视频链接是视频数据爬取的核心部分，但确实有些视频网站并不会明确提供视频地址或者使用了一些防抓取技术。在这种情况下，可以尝试以下几种方法来获取视频链接：</p><ol><li><p>视频链接直接提取：有些视频网站可能会在网页中直接提供视频链接，可以通过检查网页源代码或使用浏览器开发者工具查看网页元素来获取。</p></li><li><p>分析视频请求链接：视频播放过程中，浏览器会向服务器发送视频请求，这时可以通过抓包工具获取到视频请求链接。可以尝试通过分析请求链接中的参数和URL规则来获取到视频链接。</p></li><li><p>分析视频流媒体地址：一些视频网站会将视频切分成多个小文件进行传输，而这些小文件的地址通常是按照一定的规律排列的。可以通过分析视频流媒体地址的规律来获取到视频链接。</p></li><li><p>使用视频下载器：如果以上方法都无法获取到视频链接，可以尝试使用第三方的视频下载器来下载视频。一些下载器可以通过模拟浏览器操作来获取到视频链接，并下载视频文件。</p></li></ol><p>需要注意的是，一些视频网站可能会使用反爬虫技术，如设置验证码、限制访问频率等，需要相应的反反爬虫技术来规避风险。同时，需要遵守法律法规，不要进行侵权行为。</p><blockquote><p>视频下载器的原理是什么？请为我详细介绍一下</p></blockquote><p>视频下载器是一种可以下载在线视频的工具，它可以通过模拟浏览器行为，获取到视频文件的下载地址，并将视频文件下载到本地。其原理大致可以分为以下几个步骤：</p><ol><li><p>获取视频播放页面：视频下载器首先需要获取到目标视频的播放页面。可以通过程序发送HTTP请求获取到视频播放页面的HTML代码。</p></li><li><p>解析视频播放页面：通过解析视频播放页面，获取到视频的相关信息，包括视频链接、视频格式、视频分辨率、视频大小等等。一些视频网站会将视频链接进行加密或者使用一些防抓取技术，因此解析视频播放页面是获取视频链接的关键。</p></li><li><p>解析视频链接：视频下载器根据解析到的视频链接，对视频文件进行分段下载。在视频下载的过程中，需要考虑网络波动、网络丢包等因素，以保证视频下载的稳定性和完整性。</p></li><li><p>存储视频文件：视频下载器在下载视频文件的同时，需要将视频文件保存到本地存储设备上。在保存视频文件时，需要考虑存储设备的空间大小、视频文件的格式等因素。</p></li></ol><p>需要注意的是，一些视频网站可能会采用反爬虫技术，如验证码、限制访问频率等措施。针对这些反爬虫技术，视频下载器需要相应的反反爬虫技术来规避风险。同时，使用视频下载器需要遵守法律法规，不要进行侵权行为。</p><blockquote><p>请用python为我实现一个简单示例</p></blockquote><p>好的，这里给你一个基于Python的简单示例，演示如何使用Python爬虫来下载视频。请注意，在实际操作中，请遵守相关法律法规，不要进行侵权行为。</p><p>这个示例程序基于第三方库<code>youtube-dl</code>，它可以下载来自多个网站的视频和音频文件。我们可以使用以下步骤来下载一个Youtube视频：</p><ol><li><p>安装<code>youtube-dl</code>库：可以使用<code>pip install youtube-dl</code>命令来安装<code>youtube-dl</code>库。</p></li><li><p>使用Python脚本来下载视频：下面是一个简单的Python脚本，演示如何使用<code>youtube-dl</code>库来下载Youtube视频：</p></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import youtube_dl# 设置下载选项ydl_opts &#x3D; &#123;    &#39;format&#39;: &#39;bestvideo+bestaudio&#x2F;best&#39;,    &#39;outtmpl&#39;: &#39;%(title)s.%(ext)s&#39;,    &#39;merge_output_format&#39;: &#39;mp4&#39;,&#125;# 输入视频链接video_url &#x3D; &#39;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v&#x3D;XXXXXXXXXXX&#39;# 创建&#96;youtube-dl&#96;对象，并下载视频with youtube_dl.YoutubeDL(ydl_opts) as ydl:    ydl.download([video_url])</code></pre></div></figure><p>在上面的示例中，我们设置了下载选项，包括下载格式、输出文件名格式等。然后输入视频链接，并创建<code>youtube-dl</code>对象来下载视频。下载的视频将保存为<code>.mp4</code>格式的文件，文件名将以视频标题命名。</p><p>这只是一个简单的示例，实际上，<code>youtube-dl</code>库支持来自多个网站的视频和音频文件的下载，你可以根据需要设置相应的下载选项。</p><blockquote><p>我重点想了解如何解析网页，请为我介绍这一步骤的相关内容</p></blockquote><p>解析网页是获取网页数据的关键步骤之一。在Python中，我们可以使用一些第三方库，如BeautifulSoup、lxml、PyQuery等，来解析网页。</p><p>下面是一个使用BeautifulSoup库解析网页的示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom bs4 import BeautifulSoup# 发送HTTP请求url &#x3D; &#39;https:&#x2F;&#x2F;www.example.com&#x2F;&#39;response &#x3D; requests.get(url)# 使用BeautifulSoup解析网页soup &#x3D; BeautifulSoup(response.text, &#39;html.parser&#39;)# 获取网页中的元素title &#x3D; soup.title.stringlinks &#x3D; [link.get(&#39;href&#39;) for link in soup.find_all(&#39;a&#39;)]</code></pre></div></figure><p>在上面的示例中，我们首先发送HTTP请求，获取网页的HTML代码。然后，使用BeautifulSoup库解析HTML代码，获取网页中的元素。在这个例子中，我们获取了网页的标题和链接。可以根据实际需求获取其他元素，如文本、图片等。</p><p>需要注意的是，网页的HTML代码可能存在多层嵌套、复杂的结构，因此在解析网页时，需要根据实际情况选择合适的解析方式。同时，需要注意一些网站可能会采取反爬虫措施，如限制访问频率、验证码等，需要根据具体情况选择相应的反反爬虫技术。</p><blockquote><p>有些视频地址会嵌入在js代码中，这些通过python应该如何解析到呢？</p></blockquote><p>要解析嵌入在 JavaScript 代码中的视频地址，你可以使用 Python 的爬虫库，例如 BeautifulSoup 和 requests 库。</p><p>以下是一个简单的示例代码，它使用 requests 库获取网页源代码，然后使用正则表达式从 JavaScript 代码中提取视频地址：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import reimport requestsurl &#x3D; &#39;https:&#x2F;&#x2F;example.com&#39;  # 网页地址response &#x3D; requests.get(url)  # 获取网页源代码# 从源代码中提取 JavaScript 代码pattern &#x3D; re.compile(r&#39;&lt;script&gt;(.*?)&lt;&#x2F;script&gt;&#39;, re.DOTALL)script &#x3D; pattern.search(response.text).group(1)# 从 JavaScript 代码中提取视频地址pattern &#x3D; re.compile(r&#39;src:\s*&quot;(.*?)&quot;&#39;, re.DOTALL)video_url &#x3D; pattern.search(script).group(1)print(video_url)  # 输出视频地址</code></pre></div></figure><p>请注意，这只是一个简单的示例代码，并且可能无法适用于所有情况。在实际应用中，你需要仔细分析 JavaScript 代码，以确保提取视频地址的正则表达式正确匹配目标地址。此外，为了确保代码的可靠性和安全性，请遵循网站的使用规定和法律法规。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>视频</tag>
      
      <tag>播放器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Aria2的介绍与使用</title>
    <link href="/doc/c423ee.html"/>
    <url>/doc/c423ee.html</url>
    
    <content type="html"><![CDATA[<p>Aria2 是一个功能非常强大且功能非常齐全的下载工具，它支持 BT、磁力、HTTP、FTP 等下载协议，常用做离线下载的服务端。</p><span id="more"></span><blockquote><p>官方地址：<a href="https://aria2.github.io/">https://aria2.github.io/</a><br>源码地址：<a href="https://github.com/aria2/aria2">https://github.com/aria2/aria2</a><br>镜像源码地址：<a href="https://github.com/P3TERX/Aria2-Pro-Docker">https://github.com/P3TERX/Aria2-Pro-Docker</a><br>镜像仓库地址：<a href="https://hub.docker.com/r/p3terx/aria2-pro">https://hub.docker.com/r/p3terx/aria2-pro</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>aria2 是一个用于下载文件的实用程序。支持的协议有 HTTP(S)、FTP、SFTP、BitTorrent 和 Metalink。aria2 可以从多个来源&#x2F;协议下载文件并尝试利用您的最大下载带宽。支持同时从HTTP(S)&#x2F;FTP&#x2F;SFTP和BitTorrent下载一个文件，同时从HTTP(S)&#x2F;FTP&#x2F;SFTP下载的数据上传到BT群。使用 Metalink 块校验和，aria2 在下载文件时自动验证数据块。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>多线程下载。aria2 可以从多个来源&#x2F;协议下载文件并尝试利用您的最大下载带宽。真正加快您的下载体验。</li><li>轻量级。aria2 不需要太多内存和 CPU 时间。当磁盘缓存关闭时，物理内存使用量通常为 4MiB（正常 HTTP&#x2F;FTP 下载）到 9MiB（BitTorrent 下载）。下载速度为 2.8MiB&#x2F;秒的 BitTorrent 中的 CPU 使用率约为 6%。</li><li>功能齐全的 BitTorrent 客户端。您想要的 BitTorrent 客户端的所有功能都可用：DHT、PEX、加密、Magnet URI、网络播种、选择性下载、本地对等发现和 UDP 跟踪器。</li><li>支持元链接。aria2 支持Metalink 下载描述格式 （又名 Metalink v4）、Metalink 版本 3 和 Metalink&#x2F;HTTP。Metalink 提供文件验证、HTTP&#x2F;FTP&#x2F;SFTP&#x2F;BitTorrent 集成以及针对语言、位置、操作系统等的各种配置。</li><li>远程控制。aria2 支持 RPC 接口来控制 aria2 进程。支持的接口是 JSON-RPC（通过 HTTP 和 WebSocket）和 XML-RPC。</li></ul><h2 id="aria2-conf配置文件"><a href="#aria2-conf配置文件" class="headerlink" title="aria2.conf配置文件"></a><code>aria2.conf</code>配置文件</h2><p>默认情况下，aria2 检查遗留路径是否 <code>$HOME/.aria2/aria2.conf</code>存在，否则它会解析 <code>$XDG_CONFIG_HOME/aria2/aria2.conf</code>为它的配置文件。您可以使用选项指定配置文件的路径<code>--conf-path</code> 。如果您不想使用配置文件，请使用 <code>--no-conf</code>选项。</p><p>配置文件是一个文本文件，每行有一个选项。在每一行中，您可以指定以下格式的名称-值对，<code>NAME=VALUE</code>其中名称是不带前缀的长命令行选项名称<code>--</code>。您可以对命令行选项使用相同的语法。开头的行<code>#</code>被视为注释：</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># sample configuration file for aria2clisten-port&#x3D;60000dht-listen-port&#x3D;60000seed-ratio&#x3D;1.0max-upload-limit&#x3D;50Kftp-pasv&#x3D;true</code></pre></div></figure><blockquote><p>配置文件中可能包含用户&#x2F;密码等机密信息。建议更改配置文件的文件模式位（例如: <code>chmod 600 aria2.conf</code>），这样其他用户就看不到文件的内容。</p></blockquote><p>以下是 Aria2 的默认配置文件 <code>aria2.conf</code> 中的一些常见配置项及其作用：</p><ol><li><code>dir=DIR</code> 指定下载文件的保存目录。</li><li><code>watchdir=DIR</code> 指定监听种子的目录。</li><li><code>allow-overwrite</code>：允许覆盖已存在的文件，例如 <code>allow-overwrite=true</code></li><li><code>continue</code>：启用断点续传功能，例如 <code>continue=true</code></li><li><code>input-file=FILE</code> 指定下载任务的输入文件，多个输入文件用逗号分隔。</li><li><code>save-session=FILE</code> 指定保存所有下载任务的状态的文件。</li><li><code>continue=true/false</code> 指定是否在下载失败后自动恢复下载。</li><li><code>max-concurrent-downloads=N</code> 指定同时下载的最大任务数。</li><li><code>max-connection-per-server=N</code> 指定每个服务器的最大连接数。</li><li><code>min-split-size=N</code> 指定最小分片大小。</li><li><code>split=N</code> 指定下载时使用的线程数。</li><li><code>max-overall-download-limit=LIMIT</code> 指定所有下载任务的最大下载速度。</li><li><code>max-download-limit=LIMIT</code> 指定每个下载任务的最大下载速度。</li><li><code>max-overall-upload-limit=LIMIT</code> 指定所有上传任务的最大上传速度。</li><li><code>max-upload-limit=LIMIT</code> 指定每个上传任务的最大上传速度。</li><li><code>file-allocation=none/prealloc/falloc</code> 指定文件预分配方式。</li><li><code>log=FILE</code> 指定日志文件的保存路径。</li><li><code>log-level=DEBUG/INFO/WARNING/ERROR/FATAL</code> 指定日志记录级别。</li><li><code>daemon=true/false</code> 指定是否以守护进程方式运行。</li><li><code>enable-rpc=true/false</code> 指定是否启用 RPC 服务器。</li><li><code>rpc-listen-port=PORT</code> 指定 RPC 服务器的监听端口。</li><li><code>rpc-secret=SECRET</code> 指定 RPC 服务器的验证密钥。</li><li><code>rpc-allow-origin-all=true/false</code> 指定是否允许跨域访问 RPC 服务器。</li><li><code>bt-enable-lpd=true/false</code> 指定是否启用本地对等下载。</li><li><code>bt-max-peers=N</code> 指定 BT 下载时的最大对等连接数。</li><li><code>seed-time=SECONDS</code> 指定 BT 下载完成后继续做种的时间。</li><li><code>seed-ratio=RATIO</code> 指定 BT 下载完成后继续做种的分享比率。</li><li><code>listen-port=PORT</code> 指定监听端口。</li><li><code>rpc-secret-file=FILE</code> 指定 RPC 服务器的验证密钥文件。</li><li><code>dir-pr2efix=DIR</code>指定所有下载任务的前缀目录。</li><li><code>always-resume=true/false</code> 指定是否总是在下载任务失败后自动恢复下载。</li><li><code>allow-overwrite=true/false</code> 指定是否允许覆盖同名文件。</li><li><code>auto-save-interval=SECONDS</code> 指定自动保存下载任务状态的时间间隔。</li><li><code>file-allocation=none/prealloc/falloc/...</code> 指定文件预分配方式。</li><li><code>http-accept-gzip=true/false</code> 指定是否允许下载 gzip 压缩过的文件。</li><li><code>http-no-cache=true/false</code> 指定是否禁用 HTTP 缓存。</li><li><code>http-proxy=URL</code> 指定 HTTP 代理服务器地址。</li><li><code>https-proxy=URL</code> 指定 HTTPS 代理服务器地址。</li></ol><h2 id="RPC接口"><a href="#RPC接口" class="headerlink" title="RPC接口"></a>RPC接口</h2><p>Aria2 提供了许多 RPC（远程过程调用）接口，可以使用这些接口从其他应用程序或脚本中控制 Aria2。以下是 Aria2 中最常用的 RPC 接口：</p><ol><li>aria2.addUri([secret,] uris[, options[, position]])：这个接口用于添加一个 HTTP&#x2F;FTP&#x2F;SFTP&#x2F;BitTorrent 下载任务。您可以使用此接口添加单个 URI 或多个 URI，其中 options 参数包括诸如文件保存位置、最大下载速度和下载进度回调等选项。</li><li>aria2.addTorrent([secret,] torrent[, uris[, options[, position]]])：此接口用于添加一个种子下载任务。除了种子文件之外，您还可以提供一组 URI，以便 Aria2 可以查找和下载种子中列出的文件。</li><li>aria2.addMetalink([secret,] metalink[, options[, position]])：此接口用于添加一个 Metalink 下载任务。Metalink 是一个 XML 格式的文件，其中包含多个 URI 和文件哈希值，以便 Aria2 可以下载并验证下载的文件。</li><li>aria2.pause([secret,] gid)：此接口用于暂停正在下载的任务。</li><li>aria2.unpause([secret,] gid)：此接口用于恢复已暂停的下载任务。</li><li>aria2.remove([secret,] gid)：此接口用于删除一个下载任务。</li><li>aria2.tellStatus([secret,] gid[, keys])：此接口返回有关特定下载任务的状态信息，包括下载进度、下载速度、剩余时间和错误消息等。</li><li>aria2.getGlobalStat([secret])：此接口返回有关全局下载统计信息的信息，包括总下载速度、总下载数量和总运行时间等。</li><li>aria2.getVersion([secret])：此接口返回 Aria2 的版本信息。</li><li>aria2.getOption([secret,] gid)：此接口返回指定下载任务的选项，例如文件保存位置、最大下载速度和种子文件保存位置等。</li><li>aria2.changeOption([secret,] gid, options)：此接口用于更改指定下载任务的选项，例如文件保存位置、最大下载速度和下载进度回调等选项。</li><li>aria2.getFiles([secret,] gid)：此接口返回正在下载的文件的详细信息，包括文件名称、大小、下载进度和哈希值等。</li><li>aria2.getUris([secret,] gid)：此接口返回正在下载的文件的 URI 列表，以便您可以查看和更改下载来源。</li><li>aria2.getGlobalOption([secret])：此接口返回全局选项，例如最大下载速度和文件保存位置等。</li></ol><p>这些 RPC 接口提供了对 Aria2 的全面控制，使您可以轻松地从其他应用程序或脚本中控制 Aria2 的下载行为。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Aria2</tag>
      
      <tag>下载器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-TS与JS对比学习</title>
    <link href="/doc/47aace24.html"/>
    <url>/doc/47aace24.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>JS与TS有哪些区别，重点讲区别，要全面</p></blockquote><p>JavaScript (JS) 和 TypeScript (TS) 都是流行的编程语言，用于创建 Web 应用程序。它们都可以用于编写前端和后端应用程序，但是它们在某些方面有所不同。下面是 JS 和 TS 的一些区别：</p><ol><li><p>静态类型检查：TS 强制进行静态类型检查，这意味着您需要在编写代码时指定变量的类型，以确保类型的正确性。相比之下，JS 不需要强制执行静态类型检查。</p></li><li><p>代码可读性：由于 TS 具有静态类型检查，因此代码更易于阅读和理解。您可以在编写代码时清楚地了解变量的类型以及它们可以执行的操作。</p></li><li><p>错误检测：TS 在编译代码时执行类型检查，因此可以更早地检测到潜在的错误。相比之下，JS 只有在代码运行时才能检测到错误。</p></li><li><p>ES6 特性支持：TS 支持 ECMAScript 6 (ES6) 的所有特性，包括类、模块、箭头函数、Promise、解构等，而 JS 仅支持其中的一部分。</p></li><li><p>工具支持：TS 可以使用强大的编辑器（如VS Code）和 IDE 支持，这些工具可以提供更好的自动完成和代码重构。相比之下，JS 的编辑器支持较弱。</p></li><li><p>学习曲线：对于那些没有使用过静态类型语言的人来说，学习 TS 可能会有一定的学习曲线，因为他们需要了解类型注释和类型系统。相比之下，JS 更容易上手。</p></li><li><p>运行时性能：由于 TS 在编译时进行了类型检查和优化，因此在运行时会比 JS 快一些。</p></li></ol><p>总体而言，TS 在类型检查、代码可读性、错误检测和工具支持方面具有优势，而 JS 在学习曲线和灵活性方面具有优势。选择哪种语言取决于您的项目需求和您和您的团队的技能水平。</p><blockquote><p>我想直到他们在语法上都有哪些不通，全面列举</p></blockquote><p>以下是 JavaScript (JS) 和 TypeScript (TS) 在语法上的主要不同之处：</p><ol><li><p>类型注释：TS 要求在变量声明和函数参数、返回值等处都要添加类型注释。这意味着在 TS 中，您需要指定变量、函数参数和返回值的类型，而在 JS 中则不需要。</p></li><li><p>类型声明：TS 允许使用类型声明文件(.d.ts)将 TypeScript 代码和非 TypeScript 代码集成在一起，这是为了允许TS使用 JS 代码库。JS 不支持类型声明。</p></li><li><p>类型系统：TS 具有静态类型系统，这意味着您需要在编写代码时指定变量、函数参数和返回值的类型。而在 JS 中，变量和参数类型是动态的，这意味着它们只有在运行时才确定。</p></li><li><p>枚举：TS 提供了枚举类型，这使得您可以定义具有有限值的一组常量。JS 没有这种类型。</p></li><li><p>泛型：TS 支持泛型类型，这是一种可以在不同类型之间共享代码的方式。JS 没有这种类型。</p></li><li><p>接口：TS 支持接口，这使得您可以定义对象的结构和类型。JS 没有这种类型。</p></li><li><p>类：TS 支持类和面向对象编程，这使得您可以将数据和功能组织成一个单一的单元。JS 也支持类，但是它不是一等公民。</p></li><li><p>可选类型：TS 允许您在变量和函数参数上使用可选类型，这意味着这些变量或参数可以是 undefined。JS 没有这种类型。</p></li><li><p>元组：TS 提供了元组类型，这是一种固定长度、特定类型的数组。JS 没有这种类型。</p></li><li><p>访问修饰符：TS 支持访问修饰符(public, private, protected)，这使得您可以控制类的成员变量和方法的访问级别。JS 没有这种访问控制。</p></li></ol><p>总的来说，TS 在类型系统、泛型、枚举、接口、类和元组等方面与JS不同。</p><blockquote><p>列举一下刚刚说的第1点，用代码举例</p></blockquote><p>好的，以下是类型注释的一个例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; TypeScript中需要类型注释function addNumbers(a: number, b: number): number &#123;  return a + b;&#125;&#x2F;&#x2F; JavaScript中不需要类型注释function addNumbers(a, b) &#123;  return a + b;&#125;</code></pre></div></figure><p>在这个例子中，我们定义了一个函数<code>addNumbers</code>，该函数接受两个参数 <code>a</code> 和 <code>b</code>，并返回它们的和。在 TypeScript 中，我们在函数参数声明和返回值类型之前添加类型注释，以指定参数和返回值的类型。在 JavaScript 中，我们不需要类型注释，因为它是动态类型语言，变量类型是在运行时确定的。</p><blockquote><p>列举一下刚刚说的第2点，用代码举例</p></blockquote><p>好的，以下是类型声明文件的一个例子：</p><p>我们假设我们有一个名为 <code>greeting.js</code> 的 JavaScript 模块，它包含一个导出的函数 <code>sayHello</code>，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; greeting.jsfunction sayHello(name) &#123;  console.log(&#96;Hello $&#123;name&#125;!&#96;);&#125;module.exports &#x3D; &#123; sayHello &#125;;</code></pre></div></figure><p>现在我们想在 TypeScript 代码中使用 <code>sayHello</code> 函数，但是我们需要指定其参数和返回值类型。因此，我们可以创建一个名为 <code>greeting.d.ts</code> 的类型声明文件，将其放置在与 <code>greeting.js</code> 同级的目录中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; greeting.d.tsexport declare function sayHello(name: string): void;</code></pre></div></figure><p>在这个例子中，我们在类型声明文件中使用 <code>declare</code> 关键字来声明 <code>sayHello</code> 函数的类型，以便在 TypeScript 代码中使用它。然后，我们将其导出，以便其他模块可以使用它。</p><p>现在，当我们在 TypeScript 代码中导入 <code>greeting.js</code> 模块时，TypeScript 将自动使用 <code>greeting.d.ts</code> 文件中的类型信息。例如，我们可以编写以下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; index.tsimport &#123; sayHello &#125; from &quot;.&#x2F;greeting&quot;;sayHello(&quot;John&quot;);</code></pre></div></figure><p>在这个例子中，我们使用 <code>import</code> 关键字导入 <code>sayHello</code> 函数，并在 TypeScript 代码中使用它，而无需手动指定其类型。</p><blockquote><p>列举一下刚刚说的第3点，用代码举例</p></blockquote><p>好的，以下是可选链操作符的一个例子：</p><p>假设我们有一个包含以下属性的 JavaScript 对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const person &#x3D; &#123;  name: &quot;John&quot;,  address: &#123;    city: &quot;New York&quot;,    state: &quot;NY&quot;,  &#125;,&#125;;</code></pre></div></figure><p>现在我们想访问 <code>person</code> 对象的 <code>address</code> 属性中的 <code>city</code> 属性。在 JavaScript 中，我们可能会使用以下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const city &#x3D; person.address &amp;&amp; person.address.city;</code></pre></div></figure><p>这是因为如果 <code>person.address</code> 为 <code>undefined</code>，那么访问 <code>person.address.city</code> 将导致 <code>TypeError</code>。因此，我们使用 <code>&amp;&amp;</code> 运算符来检查 <code>person.address</code> 是否为 <code>undefined</code>，只有在 <code>person.address</code> 不为 <code>undefined</code> 时才访问 <code>person.address.city</code> 属性。</p><p>在 TypeScript 中，我们可以使用可选链操作符（<code>?.</code>）来实现相同的行为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const city &#x3D; person.address?.city;</code></pre></div></figure><p>在这个例子中，我们使用可选链操作符（<code>?.</code>）来检查 <code>person.address</code> 是否为 <code>undefined</code>，只有在 <code>person.address</code> 不为 <code>undefined</code> 时才访问 <code>person.address.city</code> 属性。这样可以让我们更方便地访问可能不存在的属性，同时避免了运行时错误。</p><blockquote><p>列举一下刚刚说的第4点，用代码举例</p></blockquote><p>好的，以下是枚举的一个例子：</p><p>在 TypeScript 中，我们可以使用枚举来定义一组有限的命名常量。以下是一个定义颜色的枚举的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum Color &#123;  Red &#x3D; &quot;red&quot;,  Green &#x3D; &quot;green&quot;,  Blue &#x3D; &quot;blue&quot;,&#125;</code></pre></div></figure><p>在这个例子中，我们定义了一个名为 <code>Color</code> 的枚举，它包含三个成员：<code>Red</code>、<code>Green</code> 和 <code>Blue</code>。每个成员都有一个与其关联的字符串值。例如，<code>Color.Red</code> 的值为 <code>&quot;red&quot;</code>。</p><p>在 TypeScript 中，我们可以使用枚举成员来代替硬编码的字符串或数字。例如，我们可以编写以下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const favoriteColor &#x3D; Color.Green;console.log(&#96;My favorite color is $&#123;favoriteColor&#125;.&#96;);</code></pre></div></figure><p>在这个例子中，我们将 <code>favoriteColor</code> 设置为 <code>Color.Green</code>，这是一个枚举成员，它代表字符串值 <code>&quot;green&quot;</code>。然后，我们使用 <code>console.log</code> 函数输出一个字符串，其中包含 <code>favoriteColor</code> 的值。</p><p>值得注意的是，在编译为 JavaScript 之后，枚举成员将被转换为相应的字符串或数字。例如，上面的枚举会被转换为以下 JavaScript 代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Color;(function (Color) &#123;  Color[&quot;Red&quot;] &#x3D; &quot;red&quot;;  Color[&quot;Green&quot;] &#x3D; &quot;green&quot;;  Color[&quot;Blue&quot;] &#x3D; &quot;blue&quot;;&#125;)(Color || (Color &#x3D; &#123;&#125;));</code></pre></div></figure><p>在这个 JavaScript 代码中，枚举成员被转换为了字符串值。因此，我们可以在 TypeScript 中使用枚举，然后在编译为 JavaScript 之后，仍然可以得到预期的结果。</p><blockquote><p>列举一下刚刚说的第5点（泛型），用代码举例</p></blockquote><p>好的，以下是泛型的一个例子：</p><p>在 TypeScript 中，我们可以使用泛型来编写通用的代码，以便在不同的数据类型上工作。以下是一个定义一个简单的泛型函数的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function identity&lt;T&gt;(arg: T): T &#123;  return arg;&#125;</code></pre></div></figure><p>在这个例子中，我们定义了一个名为 <code>identity</code> 的函数，它接受一个类型为 <code>T</code> 的参数 <code>arg</code>，并返回一个类型为 <code>T</code> 的值。<code>&lt;T&gt;</code> 是一个类型参数，它允许我们在函数内部使用 <code>T</code> 来表示任意类型。</p><p>我们可以将这个泛型函数用于不同的数据类型。例如，以下是使用 <code>identity</code> 函数处理不同数据类型的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const str &#x3D; identity&lt;string&gt;(&quot;hello&quot;);const num &#x3D; identity&lt;number&gt;(42);</code></pre></div></figure><p>在这个例子中，我们分别使用 <code>identity</code> 函数处理了字符串和数字。我们通过在函数名后面使用尖括号和类型参数来指定要使用的类型。</p><p>值得注意的是，TypeScript 通常可以根据上下文推断类型参数。因此，我们可以使用以下代码来调用 <code>identity</code> 函数，而不必显式指定类型参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const str &#x3D; identity(&quot;hello&quot;);const num &#x3D; identity(42);</code></pre></div></figure><p>在这个例子中，TypeScript 可以根据 <code>str</code> 和 <code>num</code> 变量的类型推断出类型参数 <code>T</code> 的值。</p><blockquote><p>列举一下刚刚说的第6点（接口），用代码举例</p></blockquote><p>好的，以下是接口的一个例子：</p><p>在 TypeScript 中，我们可以使用接口来描述对象的形状。以下是一个定义一个简单接口的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age: number;&#125;</code></pre></div></figure><p>在这个例子中，我们定义了一个名为 <code>Person</code> 的接口，它描述了一个包含 <code>name</code> 和 <code>age</code> 两个属性的对象。<code>name</code> 属性是一个字符串，<code>age</code> 属性是一个数字。</p><p>我们可以使用 <code>Person</code> 接口来声明一个符合其形状的对象。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person: Person &#x3D; &#123;  name: &quot;Alice&quot;,  age: 30,&#125;;</code></pre></div></figure><p>在这个例子中，我们声明了一个名为 <code>person</code> 的变量，并将其类型指定为 <code>Person</code> 接口。然后，我们将一个对象赋给这个变量，该对象符合 <code>Person</code> 接口的形状。</p><p>值得注意的是，TypeScript 只会检查对象中是否存在所需的属性，并不要求对象具有其他属性。因此，以下代码也是合法的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person: Person &#x3D; &#123;  name: &quot;Bob&quot;,  age: 25,  occupation: &quot;Developer&quot;,&#125;;</code></pre></div></figure><p>在这个例子中，我们声明了一个名为 <code>person</code> 的变量，并将其类型指定为 <code>Person</code> 接口。虽然这个对象有一个额外的 <code>occupation</code> 属性，但 TypeScript 仍然认为它符合 <code>Person</code> 接口的形状。</p><blockquote><p>列举一下刚刚说的第7点（类），用代码举例</p></blockquote><p>好的，以下是类的一个例子：</p><p>在 TypeScript 中，我们可以使用类来描述对象的行为和状态。以下是一个定义一个简单类的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Person &#123;  name: string;  age: number;  constructor(name: string, age: number) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  sayHello() &#123;    console.log(&#96;Hello, my name is $&#123;this.name&#125; and I&#39;m $&#123;this.age&#125; years old.&#96;);  &#125;&#125;</code></pre></div></figure><p>在这个例子中，我们定义了一个名为 <code>Person</code> 的类，它有两个属性 <code>name</code> 和 <code>age</code>，以及一个构造函数和一个方法 <code>sayHello()</code>。</p><p>构造函数用于创建一个新的 <code>Person</code> 对象，它接受两个参数 <code>name</code> 和 <code>age</code>，并将它们分别赋给 <code>this.name</code> 和 <code>this.age</code> 属性。</p><p>方法 <code>sayHello()</code> 用于输出一条问候语，其中包含 <code>this.name</code> 和 <code>this.age</code> 属性的值。</p><p>我们可以使用 <code>new</code> 关键字来创建一个 <code>Person</code> 对象。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person &#x3D; new Person(&quot;Alice&quot;, 30);person.sayHello();</code></pre></div></figure><p>在这个例子中，我们创建了一个名为 <code>person</code> 的变量，并将其赋值为一个新的 <code>Person</code> 对象。然后，我们调用 <code>sayHello()</code> 方法输出问候语。</p><blockquote><p>列举一下刚刚说的第8点（可选类型），用代码举例</p></blockquote><p>好的，以下是可选类型的一个例子：</p><p>在 TypeScript 中，我们可以使用 <code>?</code> 符号来表示一个属性是可选的。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age?: number;&#125;</code></pre></div></figure><p>在这个例子中，我们将 <code>age</code> 属性定义为可选的。这意味着一个 <code>Person</code> 对象可以具有或者不具有 <code>age</code> 属性。</p><p>我们可以像下面这样使用该接口：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person1: Person &#x3D; &#123;  name: &quot;Alice&quot;&#125;;const person2: Person &#x3D; &#123;  name: &quot;Bob&quot;,  age: 30&#125;;</code></pre></div></figure><p>在这个例子中，我们定义了两个变量 <code>person1</code> 和 <code>person2</code>，它们都是符合 <code>Person</code> 接口的对象。但是，<code>person1</code> 没有 <code>age</code> 属性，而 <code>person2</code> 具有 <code>age</code> 属性。</p><p>在这种情况下，如果我们尝试使用 <code>person1.age</code> 访问 <code>age</code> 属性，则 TypeScript 编译器将会给出一个编译时错误，因为 <code>age</code> 属性可能不存在。</p><blockquote><p>列举一下刚刚说的第9点（元组），用代码举例</p></blockquote><p>好的，以下是元组的一个例子：</p><p>在 TypeScript 中，我们可以使用元组来表示一个已知长度和类型的数组。元组中的每个元素可以具有不同的类型，但是它们的类型和顺序必须与元组类型中定义的类型和顺序相匹配。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let person: [string, number];person &#x3D; [&quot;Alice&quot;, 30];console.log(person[0]); &#x2F;&#x2F; 输出 &quot;Alice&quot;console.log(person[1]); &#x2F;&#x2F; 输出 30</code></pre></div></figure><p>在这个例子中，我们定义了一个名为 <code>person</code> 的元组，它具有两个元素，第一个元素的类型为 <code>string</code>，第二个元素的类型为 <code>number</code>。然后，我们将一个由两个元素组成的数组赋值给该变量。</p><p>我们可以使用下标访问元组中的元素，例如，<code>person[0]</code> 可以获取 <code>Alice</code>，<code>person[1]</code> 可以获取 <code>30</code>。</p><p>需要注意的是，元组的长度必须与类型定义中的长度相同，否则 TypeScript 编译器将会给出一个编译时错误。另外，如果我们尝试访问一个不存在的元素，或者访问一个超出元组范围的元素，TypeScript 编译器也会给出一个编译时错误。</p><blockquote><p>列举一下刚刚说的第10点（访问修饰符），用代码举例</p></blockquote><p>好的，以下是访问修饰符的一个例子：</p><p>在 TypeScript 中，我们可以使用访问修饰符来控制类中属性和方法的访问权限。有三种访问修饰符，分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><p><code>public</code> 修饰符表示公共的，可以在任何地方访问。默认情况下，类中的属性和方法都是公共的，也就是说，如果不指定访问修饰符，默认为 <code>public</code>。</p><p><code>private</code> 修饰符表示私有的，只能在类中访问，不能在类的外部访问。</p><p><code>protected</code> 修饰符表示受保护的，可以在类中和该类的子类中访问，但不能在类的外部访问。</p><p>下面是一个使用访问修饰符的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Person &#123;  public name: string;  private age: number;  protected gender: string;  constructor(name: string, age: number, gender: string) &#123;    this.name &#x3D; name;    this.age &#x3D; age;    this.gender &#x3D; gender;  &#125;  public sayHi() &#123;    console.log(&#96;Hi, my name is $&#123;this.name&#125;, I&#39;m $&#123;this.age&#125; years old.&#96;);  &#125;  private getAge() &#123;    return this.age;  &#125;  protected getGender() &#123;    return this.gender;  &#125;&#125;class Student extends Person &#123;  constructor(name: string, age: number, gender: string, studentId: number) &#123;    super(name, age, gender);    this.studentId &#x3D; studentId;  &#125;  private studentId: number;  public sayHi() &#123;    super.sayHi();    console.log(&#96;I&#39;m a student, my student id is $&#123;this.studentId&#125;.&#96;);  &#125;  public getGenderAndAge() &#123;    console.log(&#96;My gender is $&#123;this.getGender()&#125;, and my age is $&#123;this.getAge()&#125;.&#96;);  &#125;&#125;const alice &#x3D; new Person(&quot;Alice&quot;, 30, &quot;female&quot;);alice.sayHi(); &#x2F;&#x2F; 输出 &quot;Hi, my name is Alice, I&#39;m 30 years old.&quot;const bob &#x3D; new Student(&quot;Bob&quot;, 20, &quot;male&quot;, 123456);bob.sayHi(); &#x2F;&#x2F; 输出 &quot;Hi, my name is Bob, I&#39;m 20 years old. I&#39;m a student, my student id is 123456.&quot;bob.getGenderAndAge(); &#x2F;&#x2F; 输出 &quot;My gender is male, and my age is not accessible outside the class.&quot;</code></pre></div></figure><p>在这个例子中，我们定义了一个 <code>Person</code> 类和一个 <code>Student</code> 类。<code>Person</code> 类具有 <code>name</code>、<code>age</code> 和 <code>gender</code> 三个属性，分别使用了 <code>public</code>、<code>private</code> 和 <code>protected</code> 三种访问修饰符。<code>Person</code> 类中的 <code>sayHi()</code> 方法使用了 <code>public</code> 修饰符，可以在类的外部访问。<code>Person</code> 类中的 <code>getAge()</code> 方法使用了 <code>private</code> 修饰符，只能在类中访问。<code>Person</code> 类中的 <code>getGender()</code> 方法使用了 <code>protected</code> 修饰符，可以在类中和该类的子类中访问，但不能在类的外部访问。</p><p><code>Student</code> 类继承了 <code>Person</code> 类并重新实现了 <code>sayHi()</code> ，内部进行了 <code>Person</code> 类的方法调用。</p><blockquote><p>除了这10点之外还有其他的不同嘛，用代码举例</p></blockquote><p>除了这10点之外，还有一些其他的不同之处，具体包括：</p><ol start="11"><li>TS支持枚举类型</li></ol><p>枚举类型（Enum）是TS中新增的数据类型，用于定义一组有名字的常量。在JS中，可以使用对象字面量等方式实现类似的功能，但是在TS中，可以直接使用枚举类型，使代码更加清晰明了。</p><p>以下是一个使用枚举类型的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum Color &#123;  Red,  Green,  Blue&#125;let c: Color &#x3D; Color.Green;console.log(c);  &#x2F;&#x2F; 输出 1</code></pre></div></figure><ol start="12"><li>TS支持命名空间</li></ol><p>命名空间（Namespace）是TS中新增的一种语法，用于将代码组织到逻辑上的命名空间中，避免命名冲突。在JS中，可以使用对象字面量等方式实现类似的功能，但是在TS中，可以直接使用命名空间，使代码更加清晰明了。</p><p>以下是一个使用命名空间的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">namespace MyNamespace &#123;  export function sayHello() &#123;    console.log(&quot;Hello World!&quot;);  &#125;&#125;MyNamespace.sayHello();  &#x2F;&#x2F; 输出 Hello World!</code></pre></div></figure><ol start="13"><li>TS支持装饰器</li></ol><p>装饰器（Decorator）是TS中新增的一种语法，用于为类、方法、属性等添加元数据或修改行为。在JS中，可以使用函数等方式实现类似的功能，但是在TS中，可以直接使用装饰器，使代码更加简洁易读。</p><p>以下是一个使用装饰器的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function log(target: any, key: string, descriptor: PropertyDescriptor) &#123;  const originalMethod &#x3D; descriptor.value;  descriptor.value &#x3D; function(...args: any[]) &#123;    console.log(&#96;Call $&#123;key&#125; with arguments: $&#123;JSON.stringify(args)&#125;&#96;);    const result &#x3D; originalMethod.apply(this, args);    console.log(&#96;Return value: $&#123;JSON.stringify(result)&#125;&#96;);    return result;  &#125;;  return descriptor;&#125;class Calculator &#123;  @log  add(a: number, b: number): number &#123;    return a + b;  &#125;&#125;const calculator &#x3D; new Calculator();const result &#x3D; calculator.add(1, 2);console.log(&#96;Result: $&#123;result&#125;&#96;);  &#x2F;&#x2F; 输出 Result: 3</code></pre></div></figure><p>这些是TS与JS语法上的一些不同点，当然还有其他的一些不同之处，如模块化、类型兼容性、类型推断等。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
      <category>TS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>JS</tag>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-神经网络咨询</title>
    <link href="/doc/f63f87f0.html"/>
    <url>/doc/f63f87f0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>神经网络的核心思想是什么？怎么理解才能让开发者能得心应手</p></blockquote><p>神经网络的核心思想是模拟人脑中的神经元之间的相互作用，从而实现模式识别、分类、预测等任务。具体来说，神经网络由多层神经元组成，每个神经元接收来自前一层神经元的输入，并根据一定的权重和偏置值，将这些输入加权求和，再通过一个激活函数进行非线性变换，最后输出给下一层神经元。通过反复调整权重和偏置值，神经网络可以自动学习输入和输出之间的映射关系，从而实现各种任务。</p><p>为了让开发者能得心应手，他们需要深入了解神经网络的原理和基本概念，包括神经元、层、权重、偏置、损失函数、优化算法等。此外，开发者还需要了解常用的神经网络模型，如前馈神经网络、卷积神经网络、循环神经网络等，以及它们在不同领域中的应用，如计算机视觉、自然语言处理、语音识别等。在实践中，开发者需要熟练使用各种深度学习框架和工具，如TensorFlow、PyTorch等，以及进行模型训练、调参、优化等操作。最重要的是，开发者需要有持续学习和探索的精神，不断跟进最新的研究进展和技术趋势，不断提高自己的技能和水平。</p><blockquote><p>请详细说说让我能够深入理解神经网络的原理</p></blockquote><p>神经网络的原理涉及多个方面，包括神经元的模型、前向传播、反向传播、损失函数和优化算法等。下面我将逐一进行介绍。</p><ol><li><p>神经元模型 神经元是神经网络的基本单元，它接收来自前一层神经元的输入，并通过一定的权重和偏置值将这些输入加权求和，再通过一个激活函数进行非线性变换，最后输出给下一层神经元。神经元模型可以用如下公式来表示：</p><p>$y &#x3D; f(w*x + b)$</p><p>其中，$y$表示神经元的输出，$x$表示神经元的输入，$w$表示权重，$b$表示偏置，$f$表示激活函数。</p></li><li><p>前向传播 前向传播是神经网络的基本操作之一，它指的是从输入层到输出层的信号传递过程。在前向传播中，神经网络将输入信号通过多个层次的神经元进行计算，并输出最终的预测结果。具体来说，前向传播可以用如下公式来表示：</p><p>a^(l) &#x3D; f(z^(l)) &#x3D; f(w^(l)*a^(l-1) + b^(l))</p><p>其中，a^(l)表示第l层神经元的输出，f表示激活函数，z^(l)表示第l层神经元的输入，w^(l)表示第l层神经元的权重矩阵，b^(l)表示第l层神经元的偏置向量。</p></li><li><p>反向传播 反向传播是神经网络的训练过程中必不可少的一步，它指的是从输出层到输入层的误差反向传递过程。在反向传播中，神经网络通过计算损失函数对每个参数的偏导数，并将这些偏导数通过链式法则依次传递回前面的层次，从而实现参数的更新。具体来说，反向传播可以用如下公式来表示：</p><p>δ^(L) &#x3D; ∂C&#x2F;∂a^(L) * f’(z^(L)) δ^(l) &#x3D; (w^(l+1))^T * δ^(l+1) * f’(z^(l))</p><p>其中，δ^(l)表示第l层神经元的误差，C表示损失函数，f’表示激活函数的导数，L表示输出层的编号。</p></li><li><p>损失函数 损失函数是神经网络的重要组成部分，它用来衡量神经网络的预测结果与真实结果之间的差异。常见的损失函数包括均方误差、交叉熵等。均方误差可以用如下公式来表示：</p><p>C &#x3D; 1&#x2F;2 * ∑(y - y_hat)^</p></li></ol><blockquote><p>所以神经网络的核心就是一个一元一次函数，通过学习修复一次函数的参数差异来达到学习的目的</p></blockquote><p>不完全正确。虽然神经网络中的神经元模型可以看做是一种函数，但是神经网络本身并不是简单的一元一次函数。实际上，神经网络是由多个神经元组成的复杂非线性模型，可以用于解决很多非线性问题。</p><p>神经网络的学习过程主要是通过反向传播算法来进行的。反向传播算法是一种优化算法，它通过不断地调整神经网络中各个神经元之间的权重和偏置，从而使得神经网络的预测结果更加接近于真实结果。在这个过程中，损失函数扮演了至关重要的角色，它用于度量神经网络的预测误差，并反向传递给神经网络进行参数更新。</p><p>总之，神经网络的核心思想是通过多个神经元之间的联结来构建一个复杂的非线性模型，通过反向传播算法进行学习和优化，从而实现各种非线性问题的解决。</p><blockquote><p>有没有推荐的中文书籍便于我理解神经网络，理解你的大致原理</p></blockquote><p>当今有很多好的中文书籍可以帮助您深入理解神经网络，以下是一些值得推荐的书籍：</p><ol><li>《深度学习》：作者是神经网络和深度学习领域的专家，书籍深入浅出地介绍了神经网络的基本原理和深度学习的核心技术，并提供了丰富的代码和实战案例。</li><li>《Python深度学习》：该书使用Python语言介绍了神经网络的基本原理、算法和应用，旨在帮助读者快速掌握神经网络的理论和实践技巧。</li><li>《神经网络与深度学习》：该书通过实例讲解，深入浅出地介绍了神经网络的原理、结构和应用，适合初学者和进阶者学习。</li><li>《TensorFlow实战Google深度学习框架》：该书详细介绍了TensorFlow框架的使用和原理，帮助读者深入理解神经网络的基本原理和实现。</li></ol><p>希望这些推荐能够帮助您更好地理解神经网络的原理和应用。</p><blockquote><p>能不能介绍下你的原理呢？不用很深入，太深入了我相信肯定对你有所限制</p></blockquote><p>当涉及神经网络的原理时，其核心思想是通过神经元之间的联结和权重来构建一个复杂的非线性模型，使其能够进行分类、回归、聚类等各种任务。神经网络的工作方式是，它通过输入层接收输入数据，经过一系列隐藏层进行处理，最后在输出层产生结果。</p><p>神经元是神经网络的基本组成单元，每个神经元接收一组输入，通过激活函数将输入信号转换为输出信号。激活函数通常是非线性的，使神经网络可以学习非线性关系。每个神经元都有一组权重，用于调整输入信号的影响程度，从而影响神经元的输出。</p><p>神经网络的学习过程是通过反向传播算法进行的。反向传播算法基于梯度下降的优化思想，它通过计算损失函数的梯度来更新神经网络的权重和偏置，使得神经网络的预测结果更加接近真实结果。这个过程需要大量的训练数据和计算资源。</p><p>总之，神经网络的原理是通过神经元之间的联结和权重来构建一个复杂的非线性模型，通过反向传播算法进行学习和优化，从而实现各种分类、回归、聚类等任务。</p><blockquote><p>能深入一点嘛，这些我大概都了解</p></blockquote><p>当涉及到深入神经网络的原理时，可以从以下几个方面来探讨：</p><ol><li>神经网络的结构：神经网络的结构包括输入层、隐藏层和输出层。输入层接收数据，输出层产生结果，而隐藏层则对输入数据进行处理，提取特征并学习抽象概念。在隐藏层中，神经元之间的连接和权重构成了神经网络的主要计算部分，也是神经网络能够学习复杂非线性关系的关键。</li><li>激活函数：激活函数是神经元的核心部分，它接收神经元的输入信号，并将其转换为输出信号。激活函数通常是非线性的，因为线性函数无法处理非线性关系。常见的激活函数包括sigmoid函数、ReLU函数和tanh函数等。不同的激活函数具有不同的性质和适用范围，选择合适的激活函数对神经网络的性能至关重要。</li><li>损失函数：损失函数是神经网络的训练目标，它表示模型预测结果与真实结果之间的差异程度。损失函数的选择取决于任务类型，如分类问题通常采用交叉熵损失函数，回归问题则通常采用均方误差损失函数。通过最小化损失函数，神经网络的预测结果可以逐步接近真实结果。</li><li>反向传播算法：反向传播算法是神经网络的训练方法，它通过计算损失函数的梯度来更新神经网络的权重和偏置，使得神经网络的预测结果更加接近真实结果。反向传播算法的核心是链式法则，它将损失函数的梯度向后传递到每个神经元，并根据梯度大小更新权重和偏置。</li><li>神经网络的优化方法：神经网络的优化方法包括随机梯度下降、动量优化、自适应学习率、批量归一化等。这些方法可以帮助神经网络快速收敛并达到更好的性能。</li></ol><p>综上所述，深入理解神经网络的原理需要掌握其结构、激活函数、损失函数、反向传播算法和优化方法等方面的知识。</p><blockquote><p>遇到一个问题时，我该如何选择神经网络呢？我很不理解，神经网络的层数和个数应该如何确定</p></blockquote><p>在选择神经网络时，应该考虑以下几个因素：</p><ol><li>问题类型：不同的问题类型需要不同的神经网络结构。例如，分类问题通常采用卷积神经网络（Convolutional Neural Networks，CNN），而序列问题通常采用循环神经网络（Recurrent Neural Networks，RNN）或者变种模型（如长短时记忆网络（Long Short-Term Memory，LSTM）和门控循环单元（Gated Recurrent Unit，GRU））。回归问题通常采用前馈神经网络（Feedforward Neural Networks，FNN）等。</li><li>数据量和维度：对于较大的数据集和高维度的数据，通常需要较深的神经网络来学习更复杂的特征和模式。而对于小型数据集，使用浅层网络可能更为适合，以避免过拟合。</li><li>计算资源：深层神经网络需要更多的计算资源，例如GPU和TPU等，而较浅的神经网络则可以在常规计算机上进行训练。</li><li>模型复杂度：神经网络的复杂度是指神经元的数量和层数等。选择合适的复杂度可以在保证较好的预测能力的同时，减少训练时间和避免过拟合。过多的神经元和层数可能会导致过度拟合，过少的神经元和层数可能会导致欠拟合。</li></ol><p>在确定神经网络的层数和个数时，可以采用以下一些常用的方法：</p><ol><li>经验法则：通常可以根据经验法则来设置神经网络的层数和神经元个数。例如，对于FNN，通常将隐藏层数设定为1-3层，神经元个数根据数据的复杂度和维度进行设置；对于CNN和RNN，通常通过交叉验证来确定网络的结构。</li><li>网格搜索：可以采用网格搜索或随机搜索来寻找最优的神经网络结构。这种方法通常需要耗费大量的计算时间和资源，但可以得到更优秀的模型。</li><li>自动化神经网络：近年来，一些自动化神经网络设计方法的研究正在快速发展。例如，AutoML和神经架构搜索（Neural Architecture Search，NAS）等，这些方法通过搜索空间中的不同网络结构，以自动化的方式设计出更好的神经网络结构。</li></ol><p>总之，在选择神经网络结构时，需要根据不同的问题类型、数据量和维度、计算资源和模型复杂度等因素进行综合考虑，以选择出最优的神经网络结</p><blockquote><p>也就是说，没有一个确定的方式来找寻合适的层数和神经元个数</p></blockquote><p>是的，没有一种确定的方式来寻找最优的神经网络结构。不同的问题类型、数据集和任务都需要不同的网络结构和参数设置。在实践中，可以采用一些常用的方法和技巧来寻找合适的层数和神经元个数，例如经验法则、交叉验证和网格搜索等。但是，这些方法都不是完美的，也无法保证找到最优的神经网络结构。最终的选择通常是需要经验和实验验证的。同时，一些自动化神经网络设计方法的研究正在快速发展，未来也许会为神经网络结构设计提供更加高效和自动化的方法。</p><blockquote><p>人的大脑共有多少神经元，又有几层呢？可以用神经网络去模拟嘛</p></blockquote><p>人脑中神经元的数量和层数是非常庞大和复杂的，目前尚无法准确地确定人脑神经元的数量。根据科学家们的估计，大脑的神经元数量可能在数十亿到千亿个之间，并且大脑中的神经元不是简单地分成几层的，而是形成了错综复杂的连接网络。</p><p>尽管人脑的神经元结构非常复杂，但神经网络的发展正是受到人脑的启发。神经网络可以通过模拟人脑中神经元的工作方式来解决各种问题。虽然神经网络无法完美地模拟人脑，但已经在许多领域展现出了强大的表现力和广泛的应用。在实践中，根据不同的任务和数据集，可以选择不同的神经网络结构和参数设置，从而实现最佳的性能表现。</p><blockquote><p>我记得曾经有种3进制计算机，能介绍一下它的原理嘛，现在是否还有方式实现这样的三进制计算机？</p></blockquote><p>您提到的三进制计算机可能是指三进制电路或三值逻辑电路。传统的数字电路是二进制的，即使用0和1来表示数字和逻辑状态。而三进制电路则使用了三种状态（0、1和-1）来表示数字和逻辑状态。三进制电路可以在一定程度上提高数字电路的密度和功率效率。</p><p>三进制电路的实现方式可以使用三值逻辑门，例如三态门和可编程门阵列（PLA）。三态门可以具有三个不同的输出状态：高电平、低电平和高阻态（即输出不连接任何电路）。PLA可以使用一组输入和一组可编程逻辑门来实现三进制电路。</p><p>三进制电路的实现已经存在一段时间，但是在现代计算机中，二进制计算机仍然是主流，因为它们已经经过广泛的研究和开发，并且已经被证明是非常有效和可靠的。同时，三进制计算机需要新的算法和编程语言来支持三进制的运算和逻辑处理。因此，尽管三进制计算机可能在某些特殊情况下具有优势，但在当前的计算机领域中，二进制计算机仍然是主流。</p><blockquote><p>我记得曾经好像看到一个故事，说当时已经开发出了三进制计算机，却因为不赚钱最终终止了这项技术研究</p></blockquote><p>我不知道具体的故事内容，但是确实有这样的情况。三进制计算机是计算机发展的一个分支，早在20世纪50年代就已经被研究出来。三进制计算机使用三进制的数字系统，可以在某些方面比二进制计算机更有效率，尤其是在一些特殊应用中，例如数字信号处理和图像处理。</p><p>然而，三进制计算机并没有成为主流技术。一方面，三进制计算机需要使用全新的硬件和软件来支持三进制的数字系统，这在当时是一个非常大的挑战。另一方面，二进制计算机已经发展了几十年，经过了广泛的应用和改进，已经被证明是非常有效和可靠的。因此，许多人认为继续发展三进制计算机是一个冒险的选择。</p><p>此外，商业考虑也是三进制计算机研究遇到的挑战之一。在当时，二进制计算机已经成为主流，拥有广泛的市场和商业利益。与之相比，三进制计算机的市场潜力不确定，商业利益也不明显。因此，一些公司和机构在研究三进制计算机之后放弃了这项技术的研究和开发。</p><blockquote><p>为什么说三进制对数字信号处理和图像处理更有效率呢？原理是什么？</p></blockquote><p>三进制在数字信号处理和图像处理中具有一些优势。其中一个优势是在处理一些特定的算法时，三进制可以比二进制计算更快，因为在三进制中，两个数的差值可以用更少的位数来表示。</p><p>在数字信号处理和图像处理中，经常需要进行高精度的浮点数计算，而这些计算需要大量的乘法和加法运算。在二进制中，乘法和加法都是非常耗时的操作，而在三进制中，相比之下乘法和加法的运算速度更快。这是因为在三进制中，每个数位可以表示-1、0或1这三种状态，而这三种状态的计算可以使用非常简单的门电路实现，这就可以实现更快速的运算。此外，三进制计算机中的寄存器也可以更高效地利用位数，从而进一步提高运算速度。</p><p>但需要注意的是，尽管三进制计算机可以提供一些优势，但是它也具有一些局限性。例如，由于三进制数字系统中的数字位数比二进制多一倍，所以需要更多的电路来支持它，从而增加了设计和制造的难度和成本。此外，在一些计算中，三进制可能比二进制更慢，这取决于具体的算法和实现方式。</p><p>总的来说，三进制计算机是一种有趣的技术，但它并没有被广泛采用，因为它并不一定比二进制计算机更优秀。</p><blockquote><p>不考虑三进制计算机的硬件很难实现这一局限性，单纯说三进制的计算机，在神经网络方面它有优势吗？具体如何？</p></blockquote><p>对于神经网络来说，采用三进制计算可以提供一些潜在的优势。由于神经网络的训练过程通常涉及到大量的矩阵计算，因此三进制计算可以通过降低矩阵乘法的计算量来提高神经网络的计算效率。</p><p>具体来说，三进制计算可以通过使用三元位表示权重和激活函数的值，从而可以将原来的矩阵乘法转化为一种更简单的计算方式，即三进制矩阵乘法。在三进制矩阵乘法中，计算量比二进制矩阵乘法要少，这就可以大大加快神经网络的计算速度。</p><p>此外，三进制计算还可以通过减少内存访问和数据传输来降低计算的能耗，从而使得神经网络在边缘设备上的应用更加实用。</p><p>然而，需要注意的是，尽管三进制计算可以提供一些优势，但它也具有一些局限性。例如，使用三进制计算可能会导致更多的错误率和精度下降，这取决于具体的算法和实现方式。此外，采用三进制计算还需要进行更多的硬件优化和工程设计，这将增加系统的复杂度和成本。</p><blockquote><p>假设说神经网络的层数与个数已确定，但是在最初思索如何实现时使用了比确定个数更多的层数与个数时会对神经网路的有效性有影响吗？具体有何影响</p></blockquote><p>在神经网络中，使用比确定个数更多的层数和神经元通常会增加模型的复杂度，这可能会导致过度拟合和训练时间的增加。</p><p>过度拟合指的是神经网络在训练集上表现很好，但是在测试集或实际应用中表现不佳的情况。当神经网络过于复杂时，它可能会过度记忆训练集中的噪声，从而忽略真正的特征。这意味着，当应用到新数据时，模型可能会表现出不好的性能。因此，使用过多的层数和神经元可能会导致过度拟合。</p><p>此外，使用过多的层数和神经元也可能会增加训练时间。由于神经网络通常需要在大量的数据上进行训练，每个训练步骤都需要计算成千上万个神经元之间的权重和偏差的调整。如果神经网络太大，计算时间将大大增加，这将增加训练的时间和资源消耗。</p><p>因此，在设计神经网络时，应该避免使用过多的层数和神经元。应该通过反复测试和验证来确定合适的模型复杂度，并且在训练过程中使用技巧和策略来减少过度拟合和计算时间。</p><blockquote><p>所以一般在实现过程中也会适当的使用合适的降噪算法过滤数据是吗</p></blockquote><p>是的，降噪算法可以用来过滤数据中的噪声和不必要的信息，从而提高神经网络的准确性和鲁棒性。一些常见的降噪算法包括：</p><ol><li>均值滤波：用周围像素的平均值代替当前像素的值，可以平滑图像并去除噪声。</li><li>中值滤波：用周围像素的中位数代替当前像素的值，可以在保留图像细节的同时去除噪声。</li><li>高斯滤波：使用高斯核函数对图像进行卷积操作，可以平滑图像并去除噪声。</li><li>小波变换：通过将信号分解成不同的频率组件，可以去除噪声并保留信号的重要特征。</li></ol><p>这些降噪算法可以应用于各种信号和数据处理任务，例如图像处理、音频处理和时间序列分析。在神经网络的实现过程中，应该根据具体任务的需求选择合适的降噪算法，以提高数据的质量和神经网络的准确性。</p><blockquote><p>所以降噪一般用于图像、视频、音频处理，或者说流数据的处理上是吗</p></blockquote><p>是的，降噪算法通常用于图像、视频、音频等连续数据流的处理上。这是因为这些数据往往受到环境干扰、设备噪声等因素的影响，导致信号中存在各种形式的噪声，从而影响数据的质量和准确性。通过应用降噪算法，可以去除这些噪声，从而提高数据的质量和可靠性。在神经网络的实现中，使用降噪算法可以提高训练数据的准确性和鲁棒性，从而提高神经网络的性能。</p><blockquote><p>在人工智能方面，是否存在做抉择的神经网路？从我们刚刚的聊天中我发现，在学习过程中如果拥有一个抉择的神经网络的话就可以更好的去决定数据是否需要处理或者其他的决择</p></blockquote><p>是的，在人工智能领域中存在许多用于决策和分类的神经网络模型。这些模型通常被称为决策树、支持向量机、神经决策网络等。它们可以接收一组输入特征，并根据这些特征进行分类或预测。在这些模型中，决策树是一种常用的分类模型，它通过对输入数据进行逐步划分，最终将数据划分为不同的类别。而支持向量机则是一种基于分类超平面的分类模型，它通过最大化不同类别之间的间隔，来实现数据的分类。神经决策网络则是一种将神经网络与决策树相结合的模型，它可以在学习过程中动态生成决策树，从而实现更高效和准确的分类和决策。这些模型在许多领域中都有广泛的应用，例如图像识别、语音识别、自然语言处理、医学诊断等。</p><blockquote><p>我终于明白了，训练人工智能需要大量的数据支撑，一般人做不了这个</p></blockquote><p>是的，确实需要大量的数据作为支撑来训练出高质量的人工智能模型。而这些数据往往需要进行标注和处理，需要耗费大量的时间和人力成本。因此，一般来说，只有拥有大量数据和足够的资源的机构和公司才能在人工智能领域取得重要的进展。不过，近年来出现了一些开源的数据集和平台，使得个人和小型团体也能够使用这些数据和工具进行人工智能的研究和开发。</p><blockquote><p>但是很有限不是吗？因为这些机构可以控制开放的数据集</p></blockquote><p>确实如此，尽管有很多开源的数据集和平台，但是真正可以用于研究和开发的数据仍然相对有限。很多数据集都是由大型公司或者机构掌控，并不一定能够公开开放。此外，即使数据集开放了，也需要一定的技术水平才能够处理和使用这些数据集。不过，随着人工智能领域的发展，越来越多的数据集和工具会被公开开放，这也为广大的研究人员和开发者提供了更多的机会。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>人工智能</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 注册表</title>
    <link href="/doc/5ef1aa76.html"/>
    <url>/doc/5ef1aa76.html</url>
    
    <content type="html"><![CDATA[<p>注册表是Windows操作系统中的一个重要数据库，用于存储系统和应用程序的设置和配置。</p><span id="more"></span><h2 id="注册表项介绍"><a href="#注册表项介绍" class="headerlink" title="注册表项介绍"></a>注册表项介绍</h2><ul><li><code>HKEY_CLASSES_ROOT</code> 存储了文件类型和关联的应用程序信息，一般用于双击时打开何种程序。</li><li><code>HKEY_CURRENT_USER</code> 存储当前用户的个人设置和信息，包括桌面背景、文件夹选项等。</li><li><code>HKEY_LOCAL_MACHINE</code> 存储了计算机的硬件信息和软件配置信息，包括设备驱动程序、系统服务等。</li><li><code>HKEY_USERS</code> 存储了系统中所有用户的设置和配置，包括<code>HKEY_CURRENT_USER</code>的用户信息。</li><li><code>HKEY_CURRENT_CONFIG</code> 存储了当前系统的硬件配置信息，包括处理器、内存、显示器等。</li><li><code>HKEY_DYN_DATA</code> 存储了系统的动态硬件信息，包括正在使用的硬件设备的信息。例如内存、处理器等。</li><li><code>HKEY_PERFORMANCE_DATA</code> 存储了系统性能相关信息，例如CPU使用率、磁盘IO等。</li><li><code>HKEY_PERFORMANCE_DATA</code>：存储系统性能数据，包括系统启动时间、CPU利用率、内存使用情况等。</li><li><code>HKEY_USERS.DEFAULT</code>：存储新用户的默认配置信息。</li></ul><h3 id="常见注册表项"><a href="#常见注册表项" class="headerlink" title="常见注册表项"></a>常见注册表项</h3><ul><li><code>HKEY_CLASSES_ROOT\Directory</code> 存储了Windows资源管理器中文件夹的默认视图和行为。</li><li><code>HKEY_CURRENT_USER\Control Panel\Desktop</code> 存储了桌面相关的配置信息，例如屏幕保护程序、背景图片等。</li><li><code>HKEY_LOCAL_MACHINE\Software</code> 存储了安装在系统中的应用程序的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet</code> 存储了系统的当前配置信息，包括驱动程序、系统服务等。</li><li><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Enum</code> 存储硬件设备的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</code> 存储了Windows系统服务的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment</code> 存储系统环境变量的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Classes</code> 存储文件类型关联信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\Main</code> 存储Internet Explorer浏览器的主要配置信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion</code> 存储系统的版本信息和用户配置信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code> 存储Windows登录界面的配置信息，例如自动登录、欢迎动画等。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Drivers32</code> 存储了Windows系统的音频驱动程序相关的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies</code> 存储系统策略的配置信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code> 存储Windows启动时需要自动运行的程序信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall</code> 存储已安装程序的卸载信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code>：存储Windows资源管理器中各个文件夹的路径信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code>：存储当前用户的Windows资源管理器中各个文件夹的路径信息。</li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Internet Settings</code>：存储Internet Explorer浏览器的Internet设置信息。</li></ul><p>以上是一些常见的注册表键，它们的作用和用途非常广泛。虽然修改注册表可能会对系统造成一定的影响，但了解注册表的基本知识还是很有必要的，因为在某些情况下，更改注册表是解决系统问题的有效方法。</p><blockquote><p>为方便整理数据实现了一套Powershell脚本，代码如下：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1"># Env-Helper.ps1# 定义JSON数据的地址# JSON: [&#123;&quot;name&quot;:&quot;JAVA_HOME&quot;,&quot;value&quot;:&quot;E:&#x2F;tmp&#x2F;jdk&quot;,&quot;default&quot;:true,&quot;type&quot;:&quot;Machine&quot;&#125;,...]# name:环境变量名;value:环境变量值;type:环境变量类型&lt;Machine|User&gt;;default:是否为默认变量$jsonUrl &#x3D; &quot;https:&#x2F;&#x2F;example.com&#x2F;env.json&quot;$currentDirectory &#x3D; $PWD.Path# 导入JSON数据function getJsonData($url) &#123;    return Invoke-RestMethod -Uri $url&#125;# 备份环境变量function backupEnv($type) &#123;    # 定义备份文件名    $backupFileName &#x3D; $currentDirectory + &quot;\Env-$type-$(Get-Date -Format &#39;yyyy-MM-dd&#39;).reg&quot;    # 备份环境变量    switch ($type) &#123;        &quot;Machine&quot; &#123; Start-Process -FilePath &quot;reg.exe&quot; -ArgumentList &quot;export HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment &#96;&quot;$backupFileName&#96;&quot; &#x2F;y&quot; -Verb RunAs -Wait &#125;        &quot;User&quot; &#123; Start-Process -FilePath &quot;reg.exe&quot; -ArgumentList &quot;export HKCU\Environment &#96;&quot;$backupFileName&#96;&quot; &#x2F;y&quot; -Wait &#125;        &quot;All&quot; &#123; backupEnv &quot;Machine&quot;; backupEnv &quot;User&quot; &#125;    &#125;&#125;# 重置环境变量function resetEnv() &#123;    $json &#x3D; getJsonData $jsonUrl;    # 备份环境变量    backupEnv &quot;All&quot;    # 删除现有环境变量    Remove-Item -Path &quot;Env-All-$(Get-Date -Format &#39;yyyy-MM-dd&#39;).reg&quot; -Force -ErrorAction Ignore    Remove-Item -Path &quot;Env-Machine-$(Get-Date -Format &#39;yyyy-MM-dd&#39;).reg&quot; -Force -ErrorAction Ignore    Remove-Item -Path &quot;Env-User-$(Get-Date -Format &#39;yyyy-MM-dd&#39;).reg&quot; -Force -ErrorAction Ignore    # 添加默认环境变量    foreach ($envVar in $json) &#123;        if ($envVar.default) &#123;            switch ($envVar.type) &#123;                &quot;Machine&quot; &#123; [Environment]::SetEnvironmentVariable($envVar.name, $envVar.value, &quot;Machine&quot;) &#125;                &quot;User&quot; &#123; [Environment]::SetEnvironmentVariable($envVar.name, $envVar.value, &quot;User&quot;) &#125;            &#125;        &#125;    &#125;&#125;# 整理环境变量function trimEnv($type) &#123;    $json &#x3D; getJsonData $jsonUrl    # 备份环境变量    backupEnv $type    # 获取现有环境变量    switch ($type) &#123;        &quot;Machine&quot; &#123; $envVars &#x3D; Get-ItemProperty -Path &quot;Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\&quot;* &#125;        &quot;User&quot; &#123; $envVars &#x3D; Get-ItemProperty -Path &quot;Registry::HKEY_CURRENT_USER\Environment\&quot;* &#125;        &quot;All&quot; &#123; trimEnv &quot;Machine&quot;; trimEnv &quot;User&quot;; return &#125;    &#125;        # 整理环境变量    foreach ($envVar in $envVars) &#123;        foreach ($jsonEnvVar in $json) &#123;            if ($jsonEnvVar.default -and $jsonEnvVar.type -eq $type -and $envVar.PSChildName -eq $jsonEnvVar.name) &#123;                [Environment]::SetEnvironmentVariable($envVar.PSChildName, $jsonEnvVar.value, $type)                break            &#125;        &#125;    &#125;&#125;# 列出环境变量function listEnv($type, $name, $value) &#123;    # 获取现有环境变量    switch ($type) &#123;        &#39;Machine&#39; &#123;            $envVars &#x3D; [Environment]::GetEnvironmentVariables(&#39;Machine&#39;)            break        &#125;        &#39;User&#39; &#123;            $envVars &#x3D; [Environment]::GetEnvironmentVariables(&#39;User&#39;)            break        &#125;        default &#123;            $envVarsMachine &#x3D; [Environment]::GetEnvironmentVariables(&#39;Machine&#39;)            $envVarsUser &#x3D; [Environment]::GetEnvironmentVariables(&#39;User&#39;)            $envVars &#x3D; $envVarsMachine.Clone()            foreach ($key in $envVarsUser.Keys) &#123;                if (-not $envVars.Contains($key)) &#123;                    $envVars.Add($key, $envVarsUser[$key])                &#125;            &#125;        &#125;    &#125;    # 根据条件过滤     $envVars.GetEnumerator() | Where-Object &#123;        if ($name -and $value) &#123;            $_.Key -like &quot;*$name*&quot; -and $_.Value -like &quot;*$value*&quot;        &#125; elseif ($name) &#123;            $_.Key -like &quot;*$name*&quot;        &#125; elseif ($value) &#123;            $_.Value -like &quot;*$value*&quot;        &#125; else &#123;            $true        &#125;    &#125; | ForEach-Object &#123;        Write-Output &quot;$($_.Key)&#x3D;$($_.Value)&quot;    &#125;&#125;function addEnv($type, $keyValue) &#123;    $path &#x3D; getEnvPath $type    $key &#x3D; $keyValue.split(&#39;&#x3D;&#39;)[0]    $value &#x3D; $keyValue.split(&#39;&#x3D;&#39;)[1]    if (!$key -or !$value) &#123;        Write-Host &quot;Invalid parameter. Usage: add &lt;Machine|User&gt; &lt;key&#x3D;value&gt;&quot;        return    &#125;    $existing &#x3D; getEnv $type    $existing | Where-Object &#123; $_.name -eq $key &#125; | ForEach-Object &#123;        Write-Host &quot;Key &#39;$key&#39; already exists. Please use &#39;set&#39; command to update its value.&quot;        return    &#125;    $env &#x3D; New-Object System.Collections.Specialized.StringDictionary    $env.Add($key, $value)    if ($type -eq &quot;Machine&quot;) &#123;        $env | Export-Clixml -Path $path -Force        $machineEnv &#x3D; [System.EnvironmentVariableTarget]::Machine        [System.Environment]::SetEnvironmentVariable($key, $value, $machineEnv)    &#125; else &#123;        $env | Export-Clixml -Path $path -Force        $userEnv &#x3D; [System.EnvironmentVariableTarget]::User        [System.Environment]::SetEnvironmentVariable($key, $value, $userEnv)    &#125;    Write-Host &quot;Key &#39;$key&#39; added successfully.&quot;&#125;function delEnv($type, $keyValue) &#123;    # 备份环境变量    backupEnv $type    # 获取待删除的环境变量    $envsToDelete &#x3D; $keyValue | ForEach-Object &#123;        $kv &#x3D; $_ -split &#39;&#x3D;&#39;, 2        [PSCustomObject]@&#123;            key &#x3D; $kv[0]            value &#x3D; $kv[1]        &#125;    &#125;    # 遍历待删除的环境变量    foreach ($envToDelete in $envsToDelete) &#123;        $key &#x3D; $envToDelete.key        $value &#x3D; $envToDelete.value        # 获取环境变量的名称        $envName &#x3D; if ($type -eq &#39;Machine&#39;) &#123;            &quot;HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\$key&quot;        &#125; else &#123;            &quot;HKCU:\Environment\$key&quot;        &#125;        # 判断环境变量是否存在        if (Test-Path $envName) &#123;            # 删除环境变量            Remove-ItemProperty $envName -Name $key -Force            Write-Host &quot;Deleted environment variable &#39;$key&#39; with value &#39;$value&#39;.&quot;        &#125; else &#123;            Write-Host &quot;Environment variable &#39;$key&#39; with value &#39;$value&#39; does not exist.&quot;        &#125;    &#125;    # 刷新环境变量    flushEnv&#125;function defaultEnv($type, $all) &#123;    $json &#x3D; getJsonData $jsonUrl    # 获取现有环境变量    $envs &#x3D; getEnvs $type    # 备份现有环境变量    backupEnvs $type    # 根据json数据进行处理    foreach ($env in $json) &#123;        # 如果是指定类型或者是全部类型        if ($env.type -eq $type -or $all) &#123;            # 如果default为true或者使用-a参数            if ($env.default -or $all) &#123;                # 如果当前变量已存在，则替换其值                if ($envs.ContainsKey($env.name)) &#123;                    $envs[$env.name] &#x3D; $env.value                &#125;                # 否则，新增一个变量                else &#123;                    $envs.Add($env.name, $env.value)                &#125;            &#125;        &#125;    &#125;    # 保存修改    setEnvs $envs&#125;function switchEnv($type, $name) &#123;    # 获取现有环境变量    $envs &#x3D; getEnvs $type    # 如果该变量不存在，输出错误信息    if (!$envs.ContainsKey($name)) &#123;        Write-Error &quot;The environment variable $name does not exist&quot;        return    &#125;    # 如果该变量只有一个值，输出错误信息    $values &#x3D; $envs[$name] -split &quot;;&quot;    if ($values.Length -lt 2) &#123;        Write-Error &quot;The environment variable $name only has one value&quot;        return    &#125;    # 轮询切换    $newValue &#x3D; $values[1..($values.Length - 1)] + $values[0]    $envs[$name] &#x3D; $newValue -join &quot;;&quot;    # 保存修改    setEnvs $envs&#125;function flushEnv() &#123;    $envVars &#x3D; [System.Environment]::GetEnvironmentVariables()    foreach ($key in $envVars.Keys) &#123;        [System.Environment]::SetEnvironmentVariable($key, $envVars[$key], [System.EnvironmentVariableTarget]::Process)    &#125;    Write-Output &quot;Environment variables flushed successfully.&quot;&#125;function Show-Help &#123;    Write-Host &quot;Usage: &quot;    Write-Host &quot;backup [All|Machine|User]: Backup environment variables. Default: All&quot;    Write-Host &quot;reset: Reset environment variables to default values.&quot;    Write-Host &quot;trim [All|Machine|User]: Trim environment variables.&quot;    Write-Host &quot;list &lt;-a|-m|-u&gt; [-n &lt;name&gt;] [-v &lt;value&gt;]: List environment variables.&quot;    Write-Host &quot;add &lt;Machine|User&gt; &lt;key&#x3D;value&gt;: Add a new environment variable.&quot;    Write-Host &quot;del &lt;Machine|User&gt; &lt;key&#x3D;value&gt;: Delete an environment variable.&quot;    Write-Host &quot;default &lt;All|Machine|User&gt; [-a]: Update environment variables with default values.&quot;    Write-Host &quot;switch &lt;Machine|User&gt; &lt;name&gt;: Switch values of the specified environment variable.&quot;    Write-Host &quot;flush: Flush environment variables to make changes take effect in the current session.&quot;&#125;# 处理命令switch ($args[0]) &#123;    &quot;backup&quot; &#123;        if ($args.Length -eq 1) &#123;            backupEnv &quot;All&quot;        &#125; else &#123;            backupEnv $args[1]        &#125;    &#125;    &quot;reset&quot; &#123;        backupEnv &quot;All&quot;        resetEnv    &#125;    &quot;trim&quot; &#123;        if ($args.Length -eq 1) &#123;            trimEnv &quot;All&quot;        &#125; else &#123;            trimEnv $args[1]        &#125;    &#125;    &quot;list&quot; &#123;        if ($args.Length -eq 1) &#123;            listEnv &quot;All&quot; $null $null        &#125; else &#123;            $type &#x3D; &quot;&quot;            if ($args[1] -eq &quot;-m&quot;) &#123;                $type &#x3D; &quot;Machine&quot;            &#125; elseif ($args[1] -eq &quot;-u&quot;) &#123;                $type &#x3D; &quot;User&quot;            &#125; elseif ($args[1] -eq &quot;-a&quot;) &#123;                $type &#x3D; &quot;All&quot;            &#125;            $name &#x3D; $args | ? &#123;$_ -match &quot;^-n&#x3D;&quot;&#125; | %&#123;$_ -replace &quot;^-n&#x3D;&quot;,&quot;&quot;&#125;            $value &#x3D; $args | ? &#123;$_ -match &quot;^-v&#x3D;&quot;&#125; | %&#123;$_ -replace &quot;^-v&#x3D;&quot;,&quot;&quot;&#125;            listEnv $type $name $value        &#125;    &#125;    &quot;add&quot; &#123;        addEnv $args[1] $args[2]    &#125;    &quot;del&quot; &#123;        backupEnv $args[1]        delEnv $args[1] $args[2]    &#125;    &quot;default&quot; &#123;        if ($args.Length -eq 1) &#123;            defaultEnv &quot;All&quot; $false        &#125; elseif ($args[1] -eq &quot;-a&quot;) &#123;            defaultEnv $args[2] $true        &#125; else &#123;            defaultEnv $args[1] $false        &#125;    &#125;    &quot;switch&quot; &#123;        switchEnv $args[1] $args[2]    &#125;    &quot;flush&quot; &#123;        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, &quot;1&quot;, &quot;User&quot;)        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, &quot;1&quot;, &quot;Machine&quot;)        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, &quot;1&quot;, &quot;Process&quot;)        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, $null, &quot;User&quot;)        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, $null, &quot;Machine&quot;)        [Environment]::SetEnvironmentVariable(&quot;dummy&quot;, $null, &quot;Process&quot;)    &#125;    default &#123;        Show-Help    &#125;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Windows</tag>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu弃用apt-key</title>
    <link href="/doc/2964f075.html"/>
    <url>/doc/2964f075.html</url>
    
    <content type="html"><![CDATA[<h2 id="弃用原因"><a href="#弃用原因" class="headerlink" title="弃用原因"></a>弃用原因</h2><p>apt-key 命令被弃用是因为它存在安全问题。这个命令使用了非对称加密算法（公钥加密），它通过在本地计算机上生成一对公钥和私钥，然后将公钥上传到软件源服务器上，以确保软件包的完整性和认证性。然而，这种方法存在一个潜在的风险：如果攻击者能够通过某种方式篡改了软件源服务器上的公钥，那么他们就可以轻松地欺骗本地计算机，让其相信软件包是合法和完整的，即使它们被篡改或植入了恶意软件。</p><p>为了解决这个问题，Ubuntu 现在更推荐使用 gpg 命令。gpg 命令使用数字签名来保证软件包的完整性和认证性。与 apt-key 不同，gpg 不使用服务器上的公钥，而是使用软件包本身的数字签名。这样，即使攻击者篡改了服务器上的公钥，也无法通过数字签名验证软件包的完整性和认证性。</p><p>因此，使用 gpg 命令代替 apt-key 命令可以提高软件包的安全性。</p><h2 id="来自ChatGPT的回答"><a href="#来自ChatGPT的回答" class="headerlink" title="来自ChatGPT的回答"></a>来自ChatGPT的回答</h2><blockquote><p>Ubuntu 22.04在进行apt update 时报错：The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 40976EAF437D05B5 NO_PUBKEY 3B4FE6ACC0B21F32</p></blockquote><p>这个错误是由于系统中缺少对应的公钥，可以通过以下步骤来解决：</p><ol><li><p>打开终端，输入以下命令，将缺少的公钥添加到系统中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5 3B4FE6ACC0B21F32</code></pre></div></figure></li><li><p>然后再次运行 <code>sudo apt update</code> 命令，应该不会再出现该错误。</p></li></ol><p>这个命令会从 Ubuntu 的公钥服务器下载缺少的公钥并添加到系统中。如果你的网络环境有限制，你也可以使用其他的公钥服务器，比如 <code>hkp://keyserver.ubuntu.com:80</code>。</p><blockquote><p>可是apt-key已经弃用，有什么其他的办法吗</p></blockquote><p>是的，你说得对。自Ubuntu 21.10起，<code>apt-key</code> 已经被弃用了，使用 <code>gpg</code> 命令代替。因此，你需要使用以下命令将缺失的公钥添加到系统中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gpg --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5 3B4FE6ACC0B21F32sudo gpg --export --armor 40976EAF437D05B5 3B4FE6ACC0B21F32 | sudo apt-key add -</code></pre></div></figure><p>这里，第一个命令从 Ubuntu 公钥服务器接收并导入指定的公钥，第二个命令将导入的公钥导出为 ASCII 编码格式，然后使用 <code>apt-key add</code> 命令将其添加到系统中。执行以上两个命令后，你就可以再次运行 <code>sudo apt update</code> 命令了。</p><blockquote><p>既然已经弃用了，为什么你还要再指令中写<code>sudo apt-key add -</code>这一句呢</p></blockquote><p>好问题！对于新的 Ubuntu 发行版，确实不需要使用 <code>apt-key</code> 命令，因为该命令已经被弃用了。然而，一些旧的教程和文档可能仍然使用该命令，所以我在之前的回答中提到了它。</p><p>在新的 Ubuntu 发行版中，使用 <code>gpg</code> 命令代替 <code>apt-key</code>，你可以使用以下命令将公钥添加到系统中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gpg --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5 3B4FE6ACC0B21F32sudo gpg --export --armor 40976EAF437D05B5 3B4FE6ACC0B21F32 | sudo tee &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;my-apt-keys.gpg &gt; &#x2F;dev&#x2F;null</code></pre></div></figure><p>上面的命令中，第一行从 Ubuntu 公钥服务器中接收并导入指定的公钥，第二行将导入的公钥导出为 ASCII 编码格式，并将其写入到一个名为 <code>my-apt-keys.gpg</code> 的文件中，该文件保存在 <code>/etc/apt/trusted.gpg.d/</code> 目录下。这个文件夹是用于存储被信任的 GPG 公钥的。这个命令会在这个目录下创建一个新的 GPG 公钥文件。</p><p>总之，尽管 <code>apt-key</code> 命令已经被弃用了，但在某些情况下，你可能仍然需要在系统中添加公钥。在这种情况下，你可以使用 <code>gpg</code> 命令，将公钥导入并添加到 <code>/etc/apt/trusted.gpg.d/</code> 目录中。</p><blockquote><p>我刚刚使用了你第二个回答的解决方案，它在apt update时报：Key is stored in legacy trusted.gpg keyring (&#x2F;etc&#x2F;apt&#x2F;trusted.gpg), see the DEPRECATION section in apt-key(8) for details.</p></blockquote><p>这个警告信息是因为你将公钥添加到了 <code>/etc/apt/trusted.gpg.d/</code> 目录，但是 <code>apt</code> 命令仍然在使用旧的 <code>/etc/apt/trusted.gpg</code> 文件，这个文件是 <code>apt-key</code> 命令生成的。因此，<code>apt</code> 命令警告你公钥已存储在旧的 GPG 文件中。</p><p>为了解决这个问题，你可以将公钥导出到一个单独的文件中，并将该文件添加到 <code>/etc/apt/trusted.gpg.d/</code> 目录。例如，你可以运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gpg --output &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;my-apt-keys.gpg --export 40976EAF437D05B5 3B4FE6ACC0B21F32</code></pre></div></figure><p>上面的命令将公钥导出到一个名为 <code>my-apt-keys.gpg</code> 的文件中，并将该文件添加到 <code>/etc/apt/trusted.gpg.d/</code> 目录。这样，<code>apt</code> 命令就可以找到并使用新的 GPG 公钥文件了。</p><p>另外，如果你想更彻底地移除 <code>apt-key</code> 生成的旧的 GPG 公钥文件，你可以运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo rm &#x2F;etc&#x2F;apt&#x2F;trusted.gpg</code></pre></div></figure><p>这个命令会删除旧的 GPG 公钥文件，确保 <code>apt</code> 命令只使用 <code>/etc/apt/trusted.gpg.d/</code> 目录中的新 GPG 公钥文件。</p><blockquote><p>The key(s) in the keyring &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;ustc-apt-keys.gpg are ignored as the file has an unsupported filetype.</p></blockquote><p>这个警告信息表明 <code>/etc/apt/trusted.gpg.d/ustc-apt-keys.gpg</code> 文件的文件类型不受支持，因此其中的 GPG 公钥被忽略了。</p><p>这通常是由于文件的格式不正确所导致的。可能是你的 <code>apt-key add</code> 命令没有正确导入公钥。你可以尝试使用以下命令重新导入公钥：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-key --keyring &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;ustc-apt-keys.gpg add &lt;path&#x2F;to&#x2F;your&#x2F;keyfile&gt;</code></pre></div></figure><p>确保将 <code>&lt;path/to/your/keyfile&gt;</code> 替换为包含你的 GPG 公钥的文件的路径。</p><p>如果你不知道公钥文件的路径，可以尝试在终端中输入以下命令查找：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find &#x2F; -name &quot;ustc-apt-keys.gpg&quot;</code></pre></div></figure><p>这会在整个文件系统中搜索包含 <code>ustc-apt-keys.gpg</code> 文件名的文件，并显示文件的路径。然后，你可以将路径替换为上述命令中的 <code>&lt;path/to/your/keyfile&gt;</code>。</p><p>如果重新导入公钥后仍然遇到相同的问题，请确保你的公钥文件是正确的格式，它应该是一个文本文件，其中包含 ASCII 编码的 GPG 公钥。如果你不确定文件是否正确，请打开文件并检查它的内容是否与你期望的 GPG 公钥相匹配。</p><blockquote><p>请用最新的方案解决刚刚的问题，不要使用已弃用的指令apt-key</p></blockquote><p>当你向系统添加一个新的 GPG 公钥时，你可以使用 <code>gpg</code> 命令来完成这项任务。以下是如何使用 <code>gpg</code> 命令来添加 GPG 公钥的步骤：</p><ol><li><p>首先，你需要从软件提供方获取其 GPG 公钥。通常，软件提供方会在其网站上提供一个 ASCII 码格式的 GPG 公钥，你可以将其保存到一个文本文件中。假设你已经从软件提供方获取了一个名为 <code>key.asc</code> 的 GPG 公钥文件。</p></li><li><p>接下来，你需要将 GPG 公钥导入到你的 GPG 密钥环中。运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gpg --import key.asc</code></pre></div></figure><p>这会将 <code>key.asc</code> 文件中的公钥添加到你的 GPG 密钥环中。</p></li><li><p>现在，你需要找到新添加的 GPG 公钥的 Key ID。运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gpg --list-keys</code></pre></div></figure><p>这会列出你的 GPG 密钥环中的所有密钥。在输出中，找到刚刚导入的公钥的 Key ID。Key ID 是一个 8 位十六进制数字。</p></li><li><p>最后，你需要将公钥的 Key ID 添加到 <code>/etc/apt/trusted.gpg.d/</code> 目录中的一个文件中，以便 <code>apt</code> 命令可以使用该公钥。运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gpg --export &lt;key-id&gt; | sudo tee &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;my-apt-keys.gpg</code></pre></div></figure><p>这会将公钥导出到一个名为 <code>my-apt-keys.gpg</code> 的文件中，并将该文件添加到 <code>/etc/apt/trusted.gpg.d/</code> 目录。确保将 <code>&lt;key-id&gt;</code> 替换为你在步骤 3 中找到的公钥的 Key ID。</p></li></ol><p>现在，你应该能够使用 <code>apt update</code> 命令更新你的软件包列表，而不会收到公钥验证错误的消息。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Source源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiPass Cloud-init文件介绍.md</title>
    <link href="/doc/b3570cee.html"/>
    <url>/doc/b3570cee.html</url>
    
    <content type="html"><![CDATA[<p>Cloud-init 是一个用于自动化配置云计算实例的工具，它支持多种操作系统和云服务提供商。在 MultiPass 中，您可以使用 Cloud-init 文件来自动化配置虚拟机。</p><span id="more"></span><h2 id="如何书写"><a href="#如何书写" class="headerlink" title="如何书写"></a>如何书写</h2><p>Cloud-init 文件采用 YAML 格式，包含了一系列配置指令。以下是一个简单的 Cloud-init 文件的示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># User configurationusers:  - name: myuser    groups: sudo    shell: &#x2F;bin&#x2F;bash    ssh_authorized_keys:      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDsDfdAbR... myuser@example.com# Package installationpackages:  - nginx  - git  - curl# File configurationwrite_files:  - path: &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default    content: |      server &#123;        listen 80 default_server;        listen [::]:80 default_server;        root &#x2F;var&#x2F;www&#x2F;html;        index index.html;        server_name _;        location &#x2F; &#123;          try_files $uri $uri&#x2F; &#x3D;404;        &#125;      &#125;# Service configurationruncmd:  - systemctl restart nginx</code></pre></div></figure><p>在上面的示例中，我们定义了以下几个配置：</p><ul><li>创建了一个名为 <code>myuser</code> 的用户，并将其添加到 <code>sudo</code> 组中，并且配置了一个 SSH 公钥，用于允许该用户通过 SSH 访问虚拟机。</li><li>安装了 <code>nginx</code>、<code>git</code> 和 <code>curl</code> 三个软件包。</li><li>写入了一个 <code>default</code> 虚拟主机配置文件到 <code>/etc/nginx/sites-available/</code> 目录中。</li><li>最后，重新启动了 <code>nginx</code> 服务，以使配置生效。</li></ul><p>通过这种方式，您可以编写自己的 Cloud-init 文件，并将其用于自动化配置 MultiPass 虚拟机。将 Cloud-init 文件传递给 <code>multipass launch</code> 命令的 <code>--cloud-init</code> 参数，即可自动应用配置。</p><h2 id="Cloud-Init文件中所有可用配置项"><a href="#Cloud-Init文件中所有可用配置项" class="headerlink" title="Cloud-Init文件中所有可用配置项"></a>Cloud-Init文件中所有可用配置项</h2><p>Cloud-init 支持多种配置指令，这些指令可以在 Cloud-init 文件中使用。以下是 Cloud-init 文件中可用的一些配置指令：</p><h3 id="users"><a href="#users" class="headerlink" title="users"></a><code>users</code></h3><p><code>users</code> 指令可以用于配置用户和用户组。以下是一个 <code>users</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">users:  - name: myuser    groups: sudo    shell: &#x2F;bin&#x2F;bash    ssh_authorized_keys:      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDsDfdAbR... myuser@example.com</code></pre></div></figure><h3 id="packages"><a href="#packages" class="headerlink" title="packages"></a><code>packages</code></h3><p><code>packages</code> 指令可以用于配置要在系统中安装的软件包。以下是一个 <code>packages</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">packages:  - nginx  - git  - curl</code></pre></div></figure><h3 id="write-files"><a href="#write-files" class="headerlink" title="write_files"></a><code>write_files</code></h3><p><code>write_files</code> 指令可以用于写入文件。以下是一个 <code>write_files</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">write_files:  - path: &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default    content: |      server &#123;        listen 80 default_server;        listen [::]:80 default_server;        root &#x2F;var&#x2F;www&#x2F;html;        index index.html;        server_name _;        location &#x2F; &#123;          try_files $uri $uri&#x2F; &#x3D;404;        &#125;      &#125;</code></pre></div></figure><h3 id="runcmd"><a href="#runcmd" class="headerlink" title="runcmd"></a><code>runcmd</code></h3><p><code>runcmd</code> 指令可以用于在虚拟机启动后执行命令。以下是一个 <code>runcmd</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">runcmd:  - systemctl restart nginx</code></pre></div></figure><h3 id="ssh-authorized-keys"><a href="#ssh-authorized-keys" class="headerlink" title="ssh_authorized_keys"></a><code>ssh_authorized_keys</code></h3><p><code>ssh_authorized_keys</code> 指令可以用于添加 SSH 公钥，以允许用户通过 SSH 访问虚拟机。以下是一个 <code>ssh_authorized_keys</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">ssh_authorized_keys:  - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDsDfdAbR... myuser@example.com</code></pre></div></figure><h3 id="bootcmd"><a href="#bootcmd" class="headerlink" title="bootcmd"></a><code>bootcmd</code></h3><p><code>bootcmd</code> 指令可以用于在虚拟机启动时执行命令。以下是一个 <code>bootcmd</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">bootcmd:  - echo &quot;Hello, world!&quot;</code></pre></div></figure><h3 id="mounts"><a href="#mounts" class="headerlink" title="mounts"></a><code>mounts</code></h3><p><code>mounts</code> 指令可以用于挂载文件系统。以下是一个 <code>mounts</code> 指令的示例：</p><p>yaml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mounts:  - [&quot;10.0.2.1:&#x2F;share&quot;, &quot;&#x2F;mnt&#x2F;share&quot;, &quot;nfs&quot;, &quot;defaults&quot;, &quot;0&quot;, &quot;0&quot;]</code></pre></div></figure><p>这些是 Cloud-init 文件中可用的一些配置指令，您可以根据自身需要来选择合适的配置项使用。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>VM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>MultiPass</tag>
      
      <tag>Cloud-init</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiPass使用介绍</title>
    <link href="/doc/c9a14894.html"/>
    <url>/doc/c9a14894.html</url>
    
    <content type="html"><![CDATA[<p>多重密码（MultiPass）是一款开源工具，用于在本地计算机上创建和管理虚拟机。使用 MultiPass，您可以快速创建 Ubuntu 虚拟机并在其上运行各种应用程序和服务。</p><span id="more"></span><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>以下是 MultiPass 常用的命令列表：</p><ul><li><code>multipass launch</code>：启动一个新的虚拟机。</li><li><code>multipass list</code>：列出当前所有的虚拟机。</li><li><code>multipass start</code>：启动已经创建但是处于关闭状态的虚拟机。</li><li><code>multipass stop</code>：关闭运行中的虚拟机。</li><li><code>multipass delete</code>：删除指定的虚拟机。</li><li><code>multipass shell</code>：连接到虚拟机的命令行终端。</li><li><code>multipass exec</code>：在虚拟机中执行指定的命令。</li><li><code>multipass mount</code>：将本地文件系统挂载到虚拟机中。</li><li><code>multipass umount</code>：卸载已经挂载到虚拟机的本地文件系统。</li><li><code>multipass info</code>：获取有关虚拟机的详细信息。</li><li><code>multipass purge</code>：删除 MultiPass 系统中所有的虚拟机。</li><li><code>multipass version</code>：查看当前安装的 MultiPass 版本。</li></ul><p>以上是 MultiPass 的一些常用命令，还有其他更高级的命令和选项可供使用，您可以通过运行 <code>multipass help</code> 命令来了解所有可用的命令和选项。</p><hr><p>下面是一些常用的 MultiPass 命令及其示例：</p><ol><li><p><code>multipass launch</code>：启动一个新的虚拟机。</p><p> 示例：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass launch --name my-vm</code></pre></div></figure><p> 该命令会创建一个名为 <code>my-vm</code> 的新虚拟机。</p></li><li><p><code>multipass list</code>：列出当前所有的虚拟机。</p><p> 示例：</p><p> <code>multipass list</code></p><p> 该命令会列出当前 MultiPass 系统中的所有虚拟机。</p></li><li><p><code>multipass start</code>：启动已经创建但是处于关闭状态的虚拟机。</p><p> 示例：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start my-vm</code></pre></div></figure><p> 该命令会启动名为 <code>my-vm</code> 的虚拟机。</p></li><li><p><code>multipass stop</code>：关闭运行中的虚拟机。</p><p> 示例：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop my-vm</code></pre></div></figure><p> 该命令会关闭名为 <code>my-vm</code> 的虚拟机。</p></li><li><p><code>multipass delete</code>：删除指定的虚拟机。</p><p> 示例：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass delete my-vm</code></pre></div></figure><p> 该命令会删除名为 <code>my-vm</code> 的虚拟机。</p></li><li><p><code>multipass shell</code>：连接到虚拟机的命令行终端。</p><p> 示例：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell my-vm</code></pre></div></figure><p> 该命令会连接到名为 <code>my-vm</code> 的虚拟机的命令行终端。</p></li><li><p><code>multipass exec</code>：在虚拟机中执行命令，类似于在本地计算机上使用终端窗口。例如，以下命令将在名为 <code>vm1</code> 的虚拟机上执行 <code>ls</code> 命令：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec vm1 ls</code></pre></div></figure><p> 如果您需要在虚拟机中使用 <code>sudo</code> 或者 <code>su</code> 命令，可以使用 <code>--</code> 参数来将命令传递给虚拟机。例如，以下命令将在名为 <code>vm1</code> 的虚拟机上执行 <code>apt update</code> 命令：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec vm1 -- sudo apt update</code></pre></div></figure><p> 如果您需要在虚拟机中交互式地执行命令，可以使用 <code>-t</code> 参数来分配一个伪终端。例如，以下命令将在名为 <code>vm1</code> 的虚拟机上打开一个 Bash shell：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec vm1 -t -- bash</code></pre></div></figure><p> 这将在虚拟机中打开一个交互式的 Bash shell，允许您执行任意命令。要退出虚拟机，请使用 <code>exit</code> 命令。</p></li><li><p><code>multipass mount</code>：将主机目录挂载到虚拟机中。例如，以下命令将在名为 <code>vm1</code> 的虚拟机上将主机目录 <code>/home/user/data</code> 挂载到虚拟机目录 <code>/mnt/data</code>：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass mount &#x2F;home&#x2F;user&#x2F;data vm1:&#x2F;mnt&#x2F;data</code></pre></div></figure><p> 这将在虚拟机中创建 <code>/mnt/data</code> 目录，并将主机目录 <code>/home/user/data</code> 挂载到该目录中。要卸载目录，请使用 <code>multipass umount</code> 命令。</p></li><li><p><code>multipass umount</code>：卸载虚拟机中的挂载点。例如，以下命令将卸载名为 <code>vm1</code> 的虚拟机中的 <code>/mnt/data</code> 目录：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass umount vm1:&#x2F;mnt&#x2F;data</code></pre></div></figure></li><li><p><code>multipass info</code>：显示有关虚拟机的信息，如虚拟机的 IP 地址、CPU 和内存使用情况等。例如，以下命令将显示名为 <code>vm1</code> 的虚拟机的信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass info vm1</code></pre></div></figure></li><li><p><code>multipass purge</code>：删除不再使用的虚拟机和镜像。例如，以下命令将删除不再使用的所有虚拟机和镜像：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass purge</code></pre></div></figure></li><li><p><code>multipass version</code>：显示 <code>multipass</code> 的版本信息。例如，以下命令将显示当前 <code>multipass</code> 版本的信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass version</code></pre></div></figure></li></ol><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="launch指令"><a href="#launch指令" class="headerlink" title="launch指令"></a><code>launch</code>指令</h3><p><code>launch</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于创建并启动新的虚拟机。以下是 <code>launch</code> 指令的可用参数：</p><ul><li><code>&lt;name&gt;</code>: 虚拟机名称，必须是一个不包含空格的字符串，不指定则随机生成。</li><li><code>-c, --cpus &lt;count&gt;</code>: 虚拟机使用的 CPU 核心数量。</li><li><code>-d, --disk &lt;size&gt;</code>: 虚拟机磁盘的大小，格式为 <code>&lt;size&gt;[G|g|M|m|K|k]</code>，默认为 <code>5G</code>。</li><li><code>-m, --mem &lt;size&gt;</code>: 虚拟机内存的大小，格式为 <code>&lt;size&gt;[G|g|M|m|K|k]</code>，默认为 <code>1G</code>。</li><li><code>-n, --network</code>: 启用虚拟机的网络功能。</li><li><code>-i, --cloud-init &lt;file&gt;</code>: 指定 Cloud-init 配置文件的路径，以初始化虚拟机。</li><li><code>--cloud-init-data &lt;data&gt;</code>: 直接指定 Cloud-init 配置文件的内容，以初始化虚拟机。</li><li><code>--cloud-init-user-data &lt;data&gt;</code>: 指定 Cloud-init 用户数据的内容，以初始化虚拟机。</li><li><code>--no-gui</code>: 禁用虚拟机的图形用户界面。</li><li><code>--no-autostart</code>: 不自动启动虚拟机。</li><li><code>--cpuset &lt;cores&gt;</code>: 指定使用的 CPU 核心编号列表，以逗号分隔。</li><li><code>--priority &lt;level&gt;</code>: 指定虚拟机的调度优先级，可选值为 <code>low</code>、<code>normal</code> 和 <code>high</code>。</li><li><code>--tag &lt;tag&gt;</code>: 给虚拟机打上标签，用于方便地进行分类和筛选。</li></ul><p>以下是一些使用示例：</p><ol><li><p>创建一个名为 <code>test-vm</code> 的虚拟机，使用默认配置：</p><p><code>multipass launch test-vm</code></p></li><li><p>创建一个名为 <code>test-vm</code> 的虚拟机，使用 2 个 CPU 核心，2GB 内存，20GB 磁盘大小，启用网络，指定 Cloud-init 配置文件并关闭图形用户界面：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass launch test-vm -c 2 -m 2G -d 20G -n -i cloud-config.yaml --no-gui</code></pre></div></figure></li><li><p>创建一个名为 <code>test-vm</code> 的虚拟机，使用 1 个 CPU 核心，1GB 内存，5GB 磁盘大小，启用网络，指定 Cloud-init 用户数据，并不自动启动虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass launch test-vm -c 1 -m 1G -d 5G -n --cloud-init-user-data &quot;#cloud-config\n\npassword: mypassword\nssh_authorized_keys:\n  - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDT8Xqa7dPyH+I....&quot; --no-autostart</code></pre></div></figure></li><li><p>创建：可以使用 <code>multipass launch</code> 命令创建新的虚拟机。在创建虚拟机时，您可以指定虚拟机的名称、操作系统镜像、磁盘空间大小等参数。例如，以下命令将创建一个名为 <code>vm1</code> 的 Ubuntu 20.04 LTS 虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass launch --name vm1 --image ubuntu-20.04 --disk 10G --cpus 2 --mem 2G</code></pre></div></figure><p>这将创建一个具有 10GB 硬盘空间、2个 CPU 核心和 2GB RAM 的虚拟机，并安装 Ubuntu 20.04 LTS 操作系统。</p></li></ol><h3 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a><code>list</code>指令</h3><p><code>list</code> 指令是 <code>multipass</code> 命令中的一个子命令，它用于列出所有正在运行的虚拟机和镜像，以及它们的状态。以下是 <code>list</code> 指令的一些常用参数：</p><ul><li><code>-a</code> 或 <code>--all</code>: 显示所有虚拟机和镜像，包括未运行的虚拟机和下载的镜像。</li><li><code>-f</code> 或 <code>--format</code>: 以指定格式输出结果。可用格式包括 <code>table</code>（默认）、<code>json</code>、<code>yaml</code> 和 <code>csv</code>。</li><li><code>--format-columns</code>: 可用于在指定格式中选择要包含的列。</li><li><code>-v</code> 或 <code>--verbose</code>: 显示更详细的信息，例如虚拟机的 IP 地址和 RAM&#x2F;CPU 利用率。</li><li><code>--cached</code>: 只显示缓存的镜像列表。</li><li><code>--refresh</code>: 刷新镜像列表并显示结果。</li><li><code>--json</code>: 以 JSON 格式输出结果。</li><li><code>--yaml</code>: 以 YAML 格式输出结果。</li><li><code>--csv</code>: 以 CSV 格式输出结果。</li></ul><p>以下是一些使用示例：</p><ol><li><p>列出所有正在运行的虚拟机和镜像：</p><p><code>multipass list</code></p></li><li><p>列出所有虚拟机和镜像，包括未运行的虚拟机和下载的镜像：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass list -a</code></pre></div></figure></li><li><p>以 YAML 格式列出所有正在运行的虚拟机和镜像：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass list --yaml</code></pre></div></figure></li><li><p>列出所有正在运行的虚拟机和镜像，并显示更详细的信息：</p><p><code>multipass list -v</code></p></li><li><p>列出缓存的镜像列表：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass list --cached</code></pre></div></figure></li><li><p>刷新镜像列表并列出结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass list --refresh</code></pre></div></figure></li><li><p>以 JSON 格式列出所有正在运行的虚拟机和镜像：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass list --json</code></pre></div></figure></li></ol><p><code>list</code> 指令是 <code>multipass</code> 命令中一个非常有用的子命令，可以帮助您快速查看您的虚拟机和镜像的状态。</p><h3 id="start指令"><a href="#start指令" class="headerlink" title="start指令"></a><code>start</code>指令</h3><p><code>start</code> 指令是 <code>multipass</code> 命令中的一个子命令，它用于启动一个之前创建的、处于停止状态的虚拟机。以下是 <code>start</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要启动的虚拟机的名称或 ID。</li><li><code>-d</code> 或 <code>--daemon</code>: 以守护进程模式启动虚拟机。</li><li><code>-i</code> 或 <code>--ip</code>: 指定虚拟机的 IP 地址。</li><li><code>-n</code> 或 <code>--network</code>: 指定要连接的网络名称。</li><li><code>-m</code> 或 <code>--mem</code>: 指定虚拟机的内存大小（以 MB 为单位）。</li><li><code>-c</code> 或 <code>--cpus</code>: 指定虚拟机可用的 CPU 数量。</li><li><code>-s</code> 或 <code>--size</code>: 指定虚拟磁盘的大小（以 GB 为单位）。</li><li><code>-v</code> 或 <code>--verbose</code>: 显示更详细的信息，例如虚拟机的 IP 地址和 RAM&#x2F;CPU 利用率。</li><li><code>-r</code> 或 <code>--show-logs</code>: 显示虚拟机的日志输出。</li><li><code>--no-ipv6</code>: 禁用 IPv6 支持。</li><li><code>--cloud-init</code>: 指定 Cloud-init 配置文件的路径。</li><li><code>--config</code>: 指定自定义的虚拟机配置文件的路径。</li><li><code>--force</code>: 强制启动一个已停止的虚拟机。</li></ul><p>以下是一些使用示例：</p><ol><li><p>启动一个之前创建的、处于停止状态的虚拟机：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt;</code></pre></div></figure></li><li><p>以守护进程模式启动一个虚拟机：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --daemon</code></pre></div></figure></li><li><p>指定虚拟机的 IP 地址：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --ip &lt;ip_address&gt;</code></pre></div></figure></li><li><p>指定要连接的网络名称：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --network &lt;network_name&gt;</code></pre></div></figure></li><li><p>指定虚拟机的内存大小：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --mem &lt;memory_size&gt;</code></pre></div></figure></li><li><p>指定虚拟机可用的 CPU 数量：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --cpus &lt;cpu_count&gt;</code></pre></div></figure></li><li><p>指定虚拟磁盘的大小：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --size &lt;disk_size&gt;</code></pre></div></figure></li><li><p>显示更详细的信息，例如虚拟机的 IP 地址和 RAM&#x2F;CPU 利用率：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --verbose</code></pre></div></figure></li><li><p>显示虚拟机的日志输出：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --show-logs</code></pre></div></figure></li><li><p>禁用 IPv6 支持：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass start &lt;instance&gt; --no-ipv6</code></pre></div></figure></li><li><p>指定 Cloud-init 配置文件的路径：</p><p>当创建虚拟机时，您可以使用 <code>--cloud-init</code> 选项来指定包含 Cloud-init 配置文件的路径。Cloud-init 配置文件是一个 YAML 文件，其中包含有关如何初始化虚拟机的信息。在配置文件中，您可以指定用户帐户、SSH 密钥、软件包安装、文件创建等等。以下是一个示例 Cloud-init 配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#cloud-configusers:  - name: username    ssh-authorized-keys:      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCxrpA...    sudo: [&#39;ALL&#x3D;(ALL) NOPASSWD:ALL&#39;]</code></pre></div></figure><p>使用 <code>--cloud-init</code> 选项创建虚拟机时，指定配置文件的路径：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass launch --name vmname --cloud-init &#x2F;path&#x2F;to&#x2F;cloud-init-file.yaml</code></pre></div></figure><p>这将使用指定的 Cloud-init 配置文件来初始化虚拟机。</p></li></ol><h3 id="stop指令"><a href="#stop指令" class="headerlink" title="stop指令"></a><code>stop</code>指令</h3><p><code>stop</code> 指令是 <code>multipass</code> 命令中的一个子命令，它用于停止运行中的虚拟机。以下是 <code>stop</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要停止的虚拟机的名称或 ID。</li><li><code>-d</code> 或 <code>--daemon</code>: 以守护进程模式停止虚拟机。</li><li><code>-w</code> 或 <code>--wait</code>: 等待虚拟机完全停止后再返回。</li><li><code>-t</code> 或 <code>--timeout</code>: 指定等待虚拟机停止的最长时间（以秒为单位）。</li><li><code>-r</code> 或 <code>--show-logs</code>: 显示虚拟机的日志输出。</li></ul><p>以下是一些使用示例：</p><ol><li><p>停止一个运行中的虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop &lt;instance&gt;</code></pre></div></figure></li><li><p>以守护进程模式停止一个运行中的虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop &lt;instance&gt; --daemon</code></pre></div></figure></li><li><p>等待虚拟机完全停止后再返回：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop &lt;instance&gt; --wait</code></pre></div></figure></li><li><p>指定等待虚拟机停止的最长时间：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop &lt;instance&gt; --timeout &lt;timeout_in_seconds&gt;</code></pre></div></figure></li><li><p>显示虚拟机的日志输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass stop &lt;instance&gt; --show-logs</code></pre></div></figure></li></ol><p>注意：在停止虚拟机之前，请确保您已经保存了其中的所有数据。</p><h3 id="delete指令"><a href="#delete指令" class="headerlink" title="delete指令"></a><code>delete</code>指令</h3><p><code>delete</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于删除虚拟机。以下是 <code>delete</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要删除的虚拟机的名称或 ID。</li><li><code>-p</code> 或 <code>--purge</code>: 删除虚拟机时删除所有相关数据（包括磁盘映像、云初始化等）。</li><li><code>-f</code> 或 <code>--force</code>: 不要提示确认，直接删除虚拟机。</li></ul><p>以下是一些使用示例：</p><ol><li><p>删除一个虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass delete &lt;instance&gt;</code></pre></div></figure></li><li><p>删除虚拟机时删除所有相关数据（包括磁盘映像、云初始化等）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass delete &lt;instance&gt; --purge</code></pre></div></figure></li><li><p>不要提示确认，直接删除虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass delete &lt;instance&gt; --force</code></pre></div></figure></li></ol><p>注意：删除虚拟机时，请确保您已经保存了其中的所有数据。删除后无法恢复。</p><h3 id="shell指令"><a href="#shell指令" class="headerlink" title="shell指令"></a><code>shell</code>指令</h3><p><code>shell</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于在虚拟机中运行一个 shell。以下是 <code>shell</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要运行 shell 的虚拟机的名称或 ID。</li><li><code>command</code>: 要在虚拟机中运行的 shell 命令。</li></ul><p>以下是一些使用示例：</p><ol><li><p>进入虚拟机中的默认 shell：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell &lt;instance&gt;</code></pre></div></figure></li><li><p>运行指定的 shell 命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell &lt;instance&gt; &lt;command&gt;</code></pre></div></figure><p>例如，运行 <code>ls</code> 命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell &lt;instance&gt; ls</code></pre></div></figure></li><li><p>在虚拟机中以交互式模式启动一个 shell：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell &lt;instance&gt; -i</code></pre></div></figure></li><li><p>以 root 用户身份进入虚拟机中的默认 shell：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass shell &lt;instance&gt; --user root</code></pre></div></figure></li></ol><p>注意：要使用 <code>shell</code> 指令，虚拟机必须处于运行状态。另外，如果您在虚拟机中使用了 <code>sudo</code> 或其他特权命令，请小心操作，以避免意外损坏虚拟机。</p><h3 id="exec指令"><a href="#exec指令" class="headerlink" title="exec指令"></a><code>exec</code>指令</h3><p><code>exec</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于在虚拟机中执行一个命令。相比于 <code>shell</code> 指令，<code>exec</code> 指令不需要进入虚拟机的 shell 环境。以下是 <code>exec</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要执行命令的虚拟机的名称或 ID。</li><li><code>command</code>: 要在虚拟机中执行的命令。</li></ul><p>以下是一些使用示例：</p><ol><li><p>在虚拟机中执行指定的命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; &lt;command&gt;</code></pre></div></figure><p>例如，运行 <code>ls</code> 命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; ls</code></pre></div></figure></li><li><p>在虚拟机中执行一个长时间运行的命令，并将输出保存到本地文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; &lt;command&gt; &gt; &lt;local_file&gt;</code></pre></div></figure><p>例如，将虚拟机中的 <code>tar</code> 命令输出保存到本地文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; tar -cvzf - &#x2F;path&#x2F;to&#x2F;directory &gt; local_file.tar.gz</code></pre></div></figure></li><li><p>在虚拟机中以特权用户身份执行命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; sudo &lt;command&gt;</code></pre></div></figure><p>例如，以特权用户身份更新虚拟机中的软件包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass exec &lt;instance&gt; sudo apt-get update</code></pre></div></figure></li></ol><p>注意：要使用 <code>exec</code> 指令，虚拟机必须处于运行状态。另外，请小心操作，以避免意外损坏虚拟机。</p><h3 id="mount指令"><a href="#mount指令" class="headerlink" title="mount指令"></a><code>mount</code>指令</h3><p><code>mount</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于将本地文件系统中的目录挂载到虚拟机的文件系统中。以下是 <code>mount</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要挂载文件系统的虚拟机的名称或 ID。</li><li><code>&lt;host_dir&gt;</code>: 本地文件系统中要挂载的目录路径。</li><li><code>&lt;guest_dir&gt;</code>: 虚拟机文件系统中要将目录挂载到的路径。</li></ul><p>以下是一些使用示例：</p><ol><li><p>将本地文件系统中的目录挂载到虚拟机的 <code>/mnt</code> 目录：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass mount &lt;instance&gt; &lt;host_dir&gt; &#x2F;mnt</code></pre></div></figure></li><li><p>将本地文件系统中的目录挂载到虚拟机的 <code>/mnt</code> 目录，并在挂载时将目录设置为只读：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass mount &lt;instance&gt; &lt;host_dir&gt; &#x2F;mnt --read-only</code></pre></div></figure></li><li><p>将本地文件系统中的目录挂载到虚拟机的 <code>/mnt</code> 目录，并在挂载时将目录设置为可写：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass mount &lt;instance&gt; &lt;host_dir&gt; &#x2F;mnt --writable</code></pre></div></figure></li></ol><p>注意：要使用 <code>mount</code> 指令，虚拟机必须处于运行状态。另外，如果您在虚拟机中使用了 <code>sudo</code> 或其他特权命令，请小心操作，以避免意外损坏虚拟机。</p><h3 id="umount指令"><a href="#umount指令" class="headerlink" title="umount指令"></a><code>umount</code>指令</h3><p><code>umount</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于卸载虚拟机中挂载的文件系统。以下是 <code>umount</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要卸载文件系统的虚拟机的名称或 ID。</li><li><code>&lt;guest_dir&gt;</code>: 虚拟机文件系统中要卸载的目录路径。</li></ul><p>以下是一些使用示例：</p><ol><li><p>卸载虚拟机中 <code>/mnt</code> 目录的文件系统：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass umount &lt;instance&gt; &#x2F;mnt</code></pre></div></figure></li></ol><p>注意：在卸载文件系统之前，请确保虚拟机中没有正在使用该文件系统的进程或应用程序。在卸载文件系统之后，挂载的目录将不再在虚拟机中可用。</p><h3 id="info指令"><a href="#info指令" class="headerlink" title="info指令"></a><code>info</code>指令</h3><p><code>info</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于显示有关虚拟机的信息，例如虚拟机的名称、状态、IP 地址、磁盘使用情况等。以下是 <code>info</code> 指令的一些常用参数：</p><ul><li><code>&lt;instance&gt;</code>: 要显示信息的虚拟机的名称或 ID。</li><li><code>--all</code>: 显示所有虚拟机的信息。</li><li><code>--json</code>: 以 JSON 格式输出信息。</li></ul><p>以下是一些使用示例：</p><ol><li><p>显示名为 <code>vm1</code> 的虚拟机的信息：</p><p><code>multipass info vm1</code></p></li><li><p>显示所有虚拟机的信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass info --all</code></pre></div></figure></li><li><p>以 JSON 格式显示名为 <code>vm1</code> 的虚拟机的信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass info vm1 --json</code></pre></div></figure></li></ol><p>注意：<code>info</code> 指令可以用来查看虚拟机的状态和 IP 地址等信息，以便于管理虚拟机。在查看虚拟机信息时，可以通过 <code>--json</code> 参数以 JSON 格式输出信息，以便于其他脚本或程序进行处理。</p><h3 id="purge指令"><a href="#purge指令" class="headerlink" title="purge指令"></a><code>purge</code>指令</h3><p><code>purge</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于删除所有已停止的虚拟机及其磁盘映像文件。以下是 <code>purge</code> 指令的一些常用参数：</p><ul><li><code>--all</code>: 删除所有虚拟机及其磁盘映像文件，包括正在运行的虚拟机。</li><li><code>--storage</code>: 仅删除磁盘映像文件，不删除虚拟机。</li><li><code>--verbose</code>: 显示详细输出。</li></ul><p>以下是一些使用示例：</p><ol><li><p>删除所有已停止的虚拟机及其磁盘映像文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass purge --all</code></pre></div></figure></li><li><p>仅删除磁盘映像文件，不删除虚拟机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass purge --storage</code></pre></div></figure></li><li><p>显示详细输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass purge --verbose</code></pre></div></figure></li></ol><p>注意：在使用 <code>purge</code> 指令之前，请确保已备份虚拟机中重要的数据。此指令会将所有已停止的虚拟机及其磁盘映像文件永久删除，不能恢复。因此，谨慎使用此指令。</p><h3 id="version指令"><a href="#version指令" class="headerlink" title="version指令"></a><code>version</code>指令</h3><p><code>version</code> 指令是 <code>multipass</code> 命令中的一个子命令，用于显示当前 <code>multipass</code> 的版本信息。以下是 <code>version</code> 指令的可用参数：</p><ul><li><code>--format</code>: 指定输出格式，支持 <code>json</code> 和 <code>yaml</code> 两种格式。</li></ul><p>以下是一些使用示例：</p><ol><li><p>显示当前 <code>multipass</code> 的版本信息：</p><p><code>multipass version</code></p><p>输出类似于以下内容：</p><p><code>multipass 1.7.0+mac</code></p></li><li><p>将版本信息以 JSON 格式输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass version --format json</code></pre></div></figure><p>输出类似于以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;version&quot;: &quot;1.7.0+mac&quot;&#125;</code></pre></div></figure></li><li><p>将版本信息以 YAML 格式输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multipass version --format yaml</code></pre></div></figure><p>输出类似于以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">version: 1.7.0+mac</code></pre></div></figure></li></ol><p>注意：<code>version</code> 指令没有删除或修改任何虚拟机或磁盘映像文件，是只读操作。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>VM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>MultiPass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiPass环境搭建</title>
    <link href="/doc/4d4e1716.html"/>
    <url>/doc/4d4e1716.html</url>
    
    <content type="html"><![CDATA[<p>多重密码（MultiPass）是一款开源工具，用于在本地计算机上创建和管理虚拟机。使用 MultiPass，您可以快速创建 Ubuntu 虚拟机并在其上运行各种应用程序和服务。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>多重密码（MultiPass）是一款开源工具，用于在本地计算机上创建和管理虚拟机。使用 MultiPass，您可以快速创建 Ubuntu 虚拟机并在其上运行各种应用程序和服务。MultiPass 可以在 Windows、macOS 和 Linux 上运行，并使用简单的命令行接口进行操作。</p><p>使用 MultiPass，您可以轻松地在不同的 Ubuntu 版本之间切换，而无需担心在本地计算机上安装多个操作系统会占用过多的磁盘空间。MultiPass 还支持使用云提供程序，如 Amazon Web Services (AWS)、Microsoft Azure 和 Google Cloud Platform (GCP) 在云端创建和管理虚拟机。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>您可以按照以下步骤安装 MultiPass：</p><ol><li><p>首先，访问 MultiPass 的<a href="https://multipass.run/">官方网站</a>。</p></li><li><p>在网站上，您可以下载适用于您的操作系统的安装程序。请确保选择正确的操作系统版本，并按照页面上的说明进行下载。</p></li><li><p>下载完成后，运行安装程序，并按照屏幕上的指示进行操作。在 Windows 上，您需要双击下载的 .exe 文件，然后按照安装向导进行操作。在 macOS 上，您需要双击下载的 .dmg 文件，并将 MultiPass 图标拖到 Applications 文件夹中。</p></li><li><p>安装完成后，在终端中输入 <code>multipass</code> 命令，以验证 MultiPass 是否已正确安装。如果一切正常，您应该会看到 MultiPass 的命令行界面。</p></li></ol><p>当然在 Linux 上安装 MultiPass 也很简单，您可以按照以下步骤进行操作：</p><p>首先，打开终端并添加 MultiPass 存储库。要添加 MultiPass 存储库，请运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo add-apt-repository ppa:multipass&#x2F;nightly</code></pre></div></figure><p>添加存储库后，运行以下命令以更新软件包列表：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update</code></pre></div></figure><p>安装 MultiPass。要安装 MultiPass，请运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install multipass</code></pre></div></figure><p>安装完成后，在终端中输入 <code>multipass</code> 命令，以验证 MultiPass 是否已正确安装。如果一切正常，您应该会看到 MultiPass 的命令行界面。</p><p>现在，您已经成功安装了 MultiPass，并可以使用它来创建和管理虚拟机。您可以通过运行 <code>multipass help</code> 命令来了解更多 MultiPass 的使用方法和命令。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>VM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>MultiPass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu给内核升级</title>
    <link href="/doc/c5e5d89f.html"/>
    <url>/doc/c5e5d89f.html</url>
    
    <content type="html"><![CDATA[<h2 id="查看当前Kernel版本"><a href="#查看当前Kernel版本" class="headerlink" title="查看当前Kernel版本"></a>查看当前Kernel版本</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">uname -sr</code></pre></div></figure><h2 id="查看目前可用的最新的稳定内核"><a href="#查看目前可用的最新的稳定内核" class="headerlink" title="查看目前可用的最新的稳定内核"></a>查看目前可用的最新的稳定内核</h2><blockquote><p>Ubuntu内核库：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p></blockquote><p>选择合适的版本进入后，根据系统情况选择合适的内核版本，这里我使用的是<code>https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.5.19/</code></p><p>根据我的系统情况，需要的软件包共有四个，即两个header头文件，一个image镜像，一个modules模块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.5.19&#x2F;linux-headers-5.5.19-050519_5.5.19-050519.202004210831_all.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.5.19&#x2F;linux-headers-5.5.19-050519-generic_5.5.19-050519.202004210831_amd64.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.5.19&#x2F;linux-image-unsigned-5.5.19-050519-generic_5.5.19-050519.202004210831_amd64.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.5.19&#x2F;linux-modules-5.5.19-050519-generic_5.5.19-050519.202004210831_amd64.deb</code></pre></div></figure><h2 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h2><p>下载好后，使用指令<code>sudo dpkg -i *.deb</code>进行安装，完成后重启即可。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源VPN-WireGuard</title>
    <link href="/doc/a1064baf.html"/>
    <url>/doc/a1064baf.html</url>
    
    <content type="html"><![CDATA[<p>WireGuard ®是一种极其简单但快速的现代 VPN，它使用最先进的加密技术。它旨在比 IPsec更快、更简单、更精简和更有用，同时避免令人头疼的问题。它旨在比 OpenVPN 具有更高的性能。</p><span id="more"></span><blockquote><p>官网地址：<a href="https://www.wireguard.com/">https://www.wireguard.com/</a><br>docker源码：<a href="https://github.com/linuxserver/docker-wireguard">https://github.com/linuxserver/docker-wireguard</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>WireGuard是一种开源的VPN（虚拟专用网络）协议，它旨在提供更快速、更安全和更简单的VPN连接。WireGuard利用现代加密协议，如ChaCha20和Curve25519，以保护数据传输的隐私和安全性。与其他VPN协议相比，WireGuard具有更少的代码和更少的复杂性，这使得它易于部署和使用。WireGuard已经被广泛使用并受到了积极的评价。 </p><h2 id="搭建WireGuard服务器"><a href="#搭建WireGuard服务器" class="headerlink" title="搭建WireGuard服务器"></a>搭建WireGuard服务器</h2><p>搭建WireGuard服务器的步骤如下：</p><ol><li><p>选择服务器操作系统：WireGuard可以在各种操作系统上运行，包括Linux、Windows、macOS、FreeBSD等。您可以选择自己熟悉的操作系统，但是在本文中，我们将使用Linux服务器作为示例。</p></li><li><p>安装WireGuard：您可以按照WireGuard官方文档中提供的安装指南，在您选择的操作系统上安装WireGuard。</p></li><li><p>生成公钥和私钥：在您的服务器上生成一个私钥和一个公钥，您可以使用wg命令来完成此操作。例如，输入以下命令生成一个新的私钥和公钥：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wg genkey | tee privatekey | wg pubkey &gt; publickey</code></pre></div></figure><p> 这将生成一个名为privatekey的文件，其中包含私钥，以及一个名为publickey的文件，其中包含公钥。</p></li><li><p>配置WireGuard：您需要创建一个配置文件来配置WireGuard，以指定VPN客户端将使用的IP地址、端口和密钥等信息。您可以使用wg-quick工具来创建并启动WireGuard配置。例如，您可以创建一个名为wg0.conf的文件，并添加以下内容：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">[Interface]PrivateKey &#x3D; &lt;your server private key&gt;Address &#x3D; 10.0.0.1&#x2F;24ListenPort &#x3D; 51820[Peer]PublicKey &#x3D; &lt;your client public key&gt;AllowedIPs &#x3D; 10.0.0.2&#x2F;32</code></pre></div></figure><p> 其中，<code>&lt;your server private key&gt;</code>是您在步骤3中生成的私钥，<code>10.0.0.1/24</code>是服务器的IP地址，<code>51820</code>是服务器监听的端口号，<code>&lt;your client public key&gt;</code>是客户端的公钥，<code>10.0.0.2/32</code>是客户端的IP地址。</p></li><li><p>启动WireGuard：您可以使用以下命令来启动WireGuard：</p><p> <code>sudo wg-quick up wg0</code></p><p> 这将启动WireGuard服务并加载您在配置文件中指定的配置。您可以使用以下命令来验证是否成功启动：</p> <figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sudo wg show</code></pre></div></figure><p> 如果一切正常，您应该能够看到WireGuard服务器的配置信息。</p></li><li><p>客户端连接：现在您可以在客户端上安装WireGuard，并将客户端公钥添加到服务器的配置文件中。客户端应该使用您在配置文件中指定的IP地址和端口号连接到服务器。</p></li></ol><h2 id="使用Docker搭建服务器环境"><a href="#使用Docker搭建服务器环境" class="headerlink" title="使用Docker搭建服务器环境"></a>使用Docker搭建服务器环境</h2><p>如果您想使用Docker来搭建WireGuard服务器环境，可以按照以下步骤操作：</p><ol><li><p>安装Docker和Docker Compose：您需要先在您的服务器上安装Docker和Docker Compose。您可以按照Docker官方文档提供的安装指南在您选择的操作系统上安装。</p></li><li><p>创建Docker Compose文件：您可以创建一个名为docker-compose.yml的文件，并添加以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3&#39;services:  wireguard:    image: linuxserver&#x2F;wireguard    container_name: wireguard    cap_add:      - NET_ADMIN    environment:      - PUID&#x3D;&lt;your user id&gt;      - PGID&#x3D;&lt;your group id&gt;      - TZ&#x3D;&lt;your timezone&gt;    volumes:      - &#x2F;path&#x2F;to&#x2F;config:&#x2F;config    ports:      - 51820:51820&#x2F;udp    restart: always</code></pre></div></figure><p>其中，<code>&lt;your user id&gt;</code>是您的用户ID，<code>&lt;your group id&gt;</code>是您的用户组ID，<code>&lt;your timezone&gt;</code>是您的时区，<code>/path/to/config</code>是您的配置文件目录，<code>51820</code>是WireGuard使用的端口号。</p></li><li><p>创建配置文件：在您的配置文件目录中创建一个名为wg0.conf的文件，并添加以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">[Interface]PrivateKey &#x3D; &lt;your server private key&gt;Address &#x3D; 10.0.0.1&#x2F;24ListenPort &#x3D; 51820[Peer]PublicKey &#x3D; &lt;your client public key&gt;AllowedIPs &#x3D; 10.0.0.2&#x2F;32</code></pre></div></figure><p>其中，<code>&lt;your server private key&gt;</code>是您在步骤3中生成的私钥，<code>10.0.0.1/24</code>是服务器的IP地址，<code>51820</code>是服务器监听的端口号，<code>&lt;your client public key&gt;</code>是客户端的公钥，<code>10.0.0.2/32</code>是客户端的IP地址。</p></li><li><p>启动容器：您可以使用以下命令启动容器：</p><p><code>docker-compose up -d</code></p><p>这将启动WireGuard容器并加载您在配置文件中指定的配置。</p></li><li><p>客户端连接：现在您可以在客户端上安装WireGuard，并将客户端公钥添加到服务器的配置文件中。客户端应该使用您在配置文件中指定的IP地址和端口号连接到服务器。</p></li></ol><h2 id="配置Windows客户端"><a href="#配置Windows客户端" class="headerlink" title="配置Windows客户端"></a>配置Windows客户端</h2><p>要在Windows上配置WireGuard客户端以连接到您的Docker搭建的WireGuard服务器，您可以按照以下步骤进行操作：</p><ol><li><p>在Windows上安装WireGuard客户端：您可以从WireGuard官方网站下载和安装Windows版的WireGuard客户端。</p></li><li><p>生成客户端密钥对：您需要在客户端上生成一个密钥对，以便连接到服务器。您可以使用WireGuard客户端生成一个新的密钥对。</p></li><li><p>向服务器添加客户端公钥：将客户端的公钥添加到服务器的配置文件中，这样服务器就能够识别并允许客户端连接。您可以将客户端的公钥复制到服务器配置文件的[Peer]部分中，并设置允许的IP地址（例如，<code>AllowedIPs = 10.0.0.2/32</code>）。</p></li><li><p>配置WireGuard客户端：打开WireGuard客户端，并点击“添加配置文件”。在新窗口中，选择“从文件加载”并导入您在步骤3中生成的客户端私钥和服务器配置文件。然后，点击“添加隧道”并连接到服务器。</p></li><li><p>测试连接：完成以上步骤后，您应该能够连接到服务器。您可以测试连接是否成功，例如，使用ping命令测试是否能够访问服务器上的资源。</p></li></ol><p>以上是在Windows上配置WireGuard客户端以连接到Docker搭建的WireGuard服务器的基本步骤。</p><h2 id="配置Linux客户端"><a href="#配置Linux客户端" class="headerlink" title="配置Linux客户端"></a>配置Linux客户端</h2><p>要在Linux上配置WireGuard客户端以连接到您的Docker搭建的WireGuard服务器，您可以按照以下步骤进行操作：</p><ol><li><p>在Linux上安装WireGuard客户端：您可以在Linux上安装WireGuard客户端。具体的安装方法因Linux发行版而异，您可以在WireGuard官方文档中找到相关说明。</p></li><li><p>生成客户端密钥对：您需要在客户端上生成一个密钥对，以便连接到服务器。您可以使用WireGuard客户端生成一个新的密钥对。</p></li><li><p>向服务器添加客户端公钥：将客户端的公钥添加到服务器的配置文件中，这样服务器就能够识别并允许客户端连接。您可以将客户端的公钥复制到服务器配置文件的[Peer]部分中，并设置允许的IP地址（例如，<code>AllowedIPs = 10.0.0.2/32</code>）。</p></li><li><p>配置WireGuard客户端：您可以在Linux上通过命令行配置WireGuard客户端。您需要创建一个名为<code>wg0.conf</code>的配置文件，并添加以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">[Interface]PrivateKey &#x3D; &lt;your client private key&gt;Address &#x3D; 10.0.0.2&#x2F;24DNS &#x3D; 1.1.1.1[Peer]PublicKey &#x3D; &lt;your server public key&gt;Endpoint &#x3D; &lt;your server IP address&gt;:51820AllowedIPs &#x3D; 0.0.0.0&#x2F;0</code></pre></div></figure><p>其中，<code>&lt;your client private key&gt;</code>是您在步骤2中生成的私钥，<code>10.0.0.2/24</code>是客户端的IP地址，<code>1.1.1.1</code>是您希望使用的DNS服务器，<code>&lt;your server public key&gt;</code>是服务器的公钥，<code>&lt;your server IP address&gt;</code>是服务器的IP地址，<code>51820</code>是服务器监听的端口号。</p></li><li><p>启动WireGuard客户端：使用以下命令启动WireGuard客户端：</p><p><code>sudo wg-quick up wg0</code></p><p>这将启动WireGuard客户端并加载您在配置文件中指定的配置。</p></li><li><p>测试连接：完成以上步骤后，您应该能够连接到服务器。您可以测试连接是否成功，例如，使用ping命令测试是否能够访问服务器上的资源。</p></li></ol><p>以上是在Linux上配置WireGuard客户端以连接到Docker搭建的WireGuard服务器的基本步骤。</p><h2 id="WireGuard可用配置项"><a href="#WireGuard可用配置项" class="headerlink" title="WireGuard可用配置项"></a>WireGuard可用配置项</h2><p>WireGuard是一种快速且现代的VPN协议，它提供了各种配置选项来优化连接和安全性。以下是一些常用的WireGuard配置选项：</p><ol><li>[Interface]：指定本地网络接口的设置，包括私钥、地址、DNS服务器和MTU等。</li></ol><ul><li>PrivateKey：本地网络接口的私钥。</li><li>Address：本地网络接口的IP地址，可以是单个地址或CIDR块。</li><li>DNS：指定DNS服务器的IP地址。</li><li>MTU：设置网络接口的最大传输单元。</li></ul><ol start="2"><li>[Peer]：指定连接到的对等端的设置，包括公钥、IP地址、端点和允许IP地址等。</li></ol><ul><li>PublicKey：对等端的公钥。</li><li>Endpoint：对等端的IP地址和端口号，用于建立连接。</li><li>AllowedIPs：指定可以通过VPN访问的IP地址范围，可以是单个地址或CIDR块。</li></ul><ol start="3"><li>[Interface]或[Peer]的PreUp、PostUp、PreDown和PostDown：指定在启动或停止WireGuard接口时执行的脚本。</li></ol><ul><li>PreUp：在启动WireGuard接口之前执行的脚本。</li><li>PostUp：在启动WireGuard接口之后执行的脚本。</li><li>PreDown：在停止WireGuard接口之前执行的脚本。</li><li>PostDown：在停止WireGuard接口之后执行的脚本。</li></ul><ol start="4"><li>PersistentKeepalive：指定在网络空闲时发送keepalive消息以避免连接中断。</li></ol><ul><li>PersistentKeepalive：设置keepalive消息发送的时间间隔（以秒为单位）。</li></ul><ol start="5"><li>ListenPort：指定WireGuard服务监听的端口号。</li></ol><ul><li>ListenPort：设置WireGuard服务监听的端口号。</li></ul><ol start="6"><li>PeerDNS：指定是否将DNS查询路由到远程VPN服务器。</li></ol><ul><li>PeerDNS：设置是否将DNS查询路由到远程VPN服务器。</li></ul><p>以上是一些常用的WireGuard配置选项。</p><h2 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h2><p>以下是一个基本的WireGuard配置文件示例，包括[Interface]和[Peer]配置段：</p><figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">[Interface]PrivateKey &#x3D; [Private Key]Address &#x3D; 10.0.0.1&#x2F;24ListenPort &#x3D; 51820DNS &#x3D; 8.8.8.8[Peer]PublicKey &#x3D; [Public Key]AllowedIPs &#x3D; 10.0.0.2&#x2F;32Endpoint &#x3D; [Remote Server IP]:51820PersistentKeepalive &#x3D; 25</code></pre></div></figure><p>请将上述配置文件保存为名为<code>wg0.conf</code>的文件，并将其中的私钥、公钥和远程服务器IP地址替换为您自己的值。</p><p>此示例配置文件包含一个[Interface]段和一个[Peer]段。[Interface]定义了本地WireGuard接口的设置，包括私钥、IP地址、监听端口和DNS服务器。[Peer]定义了要连接的远程对等端的设置，包括公钥、允许IP地址、端点和持久keepalive设置。</p><p>要在Linux系统上使用此配置文件，可以执行以下命令启动WireGuard接口：</p><p><code>sudo wg-quick up wg0</code></p><p>要停止接口，请使用以下命令：</p><p><code>sudo wg-quick down wg0</code></p><p>请注意，这只是一个基本示例，您可以根据自己的需求调整配置文件中的各个选项。</p><blockquote><p>注：如需开启自启服务可使用如下指令：</p><p><code>sudo systemctl enable wg-quick@wg0 --now</code></p></blockquote><h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><p>服务端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#!&#x2F;bin&#x2F;bash# 检查操作系统OS&#x3D;$(uname -s)# 检查WireGuard是否已安装if [ &quot;$OS&quot; &#x3D; &quot;Linux&quot; ]; then    if ! command -v wg &gt;&#x2F;dev&#x2F;null; then        echo &quot;正在安装WireGuard...&quot;        # 根据不同的Linux发行版使用相应的包管理器进行安装        if command -v apt-get &gt;&#x2F;dev&#x2F;null; then            sudo apt-get update            sudo apt-get install -y wireguard resolvconf            sudo modprobe wireguard        elif command -v dnf &gt;&#x2F;dev&#x2F;null; then            sudo dnf install -y wireguard-tools        elif command -v yum &gt;&#x2F;dev&#x2F;null; then            sudo yum install -y elrepo-release epel-release            sudo yum install -y kmod-wireguard wireguard-tools            sudo modprobe wireguard        else            echo &quot;无法自动安装WireGuard，请手动安装。&quot;            exit 1        fi    fielif [ &quot;$OS&quot; &#x3D; &quot;Darwin&quot; ]; then    if ! command -v wg &gt;&#x2F;dev&#x2F;null; then        echo &quot;正在安装WireGuard...&quot;        brew install wireguard-tools    fielse    echo &quot;不支持的操作系统。&quot;    exit 1fi# 启用IP转发echo &quot;启用IP转发...&quot;# 检查是否已经设置IP转发ip_forward&#x3D;$(cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward)if [ &quot;$ip_forward&quot; -eq 1 ]; then  echo &quot;IP转发已经启用，无需进行设置。&quot;fiecho &quot;net.ipv4.ip_forward&#x3D;1&quot; | sudo tee -a &#x2F;etc&#x2F;sysctl.confsudo sysctl -pecho &quot;IP转发已成功启用。&quot;echo &quot;WireGuard已安装，清除原有配置并重新生成新配置...&quot;# 停止WireGuard服务sudo wg-quick down wg0# 移除WireGuard配置文件sudo rm &#x2F;etc&#x2F;wireguard&#x2F;wg0.conf# 清除WireGuard相关的iptables规则# sudo iptables -D FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT# sudo iptables -D FORWARD -i wg0 -o eth0 -j ACCEPT# sudo iptables -D FORWARD -i eth0 -o wg0 -j ACCEPT# sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE# 重新生成WireGuard配置文件echo &quot;请输入服务器的IP地址：&quot;read -r server_ipecho &quot;请输入服务器的监听端口：&quot;read -r server_portsudo mkdir -p &#x2F;etc&#x2F;wireguardsudo chmod 700 &#x2F;etc&#x2F;wireguardwg genkey | sudo tee &#x2F;etc&#x2F;wireguard&#x2F;privatekey | wg pubkey | sudo tee &#x2F;etc&#x2F;wireguard&#x2F;publickeyserver_privatekey&#x3D;$(sudo cat &#x2F;etc&#x2F;wireguard&#x2F;privatekey)server_publickey&#x3D;$(sudo cat &#x2F;etc&#x2F;wireguard&#x2F;publickey)wg_config&#x3D;&quot;&#x2F;etc&#x2F;wireguard&#x2F;wg0.conf&quot;echo &quot;[Interface]&quot; | sudo tee &quot;$wg_config&quot;echo &quot;Address &#x3D; 10.13.13.1&#x2F;24&quot; | sudo tee -a &quot;$wg_config&quot;echo &quot;ListenPort &#x3D; $server_port&quot; | sudo tee -a &quot;$wg_config&quot;echo &quot;PrivateKey &#x3D; $server_privatekey&quot; | sudo tee -a &quot;$wg_config&quot;echo &quot;&quot; | sudo tee -a &quot;$wg_config&quot;echo &quot;WireGuard服务端配置文件已创建：$wg_config&quot;# 重新生成WireGuard配置文件echo &quot;请输入生成的客户端数量：&quot;read -r client_countfor ((i&#x3D;1; i&lt;&#x3D;client_count; i++)); do    wg genkey | sudo tee &#x2F;etc&#x2F;wireguard&#x2F;privatekey$i | wg pubkey | sudo tee &#x2F;etc&#x2F;wireguard&#x2F;publickey$i    client_privatekey&#x3D;$(sudo cat &#x2F;etc&#x2F;wireguard&#x2F;privatekey$i)    echo &quot;[Peer]&quot; | sudo tee -a &quot;$wg_config&quot;    echo &quot;PublicKey &#x3D; $(sudo cat &#x2F;etc&#x2F;wireguard&#x2F;publickey$i)&quot; | sudo tee -a &quot;$wg_config&quot;    echo &quot;AllowedIPs &#x3D; 10.13.13.$((i+1))&#x2F;32&quot; | sudo tee -a &quot;$wg_config&quot;    client_config&#x3D;&quot;&#x2F;root&#x2F;wireguard-clients&#x2F;client$i.conf&quot;    sudo mkdir -p &quot;$(dirname &quot;$client_config&quot;)&quot;    sudo chmod 700 &quot;$(dirname &quot;$client_config&quot;)&quot;    echo &quot;[Interface]&quot; | sudo tee &quot;$client_config&quot;    echo &quot;PrivateKey &#x3D; $client_privatekey&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;Address &#x3D; 10.13.13.$((i+1))&#x2F;24&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;DNS &#x3D; 10.13.13.1&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;[Peer]&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;PublicKey &#x3D; $server_publickey&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;Endpoint &#x3D; $server_ip:$server_port&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;AllowedIPs &#x3D; 10.13.13.0&#x2F;24&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;PersistentKeepalive &#x3D; 25&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;&quot; | sudo tee -a &quot;$client_config&quot;    echo &quot;客户端$i的配置文件已创建：$client_config&quot;done# 启动WireGuard服务sudo systemctl enable --now wg-quick@wg0echo &quot;WireGuard已配置完毕&quot;exit 0</code></pre></div></figure><p>客户端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 检查操作系统OS&#x3D;$(uname -s)# 检查WireGuard是否已安装if [ &quot;$OS&quot; &#x3D; &quot;Linux&quot; ]; then    if ! command -v wg &gt;&#x2F;dev&#x2F;null; then        echo &quot;正在安装WireGuard...&quot;        # 根据不同的Linux发行版使用相应的包管理器进行安装        if command -v apt-get &gt;&#x2F;dev&#x2F;null; then            sudo apt-get update            sudo apt-get install -y wireguard resolvconf        elif command -v yum &gt;&#x2F;dev&#x2F;null; then            sudo yum install -y wireguard-tools resolvconf        elif command -v pacman &gt;&#x2F;dev&#x2F;null; then            sudo pacman -S --noconfirm wireguard-tools openresolv        elif command -v dnf &gt;&#x2F;dev&#x2F;null; then            sudo dnf install -y wireguard-tools resolvconf        else            echo &quot;无法自动安装WireGuard，请手动安装。&quot;            exit 1        fi    fielif [ &quot;$OS&quot; &#x3D; &quot;Darwin&quot; ]; then    if ! command -v wg &gt;&#x2F;dev&#x2F;null; then        echo &quot;正在安装WireGuard...&quot;        brew install wireguard-tools    fielse    echo &quot;不支持的操作系统。&quot;    exit 1fi# 检查WireGuard配置文件是否已存在if [ -f &#x2F;etc&#x2F;wireguard&#x2F;wg0.conf ]; then    echo &quot;已存在WireGuard配置文件。&quot;    read -p &quot;是否替换现有配置？(y&#x2F;n): &quot; replace_config    if [ &quot;$replace_config&quot; !&#x3D; &quot;y&quot; ]; then        echo &quot;使用现有配置文件。&quot;        exit 0    fifi# 用户编辑WireGuard配置文件echo &quot;请在vi或vim中编辑WireGuard配置文件。&quot;read -p &quot;按Enter键继续...&quot; enter_keyif command -v vi &gt;&#x2F;dev&#x2F;null; then    sudo vi &#x2F;etc&#x2F;wireguard&#x2F;wg0.confelif command -v vim &gt;&#x2F;dev&#x2F;null; then    sudo vim &#x2F;etc&#x2F;wireguard&#x2F;wg0.confelse    echo &quot;未找到合适的编辑工具，请手动编辑 &#x2F;etc&#x2F;wireguard&#x2F;wg0.conf 并保存。&quot;fi# 启动WireGuard服务sudo systemctl start wg-quick@wg0# 设置开机自启sudo systemctl enable wg-quick@wg0echo &quot;WireGuard客户端已成功配置并连接。&quot;exit 0</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>端口转发</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Byte Buddy介绍</title>
    <link href="/doc/97f0c167.html"/>
    <url>/doc/97f0c167.html</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Byte Buddy是一个Java字节码生成和操作库，它允许在运行时创建新的类和修改现有的类。它可以用于动态代理、AOP（面向切面编程）、类加载、代码生成等多个领域。</p><p>Byte Buddy提供了一个简单而强大的API，使得在运行时创建和修改类变得非常容易。它的API使用起来非常直观，并且支持链式编程风格，使得代码可读性和可维护性更好。</p><p>Byte Buddy支持Java 6及以上版本，并提供了丰富的功能，例如：</p><ul><li>创建新的类和接口</li><li>修改现有的类和接口</li><li>实现动态代理</li><li>拦截和修改方法</li><li>重定义类</li><li>改变类的继承和实现关系</li><li>自定义类加载器</li><li>生成和加载Java字节码</li></ul><p>Byte Buddy的性能也非常优秀，它能够生成高效的字节码，并且不会对JVM的性能造成显著的影响。</p><p>总之，Byte Buddy是一个功能强大、易于使用、性能优秀的Java字节码生成和操作库，适用于各种场景下的动态代码生成和操作需求。</p><h2 id="常见功能列举"><a href="#常见功能列举" class="headerlink" title="常见功能列举"></a>常见功能列举</h2><p>下面是Byte Buddy的一些主要功能：</p><ol><li>创建新的类和接口：Byte Buddy可以通过代码动态生成新的类和接口，并为它们添加字段、方法、构造函数等。</li><li>修改现有的类和接口：Byte Buddy可以修改现有的类和接口的字段、方法等，从而实现对现有代码的增强或修复。</li><li>实现动态代理：Byte Buddy可以实现动态代理，包括JDK动态代理和CGLIB动态代理，并且支持创建带有拦截器的代理。</li><li>拦截和修改方法：Byte Buddy可以拦截和修改现有的方法，并且可以添加前置和后置拦截器，实现类似AOP的功能。</li><li>重定义类：Byte Buddy可以重新定义类的字节码，从而实现类的热替换和重新加载。</li><li>改变类的继承和实现关系：Byte Buddy可以修改类的继承和实现关系，从而实现对现有代码的增强或修复。</li><li>自定义类加载器：Byte Buddy可以支持自定义类加载器，从而实现对类的动态加载和卸载。</li><li>生成和加载Java字节码：Byte Buddy可以生成Java字节码并将其加载到JVM中。</li></ol><p>总之，Byte Buddy是一个功能强大的Java字节码生成和操作库，适用于各种场景下的动态代码生成和操作需求。</p><h3 id="对类的操作"><a href="#对类的操作" class="headerlink" title="对类的操作"></a>对类的操作</h3><p>Byte Buddy 可以对类进行多种操作，包括创建、修改和重定义等。下面分别介绍这些操作：</p><ol><li>创建新的类和接口：使用 Byte Buddy 可以动态地创建新的类和接口，可以添加字段、方法、构造函数等，通过一个简单的 API 就可以完成这些操作。</li><li>修改现有的类和接口：使用 Byte Buddy 可以修改现有的类和接口的字段、方法等，包括添加、删除、修改等操作，可以使用编程的方式对现有代码进行增强或修复。</li><li>重定义类：使用 Byte Buddy 可以重新定义类的字节码，包括修改类的方法、字段等，从而实现类的热替换和重新加载。</li><li>改变类的继承和实现关系：使用 Byte Buddy 可以修改类的继承和实现关系，包括实现接口、继承父类等操作，从而实现对现有代码的增强或修复。</li><li>拦截和修改方法：使用 Byte Buddy 可以拦截和修改现有的方法，包括添加前置和后置拦截器、修改方法参数和返回值等操作，实现类似 AOP 的功能。</li></ol><p>总之，Byte Buddy 提供了一系列操作类的 API，可以方便地进行类的创建、修改和重定义等操作，从而满足各种动态代码生成和操作的需求。</p><h3 id="对自定义类加载器的支持"><a href="#对自定义类加载器的支持" class="headerlink" title="对自定义类加载器的支持"></a>对自定义类加载器的支持</h3><p>Byte Buddy 对自定义类加载器的支持非常完善，可以使用自定义类加载器加载和卸载类。这为动态代码生成和操作提供了更大的灵活性和可扩展性。</p><p>在 Byte Buddy 中，可以通过使用 ClassLoadingStrategy 类来实现自定义类加载器的支持。ClassLoadingStrategy 可以指定加载新生成的类的类加载器，也可以指定重新定义类的类加载器。</p><p>Byte Buddy 提供了多种 ClassLoadingStrategy 的实现，包括：</p><ol><li>DefaultClassLoaderStrategy：使用默认的类加载器加载新生成的类。</li><li>InjectionClassLoaderStrategy：使用 Instrumentation API 注入类加载器，从而实现类的动态加载和卸载。</li><li>ChildFirstClassLoaderStrategy：使用一个子类加载器来加载新生成的类，这个子类加载器优先加载自己的类，如果找不到再委托给父类加载器。</li><li>ParentFirstClassLoaderStrategy：使用一个父类加载器来加载新生成的类，这个父类加载器优先加载自己的类，如果找不到再委托给子类加载器。</li></ol><p>通过使用 ClassLoadingStrategy，可以轻松地实现自定义类加载器，并且在不同的场景下选择合适的加载策略。这为动态代码生成和操作提供了更大的灵活性和可扩展性，使得 Byte Buddy 成为一款功能强大、易于使用、性能优秀的 Java 字节码生成和操作库。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>Byte Buddy 提供了丰富的 API 可以用于动态调整已加载类的元数据，包括添加、修改、删除方法、字段、注解等等。</p><p>以下是一些常见的操作示例：</p><ol><li>添加方法</li></ol><p>java</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; dynamicType &#x3D; new ByteBuddy()        .subclass(Object.class)        .method(named(&quot;greet&quot;)).intercept(FixedValue.value(&quot;Hello World!&quot;))        .make()        .load(getClass().getClassLoader())        .getLoaded();Object dynamicObject &#x3D; dynamicType.newInstance();String result &#x3D; dynamicObject.greet(); &#x2F;&#x2F; &quot;Hello World!&quot;</code></pre></div></figure><p>这个示例创建了一个 Object 的子类，然后添加了一个名为 greet 的方法，这个方法的实现返回固定的字符串 “Hello World!”。最后，调用 make() 方法生成这个新的类，然后使用 load() 方法加载到指定的类加载器中。</p><ol start="2"><li>修改方法</li></ol><p>java</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; dynamicType &#x3D; new ByteBuddy()        .subclass(Object.class)        .method(named(&quot;toString&quot;)).intercept(FixedValue.value(&quot;Hello World!&quot;))        .make()        .load(getClass().getClassLoader())        .getLoaded();Object dynamicObject &#x3D; dynamicType.newInstance();String result &#x3D; dynamicObject.toString(); &#x2F;&#x2F; &quot;Hello World!&quot;</code></pre></div></figure><p>这个示例也创建了一个 Object 的子类，但是它修改了父类的 toString() 方法的实现，使得它返回固定的字符串 “Hello World!”。</p><ol start="3"><li>删除方法</li></ol><p>java</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; dynamicType &#x3D; new ByteBuddy()        .subclass(Object.class)        .method(named(&quot;toString&quot;)).withoutCode()        .make()        .load(getClass().getClassLoader())        .getLoaded();Object dynamicObject &#x3D; dynamicType.newInstance();String result &#x3D; dynamicObject.toString(); &#x2F;&#x2F; default implementation</code></pre></div></figure><p>这个示例同样创建了一个 Object 的子类，但是它删除了父类的 toString() 方法的实现，使得它恢复为默认的实现。</p><ol start="4"><li>添加注解</li></ol><p>java</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; dynamicType &#x3D; new ByteBuddy()        .subclass(Object.class)        .annotateType(AnnotationDescription.Builder.ofType(MyAnnotation.class).build())        .make()        .load(getClass().getClassLoader())        .getLoaded();Annotation annotation &#x3D; dynamicType.getAnnotation(MyAnnotation.class);</code></pre></div></figure><p>这个示例为 Object 的子类添加了一个自定义注解 MyAnnotation，并使用 Java 反射 API 获取了这个注解的实例。</p><p>总之，Byte Buddy 提供了强大而灵活的 API，可以用于修改已加载类的元数据，使得程序可以在运行时动态地适应不同的需求和场景。</p><h2 id="Byte-Buddy-的学习路线"><a href="#Byte-Buddy-的学习路线" class="headerlink" title="Byte Buddy 的学习路线"></a>Byte Buddy 的学习路线</h2><p>如果您想学习Byte Buddy，以下是一些可能的学习路线：</p><ol><li>学习Java字节码：Byte Buddy的核心功能是通过动态生成Java字节码来创建新的类。因此，如果您不熟悉Java字节码，建议先学习它。有一些非常好的资源可以帮助您了解Java字节码的基础知识，如《深入理解Java虚拟机》一书。</li><li>学习Byte Buddy的基础知识：Byte Buddy的官方文档是一个很好的起点。您可以从官方文档中了解Byte Buddy的基础知识，包括如何创建和修改类、方法和字段等。</li><li>探索Byte Buddy的高级功能：一旦您了解了Byte Buddy的基础知识，可以开始探索它的高级功能，如类加载、动态代理、方法拦截等。Byte Buddy的官方文档提供了很多示例代码，可以帮助您学习这些高级功能。</li><li>阅读Byte Buddy的源代码：如果您想更深入地了解Byte Buddy的工作原理，可以阅读其源代码。Byte Buddy的源代码非常清晰，注释详细，可以帮助您了解其实现细节。</li><li>尝试在实际项目中使用Byte Buddy：最后，如果您想真正掌握Byte Buddy，最好的方法是在实际项目中使用它。尝试使用Byte Buddy创建和修改类，动态代理等等，并观察其效果。这将帮助您深入了解Byte Buddy的工作原理和用途。</li></ol><p>希望这些提示能够帮助您学习Byte Buddy，并在实际项目中有效地使用它。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>ByteCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ByteCode</tag>
      
      <tag>Java</tag>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK的升级指南</title>
    <link href="/doc/ccb79e1b.html"/>
    <url>/doc/ccb79e1b.html</url>
    
    <content type="html"><![CDATA[<h1 id="JDK的升级指南"><a href="#JDK的升级指南" class="headerlink" title="JDK的升级指南"></a>JDK的升级指南</h1><p>接着 <a href="/doc/f7ea7089.html">JDK的选择</a> 这一章继续更新，这次我使用了近期比较火的 <strong>ChatGPT</strong> 来介绍，一起来看一下吧！</p><h2 id="与ChatGPT的对话"><a href="#与ChatGPT的对话" class="headerlink" title="与ChatGPT的对话"></a>与ChatGPT的对话</h2><hr><blockquote><p>我一直在使用JDK 8，请介绍一下JDK 8都有哪些特性</p></blockquote><hr><p>Java Development Kit (JDK) 8是Java语言的一个版本，它引入了很多新特性。下面是JDK 8中的一些主要特性：</p><ol><li><p>Lambda表达式和函数式接口：Lambda表达式是一个简洁而强大的语法，可以使编写代码更为简单和易读。函数式接口是只有一个抽象方法的接口。</p></li><li><p>Stream API：Stream API提供了一种高效而简洁的方式来处理集合数据，支持并行处理。</p></li><li><p>新的日期&#x2F;时间API：JDK 8引入了一个全新的日期&#x2F;时间API，支持更为灵活和易用的日期和时间处理。</p></li><li><p>接口中的默认方法：接口中的默认方法可以使接口的实现类不必全部实现接口中的方法。</p></li><li><p>方法引用：方法引用可以将一个方法作为参数传递给另一个方法，从而使代码更为简洁。</p></li><li><p>Type Annotations：类型注解使得开发者可以在编译时检查代码的类型正确性。</p></li><li><p>Nashorn JavaScript引擎：JDK 8中引入了一个全新的JavaScript引擎，可以直接在Java程序中运行JavaScript代码。</p></li><li><p>PermGen空间移除：PermGen空间在JDK 8中被移除，被Metaspace代替，从而改善了JVM的性能和稳定性。</p></li><li><p>新的重复注解和类型注解：JDK 8引入了新的重复注解和类型注解，可以使得注解的使用更为灵活和方便。</p></li><li><p>Base64编码：JDK 8提供了一个Base64编码类，可以使得编码和解码更为方便。</p></li></ol><p>这些特性是JDK 8的一些主要特点，可以帮助开发者编写更加简洁和高效的代码。</p><hr><blockquote><p>现在已经有新版本的LTS了，请以JDK 8为起点，介绍JDK 17都拥有了哪些新特性</p></blockquote><hr><p>Java Development Kit (JDK) 17是Java语言的一个版本，是自JDK 8以来的第二个长期支持（LTS）版本，引入了许多新特性和改进。下面是JDK 17中的一些主要特性：</p><ol><li><p>Sealed类：Sealed类是一种限制继承和实现的新机制，可以使类更加安全和可靠。</p></li><li><p>垃圾回收器接口：JDK 17中引入了一个新的垃圾回收器接口，使得开发者可以更容易地扩展JVM的垃圾回收器。</p></li><li><p>Pattern Matching for instanceof：JDK 17引入了一种新的语法，可以使开发者更容易地在代码中使用instanceof。</p></li><li><p>基于事件的异步IO：JDK 17中引入了一种基于事件的异步IO机制，可以更高效地进行IO操作。</p></li><li><p>Switch表达式增强：JDK 17中对switch表达式进行了增强，支持更复杂的语法和更灵活的使用。</p></li><li><p>JEP 409: 增强的方法处理：JDK 17中引入了一些增强的方法处理机制，包括对嵌套类的改进和方法描述符的支持。</p></li><li><p>JEP 411: 基于ZGC的并发线程栈处理：JDK 17中引入了一种新的线程栈处理机制，可以更好地支持大规模并发。</p></li><li><p>JEP 412: 基于Vector API的增强：JDK 17中引入了一种新的矢量API，可以更好地支持向量操作。</p></li><li><p>JEP 418: 简化的字符串操作：JDK 17中引入了一些新的字符串操作方法，可以使得字符串处理更加简洁和高效。</p></li><li><p>JEP 403: Strongly Encapsulate JDK Internals by Default：JDK 17中增强了JDK的封装机制，使得JDK的内部实现更加安全和可靠。</p></li></ol><p>这些新特性和改进可以帮助开发者编写更加高效、安全和可靠的Java应用程序。同时，作为一个LTS版本，JDK 17将得到长期支持和维护，可以为企业和开发者提供更稳定和可靠的Java开发环境。</p><hr><blockquote><p>只有这些吗？除了这10条还有吗？</p></blockquote><hr><p>除了上述提到的10个主要特性之外，JDK 17还有其他一些新特性和改进，下面列举一些：</p><ol start="11"><li><p>在Java CDS中启用Application Class-Data Sharing（CDS）默认情况下不支持将应用程序类存档在CDS中，但JDK 17支持使用-Xshare:app选项启用此功能。</p></li><li><p>在垃圾回收器中增加内存分配提示（JEP 412）：在ZGC中，引入了一个新的接口，允许应用程序向JVM发送内存分配提示，以帮助ZGC更好地管理内存。</p></li><li><p>增强的数组支持（JEP 409）：为了增强数组的语法和性能，JDK 17增加了一些新的数组操作API，包括Arrays.compare()和Arrays.mismatch()方法。</p></li><li><p>废弃Thread.destroy()和Thread.stop(Throwable)方法（JEP 411）：为了提高线程安全性和可靠性，JDK 17废弃了Thread.destroy()和Thread.stop(Throwable)方法。</p></li><li><p>废弃RMI Activation功能（JEP 398）：为了减少JDK的复杂性和维护成本，JDK 17废弃了RMI Activation功能。</p></li></ol><p>这些新特性和改进可以进一步提升Java开发的效率、性能和可靠性。</p><hr><blockquote><p>请详细介绍第一条特性并举例说明</p></blockquote><hr><p>第一条特性是Sealed类（Sealed Classes），它是一种限制继承和实现的新机制，可以使类更加安全和可靠。</p><p>在Java中，一个类可以被其他类继承或实现，这使得Java具有了非常强大的面向对象编程能力，但同时也可能导致一些问题，例如类的行为在继承时可能会被重写，从而导致不可预期的结果。为了解决这些问题，JDK 17引入了Sealed类机制。</p><p>Sealed类可以通过使用sealed关键字来声明，它可以限制哪些类可以继承它或实现它，从而提高代码的可靠性和安全性。使用Sealed类可以确保类的行为在继承时不会被修改，从而使得代码更加可靠和稳定。</p><p>下面是一个简单的示例，说明如何声明和使用Sealed类：</p><p>kotlin</p><figure><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">public sealed class Animal permits Dog, Cat, Bird &#123;   &#x2F;&#x2F; ...&#125;public final class Dog extends Animal &#123;   &#x2F;&#x2F; ...&#125;public final class Cat extends Animal &#123;   &#x2F;&#x2F; ...&#125;public non-sealed class Bird extends Animal &#123;   &#x2F;&#x2F; ...&#125;</code></pre></div></figure><p>在这个示例中，Animal是一个Sealed类，它通过permits关键字声明了哪些类可以继承它，包括Dog和Cat。同时，Bird是一个非Sealed类，它继承自Animal类，但没有被列入Animal类的permits列表中。</p><p>通过这种方式，Animal类就可以限制它的子类，从而保证了代码的可靠性和安全性。如果其他类尝试继承Animal类，编译器将会报错。</p><p>Sealed类的引入可以在一定程度上解决继承带来的问题，提高代码的可靠性和安全性。</p><hr><blockquote><p>请详细介绍第2条特性并举例说明</p></blockquote><hr><p>第二条特性是支持Switch表达式中的多个case标签（Switch Expressions with Multiple Labels），它可以让Switch语句更加简洁和易读。</p><p>在Java中，Switch语句通常用于在一组固定值中选择一个执行路径。在JDK 17之前，Switch语句只能使用单个case标签来匹配单个值，这可能会导致代码冗长、难以维护和阅读。</p><p>在JDK 17中，Switch语句可以使用多个case标签来匹配多个值，从而使代码更加简洁和易读。下面是一个简单的示例，说明如何使用Switch表达式中的多个case标签：</p><p>go</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">int dayOfWeek &#x3D; 5;switch (dayOfWeek) &#123;  case 1, 2, 3, 4, 5 -&gt; System.out.println(&quot;Weekday&quot;);  case 6, 7 -&gt; System.out.println(&quot;Weekend&quot;);&#125;</code></pre></div></figure><p>在这个示例中，Switch语句使用了多个case标签来匹配多个值。如果dayOfWeek的值为1、2、3、4或5，Switch语句将会执行第一个case块中的代码，如果dayOfWeek的值为6或7，Switch语句将会执行第二个case块中的代码。</p><p>通过这种方式，Switch语句可以更加简洁和易读，同时也提高了代码的可读性和可维护性。</p><hr><blockquote><p>请详细介绍第3条特性并举例说明</p></blockquote><hr><p>第三条特性是支持嵌套的JVM元数据（Nested JVM Metadata），它可以在Java类文件中嵌套存储一些额外的元数据信息，使得这些信息更加易于管理和维护。</p><p>在Java中，类文件包含了Java类的代码和一些元数据信息，例如类名、字段名、方法名等等。在JDK 17中，Java类文件可以支持嵌套的JVM元数据，也就是将一些额外的元数据信息嵌套存储在类文件中。</p><p>下面是一个简单的示例，说明如何使用嵌套的JVM元数据：</p><p>java</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;  private String name;  private int age;  public Person(String name, int age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  &#x2F;&#x2F; ...  public static class Metadata &#123;    private String version;    public Metadata(String version) &#123;      this.version &#x3D; version;    &#125;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre></div></figure><p>在这个示例中，Person类嵌套了一个名为Metadata的静态类，该类包含了一些额外的元数据信息，例如版本号等等。这些元数据信息存储在类文件中，可以在运行时通过反射等方式访问到。</p><p>通过使用嵌套的JVM元数据，Java类文件可以存储更多的元数据信息，这些信息可以用于调试、测试、优化等方面，同时也使得代码更加易于管理和维护。</p><hr><blockquote><p>请详细介绍第4条特性并举例说明</p></blockquote><hr><p>第四条特性是支持在记录类型中添加更多的方法（More Efficient and Expressive Records），它可以让记录类型（Records）更加高效和灵活。</p><p>在Java中，记录类型是一种新的数据类型，它可以让我们更方便地定义一些轻量级的数据类。在JDK 16中，Java引入了记录类型，使得我们可以更方便地定义一些轻量级的数据类。</p><p>在JDK 17中，记录类型得到了进一步改进，可以支持在记录类型中添加更多的方法，从而使得记录类型更加高效和灵活。下面是一个简单的示例，说明如何在记录类型中添加方法：</p><p>csharp</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public record Person(String name, int age) &#123;  public void sayHello() &#123;    System.out.println(&quot;Hello, my name is &quot; + name);  &#125;&#125;</code></pre></div></figure><p>在这个示例中，我们在Person记录类型中添加了一个名为sayHello的方法，该方法可以输出一些信息。通过这种方式，我们可以在记录类型中添加更多的方法，从而使得记录类型更加高效和灵活。</p><p>值得注意的是，记录类型的方法默认都是final和public的，我们无法在记录类型的子类中重写这些方法。如果需要让方法可重写，可以使用关键字open来修饰方法。</p><hr><blockquote><p>请详细介绍第5条特性并举例说明</p></blockquote><hr><p>第五条特性是G1垃圾回收器的改进（Improvements to the G1 Garbage Collector），它可以让G1垃圾回收器更加高效和稳定。</p><p>G1垃圾回收器是Java中一种高效的垃圾回收器，它可以在大内存环境下高效地回收垃圾。在JDK 17中，G1垃圾回收器得到了进一步改进，包括以下方面：</p><ol><li><p>垃圾回收时不再占用全局安全点（Global Safepoint）：在JDK 17之前，G1垃圾回收器在进行垃圾回收时会占用全局安全点，导致应用程序暂停运行。在JDK 17中，G1垃圾回收器可以在不占用全局安全点的情况下进行垃圾回收，从而减少应用程序的暂停时间。</p></li><li><p>垃圾回收时可以更好地处理碎片化（Fragmentation）：在JDK 17中，G1垃圾回收器可以更好地处理碎片化，从而减少内存碎片的数量，提高内存使用效率。</p></li><li><p>垃圾回收时可以更好地处理内存压缩（Memory Compaction）：在JDK 17中，G1垃圾回收器可以更好地处理内存压缩，从而减少内存碎片的数量，提高内存使用效率。</p></li><li><p>垃圾回收时可以更好地处理超大对象（Huge Pages）：在JDK 17中，G1垃圾回收器可以更好地处理超大对象，从而减少内存碎片的数量，提高内存使用效率。</p></li></ol><p>这些改进使得G1垃圾回收器更加高效和稳定，可以更好地满足大型应用程序的垃圾回收需求。同时，G1垃圾回收器的改进也为Java应用程序提供了更好的性能和稳定性。</p><hr><blockquote><p>请详细介绍第6条特性并举例说明</p></blockquote><hr><p>第六条特性是支持在JVM启动时加载指定的Java类（Load Specific Java Classes at JVM Start），它可以让我们在启动JVM时预先加载需要的Java类，提高应用程序的启动速度。</p><p>在JDK 17之前，如果我们需要在Java应用程序启动时预先加载某些Java类，需要通过修改Java命令行参数或者使用特殊的类加载器来实现。这些方法都比较繁琐，而且容易出错。在JDK 17中，Java引入了一个新的命令行参数“–class-path-xx”，可以让我们在启动JVM时预先加载指定的Java类。</p><p>下面是一个简单的示例，说明如何在JVM启动时预先加载指定的Java类：</p><p>python</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">java --class-path-xx:mylib.jar:myapp.jar com.example.MyApp</code></pre></div></figure><p>在这个示例中，我们通过“–class-path-xx”参数指定了需要预先加载的Java类所在的jar包，以及应用程序的jar包。当我们启动JVM时，JVM会自动加载这些Java类，并预先编译它们，从而提高应用程序的启动速度。</p><p>这个特性可以在一些对应用程序启动速度有较高要求的场景下发挥作用，比如云计算、虚拟化环境等。通过预先加载需要的Java类，我们可以减少应用程序的启动时间，提高应用程序的性能和用户体验。同时，这个特性也为Java应用程序的开发和部署提供了更好的灵活性和便捷性。</p><hr><blockquote><p>请详细介绍第7条特性并举例说明</p></blockquote><hr><p>第七条特性是支持嵌套式访问控制（Nest-Based Access Control），它可以让Java类库更好地管理和控制对其私有成员的访问。</p><p>在Java中，类的私有成员（如私有方法、字段）只能被类本身访问，而不能被其它类访问。这种限制可以确保Java类的封装性和安全性，但在某些情况下也会带来一些限制。比如，在一个类库中，如果有多个类需要访问彼此的私有成员，就会遇到限制。在JDK 17之前，为了解决这个问题，开发人员需要使用反射等手段来绕过私有成员的限制，这不仅繁琐而且不安全。</p><p>在JDK 17中，Java引入了嵌套式访问控制特性，它可以让Java类库更好地管理和控制对其私有成员的访问。具体来说，它可以让一个类声明自己嵌套在另一个类中，从而可以访问该类的私有成员。这种嵌套关系是静态的，即在编译时确定，并通过特殊的访问标志来标识。</p><p>下面是一个简单的示例，说明如何使用嵌套式访问控制特性：</p><p>csharp</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class Outer &#123;    private int value;    public static void main(String[] args) &#123;        Inner inner &#x3D; new Outer().new Inner();        System.out.println(inner.getValue());    &#125;    private class Inner &#123;        private int getValue() &#123;            return value;        &#125;    &#125;&#125;</code></pre></div></figure><p>在这个示例中，我们定义了一个名为“Outer”的类，它有一个私有成员变量“value”，并定义了一个名为“Inner”的内部类，它可以访问“Outer”的私有成员变量“value”。通过使用嵌套式访问控制特性，我们可以让“Inner”类访问“Outer”的私有成员变量“value”，而不需要使用反射等手段来绕过私有成员的限制。</p><p>嵌套式访问控制特性可以为Java类库的开发和维护带来更好的灵活性和安全性，同时也可以提高Java应用程序的性能和可维护性。</p><hr><blockquote><p>请详细介绍第8条特性并举例说明</p></blockquote><hr><p>第八条特性是在switch语句中支持用lambda表达式和方法引用作为分支条件，这可以使代码更加简洁、易读和易维护。</p><p>在JDK 17之前，switch语句只能支持常量表达式作为分支条件，这在某些情况下可能会使代码变得冗长和难以维护。在JDK 17中，Java引入了一个新的特性，允许在switch语句中使用lambda表达式和方法引用作为分支条件，这使得开发人员可以使用更简洁、更灵活的代码来实现同样的功能。</p><p>下面是一个简单的示例，说明如何使用lambda表达式和方法引用作为switch语句的分支条件：</p><p>csharp</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class SwitchExample &#123;    public static void main(String[] args) &#123;        String s &#x3D; &quot;hello&quot;;        switch (s) &#123;            case &quot;hello&quot; -&gt; System.out.println(&quot;Hello, world!&quot;);            case &quot;world&quot; -&gt; System.out.println(&quot;World, hello!&quot;);            case &quot;foo&quot; -&gt; System.out.println(&quot;Foo, bar!&quot;);            case &quot;bar&quot; -&gt; System.out.println(&quot;Bar, foo!&quot;);            case &quot;goodbye&quot; -&gt; System.out.println(&quot;Goodbye, cruel world!&quot;);            default -&gt; System.out.println(&quot;Unknown string: &quot; + s);        &#125;    &#125;&#125;</code></pre></div></figure><p>在这个示例中，我们使用了lambda表达式作为switch语句的分支条件，其中“-&gt;”符号后面的代码块表示分支的执行逻辑。这种语法形式使代码更加简洁和易读，而且可以使开发人员更加灵活地定义分支条件和分支执行逻辑。</p><p>通过使用lambda表达式和方法引用作为switch语句的分支条件，开发人员可以使用更加简洁、易读和易维护的代码来实现同样的功能，从而提高代码的质量和开发效率。</p><hr><blockquote><p>请详细介绍第9条特性并举例说明</p></blockquote><hr><p>第九条特性是在try语句中支持使用资源的自动管理，这使得代码更加简洁、易读和易维护。</p><p>在JDK 17之前，try语句只能用于捕获异常，而无法自动管理资源，这在某些情况下可能会使代码变得冗长和难以维护。在JDK 17中，Java引入了一个新的特性，允许在try语句中自动管理资源，这使得开发人员可以使用更简洁、更灵活的代码来实现同样的功能。</p><p>下面是一个简单的示例，说明如何使用try语句中自动管理资源的特性：</p><p>typescript</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">public class TryWithResourcesExample &#123;    public static void main(String[] args) &#123;        try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;file.txt&quot;))) &#123;            String line;            while ((line &#x3D; reader.readLine()) !&#x3D; null) &#123;                System.out.println(line);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div></figure><p>在这个示例中，我们使用了try语句来自动管理资源，其中BufferedReader和FileReader对象在try语句的括号中声明，并在try语句块执行完成后自动关闭。这种语法形式使代码更加简洁和易读，而且可以使开发人员更加灵活地处理资源的管理和释放。</p><p>通过使用try语句中自动管理资源的特性，开发人员可以使用更加简洁、易读和易维护的代码来实现同样的功能，从而提高代码的质量和开发效率。同时，这也可以避免一些常见的资源泄漏和错误，从而增强代码的健壮性和稳定性。</p><hr><blockquote><p>请详细介绍第10条特性并举例说明</p></blockquote><hr><p>第十条特性是对嵌套的诊断信息进行改进，这使得在调试和排除错误时更加容易。</p><p>在JDK 17之前，当代码中出现嵌套的异常或错误时，诊断信息可能会变得非常混乱和难以理解。在JDK 17中，Java引入了一个新的特性，允许在嵌套的诊断信息中使用占位符，这使得在调试和排除错误时更加容易。</p><p>下面是一个简单的示例，说明如何使用占位符来改进嵌套的诊断信息：</p><p>php</p><figure><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">public class NestedDiagnosticExample &#123;    public static void main(String[] args) &#123;        try &#123;            doSomething();        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;Something went wrong: %s&quot;, e.getMessage(), e);        &#125;    &#125;    private static void doSomething() throws Exception &#123;        try &#123;            doSomethingElse();        &#125; catch (Exception e) &#123;            throw new Exception(&quot;Something else went wrong: %s&quot;, e.getMessage(), e);        &#125;    &#125;    private static void doSomethingElse() throws Exception &#123;        throw new Exception(&quot;Something else went wrong&quot;);    &#125;&#125;</code></pre></div></figure><p>在这个示例中，我们在异常的消息中使用了占位符，以便在嵌套的诊断信息中添加更多的信息。这使得在调试和排除错误时更加容易，因为开发人员可以更加准确地了解每个异常的原因和上下文信息。</p><p>通过使用占位符来改进嵌套的诊断信息，开发人员可以更加轻松地调试和排除错误，从而提高代码的质量和开发效率。同时，这也可以使代码更加健壮和可靠，从而增强应用程序的稳定性和可维护性。</p><hr><blockquote><p>请详细介绍第11条特性并举例说明</p></blockquote><hr><p>第11条特性是“ZGC支持类数据共享”，这个特性是在JDK 15中引入的，并在JDK 17中进行了改进和扩展。</p><p>在Java应用程序中，类数据通常被存储在永久代或元数据区域中。这些数据包括类的结构信息、方法信息、字段信息等等。在多个Java虚拟机实例之间共享类数据可以提高内存利用率和应用程序性能。在JDK 17中，ZGC（Z Garbage Collector）开始支持类数据共享。</p><p>ZGC是一种低延迟的垃圾收集器，它可以在非常大的堆内存下运行，并且在处理大量数据时可以保持一致的低延迟。它是Java 11中引入的一项实验性功能，并在JDK 15中得到了改进和加强。</p><p>现在，在JDK 17中，ZGC已经支持了类数据共享，这使得多个Java虚拟机实例之间可以共享类数据，从而提高了内存利用率和应用程序性能。具体来说，ZGC使用了一种名为“类元数据共享（CDS）”的技术来实现这个特性。</p><p>下面是一个简单的示例，说明如何使用ZGC来实现类数据共享：</p><p>ruby</p><figure><div class="code-wrapper"><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">java -XX:SharedArchiveFile&#x3D;myapp.jsa -XX:+UseZGC -jar myapp.jar</code></pre></div></figure><p>在这个示例中，我们使用了“-XX:SharedArchiveFile”参数来指定类数据共享文件的名称和位置。然后，我们使用“-XX:+UseZGC”参数来启用ZGC，并使用“-jar”参数来指定要运行的应用程序。</p><p>通过使用ZGC支持类数据共享的特性，开发人员可以提高Java应用程序的性能和内存利用率，从而更加有效地满足不断增长的业务需求和用户期望。同时，这也可以减少Java虚拟机实例之间的内存占用和开销，从而提高应用程序的可扩展性和可维护性。</p><hr><blockquote><p>请详细介绍第12条特性并举例说明</p></blockquote><hr><p>第12条特性是“Switch表达式增强”，这个特性是在JDK 12中引入的，并在JDK 17中得到了改进和扩展。</p><p>在之前的Java版本中，Switch语句只能使用常量或枚举类型的值作为case标签。但是，在现实世界的编程中，我们通常需要使用更灵活的表达式作为case标签，以便更好地处理不同的情况。在JDK 12中，Java引入了Switch表达式，这使得Switch语句更加灵活和强大。</p><p>在JDK 17中，Switch表达式得到了进一步的改进和扩展，包括新增了一些语法特性和操作符，使得Switch表达式更加易于使用和理解。</p><p>下面是一些示例代码，说明如何使用Switch表达式的新特性：</p><p>javascript</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 使用新的Lambda箭头语法String result &#x3D; switch (day) &#123;    case MONDAY -&gt; &quot;星期一&quot;;    case TUESDAY -&gt; &quot;星期二&quot;;    case WEDNESDAY -&gt; &quot;星期三&quot;;    case THURSDAY -&gt; &quot;星期四&quot;;    case FRIDAY -&gt; &quot;星期五&quot;;    case SATURDAY, SUNDAY -&gt; &quot;周末&quot;;    default -&gt; throw new IllegalStateException(&quot;非法日期值：&quot; + day);&#125;;&#x2F;&#x2F; 使用新的Yield操作符String result &#x3D; switch (day) &#123;    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;工作日&quot;;    case SATURDAY, SUNDAY -&gt; &#123;        yield &quot;周末&quot;;    &#125;    default -&gt; throw new IllegalStateException(&quot;非法日期值：&quot; + day);&#125;;</code></pre></div></figure><p>在这些示例中，我们使用了新的Lambda箭头语法和Yield操作符来创建Switch表达式。在第一个示例中，我们使用Lambda箭头语法来映射每个枚举值到一个字符串。在第二个示例中，我们使用了Yield操作符来从Switch表达式中返回一个值。</p><p>通过使用Switch表达式的增强功能，开发人员可以更加方便地编写更灵活和强大的代码，从而更好地满足复杂的业务需求和用户期望。同时，这也可以提高代码的可读性和可维护性，从而降低开发和维护成本。</p><hr><blockquote><p>请详细介绍第13条特性并举例说明</p></blockquote><hr><p>第13条特性是“文本块”，这是在JDK 15中引入的新功能，旨在简化Java代码中的文本操作。</p><p>在Java中，处理多行文本通常会导致代码变得冗长和难以阅读，例如，在字符串中插入换行符等。为了解决这个问题，JDK 15引入了文本块，这使得在Java中处理多行文本变得更加容易和直观。</p><p>文本块是由三个双引号包围的文本段，可以包含多行文本和换行符，类似于Python中的三引号字符串。与常规字符串不同，文本块中的任何缩进和换行符都将被保留在字符串中，因此文本块中的格式和布局可以与实际文本匹配，而不需要额外的转义符号。</p><p>下面是一个示例代码，说明如何使用文本块：</p><p>python</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">String html &#x3D; &quot;&quot;&quot;    &lt;html&gt;        &lt;head&gt;            &lt;title&gt;文本块示例&lt;&#x2F;title&gt;        &lt;&#x2F;head&gt;        &lt;body&gt;            &lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;        &lt;&#x2F;body&gt;    &lt;&#x2F;html&gt;&quot;&quot;&quot;;</code></pre></div></figure><p>在这个示例中，我们使用文本块来创建一个HTML字符串。注意，该字符串中的缩进和换行符与实际HTML代码相匹配，这使得代码更加易于阅读和维护。</p><p>使用文本块可以使得Java代码中的文本操作更加直观和简单，从而提高代码的可读性和可维护性。同时，这也可以减少代码中的错误和调试时间，提高开发效率。</p><hr><blockquote><p>请详细介绍第14条特性并举例说明</p></blockquote><hr><p>第14条特性是“记录类型”，这是在JDK 14中引入的新功能，旨在简化Java中的数据模型定义。</p><p>在Java中，通常需要创建许多简单的数据对象来表示业务实体，例如人员、订单等。这些对象通常需要定义一些属性，并且需要为这些属性提供getter和setter方法。在以前的Java版本中，定义这些数据对象通常需要编写大量的重复代码。而在JDK 14中，引入了记录类型，可以大大简化这个过程。</p><p>记录类型是一种特殊类型的Java类，可以使用关键字“record”进行声明。与传统的Java类不同，记录类型提供了一个简洁的语法，用于定义数据对象的属性和方法。例如：</p><p>csharp</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public record Person(String name, int age) &#123;&#125;</code></pre></div></figure><p>在这个示例中，我们定义了一个记录类型“Person”，它有两个属性“name”和“age”。由于这是一个记录类型，因此不需要提供getter和setter方法，它们会自动生成。此外，记录类型还提供了一些其他的默认方法，例如equals()和hashCode()，这些方法可以方便地比较两个记录类型对象的属性值。</p><p>使用记录类型可以大大简化Java中的数据模型定义，减少了冗余代码的编写，同时也提高了代码的可读性和可维护性。此外，由于记录类型是一个不可变类型，它们也可以提高代码的安全性和稳定性。</p><hr><blockquote><p>请详细介绍第15条特性并举例说明</p></blockquote><hr><p>第15条特性是“Pattern Matching for instanceof”，这是在JDK 16中引入的新功能，旨在提高Java中的模式匹配能力。</p><p>在以前的Java版本中，我们通常使用“instanceof”操作符来检查对象的类型，然后根据对象的类型执行不同的操作。例如：</p><p>vbnet</p><figure><div class="code-wrapper"><pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">if (obj instanceof String) &#123;    String str &#x3D; (String) obj;    &#x2F;&#x2F; do something with str&#125; else if (obj instanceof Integer) &#123;    Integer i &#x3D; (Integer) obj;    &#x2F;&#x2F; do something with i&#125;</code></pre></div></figure><p>在JDK 16中，引入了“模式匹配”语法，可以更方便地实现这个功能。例如：</p><p>vbnet</p><figure><div class="code-wrapper"><pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">if (obj instanceof String str) &#123;    &#x2F;&#x2F; do something with str&#125; else if (obj instanceof Integer i) &#123;    &#x2F;&#x2F; do something with i&#125;</code></pre></div></figure><p>在这个示例中，我们使用了新的“instanceof”语法来进行模式匹配。如果对象是一个字符串，那么将其转换为字符串类型并将其赋值给“str”变量；如果对象是一个整数，则将其转换为整数类型并将其赋值给“i”变量。这个新的语法使得代码更加简洁和易读。</p><p>此外，模式匹配还可以与“switch”语句一起使用，使得代码更加简洁和易读。例如：</p><p>vbnet</p><figure><div class="code-wrapper"><pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">switch (obj) &#123;    case String str -&gt; &#x2F;&#x2F; do something with str    case Integer i -&gt; &#x2F;&#x2F; do something with i&#125;</code></pre></div></figure><p>在这个示例中，我们使用了“switch”语句和模式匹配来实现对象类型的检查和操作。如果对象是一个字符串，那么将执行第一个“case”语句中的操作；如果对象是一个整数，则将执行第二个“case”语句中的操作。这个新的语法可以大大简化Java中的分支逻辑，使得代码更加易读和易于维护。</p><hr><blockquote><p>我在阅读JDK 17的源码过程中发现了一些新的注解，请介绍一下自JDK 8之后额外添加的注解都有哪些，以及他们所表示的意义</p></blockquote><hr><p>自JDK 8以来，Java平台添加了很多新的注解，这些注解提供了额外的信息和功能，可以帮助Java开发人员更好地编写代码。以下是一些常见的新注解及其含义：</p><ol><li><p>@FunctionalInterface：用于标记函数式接口，即只包含一个抽象方法的接口。</p></li><li><p>@Repeatable：用于指定一个注解可以重复应用于同一元素上。</p></li><li><p>@Deprecated：用于标记已弃用的类、方法或字段。</p></li><li><p>@SafeVarargs：用于标记方法中使用可变参数时的安全性。</p></li><li><p>@Override：用于标记方法覆盖了父类的方法。</p></li><li><p>@SuppressWarnings：用于禁止编译器产生警告。</p></li><li><p>@Nullable：用于标记一个参数、字段或方法的返回值可以为空。</p></li><li><p>@NonNull：用于标记一个参数、字段或方法的返回值不能为空。</p></li><li><p>@Contract：用于指定方法的行为，例如返回值不能为空、参数不能为空等。</p></li><li><p>@Retention：用于指定注解的保留策略，即注解在编译时、运行时还是两者都保留。</p></li><li><p>@Target：用于指定注解可以应用于哪些元素，例如类、方法、字段等。</p></li><li><p>@Documented：用于指定注解将被包含在Java文档中。</p></li><li><p>@Native：用于标记一个方法是本地方法。</p></li><li><p>@Inherited：用于指定一个注解可以被子类继承。</p></li><li><p>@FunctionalInterface：用于标记函数式接口。</p></li><li><p>@SuppressWarnings：用于抑制Java编译器的警告信息。</p></li><li><p>@Override：用于标记方法覆盖了父类的方法。</p></li></ol><p>这些注解为Java开发人员提供了额外的信息和功能，可以帮助开发人员更好地编写高质量、易于维护的代码。</p><hr><blockquote><p>还有一些你没有讲到的注解，他们都在jdk.internal.vm.annotation包中，请介绍一下他们</p></blockquote><hr><p><code>jdk.internal.vm.annotation</code> 包中的注解是为了JDK内部使用而设计的，不建议用户在应用程序中使用。这些注解包括：</p><ol><li><p><code>Contended</code>：这个注解用于表示一个变量或者类需要被消除伪共享。在多线程应用程序中，伪共享指的是两个或多个线程尝试更新彼此分别访问的变量，这会导致性能下降。<code>@Contended</code> 可以告诉JVM，要把这个变量或类放到单独的缓存行中。</p></li><li><p><code>ForceInline</code>：这个注解用于向JVM发出信号，请求将方法调用内联（inline）。方法内联是一种JIT编译器优化技术，它可以消除方法调用开销，从而提高应用程序的性能。</p></li><li><p><code>HotSpotIntrinsicCandidate</code>：这个注解用于表示一个方法是内置函数。内置函数是由JVM特殊处理的函数，它们是JVM的一部分，可以被JIT编译器优化。使用此注解可以告诉JVM，该方法可以作为内置函数优化。</p></li><li><p><code>ReservedStackAccess</code>：这个注解用于在Java栈上保留一个位置，以便在JVM内部使用。JVM使用此位置来存储一些元数据，以便在异常处理期间快速访问。</p></li><li><p><code>Stable</code>：这个注解用于表示一个类是不变的。如果一个类被标记为<code>@Stable</code>，则JVM可以进行额外的优化，例如将实例的字段缓存起来以提高访问速度。</p></li></ol><p>这些注解是为了JVM内部使用而设计的，一般情况下不需要在应用程序中使用它们。</p><hr><blockquote><p>@IntrinsicCandidate这个注解有什么用？</p></blockquote><hr><p><code>@IntrinsicCandidate</code> 是一种用于JDK内部使用的注解，表示一个方法可能会被JVM内置实现为一个本地方法，以提高性能。在JDK 17中，很多常见的Java库方法，如<code>String::indexOf</code>、<code>Arrays::sort</code>等，都被JVM内置实现为本地方法。</p><p>当一个方法被标记为 <code>@IntrinsicCandidate</code> 时，JVM会在编译时和运行时检查该方法的特征，如果符合内置条件，则会将该方法转换为内置方法调用。这样，每次调用该方法时，就不需要再通过JIT编译，而是直接调用本地方法，可以大大提高方法的执行效率。</p><p>需要注意的是，<code>@IntrinsicCandidate</code> 注解只是一种提示，JVM并不保证会将被标记的方法内置实现，具体是否内置还要根据JVM实现版本和具体场景而定。</p><hr><blockquote><p>JDK 17 相比起 JDK 8在类库上有哪些改变</p></blockquote><hr><p>JDK 17 相比起 JDK 8在类库上有不少的改变，下面列出一些主要的改变：</p><ol><li>新增加了许多API</li></ol><p>JDK 17 引入了许多新的API，例如：</p><ul><li><code>java.util.sealed</code>，用于封闭类和接口，以增强Java的安全性和可维护性。</li><li><code>java.lang.invoke.VarHandle</code>，提供了一种类型安全、高效的方式来访问和修改对象中的字段。</li><li><code>java.net.http.HttpClient</code>，提供了一个标准化的、异步的、非阻塞的HTTP客户端，使得开发者可以轻松地发送HTTP请求和接收HTTP响应。</li><li><code>java.util.stream</code>，提供了许多新的方法，例如<code>takeWhile()</code>、<code>dropWhile()</code>和<code>iterate()</code>，使得流的操作更加方便和灵活。</li><li><code>java.util.collection</code>，提供了一些新的方法，例如<code>toList()</code>和<code>toSet()</code>，使得集合的操作更加方便和高效。</li></ul><ol start="2"><li>移除了一些API</li></ol><p>JDK 17 移除了一些已经过时或不再使用的API，例如：</p><ul><li><code>java.lang.Thread.destroy()</code>，不安全，容易导致死锁等问题，已经被标记为过时并被移除。</li><li><code>java.util.logging.LogManager.readConfiguration()</code>，这个方法很容易被恶意代码利用，已经被标记为过时并被移除。</li></ul><ol start="3"><li>改进了一些API</li></ol><p>JDK 17 对一些API进行了改进，例如：</p><ul><li><code>java.lang.String</code>，新增加了<code>formatted()</code>方法，用于格式化字符串，替代了<code>String.format()</code>方法，提供了更加类型安全和易读的格式化方式。</li><li><code>java.util.concurrent</code>，提供了一些新的并发类，例如<code>StampedLock</code>，用于支持读写锁和乐观锁。</li></ul><p>总之，JDK 17 在类库上进行了许多改进和扩展，使得开发者可以更加方便地编写高效、安全、可维护的Java应用程序。</p><hr><blockquote><p>再详细介绍一下这些变化吧</p></blockquote><hr><p>2 &#x2F; 2</p><p>JDK 17 相对于 JDK 8，在类库上有以下主要变化：</p><ol><li><p>增加了新的Unicode版本支持：JDK 17 通过引入 Unicode 13、14 和 15 版本支持，新增了超过75,000个字符、标记、符号和表情等。</p></li><li><p>增强了集合类：在JDK 17中，集合类增加了许多新的方法，以方便进行流式编程和并行编程，同时提高了集合类的性能。</p></li><li><p>增加了Stream API的改进：新增了takeWhile和dropWhile等方法，可以使Stream API更加灵活。</p></li><li><p>引入了Optional新方法：在JDK 17中，Optional类新增了ifPresentOrElse()方法，该方法在存在值时执行第一个lambda表达式，在不存在值时执行第二个lambda表达式。</p></li><li><p>引入了Pattern Matching：在JDK 17中，对instanceof操作符进行了增强，支持类似于switch语句的模式匹配功能。</p></li><li><p>增强了ConcurrentHashMap：JDK 17中的ConcurrentHashMap类实现了一个全新的算法，以改善其性能和可伸缩性。</p></li><li><p>引入了Sealed Class：Sealed Class 是 JDK 17 中的一项新功能，它允许在一定程度上限制类的继承。</p></li><li><p>优化了GC：JDK 17 中对垃圾收集器进行了一些优化，提高了其性能和可伸缩性。</p></li><li><p>新增加了一些辅助方法，如Files::readString、Files::writeString等，方便进行文件读写。</p></li></ol><p>总之，JDK 17相较于JDK 8，在类库方面进行了许多增强和优化，这些新特性可以提高开发效率、降低代码复杂度、提高程序的可维护性、可读性和性能。</p><hr><blockquote><p>还有吗？再详细介绍一下这些变化吧</p></blockquote><hr><p>是的，除了上面提到的变化之外，JDK 17还有一些其他的类库变化，具体如下：</p><ol start="18"><li><p>Java 2D中新增了支持矢量图形渲染的API JDK 17新增了一个名为“Java2D Vector API”的API，用于支持矢量图形渲染。这个API提供了一个简单的方式来描述2D矢量图形，它可以通过图形、颜色、填充和变换等属性来定义矢量图形。此外，Java2D Vector API还支持将矢量图形转换为像素图形进行渲染，以便在Java2D环境中进行显示。</p></li><li><p>为集合框架添加了新的方法 在JDK 17中，为集合框架添加了几个新的方法，以进一步简化集合操作。这些新方法包括：</p></li></ol><ul><li>List.copyOf()：用于创建一个不可修改的List集合，该集合是指定集合的浅副本。</li><li>Map.copyOf()：用于创建一个不可修改的Map集合，该集合是指定Map集合的浅副本。</li><li>Set.copyOf()：用于创建一个不可修改的Set集合，该集合是指定Set集合的浅副本。</li><li>Collection.toArray(IntFunction)：新增了一个IntFunction参数，允许在转换集合元素类型时指定数组类型。</li></ul><ol start="20"><li>优化Stream API 在JDK 17中，优化了Stream API的性能，加快了处理大量元素的速度。此外，Stream API还新增了一些方法，以便更方便地对流进行操作。这些新方法包括：</li></ol><ul><li>Stream.toList()：用于将流转换为List集合。</li><li>Stream.toSet()：用于将流转换为Set集合。</li><li>Stream.toUnmodifiableList()：用于将流转换为不可修改的List集合。</li><li>Stream.toUnmodifiableSet()：用于将流转换为不可修改的Set集合。</li><li>Stream.flatMapToDouble()：用于将流中的元素映射到DoubleStream中，并返回DoubleStream。</li><li>Stream.flatMapToInt()：用于将流中的元素映射到IntStream中，并返回IntStream。</li><li>Stream.flatMapToLong()：用于将流中的元素映射到LongStream中，并返回LongStream。</li></ul><p>总的来说，JDK 17中的类库变化主要集中在优化性能、增强安全性和提高开发效率等方面。这些变化不仅可以提升应用程序的性能和可靠性，还可以让开发者更加便捷地编写Java代码。</p><hr><blockquote><p>还有吗？再详细介绍一下这些变化吧</p></blockquote><hr><p>当然，还有一些其他的变化，下面继续介绍：</p><ol><li>Stream API</li></ol><p>JDK 17为Stream API添加了三个新的方法：</p><ul><li>Stream.iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator<T> next)，用于创建一个无限的流，其元素的值是通过将前一个元素传递给指定的UnaryOperator函数来生成的，当指定的Predicate函数返回false时，停止流的生成。</li><li>Stream.takeWhile(Predicate&lt;? super T&gt; predicate)，用于返回满足给定条件的前缀子流。</li><li>Stream.dropWhile(Predicate&lt;? super T&gt; predicate)，用于返回不满足给定条件的后缀子流。</li></ul><p>这些方法使得Stream API更加强大和灵活。</p><ol start="2"><li>弱引用</li></ol><p>JDK 17为Reference类添加了一个新的方法：</p><ul><li>Reference.reachabilityFence(Object referent)，用于在某些场景下确保某个对象不被过早地回收。</li></ul><p>该方法使得弱引用更加可靠和灵活。</p><ol start="3"><li>集合</li></ol><p>JDK 17为集合类添加了以下新方法：</p><ul><li>List.ofNullable(T value)，用于创建一个包含指定元素（如果非空）的单元素列表，否则创建一个空列表。</li><li>Map.ofEntries(Map.Entry&lt;? extends K, ? extends V&gt;… entries)，用于创建一个不可变的Map，其键和值由指定的Map.Entry数组提供。</li><li>Map.copyOf(Map&lt;? extends K, ? extends V&gt; map)，用于创建一个不可变的Map，其中的元素是指定Map的副本。</li></ul><p>这些方法可以使集合的创建更加方便和安全。</p><ol start="4"><li>数组</li></ol><p>JDK 17为数组添加了以下新方法：</p><ul><li>Arrays.compareXXX()，用于比较两个数组的元素，其中XXX可以是boolean、byte、char、double、float、int、long、short。</li><li>Arrays.mismatch()，用于查找两个数组在哪里第一次出现不同的元素，如果两个数组是相等的，则返回-1。</li></ul><p>这些方法可以使数组的处理更加便捷和高效。</p><ol start="5"><li>I&#x2F;O</li></ol><p>JDK 17为I&#x2F;O操作添加了以下新方法：</p><ul><li>InputStream.transferTo(OutputStream out)，用于将此输入流中的所有字节传输到指定的输出流中。</li><li>Reader.transferTo(Writer out)，用于将此输入流中的所有字符传输到指定的输出流中。</li><li>Files.readString(Path path)，用于读取指定路径下的文件的内容为字符串。</li><li>Files.writeString(Path path, CharSequence csq, OpenOption… options)，用于将字符串写入到指定路径下的文件中。</li></ul><p>这些方法可以使得I&#x2F;O操作更加方便和高效。</p><p>总的来说，JDK 17在类库上的改变是比较多的，这些改变使得Java程序更加方便、高效、灵活和安全。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNI开发教程</title>
    <link href="/doc/aaec9140.html"/>
    <url>/doc/aaec9140.html</url>
    
    <content type="html"><![CDATA[<p>JNI 是 Java 语言提供的 Java 和 C&#x2F;C++ 相互沟通的机制，Java 可以通过 JNI 调用本地的 C&#x2F;C++ 代码，本地的 C&#x2F;C++ 的代码也可以调用 Java 代码。JNI 是本地编程接口，Java 和 C&#x2F;C++<br>互相通过的接口。Java 通过 C&#x2F;C++ 使用本地的代码的一个关键性原因在于 C&#x2F;C++ 代码的高效性。 代码和其他语言写的代码进行交互。</p><span id="more"></span><h2 id="JNI概述"><a href="#JNI概述" class="headerlink" title="JNI概述"></a>JNI概述</h2><p>JNI 全称是 Java Native Interface（Java 本地接口）单词首字母的缩写，本地接口就是指用 C 和 C++ 开发的接口。由于 JNI 是 JVM 规范中的一部份，因此可以将我们写的 JNI 程序在任何实现了 JNI<br>规范的 Java 虚拟机中运行。同时，这个特性使我们可以复用以前用 C&#x2F;C++ 写的大量代码。</p><p>开发 JNI 程序会受到系统环境的限制，因为用 C&#x2F;C++<br>语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和 CPU 指令集，而且各个平台对标准<br>C&#x2F;C++ 的规范和标准库函数实现方式也有所区别。这就造成使用了 JNI 接口的 JAVA 程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。</p><h2 id="JNI与NDK"><a href="#JNI与NDK" class="headerlink" title="JNI与NDK"></a>JNI与NDK</h2><p>JNI 是 Java 提供的一种和其他语言(一般为C或C++)沟通的机制，而 NDK 则是 Android 通过封装 JNI、gcc、g++ 等多种工具实现的工具包。一般情况下，只有运行效率较高的应用会使用 JNI ，例如：手机游戏开发等。</p><h2 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h2><p>一般情况下，JNI 开发流程主要分为以下几个步骤：</p><ul><li>编写声明了<code>native</code>方法的Java类或接口。</li><li>将编写好的类编译为<code>class</code>字节码文件。</li><li>利用 JDK 提供的<code>javah</code>命令为字节码文件生成对应的 JNI 头文件。</li><li>搭建C&#x2F;C++开发环境、编写代码。</li><li>编译为合适的动态链接库：<ul><li>Windows —— <code>*.dll</code></li><li>Linux&#x2F;Unix —— <code>*.so</code></li><li>Mac —— <code>*.jnilib</code></li></ul></li><li>在Java代码中通过<code>System.load()</code>或<code>System.loadLibrary()</code>加载<code>java.library.path</code>下合适的链接库，以下是两种映射模式：<ul><li>直接生成头文件并引用实现</li><li>通过<code>RegisterNatives()</code>的方式注册函数映射</li></ul></li></ul><h2 id="JNIEXPORT和JNICALL的作用"><a href="#JNIEXPORT和JNICALL的作用" class="headerlink" title="JNIEXPORT和JNICALL的作用"></a><code>JNIEXPORT</code>和<code>JNICALL</code>的作用</h2><p>在生成的头文件定义中，你可以发现有两个常量定义的关键字：<code>JNIEXPORT</code>、<code>JNICALL</code><br>为什么会存在他们？这是因为在 Windows 中编译 dll 动态库规定，如果动态库中的函数要被外部调用，需要在函数声明中添加__declspec(dllexport)标识，表示将该函数导出在外部可以调用。在 Linux&#x2F;Unix<br>系统中，这两个宏可以省略不加。这两个平台的区别是由于各自的编译器所产生的可执行文件格式不一样。 所以为了让代码统一，用<code>#define</code>等预处理手段保证了不同系统环境下代码仍然保持一致。</p><h2 id="数据类型映射"><a href="#数据类型映射" class="headerlink" title="数据类型映射"></a>数据类型映射</h2><p>在调用 Java native 方法将实参传递给 C&#x2F;C++ 函数的时候，会自动将 java 形参的数据类型自动转换成 C&#x2F;C++ 相应的数据类型，所以我们在写 JNI 程序的时候，必须要明白它们之间数据类型的对应关系。</p><table><thead><tr><th align="center">Java Type</th><th align="center">Native Type</th><th align="center">Sign</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">void</td><td align="center">V</td></tr><tr><td align="center">boolean</td><td align="center">jboolean</td><td align="center">Z</td></tr><tr><td align="center">byte</td><td align="center">jbyte</td><td align="center">B</td></tr><tr><td align="center">char</td><td align="center">jchar</td><td align="center">C</td></tr><tr><td align="center">short</td><td align="center">jshort</td><td align="center">S</td></tr><tr><td align="center">int</td><td align="center">jint</td><td align="center">I</td></tr><tr><td align="center">long</td><td align="center">jlong</td><td align="center">J</td></tr><tr><td align="center">float</td><td align="center">jfloat</td><td align="center">F</td></tr><tr><td align="center">double</td><td align="center">jdouble</td><td align="center">D</td></tr><tr><td align="center">int[]</td><td align="center">jarray</td><td align="center">[I</td></tr><tr><td align="center">int[][]</td><td align="center">jarray</td><td align="center">[[I</td></tr><tr><td align="center">Object</td><td align="center">jobject</td><td align="center">Ljava&#x2F;lang&#x2F;Object;</td></tr><tr><td align="center">Object[]</td><td align="center">jarray</td><td align="center">[Ljava&#x2F;lang&#x2F;Object;</td></tr></tbody></table><h2 id="JNI-API"><a href="#JNI-API" class="headerlink" title="JNI API"></a>JNI API</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><table><thead><tr><th>JNI API</th><th>参数列表</th><th>参数说明</th><th>函数说明</th></tr></thead><tbody><tr><td>jobject NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: 对象类，methodID: 构造方法ID，…: 构造方法参数</td><td>创建一个新的Java对象</td><td>该函数创建并返回一个新的Java对象</td></tr><tr><td>jobject NewGlobalRef(JNIEnv *env, jobject obj)</td><td>env: JNI环境变量，obj: 要创建全局引用的对象</td><td>创建一个全局引用</td><td>该函数创建并返回一个指向Java对象的全局引用</td></tr><tr><td>jobject NewLocalRef(JNIEnv *env, jobject obj)</td><td>env: JNI环境变量，obj: 要创建局部引用的对象</td><td>创建一个局部引用</td><td>该函数创建并返回一个指向Java对象的局部引用</td></tr><tr><td>jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args)</td><td>env: JNI环境变量，clazz: 对象类，methodID: 构造方法ID，args: 构造方法参数数组</td><td>创建一个新的Java对象</td><td>该函数创建并返回一个新的Java对象</td></tr></tbody></table><h3 id="对象的操作"><a href="#对象的操作" class="headerlink" title="对象的操作"></a>对象的操作</h3><table><thead><tr><th>JNI API</th><th>参数列表</th><th>参数说明</th><th>函数说明</th></tr></thead><tbody><tr><td>jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig)</td><td>env: JNI环境变量，clazz: 对象类，name: 字段名称，sig: 字段签名</td><td>获取Java对象字段ID</td><td>该函数返回Java对象字段ID</td></tr><tr><td>void SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value)</td><td>env: JNI环境变量，obj: Java对象，fieldID: 字段ID，value: 要设置的值</td><td>设置Java对象的字段值</td><td>该函数设置Java对象的字段值</td></tr><tr><td>jobject GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID)</td><td>env: JNI环境变量，obj: Java对象，fieldID: 字段ID</td><td>获取Java对象的字段值</td><td>该函数返回Java对象的字段值</td></tr><tr><td>jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig)</td><td>env: JNI环境变量，clazz: 对象类，name: 字段名称，sig: 字段签名</td><td>获取Java类静态字段ID</td><td>该函数返回Java类静态字段ID</td></tr><tr><td>jobject GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID)</td><td>env: JNI环境变量，clazz: 对象类，fieldID: 静态字段ID</td><td>获取Java类静态字段值</td><td>该函数返回Java类静态字段值</td></tr><tr><td>void SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value)</td><td>env: JNI环境变量，clazz: 对象类，fieldID: 静态字段ID，value: 要设置的值</td><td>设置Java类静态字段值</td><td>该函数设置Java类静态字段值</td></tr><tr><td>jclass GetObjectClass(JNIEnv *env, jobject obj)</td><td>env: JNI环境变量，obj: Java对象</td><td>获取Java对象的类</td><td>该函数返回Java对象的类</td></tr><tr><td>jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig)</td><td>env: JNI环境变量，clazz: 对象类，name: 方法名称，sig: 方法签名</td><td>获取Java方法ID</td><td>该函数返回Java方法ID</td></tr><tr><td>jobject CallObjectMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: 方法ID，…: 方法参数</td><td>调用Java对象的方法</td><td>该函数调用Java对象的方法并返回结果</td></tr><tr><td>jobject CallStaticObjectMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: 对象类，methodID: 方法ID，…: 方法参数</td><td>调用Java类的静态方法</td><td>该函数调用Java类的</td></tr></tbody></table><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="静态方法调用"><a href="#静态方法调用" class="headerlink" title="静态方法调用"></a>静态方法调用</h4><table><thead><tr><th>JNI API</th><th>参数列表</th><th>参数说明</th><th>函数说明</th></tr></thead><tbody><tr><td>jobject CallStaticObjectMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回jobject类型结果</td><td>该函数调用Java静态方法并返回jobject类型结果</td></tr><tr><td>jboolean CallStaticBooleanMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回boolean类型结果</td><td>该函数调用Java静态方法并返回boolean类型结果</td></tr><tr><td>jbyte CallStaticByteMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回byte类型结果</td><td>该函数调用Java静态方法并返回byte类型结果</td></tr><tr><td>jchar CallStaticCharMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回char类型结果</td><td>该函数调用Java静态方法并返回char类型结果</td></tr><tr><td>jshort CallStaticShortMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回short类型结果</td><td>该函数调用Java静态方法并返回short类型结果</td></tr><tr><td>jint CallStaticIntMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回int类型结果</td><td>该函数调用Java静态方法并返回int类型结果</td></tr><tr><td>jlong CallStaticLongMethod(JNIEnv *env, jclass clazz, jmethodID methodID, …)</td><td>env: JNI环境变量，clazz: Java类，methodID: Java方法ID，…: 可变参数</td><td>调用Java静态方法并返回long类型结果</td><td>该函数调用Java静态方法并返回long类型结果</td></tr></tbody></table><h4 id="动态方法调用"><a href="#动态方法调用" class="headerlink" title="动态方法调用"></a>动态方法调用</h4><table><thead><tr><th>JNI API</th><th>参数列表</th><th>参数说明</th><th>函数说明</th></tr></thead><tbody><tr><td>jobject CallObjectMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回jobject类型结果</td><td>该函数调用Java动态方法并返回jobject类型结果</td></tr><tr><td>jboolean CallBooleanMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回boolean类型结果</td><td>该函数调用Java动态方法并返回boolean类型结果</td></tr><tr><td>jbyte CallByteMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回byte类型结果</td><td>该函数调用Java动态方法并返回byte类型结果</td></tr><tr><td>jchar CallCharMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回char类型结果</td><td>该函数调用Java动态方法并返回char类型结果</td></tr><tr><td>jshort CallShortMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回short类型结果</td><td>该函数调用Java动态方法并返回short类型结果</td></tr><tr><td>jint CallIntMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回int类型结果</td><td>该函数调用Java动态方法并返回int类型结果</td></tr><tr><td>jlong CallLongMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回long类型结果</td><td>该函数调用Java动态方法并返回long类型结果</td></tr><tr><td>jfloat CallFloatMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: Java方法ID，…: 可变参数</td><td>调用Java动态方法并返回float类型结果</td><td>该函数调用Java动态方法并返回float类型结果</td></tr><tr><td>jdouble CallDoubleMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: 方法ID，…: 方法参数</td><td>调用Java对象的方法</td><td>该函数调用Java对象的方法并返回双精度浮点型结果</td></tr><tr><td>void CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, …)</td><td>env: JNI环境变量，obj: Java对象，methodID: 方法ID，…: 方法参数</td><td>调用Java对象的方法</td><td>该函数调用Java对象的方法并返回void</td></tr></tbody></table><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><table><thead><tr><th>JNI API</th><th>参数列表</th><th>参数说明</th><th>函数说明</th></tr></thead><tbody><tr><td>jthrowable ExceptionOccurred(JNIEnv *env)</td><td>env: JNI环境变量</td><td>判断是否有异常发生</td><td>如果有异常发生，返回异常对象</td></tr><tr><td>void ExceptionDescribe(JNIEnv *env)</td><td>env: JNI环境变量</td><td>打印异常信息</td><td>如果有异常发生，该函数将异常信息打印到标准输出</td></tr><tr><td>void ExceptionClear(JNIEnv *env)</td><td>env: JNI环境变量</td><td>清除异常</td><td>该函数清除当前线程中的异常</td></tr><tr><td>void ThrowNew(JNIEnv *env, jclass clazz, const char *msg)</td><td>env: JNI环境变量，clazz: 异常类，msg: 异常信息</td><td>抛出异常</td><td>该函数抛出一个新的异常</td></tr><tr><td>jint Throw(JNIEnv *env, jthrowable obj)</td><td>env: JNI环境变量，obj: 异常对象</td><td>抛出异常</td><td>该函数抛出一个异常</td></tr><tr><td>jint FatalError(JNIEnv *env, const char *msg)</td><td>env: JNI环境变量，msg: 错误信息</td><td>抛出致命错误</td><td>该函数抛出一个致命错误并终止程序的运行</td></tr><tr><td>jint ThrowNew(JNIEnv *env, jclass clazz, const char *msg)</td><td>env: JNI环境变量，clazz: 异常类，msg: 异常信息</td><td>抛出异常</td><td>该函数抛出一个新的异常并返回一个非零值表示成功</td></tr><tr><td>jint Throw(JNIEnv *env, jthrowable obj)</td><td>env: JNI环境变量，obj: 异常对象</td><td>抛出异常</td><td>该函数抛出一个异常并返回一个非零值表示成功</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译器(compiler)</title>
    <link href="/doc/7a794a32.html"/>
    <url>/doc/7a794a32.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GCC（GNU Compiler Collection）是一种广泛使用的编译器，用于将高级编程语言（例如C、C++、Objective-C、Fortran、Ada等）翻译成机器代码。GCC是自由软件，其代码在GNU通用公共许可证（GPL）下发布。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GCC编译器的工作原理大致可分为四个步骤：预处理、编译、汇编和链接。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理器是GCC的第一个阶段。它读取源文件并执行以下操作：</p><ul><li>删除注释：预处理器会删除所有的注释，以简化后续阶段的处理。</li><li>展开宏定义：预处理器会将所有的宏定义展开为它们实际的代码。</li><li>处理条件编译指令：预处理器会根据条件编译指令的结果决定哪些代码应该被编译，哪些代码应该被忽略。</li><li>处理包含指令：预处理器会将所有的#include指令替换为被包含文件的实际内容。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译器是GCC的第二个阶段。它接收预处理器生成的文件，并将其转换为汇编代码。在这个阶段，编译器会执行以下操作：</p><ul><li>词法分析：编译器会将源代码分解成一个个词法单元，例如标识符、关键字、运算符等等。</li><li>语法分析：编译器会根据语法规则将词法单元组合成语法结构，例如函数、语句、表达式等等。</li><li>语义分析：编译器会检查语法结构是否符合语言规范，并进行类型检查。</li><li>生成中间代码：编译器会将源代码转换为中间代码，它是一种抽象的、与平台无关的代码形式。</li></ul><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器是GCC的第三个阶段。它将中间代码转换为可执行的机器代码。在这个阶段，汇编器会执行以下操作：</p><ul><li>操作选择：汇编器会将中间代码转换为适合目标计算机的操作码序列。</li><li>寄存器分配：汇编器会将中间代码中的变量映射到CPU寄存器中。</li><li>生成目标代码：汇编器会将操作码序列转换为目标计算机的二进制代码。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接器的工作是将目标文件和库文件合并为一个可执行文件。具体来说，链接器会执行以下操作：</p><ul><li>符号解析：链接器会解析目标文件中的符号引用，以确定它们对应的地址。符号是指函数、变量、常量等在源代码中定义的标识符。链接器会将符号引用和符号定义进行匹配，以确定符号引用所对应的符号定义的地址。</li><li>重定位：在符号解析的基础上，链接器会将所有的地址修正为正确的值。目标文件和库文件中的符号引用最初只包含了相对地址，即它们距离符号定义的地址的偏移量。链接器会将这些相对地址加上符号定义的地址，以得到正确的绝对地址。</li><li>生成可执行文件：最终，链接器会将所有的目标文件和库文件合并为一个可执行文件。可执行文件包含了所有的代码和数据，可以被操作系统加载和执行。</li></ul><p>需要注意的是，在链接阶段还可能会发生符号冲突的情况。如果多个目标文件或库文件中定义了相同的符号，链接器会尝试解决这些冲突。常见的解决方式包括静态链接和动态链接。静态链接会将所有的代码和数据都打包在可执行文件中，而动态链接会将一部分代码和数据打包在可执行文件中，而将其他部分作为库文件在运行时加载。</p><h2 id="常用指令和参数"><a href="#常用指令和参数" class="headerlink" title="常用指令和参数"></a>常用指令和参数</h2><p>GCC是一个功能强大的编译器，它支持多种编程语言和操作系统。下面介绍一些常用的GCC指令和相关参数：</p><ul><li>编译指令：<code>gcc filename.c</code>，将C源代码编译为可执行文件。这个命令会执行预处理、编译、汇编、链接四个步骤，并生成一个默认的可执行文件<code>a.out</code>。</li><li>指定输出文件名：<code>gcc -o filename filename.c</code>，将C源代码编译为指定名称的可执行文件。</li><li>生成静态库：<code>ar rcs libname.a file1.o file2.o ...</code>，将多个目标文件打包为静态库<code>libname.a</code>。静态库包含可重定位目标文件，可供链接器使用。</li><li>生成动态库：<code>gcc -shared -o libname.so file1.o file2.o ...</code>，将多个目标文件打包为动态库<code>libname.so</code>。动态库包含可重定位目标文件和符号表，可供运行时动态加载。</li><li>调试信息：<code>gcc -g filename.c</code>，在编译时添加调试信息，方便调试程序。</li><li>优化级别：<code>gcc -O1 filename.c</code>，指定优化级别为1，可以有效提高程序运行效率。</li><li>指定编译器：<code>gcc -B /path/to/compiler filename.c</code>，指定编译器路径。</li></ul><p>在编译操作系统时，需要使用GCC的交叉编译功能，以生成目标系统的可执行文件。常用的指令和参数如下：</p><ul><li>指定目标平台：<code>--target=target</code>，指定目标平台，如<code>arm-linux-gnueabi</code>、<code>mips-linux-gnu</code>等。</li><li>指定交叉编译工具链：<code>--with-arch=arch</code>，指定交叉编译工具链的CPU架构，如<code>armv7-a</code>、<code>mips32r2</code>等。</li><li>指定编译器前缀：<code>--prefix=path</code>，指定编译器前缀，如<code>arm-linux-gnueabi-</code>、<code>mips-linux-gnu-</code>等。</li><li>指定交叉编译选项：<code>-march=arch -mtune=cpu</code>，指定目标平台的CPU架构和优化级别。</li><li>指定库搜索路径：<code>-L path</code>，指定库文件搜索路径。</li><li>指定头文件搜索路径：<code>-I path</code>，指定头文件搜索路径。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="编译ARM架构的Linux操作系统"><a href="#编译ARM架构的Linux操作系统" class="headerlink" title="编译ARM架构的Linux操作系统"></a>编译ARM架构的Linux操作系统</h3><p>在编译ARM架构的Linux操作系统时，可以使用如下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --target&#x3D;arm-linux-gnueabi --with-arch&#x3D;armv7-a --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;arm-linux-gnueabimake ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi-</code></pre></div></figure><p>其中，<code>./configure</code>命令用于生成Makefile，<code>--target</code>、<code>--with-arch</code>、<code>--prefix</code>参数指定编译选项，<code>make</code>命令用于执行编译操作。<code>ARCH</code>和<code>CROSS_COMPILE</code>是<code>make</code>命令的两个参数，用于指定编译器的架构和前缀，分别对应GCC的<code>-march</code>和<code>--prefix</code>选项。</p><p><code>ARCH</code>指定编译器的架构，可以是<code>arm</code>、<code>mips</code>、<code>x86</code>等，用于选择对应的头文件和库文件。</p><p><code>CROSS_COMPILE</code>指定编译器前缀，通常是交叉编译器的路径和名称前缀，如<code>arm-linux-gnueabi-</code>、<code>mips-linux-gnu-</code>等。这个前缀会自动加在编译命令中，指定使用对应的交叉编译器。</p><p>例如，<code>ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-</code>表示使用ARM架构的交叉编译器<code>arm-linux-gnueabi-gcc</code>编译程序。在编译操作系统时，需要使用交叉编译器，生成目标系统的可执行文件和库文件。</p><p>如果你想从零开始自主开发操作系统，并使用GCC进行编译，通常需要执行以下步骤：</p><ul><li>配置交叉编译环境：操作系统开发通常需要使用交叉编译环境，即编译器和工具链，可以在主机上编译生成适用于目标系统的程序。你需要在主机上安装交叉编译器，并配置交叉编译环境。</li><li>编写操作系统内核代码：你需要编写操作系统内核代码，这通常包括操作系统启动代码、中断处理程序、内存管理代码、文件系统和设备驱动等。</li><li>编写Makefile：Makefile是用于编译和链接操作系统代码的脚本文件，你需要编写Makefile，指定编译选项和编译顺序等信息。Makefile可以自动化地执行编译过程，生成目标系统的二进制代码。</li><li>执行编译操作：你可以使用GCC编译器执行编译操作，编译操作系统内核代码，生成目标系统的二进制代码。</li></ul><p>通常情况下，操作系统开发需要了解底层硬件、操作系统内核架构和汇编语言等知识，这些知识对于操作系统开发者来说是非常重要的。如果你是初学者，建议先学习相关知识，熟悉操作系统开发的基本流程和编译器的使用方法，然后再开始自主开发操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>编译器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>编译原理</tag>
      
      <tag>链接器</tag>
      
      <tag>编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接器(linker)</title>
    <link href="/doc/8a5babea.html"/>
    <url>/doc/8a5babea.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在计算机科学中，链接器（Linker）是将多个目标文件（object file）合并成单个可执行文件（executable file）的程序。在编译C或C++程序时，源代码首先被编译器（compiler）翻译成目标文件，然后链接器将这些目标文件合并成单个可执行文件。</p><h2 id="学习前要了解的知识"><a href="#学习前要了解的知识" class="headerlink" title="学习前要了解的知识"></a>学习前要了解的知识</h2><p>在学习链接器之前，需要掌握以下基础知识：</p><p>目标文件格式：了解不同操作系统下的目标文件格式（如ELF、COFF、Mach-O等），以及目标文件中包含的数据和代码段、符号表、重定位表等结构。</p><p>符号解析和重定位：理解符号解析的过程，包括符号绑定、强符号和弱符号等概念，同时也需要掌握重定位的相关知识，如重定位类型、符号重定位等。</p><p>静态链接和动态链接：了解静态链接和动态链接的概念以及它们的优缺点，掌握使用静态链接和动态链接的方法。</p><h2 id="命令使用："><a href="#命令使用：" class="headerlink" title="命令使用："></a>命令使用：</h2><p>链接器一般由编译器提供，通常使用命令行进行操作。以下是一些常用的链接器命令：</p><p><code>ld</code>：Linux系统下的链接器命令，可用于链接目标文件生成可执行文件或共享库文件。</p><p><code>lld</code>：LLVM项目提供的链接器，支持多种目标文件格式和平台。</p><p><code>link</code>：Windows系统下的链接器命令，可用于链接目标文件生成可执行文件或动态链接库。</p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>链接器脚本（linker script）是一种用于控制链接器行为的脚本语言。它可以控制内存布局、符号定义、符号位置等，使得程序可以正确地链接和运行。在操作系统和嵌入式系统中，链接器脚本是非常重要的。</p><p>链接器脚本通常包括以下部分：</p><p>头文件（Header）：声明脚本使用的语言和版本。</p><p>符号定义（Symbol Definitions）：定义链接器脚本中的符号。</p><p>内存布局（Memory Layout）：定义链接器在内存中放置程序的方式。</p><p>节定义（Section Definitions）：定义程序的代码和数据段。</p><p>地址重定位（Address Relocations）：定义符号的位置，链接器将会对这些位置进行重定位。</p><p>下面是一个示例链接器脚本，用于从零开始编写操作系统的链接：</p><figure><div class="code-wrapper"><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">ENTRY(_start)SECTIONS &#123;&#x2F;* 从0x00100000地址处开始运行 *&#x2F;. &#x3D; 0x00100000;    &#x2F;* 代码段 *&#x2F;    .text : &#123;        *(.text)    &#125;    &#x2F;* 数据段 *&#x2F;    .data : &#123;        *(.data)    &#125;    &#x2F;* 只读数据段 *&#x2F;    .rodata : &#123;        *(.rodata)    &#125;    &#x2F;* 未初始化数据段 *&#x2F;    .bss : &#123;        *(.bss)    &#125;    &#x2F;* 引导扇区 *&#x2F;    .boot : &#123;        *(.boot)    &#125;    &#x2F;* 结束符 *&#x2F;    _end &#x3D; .;&#125;</code></pre></div></figure><p>这个脚本定义了操作系统的内存布局和链接方式，将代码和数据放置到合适的位置。其中，<code>ENTRY(_start)</code> 定义了程序的入口点为 <code>_start</code>，<code>SECTIONS</code> 块定义了程序的各个部分，包括代码段、数据段、只读数据段、未初始化数据段、引导扇区等。最后一个段定义了 <code>_end</code> 符号，表示整个程序的结束位置。</p><p>需要注意的是，具体的链接器脚本语法和使用方式可能因不同的链接器而有所不同。在实际使用中，需要根据具体情况进行修改和调整。</p><p>总之，链接器脚本是链接器中非常重要的一部分，它可以控制链接器的行为，定义程序的内存布局和链接方式。对于从零开始编写操作系统的开发者来说，编写自定义的链接器脚本是非常必要的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>链接器的主要作用是将多个目标文件合并成单个可执行文件或共享库文件，以便于程序运行。此外，链接器还具有以下功能：</p><p>符号解析：解析目标文件中的符号并将它们解析为地址。</p><p>重定位：处理目标文件中的重定位表，修改目标文件中的地址，使其正确地指向目标文件中的符号。</p><p>库文件链接：将目标文件中的函数调用链接到正确的库函数。</p><p>符号隐藏：隐藏不需要外部访问的符号，以减小可执行文件的大小。</p><p>总之，链接器是一个非常重要的工具，它将目标文件组合成最终的可执行文件或共享库文件，为程序的运行提供了基础。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>链接器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>编译原理</tag>
      
      <tag>链接器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怀旧-红警2服务器环境搭建</title>
    <link href="/doc/1b2e9510.html"/>
    <url>/doc/1b2e9510.html</url>
    
    <content type="html"><![CDATA[<h1 id="怀旧-红警2服务器环境搭建"><a href="#怀旧-红警2服务器环境搭建" class="headerlink" title="怀旧-红警2服务器环境搭建"></a>怀旧-红警2服务器环境搭建</h1><blockquote><p>服务器源码来自：<a href="https://github.com/t123yh/ipxrouter">https://github.com/t123yh/ipxrouter</a><br>Docker源码：<a href="https://github.com/Cikaros/ra2-server">https://github.com/Cikaros/ra2-server</a><br>游戏下载地址：<a href="http://a.uc129.com/hj/uploads/soft/hongj2yuri.rar">http://a.uc129.com/hj/uploads/soft/hongj2yuri.rar</a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一台2核4G的云服务器（当然本地虚拟机也可以，只要能被外网访问即可）</li><li>一个域名（可有可无的东西）</li><li>获取<a href="https://github.com/Cikaros/ra2-server">源码</a></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>将源码解压到工作目录下</li><li>为服务器安装Docker环境（包括Docker和Docker-Compose）</li><li>根据源码调整适合自己的配置</li><li>运行docker-compose完成环境搭建</li><li>开放服务器指定端口</li><li>有域名的可以进行DNS映射解析</li></ol><h2 id="游戏安装"><a href="#游戏安装" class="headerlink" title="游戏安装"></a>游戏安装</h2><ol><li>安装红警2（根据自身情况选择安装位置）</li><li>将client文件夹中的补丁解压到游戏根目录下</li><li>运行红警2，修改用户名，开始联机！</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="运行提示-FATAL-String-Manager-failed-to-initilaized-properly"><a href="#运行提示-FATAL-String-Manager-failed-to-initilaized-properly" class="headerlink" title="运行提示***FATAL***String Manager failed to initilaized properly"></a>运行提示<code>***FATAL***String Manager failed to initilaized properly</code></h3><p>首先值得怀疑的是程序兼容问题造成的win10无法运行红警。可在桌面创建快捷方式并为程序设置游戏兼容性。</p><img src="/doc/1b2e9510/2017063014410616.jpg" srcset="/img/loading.gif" lazyload class=""><h3 id="解决联机无法创建房间的问题"><a href="#解决联机无法创建房间的问题" class="headerlink" title="解决联机无法创建房间的问题"></a>解决联机无法创建房间的问题</h3><p>还有些小伙伴无法在联机大厅创建房间，这个是由于Win10&#x2F;11的分辨率比例导致的，一般情况下电脑的比例都是大于100%的。解决方案如下:</p><img src="/doc/1b2e9510/202302071056.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/1b2e9510/202302071057.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单机游戏</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怀旧-我的世界(MC)私服环境搭建</title>
    <link href="/doc/365b8e86.html"/>
    <url>/doc/365b8e86.html</url>
    
    <content type="html"><![CDATA[<h1 id="怀旧-我的世界-MC-私服环境搭建"><a href="#怀旧-我的世界-MC-私服环境搭建" class="headerlink" title="怀旧-我的世界(MC)私服环境搭建"></a>怀旧-我的世界(MC)私服环境搭建</h1><blockquote><p>服务器源码来自：<a href="https://github.com/itzg/docker-minecraft-server/">https://github.com/itzg/docker-minecraft-server/</a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一台2核4G的云服务器（当然本地虚拟机也可以，只要能被外网访问即可）</li><li>一个域名（可有可无的东西）</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>新建并编辑<code>docker-compose.yml</code><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3&#39;services:  mc:    image: itzg&#x2F;minecraft-server    ports:      - &#39;25565:25565&#39;    environment:      MEMORY: &quot;2G&quot;      MOTD: &quot;欢迎进入糖糖的专属MC-Server&quot;      SERVER_PORT: &quot;25565&quot;      ENABLE_RCON: &quot;TRUE&quot;      MODE: &quot;creative&quot;      SNOOPER_ENABLED: &quot;FALSE&quot;      MAX_PLAYERS: 2      EULA: &quot;TRUE&quot;      ONLINE_MODE: &quot;FALSE&quot;      ENABLE_WHITELIST: &quot;TRUE&quot;      WHITELIST: &quot;Cikaros&quot;      ENFORCE_WHITELIST: &quot;TRUE&quot;      VERSION: &quot;1.18.2&quot;      TYPE: &quot;FORGE&quot;      FORGE_VERSION: &quot;40.1.80&quot;    tty: true    stdin_open: true    restart: unless-stopped    volumes:      - mc-data:&#x2F;datavolumes:  mc-data:</code></pre></div></figure></li><li>为服务器安装Docker环境（包括Docker和Docker-Compose）</li><li>根据源码调整适合自己的配置</li><li>运行docker-compose完成环境搭建</li><li>开放服务器指定端口</li><li>有域名的可以进行DNS映射解析</li></ol>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单机游戏</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怀旧-CS1.6服务器环境搭建</title>
    <link href="/doc/661836f.html"/>
    <url>/doc/661836f.html</url>
    
    <content type="html"><![CDATA[<h1 id="怀旧-CS1-6服务器环境搭建"><a href="#怀旧-CS1-6服务器环境搭建" class="headerlink" title="怀旧-CS1.6服务器环境搭建"></a>怀旧-CS1.6服务器环境搭建</h1><blockquote><p>服务器源码来自：<a href="https://github.com/kriansa/cs-16-server">https://github.com/kriansa/cs-16-server</a><br>CS1.6下载地址：<a href="https://frageris.lt/Counter-Strike-1.6-original.exe">https://frageris.lt/Counter-Strike-1.6-original.exe</a><br>作者服务器地址：cikaros.top</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一台2核4G的云服务器（当然本地虚拟机也可以，只要能被外网访问即可）</li><li>一个域名（可有可无的东西）</li><li>下载<a href="https://github.com/Cikaros/cs-16-server">环境资源</a></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>将环境资源解压到工作目录下</li><li>为服务器安装Docker环境（包括Docker和Docker-Compose）</li><li>根据源码调整适合自己的配置</li><li>运行docker-compose完成环境搭建</li><li>开放服务器指定端口</li><li>有域名的可以进行DNS映射解析</li></ol><h2 id="游戏安装"><a href="#游戏安装" class="headerlink" title="游戏安装"></a>游戏安装</h2><ol><li>安装CS1.6（根据自身情况选择安装位置）</li><li>打开Find Servers（输入服务器地址，连接服务器，耐心等待地图资源下载）</li><li>GoGoGo！（阵营自己选）</li></ol><h2 id="常用管理员指令"><a href="#常用管理员指令" class="headerlink" title="常用管理员指令"></a>常用管理员指令</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rcon_password 管理员密码 #管理员登录amxmodxmenu #AMX Mod菜单yb add将特定的机器人添加到游戏中yb kick从游戏中启动随机或指定的机器人yb removebots从游戏中踢出所有机器人.也可以通过 alias 获得.yb kickallyb kill杀死指定的团队或所有机器人.yb fill使用指定参数填充服务器.yb vote强制所有机器人投票给指定的地图.yb weapons设置要使用的机器人武器模式.yb menu打开主机器人菜单.yb version显示有关机器人构建的版本信息.yb list列出当前在服务器上玩的机器人.yb cvars显示所有 cvar 及其描述.yb graph处理图形操作.yb show_custom显示来自 custom.cfg 的当前值</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单机游戏</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运-CMake教程</title>
    <link href="/doc/dc5b9862.html"/>
    <url>/doc/dc5b9862.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://github.com/chaneyzorn/CMake-tutorial/blob/master/README.md">https://github.com/chaneyzorn/CMake-tutorial/blob/master/README.md</a></p></blockquote><h1 id="CMake-tutorial-原文"><a href="#CMake-tutorial-原文" class="headerlink" title="CMake-tutorial(原文)"></a>CMake-tutorial(<a href="https://cmake.org/cmake-tutorial/">原文</a>)</h1><p>这份渐进式的教程涵盖了 CMake 帮助处理的一些常见的构建问题。许多议题已经在<a href="http://www.kitware.com/products/books/CMakeBook.html">《Mastering CMake》</a>中作为独立的话题介绍过，但是了解它们是如何在示例项目中结合在一起的将非常有帮助。你可以在 CMake 源码中的 <a href="https://gitlab.kitware.com/cmake/cmake/tree/master/Tests/Tutorial">Tests&#x2F;Tutorial</a> 文件夹找到这份教程，每一步的内容都放置在各自的子文件夹中。</p><h2 id="一个基本的出发点-Step1"><a href="#一个基本的出发点-Step1" class="headerlink" title="一个基本的出发点 (Step1)"></a>一个基本的出发点 (Step1)</h2><p>最简单的项目是从源代码文件中构建一个可执行文件，CMakeLists.txt 文件仅需要两行，这将作为我们教程的起点，内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake_minimum_required (VERSION 2.6)project (Tutorial)add_executable(Tutorial tutorial.cxx)</code></pre></div></figure><p>文件中的命令支持大写、小写或者混合使用，这个例子中的命令使用小写。tutorial.cxx 用于计算一个数的平方根，源码的第一版非常简单：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 计算一个数的平方根#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[])&#123;  if (argc &lt; 2)    &#123;    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    &#125;  double inputValue &#x3D; atof(argv[1]);  double outputValue &#x3D; sqrt(inputValue);  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;&#125;</code></pre></div></figure><h3 id="添加一个版本号并配置头文件"><a href="#添加一个版本号并配置头文件" class="headerlink" title="添加一个版本号并配置头文件"></a>添加一个版本号并配置头文件</h3><p>你可以直接在源代码中添加版本号，但在 CMakeLists.txt 文件中提供版本号将会更加灵活，我们将文件修改如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake_minimum_required (VERSION 2.6)project (Tutorial)# 版本号 1.0set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# 配置一个头文件将一些 CMake 设置传入到源代码中# 以 TutorialConfig.h.in 为模版，替换相关变量# 以生成 TutorialConfig.hconfigure_file (  &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;TutorialConfig.h.in&quot;  &quot;$&#123;PROJECT_BINARY_DIR&#125;&#x2F;TutorialConfig.h&quot;  )# 将构建目录添加到 include 的搜索路径中以便找到# TutorialConfig.h 文件include_directories(&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)# 添加可执行文件add_executable(Tutorial tutorial.cxx)</code></pre></div></figure><p>因为配置文件将会写入到构建目录中，所以我们将这个目录添加到包含文件的搜索路径中。在源代码中添加 TutorialConfig.h.in 文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</code></pre></div></figure><p>当 CMake 生成这个头文件时，@Tutorial_VERSION_MAJOR@ 和 @Tutorial_VERSION_MINOR@ 的值将会由 CMakeLists.txt 中对应的值替换。接下来我们将头文件包含到 tutorial.cxx 中并且使用这个版本号，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;TutorialConfig.h&quot;int main (int argc, char *argv[])&#123;  if (argc &lt; 2)    &#123;    fprintf(stdout,&quot;%s Version %d.%d\n&quot;,            argv[0],            Tutorial_VERSION_MAJOR,            Tutorial_VERSION_MINOR);    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    &#125;  double inputValue &#x3D; atof(argv[1]);  double outputValue &#x3D; sqrt(inputValue);  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;&#125;</code></pre></div></figure><p>主要的改变是包含了头文件并且在使用方法信息中打印了版本号。</p><h2 id="添加一个库-Step-2"><a href="#添加一个库-Step-2" class="headerlink" title="添加一个库 (Step 2)"></a>添加一个库 (Step 2)</h2><p>现在我们要在项目中添加一个库，这个库将会包含我们自己的计算平方根的实现。可执行文件将可以使用这个库，而不是使用编译器提供的平方根标准方法。本教程中将这个库放到名为 MathFunctions 的子文件夹中，这个子文件夹需要包含一个 CMakeLists.txt 文件，文件中有如下一行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_library(MathFunctions mysqrt.cxx)</code></pre></div></figure><p>mysqrt.cxx 文件中有一个叫做 mysqrt 的函数，它提供与编译器的 sqrt 函数相同的功能。我们在顶层的 CMakeLists.txt 中添加一个 add_subdirectory 调用以构建这个库。为了找到 MathFunctions&#x2F;MathFunctions.h 头文件中的函数原型，我们添加另一条包含路径。最后一个改动是将这个库添加到可执行文件中。顶层 CMakeLists.txt 文件中添加的最新几行如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;MathFunctions&quot;)add_subdirectory (MathFunctions)# add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial MathFunctions)</code></pre></div></figure><p>考虑一下将这个库设计为可选的，本教程中这样做也许是不必要的，但是当使用更大的库或者第三方的库时你也许会用到。第一步是在顶层的 CMakeLists.txt 中添加一个选择：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># 是否使用我们自己的函数？option (USE_MYMATH        &quot;Use tutorial provided math implementation&quot; ON)</code></pre></div></figure><p>CMake GUI 中将会显示一个 ON 的默认值，用户可以按需更改。这个设置将会被缓存，这样在每次对这个项目运行 CMake 时用户不需要再次设置。接下来的更改是将 MathFunctions 库的构建和连接设置为可选的，我们在顶层 CMakeLists.txt 的最后修改如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># add the MathFunctions library?if (USE_MYMATH)  include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;MathFunctions&quot;)  add_subdirectory (MathFunctions)  set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif (USE_MYMATH)# add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial  $&#123;EXTRA_LIBS&#125;)</code></pre></div></figure><p>这将根据 USE_MYMATH 的设置来决定是否编译并使用 MathFunctions 库。注意这里使用了一个 EXTRA_LIBS 变量来收集任何可选的库，以在之后链接到可执行文件中。对有许多可选组件的项目，这是一种保持其整洁的常用方法。相应的源代码更改如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F; A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;TutorialConfig.h&quot;#ifdef USE_MYMATH#include &quot;MathFunctions.h&quot;#endifint main (int argc, char *argv[])&#123;  if (argc &lt; 2)    &#123;    fprintf(stdout,&quot;%s Version %d.%d\n&quot;, argv[0],            Tutorial_VERSION_MAJOR,            Tutorial_VERSION_MINOR);    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    &#125;  double inputValue &#x3D; atof(argv[1]);#ifdef USE_MYMATH  double outputValue &#x3D; mysqrt(inputValue);#else  double outputValue &#x3D; sqrt(inputValue);#endif  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;&#125;</code></pre></div></figure><p>在源代码中我们同样使用了 USE_MYMATH 变量。通过在 TutorialConfig.h.in 中添加如下配置，Cmake 将这个变量引入到源代码中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#cmakedefine USE_MYMATH</code></pre></div></figure><h2 id="安装与测试-Step-3"><a href="#安装与测试-Step-3" class="headerlink" title="安装与测试 (Step 3)"></a>安装与测试 (Step 3)</h2><p>接下来我们在项目中添加安装规则和测试支持。安装规则非常直接，对于 MathFunctions 库的安装，我们在  MathFunctions 的 CMakeLists.txt 中添加如下几行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)</code></pre></div></figure><p>对于应用程序可执行文件和头文件的安装，我们在顶层的 CMakeLists.txt 中添加如下几行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;&#x2F;TutorialConfig.h&quot;         DESTINATION include)</code></pre></div></figure><p>万事俱备，接下来你应该可以构建这个项目，然后键入 <code>make install</code> （或者在 IDE 中构建 INSTALL 目标），它将会安装合适的头文件，库和执行文件。CMake 的 CMAKE_INSTALL_PREFIX 变量用于决定文件安装位置的根。添加测试也是一个同样直接的过程。在顶层 CMakeLists.txt 的结尾，我们可以添加几个基础测试以判别程序是否工作正常：</p><figure><div class="code-wrapper"><pre class="line-numbers language-camke" data-language="camke"><code class="language-camke">include(CTest)# does the application runadd_test (TutorialRuns Tutorial 25)# does it sqrt of 25add_test (TutorialComp25 Tutorial 25)set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;)# does it handle negative numbersadd_test (TutorialNegative Tutorial -25)set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;)# does it handle small numbersadd_test (TutorialSmall Tutorial 0.0001)set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;)# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;)</code></pre></div></figure><p>构建完成后，可以使用命令行工具 <code>ctest</code> 运行测试。第一个测试只是验证程序是否运行，没有段错误或其他的崩溃，并返回零值。这是一个 CTest 测试的基本形式。接下来的几个测试都使用 PASS_REGULAR_EXPRESSION 测试属性来验证测试的输出是否包含某些字符串。这样用来验证预期的计算结果，并且当参数数目不正确时打印使用信息。如果你想添加大量测试来测试不同的输入值，你可能会考虑创建如下所示的宏：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">#define a macro to simplify adding tests, then use itmacro (do_test arg result)  add_test (TutorialComp$&#123;arg&#125; Tutorial $&#123;arg&#125;)  set_tests_properties (TutorialComp$&#123;arg&#125;    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)endmacro (do_test)# do a bunch of result based testsdo_test (25 &quot;25 is 5&quot;)do_test (-25 &quot;-25 is 0&quot;)</code></pre></div></figure><p>每调用一次 do_test，根据传递的参数，都会添加一个拥有名字、输入和输出的测试。</p><h2 id="添加系统自检-Step-4"><a href="#添加系统自检-Step-4" class="headerlink" title="添加系统自检 (Step 4)"></a>添加系统自检 (Step 4)</h2><p>接下来让我们向项目中添加一些代码，这些代码依赖的功能目标平台可能没有提供。这个例子中，我们添加的代码依赖于目标平台是否提供了对数 log 和指数 exp 函数。当然几乎所有的平台都提供了这样的函数，本教程假定它们是不常见的功能。如果平台提供了 log，那么我们可以在 mysqrt 函数中使用它计算平方根。我们首先使用顶层 CMakeLists.txt 文件中的 CheckFunctionExists.cmake 宏来测试这些功能的可用性，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># does this system provide the log and exp functions?include (CheckFunctionExists)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP)</code></pre></div></figure><p>当 CMake 在平台上发现它们时，我们在 TutorialConfig.h.in 中定义这些值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">&#x2F;&#x2F; does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP</code></pre></div></figure><p>log 和 exp 的测试需要放在 configure_file 命令之前，configure_file 命令会立即使用 CMake 中的当前设置生成文件。当系统提供了这两个函数时，我们可以使用以下代码在 mysqrt 函数中提供一个基于 log 和 exp 的替代实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; if we have both log and exp then use them#if defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP)  result &#x3D; exp(log(x)*0.5);#else &#x2F;&#x2F; otherwise use an iterative approach  . . .</code></pre></div></figure><h2 id="添加生成文件和生成器-Step-5"><a href="#添加生成文件和生成器-Step-5" class="headerlink" title="添加生成文件和生成器 (Step 5)"></a>添加生成文件和生成器 (Step 5)</h2><p>在本节中，我们将展示如何将生成的源文件添加到应用程序的构建过程中。本例中，我们将会在构建过程中创建一个预先计算的平方根表，然后将这张表编译进我们的程序中。我们首先需要一个生成这张表的程序，为此我们在 MathFunctions 的子文件夹中添加一个新的名为 MakeTable.cxx 的源文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A simple program that builds a sqrt table#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[])&#123;  int i;  double result;  &#x2F;&#x2F; make sure we have enough arguments  if (argc &lt; 2)    &#123;    return 1;    &#125;  &#x2F;&#x2F; open the output file  FILE *fout &#x3D; fopen(argv[1],&quot;w&quot;);  if (!fout)    &#123;    return 1;    &#125;  &#x2F;&#x2F; create a source file with a table of square roots  fprintf(fout,&quot;double sqrtTable[] &#x3D; &#123;\n&quot;);  for (i &#x3D; 0; i &lt; 10; ++i)    &#123;    result &#x3D; sqrt(static_cast&lt;double&gt;(i));    fprintf(fout,&quot;%g,\n&quot;,result);    &#125;  &#x2F;&#x2F; close the table with a zero  fprintf(fout,&quot;0&#125;;\n&quot;);  fclose(fout);  return 0;&#125;</code></pre></div></figure><p>注意这张表会以有效的 C++ 代码的形式生成，输出文件的名字以参数的形式提供。接下来向 MathFunctions 的 CMakeLists.txt 文件中添加合适的命令以构建 MakeTable 的可执行文件，并运行它作为构建过程的一部分。需要几个命令来完成此操作，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command (  OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h  COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h  DEPENDS MakeTable  )# add the binary tree directory to the search path for# include filesinclude_directories( $&#123;CMAKE_CURRENT_BINARY_DIR&#125; )# add the main libraryadd_library(MathFunctions mysqrt.cxx $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h  )</code></pre></div></figure><p>首先像添加其他执行文件那样添加 MakeTable 的执行文件。然后我们添加一个自定义命令以使用 MakeTable 生成 Table.h 文件。接下来我们需要将生成的文件添加到 MathFunctions 库的源文件列表中，以让 CMake 知道 mysqrt.cxx 依赖于 Table.h 文件。我们也需要将当前的构建文件夹添加到包含文件列表中，以让 Table.h 文件可以被发现并包含到 mysqrt.cxx 中。当构建这个项目时，它会先构建 MakeTable 的执行文件，然后运行 MakeTable 生成 Table.h 文件，最后它会编译包含有 Table.h 的 mysqrt.cxx 以生成 MathFunctions 库。此时，顶层 CMakeLists.txt 文件如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake_minimum_required (VERSION 2.6)project (Tutorial)include(CTest)# The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# does this system provide the log and exp functions?include ($&#123;CMAKE_ROOT&#125;&#x2F;Modules&#x2F;CheckFunctionExists.cmake)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP)# should we use our own math functionsoption(USE_MYMATH  &quot;Use tutorial provided math implementation&quot; ON)# configure a header file to pass some of the CMake settings# to the source codeconfigure_file (  &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;TutorialConfig.h.in&quot;  &quot;$&#123;PROJECT_BINARY_DIR&#125;&#x2F;TutorialConfig.h&quot;  )# add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories (&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)# add the MathFunctions library?if (USE_MYMATH)  include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;MathFunctions&quot;)  add_subdirectory (MathFunctions)  set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif (USE_MYMATH)# add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial  $&#123;EXTRA_LIBS&#125;)# add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;&#x2F;TutorialConfig.h&quot;         DESTINATION include)# does the application runadd_test (TutorialRuns Tutorial 25)# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage  PROPERTIES  PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;  )#define a macro to simplify adding testsmacro (do_test arg result)  add_test (TutorialComp$&#123;arg&#125; Tutorial $&#123;arg&#125;)  set_tests_properties (TutorialComp$&#123;arg&#125;    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;    )endmacro (do_test)# do a bunch of result based testsdo_test (4 &quot;4 is 2&quot;)do_test (9 &quot;9 is 3&quot;)do_test (5 &quot;5 is 2.236&quot;)do_test (7 &quot;7 is 2.645&quot;)do_test (25 &quot;25 is 5&quot;)do_test (-25 &quot;-25 is 0&quot;)do_test (0.0001 &quot;0.0001 is 0.01&quot;)</code></pre></div></figure><p>TutorialConfig.h.in 如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@#cmakedefine USE_MYMATH&#x2F;&#x2F; does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP</code></pre></div></figure><p>MathFunctions 的 CMakeLists.txt 文件如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command (  OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h  DEPENDS MakeTable  COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h  )# add the binary tree directory to the search path# for include filesinclude_directories( $&#123;CMAKE_CURRENT_BINARY_DIR&#125; )# add the main libraryadd_library(MathFunctions mysqrt.cxx $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&#x2F;Table.h)install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)</code></pre></div></figure><h2 id="构建安装程序-Step-6"><a href="#构建安装程序-Step-6" class="headerlink" title="构建安装程序 (Step 6)"></a>构建安装程序 (Step 6)</h2><p>接下来假设我们想将我们的项目分发给其他人，以便他们可以使用它。我们希望在各种平台上提供二进制和源代码分发。这与之前的第三步有些不同，在这个例子中，我们将构建安装包以支持二进制安装和包管理功能，比如 cygwin，debian，RPMs 等。我们将会使用 CPack 来创建平台相关的安装程序。具体来说，我们需要在我们的顶层 CMakeLists.txt 文件的底部添加几行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># build a CPack driven installer packageinclude (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE     &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;)include (CPack)</code></pre></div></figure><p>我们从包含 InstallRequiredSystemLibraries 开始。该模块包含有这个项目在当前平台所需的任何运行时库。然后我们设置一些 CPack 变量指明此项目许可证和版本信息的位置。版本信息使用了本教程前面设置的变量。最后我们包含了 CPack 模块，它将使用你设置的这些变量和其他系统属性来配置安装程序。</p><p>接下来就是按照通常的方法构建项目，然后运行 CPack 命令。要构建一个二进制分发，你可以运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cpack --config CPackConfig.cmake</code></pre></div></figure><p>要创建一个源码分发，你可以键入：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cpack --config CPackSourceConfig.cmake</code></pre></div></figure><h2 id="添加对仪表板的支持-Step-7"><a href="#添加对仪表板的支持-Step-7" class="headerlink" title="添加对仪表板的支持 (Step 7)"></a>添加对仪表板的支持 (Step 7)</h2><p>添加将测试结果提交给仪表板的支持非常简单。在教程之前的步骤中已经定义了一些测试，我们只需运行这些测试并且将它们提交给一个仪表板。要包括对仪表板的支持，我们将 CTest 模块包含在我们的顶层 CMakeLists.txt 文件中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># enable dashboard scriptinginclude (CTest)</code></pre></div></figure><p>我们还创建一个CTestConfig.cmake文件，可以在该文件中为仪表板指定此项目的名称。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set (CTEST_PROJECT_NAME &quot;Tutorial&quot;)</code></pre></div></figure><p>当运行 CTest 时它会读取这个文件。要创建简单的仪表板，你可以在项目中运行 CMake，然后切换目录到构建目录中运行 <code>ctest –D Experimental</code>. 仪表板的结构将会上传到 Kitware 的公共仪表板中（<a href="http://www.cdash.org/CDash/index.php?project=PublicDashboard">这里</a>）。</p>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>CLion</category>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDE</tag>
      
      <tag>CLion</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运-操作系统开发：编写开机引导</title>
    <link href="/doc/483bf2e0.html"/>
    <url>/doc/483bf2e0.html</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统开发：编写开机引导"><a href="#操作系统开发：编写开机引导" class="headerlink" title="操作系统开发：编写开机引导"></a>操作系统开发：编写开机引导</h1><blockquote><p>文章来源：<a href="https://www.cnblogs.com/LyShark/p/16517379.html">https://www.cnblogs.com/LyShark/p/16517379.html</a></p></blockquote><p>操作系统是用来管理与协调硬件工作的，开发一款操作系统有利于理解底层的运转逻辑，本篇内容主要用来理解操作系统是如何启动的，又是如何加载磁盘中的内核的，该系列文章参考各类底层书籍，通过自己的理解并加以叙述，让内容变得更加简单，一目了然，即可学到知识又能提高自己的表述能力。</p><p>该系列文章是在学习《操作系统真相还原》时通过阅读后简化并适当描述整理的学习笔记，首先，致敬作者郑刚博士，在读本书时能深刻的感觉到作者写书时一丝不苟的态度，书很厚写的，讲解细致幽默，很能让人愿意继续读下去，同时也不得不佩服作者计算机底层功力的深厚。</p><h2 id="BOIS是如何苏醒的"><a href="#BOIS是如何苏醒的" class="headerlink" title="BOIS是如何苏醒的"></a>BOIS是如何苏醒的</h2><p><strong>BIOS</strong> 基本输入输出系统,<strong>BIOS</strong> 代码所做的工作是一成不变的,所以他是被固化到<strong>ROM</strong>中的一块只读区域中,在开机时此<strong>ROM</strong>会被映射到低端<code>1MB</code>内存的顶部,原因是系统在开启时默认是实地址模式(该模式最大寻址范围<code>0-fffff</code>),所以其寻址范围也就被限制在了<code>0xF0000-x0xFFFFF</code>区域中,这<code>64KB</code>的内存就是<strong>BIOS</strong>的执行代码.</p><p>在开机的一瞬间,<strong>CPU</strong>的<strong>CS:IP</strong>寄存器会被强制初始化为<code>0xF000:0xFFF0</code>,在实地址模式下该地址需要乘以16也就是左移四位加上偏移地址得到,于是<code>0xF000:0xFFF0</code>就等效于<code>0xFFFF0</code>此处的地址距离<code>0xFFFFF</code>只有16个字节的空间,里面存放着一条<code>jmp far f000:e05b = fe05b</code>的汇编指令,该指令将跳转到真正的<strong>BIOS</strong>开始的位置.</p><p>接着<strong>BIOS</strong>将会通过自身的代码对硬件进行自检测,在初始化硬件后,则开始向内存<code>0x000-0x3ff</code>中初始化数据结构以及拷贝中断向量表,紧接着<strong>BIOS</strong>将会通过调用<code>int 19h</code>中断,此中断用以检测计算机中的硬盘,如果检测到0盘0道1扇区末尾的两个字节是<code>0x55,0xaa</code>则认为此扇区确实存在,于是就会将此区域中的内容,加载到内存<code>0x7c00</code>的位置,并通过一条<code>jmp far 0:0x7c00h</code>的指令跳转到该位置执行,这样<strong>BIOS</strong>就将<strong>CPU</strong>控制权交给了<strong>MBR</strong>了,而<strong>BIOS</strong>将会再次睡去.</p><h2 id="MBR继续执行引导"><a href="#MBR继续执行引导" class="headerlink" title="MBR继续执行引导"></a>MBR继续执行引导</h2><p>如上提到过的<code>0x7c00</code>就是<strong>MBR</strong>代码的开始位置,之所以是<code>0x7C00</code>是因为,<strong>DOS</strong>中要求最小内存是<code>32KB</code>而<strong>MBR</strong>大小必须是<code>512</code>字节,所以选择<code>32kB</code>中的最后<code>1KB</code>的位置最为合适(<code>32KB(0x8000)-1KB(0x400)=&gt;0x7c00</code>),这就是<code>0x7C00</code>的由来,同时还需要保证第<code>510-511</code>字节必须为<code>0x55,0xaa</code>才可以,这就需要在末尾部分自动补齐两字节的填充.</p><p>简单的引导<strong>MBR</strong>的代码如下,首先我们需要先初始化每个段寄存器<strong>DS</strong>,<strong>ES</strong>,<strong>SS</strong>,<strong>FS</strong>,<strong>SP</strong>然后通过调用两次<code>int 0x10</code>中断对命令行进行置空操作,最后通过<code>mov ax,01301h</code>也就是13号中断,打印出字符串.</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">SECTION MBR vstart&#x3D;0x7c00     ; 告诉编译器加载到7c00内存处        mov ax,cs        mov ds,ax        mov es,ax        mov ss,ax        mov fs,ax        mov sp,0x7c00        mov ax,0x600      ; 清屏范围,也就是宽度        mov bx,0x0        mov cx,0x0        ; 清屏 左上角(0,0)        mov dx,0x184f     ; 清屏 右下角(80&#x3D;0x4f,25&#x3D;0x18)        int 0x10        mov dh,0x0        ; 设置光标列号        mov dl,0x0        ; 设置光标行号        mov bh,0x0        ; 页码        int 0x10        mov ax,Message        mov bp,ax         ; 保存字符串地址        mov cx,15         ; 保存字符串长度        mov ax,01301h     ; 子功能号13是显示字符及属性        mov bx,000ch      ; 页号位0,使用黑色为背景色,红色为字体颜色        mov dl,0        int 10h           ; 调用10h号中断,用来显示字符        hlt        retMessage: db &quot;hello lyshark !&quot;times 510-($-$$) db 0  ; 填充剩余的510字节的空间为0db 0x55,0xaa           ; mbr的结束标志</code></pre></div></figure><p>我们直接将其保存为<code>mbr.asm</code>文件,通过Nasm汇编器编译为二进制文件,然后再通过<code>dd</code>命令写入到一个镜像文件中,具体编译流程如下,这里需要下载好Windows版本的<code>dd</code>命令.</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 首先编译为二进制文件nasm mbr.asm -o mbr.bin# 将镜像写入到kernel.img镜像中,写入长度512字节,循环1次dd if&#x3D;mbr.bin of&#x3D;kernel.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc# 通过seek跳过第一个扇区,然后向后填充4096字节的0dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;kernel.img seek&#x3D;1 bs&#x3D;512 count&#x3D;4096</code></pre></div></figure><p>由于我们使用的模拟器是<strong>Bochs x86</strong>所以,在制作好镜像后,需要在编写一个虚拟机配置文件,该配置文件命名为<code>mbr.src</code>其内部需要定义好虚拟机的类型,启动方式,镜像位置等基本参数,一个简易版定义语句如下.</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">megs:32romimage:file&#x3D;.&#x2F;BIOS-bochs-latestvgaromimage:file&#x3D;.&#x2F;VGABIOS-lgpl-latestboot:diskmouse:enabled&#x3D;0ata0-master: type&#x3D;disk, path&#x3D;&quot;kernel.img&quot;, mode&#x3D;flat, status&#x3D;insertedkeyboard: keymap&#x3D;.&#x2F;x11-pc-de.map</code></pre></div></figure><p>启动时可以直接调用<code>bochsdbg -q -f mbr.src</code>命令,使用调试模式运行,并通过语句<code>vb sp:0x7c00</code>在开头下断点,使用<code>c</code>命令可运行到<strong>MBR</strong>代码处,单步<code>n</code>执行,即可输出一段话,标志着<strong>MBR</strong>已经成功被加载.</p><img src="/doc/483bf2e0/1379525-20220725145517602-1715723101.png" srcset="/img/loading.gif" lazyload class=""><h2 id="让MBR直接驱动显卡"><a href="#让MBR直接驱动显卡" class="headerlink" title="让MBR直接驱动显卡"></a>让MBR直接驱动显卡</h2><p>如上代码，我们通过调用<strong>BIOS</strong>提供的<code>int 0x10</code>中断来实现打印字符操作，但我们在后期必须要借助显卡来输出图像，而显卡是外部设备，必须通过总线来操作。</p><p>由于<strong>CPU</strong>使用的信号是<strong>TTL</strong>电平，而外部设备都是机械设备，故他们不会使用该电平驱动，这就导致<strong>CPU</strong>与硬件设备没有办法实现沟通，硬件工程师们提供的方法是，在这两者之间架起一座桥，也就是在<strong>CPU</strong>和外设之间加上一层<strong>IO</strong>接口，该接口的作用就是实现<strong>CPU</strong>和外设之间相互做协调转换。</p><p>其次外部设备的种类也是多种多样的，其输出的信号可能是数字信号，也可能是模拟信号，而我们的<strong>CPU</strong>只能处理数字信号，数字信号需要经过数模转换器<code>&lt;D/A&gt;</code>成模拟量才能送到外设来驱动硬件工作，模拟量也同样需要经过模数转换器<code>&lt;A/D&gt;</code>转换成数字量才能被<strong>CPU</strong>直接处理，所以接口电路中需要包括<code>A/D</code>转换器和<code>D/A</code>转换器。</p><p>转换后的数字信号，会经过总线进行传递，总线的别名是<strong>BUS</strong>，之所以叫做<strong>BUS</strong>是因为其是公共线路，所有硬件设备都会走此线路，但同一时刻，<strong>CPU</strong>只能和一个<strong>IO</strong>接口(寄存器&#x2F;端口)通信，当有多个<strong>IO</strong>接口同时想和<strong>CPU</strong>通信时，那么<strong>IO</strong>仲裁模块会对其进行竞争与选优，仲裁模块固化到，输入输出控制中心(<strong>ICH</strong>)也就是南桥芯片上的。</p><p>多数情况下，南桥和北桥是成对出现的，南桥主要负责连接<strong>PCI</strong>,<strong>PCI-Express</strong>,<strong>AGP</strong>等低速设备，而北桥则用于链接高速设备，如内存等。</p><p><strong>IO</strong>接口都是串行口，其在设计之初就是负责与<strong>CPU</strong>进行通信的，我们想要与<strong>CPU</strong>通信，其实是向这些接口中写入数据，同时为了区别<strong>CPU</strong>中的寄存器，所以把<strong>IO</strong>接口叫做端口，某些外设可以通过内存映射来访问，即把某些端口映射到指定内存中，访问某个内存区域就相当于访问了指定的端口。</p><p>由于显卡的起始地址为<code>0xb800</code>向该地址写入数据即可回显在显示器上，如下代码是一个简单的填充过程。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">SECTION MBR vstart&#x3D;0x7c00     ; 告诉编译器加载到7c00内存处        mov ax,cs        mov sp,0x7c00        mov ax,0xb800        mov gs,ax        mov ax,0x600      ; 清屏范围,也就是宽度        mov bx,0x0        mov cx,0x0        ; 清屏 左上角(0,0)        mov dx,0x184f     ; 清屏 右下角(80&#x3D;0x4f,25&#x3D;0x18)        int 0x10        mov dh,0x0        ; 设置光标列号        mov dl,0x0        ; 设置光标行号        mov bh,0x0        ; 页码        int 0x10        mov byte [gs:0x00],&#39;L&#39;        mov byte [gs:0x01],0xa4 ; 显示A&#x3D;绿色闪烁 4&#x3D;红色        mov byte [gs:0x02],&#39;y&#39;        mov byte [gs:0x03],0xa5        mov byte [gs:0x04],&#39;S&#39;        mov byte [gs:0x05],0xa6        mov byte [gs:0x6],&#39;h&#39;        mov byte [gs:0x7],0xa7        mov byte[gs:0x8],&#39;a&#39;        mov byte [gs:0x9],0xa6        mov byte[gs:0xa],&#39;r&#39;        mov byte [gs:0xb],0xa5        mov byte[gs:0xc],&#39;k&#39;        mov byte [gs:0xd],0xa4        hlt        rettimes 510-($-$$) db 0  ; 填充剩余的510字节的空间为0db 0x55,0xaa           ; mbr的结束标志</code></pre></div></figure><p>编译并运行这段代码，由于使用的是显卡输出，所以在输出色彩上，我们的选择余地更多了。</p><img src="/doc/483bf2e0/1379525-20220725145548953-1827793088.png" srcset="/img/loading.gif" lazyload class=""><p>如上代码中需要注意，偶数行<code>gs:0x04</code>代表的是输出数据，奇数行<code>gs:0x05</code>则代表颜色背景色，如果需要实现循环输出，那么我们除需要考虑循环条件外，还应把基数偶数行也考虑进来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">SECTION MBR vstart&#x3D;0x7c00     ; 告诉编译器加载到7c00内存处; 清屏和设置光标位置mov ax,0x600      ; 清屏范围,也就是宽度mov bx,0x0mov cx,0x0        ; 清屏 左上角(0,0)mov dx,0x184f     ; 清屏 右下角(80&#x3D;0x4f,25&#x3D;0x18)int 0x10mov dh,0x0        ; 设置光标列号 左上角(0,0)mov dl,0x0        ; 设置光标行号 右下角(0,0)mov bh,0x0        ; 页码int 0x10; 初始化,使SP寄存器指向段基址0X7C0处,GS指向显存基地址mov ax,csmov sp,0x7c00mov ax,0xb800mov gs,ax              ; 设置显存地址; 设置字符串长度与字符串基地址mov cx, msglen        ; 获取字符串长度mov si, message       ; 设置字符串基址xor di, di            ; 每次清空di寄存器loop_str:mov al, [si]            ; 每次取出一个字符mov [gs:di], al         ; 将字符逐一赋值到显存中inc siinc dimov byte [gs:di], 000ch ; 设置字体颜色inc diloop loop_strhlt      ; 程序在此处终止;message db &quot;Loading MBR...&quot;,0ah,0dhmessage db &quot;Loading MBR...&quot;msglen  equ $ - messagetimes 510-($-$$) db 0  ; 填充剩余的510字节的空间为0db 0x55,0xaa           ; mbr的结束标志</code></pre></div></figure><img src="/doc/483bf2e0/1379525-20220725145604208-911099651.png" srcset="/img/loading.gif" lazyload class=""><h2 id="让MBR直接驱动硬盘"><a href="#让MBR直接驱动硬盘" class="headerlink" title="让MBR直接驱动硬盘"></a>让MBR直接驱动硬盘</h2><p>既然显卡中存在端口可以被操作，那么硬盘也同样存在，硬盘控制器属于<strong>IO</strong>接口，如果想让硬盘工作，我们需要通过读写硬盘控制器上的端口，此处的端口指的就是硬盘控制器上的寄存器组。</p><ul><li>硬盘控制器中的端口可被分为两种,最主要的是 <strong>Command Block registers</strong> 组中的寄存器</li><li><strong>Command Block registers</strong> 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态</li><li><strong>Control Block registers</strong> 用于控制硬盘工作状态</li></ul><p>一般硬盘中的一个通道包括两片硬盘，其中<code>0</code>为主盘，<code>1</code>为从盘，硬盘控制器中的主要寄存器如下，其中主盘所对应的通道为<strong>Primary</strong>，后面的那个<strong>Secondary</strong>则是从盘通道，主从盘调用中断号完全不同：</p><img src="/doc/483bf2e0/1379525-20220725145627186-461943681.png" srcset="/img/loading.gif" lazyload class=""><ul><li><strong>DATA</strong> 寄存器主要负责管理数据,相当于数据的门,作用是读取或写入数据</li><li>读硬盘时: 硬盘准备好数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据。</li><li>写硬盘时: 把数据源源不断地输送到此端口，数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。</li><li><strong>ERROR&#x2F;FEATURES</strong> 由于环境不同用途不同,所以两个寄存器名字指的是同一个</li><li>读硬盘时: 端口<code>0x171</code>或<code>0x1F1</code>的寄存器名字叫<strong>Error</strong>寄存器，若读取失败，里面存储的是失败状态信息，并且<code>0x1F2</code>端口中存储未读的扇区数。</li><li>写硬盘时: 就变成<strong>feauture</strong>寄存器，用于写命令的参数，有些命令需要指定额外参数，这些参数就写在 <strong>Feature</strong> 寄存器中。</li><li><strong>SectorCount</strong> 寄存器用来指定待读取或待写入的扇区数</li><li>硬盘每完成1个扇区，就会将此寄存器的值减1，如果中间失败了，此寄存器中的值便是尚未完成的扇区。</li><li><strong>LBA</strong> 逻辑块地址,解决了磁盘在柱面磁头扇区上寻址的麻烦(<strong>CHS</strong>),寻址时不用再考虑扇区所在的物理结构,当今<strong>LBA</strong>有两种,一种是<strong>LBA28</strong>最大支持<code>128GB</code>的寻址,另外一种是<strong>LBA48</strong>,最大支持<code>128PB</code>寻址.</li><li><strong>LBA</strong>寄存器,有三种不同的形式: <code>LBA low</code>、<code>LBA mid</code>、<code>LBA high</code><ul><li><code>LBA low</code> 寄存器用来存储28位地址的第0-7位</li><li><code>LBA mid</code> 寄存器用来存储第8-15位</li><li><code>LBA high</code> 寄存器存储第16-23位</li></ul></li><li><strong>Device</strong> 寄存器是个杂项,宽度<code>8</code>位,此寄存器的低<code>4</code>位用来存储<strong>LBA</strong>地址的第<code>24-27</code>位<ul><li>第<code>4</code>位用来指定通道上的主盘或从盘</li><li>第<code>6</code>位用来设置是否启用<strong>LBA</strong>方式</li><li>第<code>5</code>位和第<code>7</code>位是固定为<code>1</code>的,称为<strong>MBS</strong>位</li></ul></li><li><strong>Status</strong> 状态寄存器,控制端口<code>0x1F7</code>或<code>0x177</code>,它是<code>8</code>位宽度寄存器,用来给出硬盘的状态信息<ul><li>第<code>0</code>位是<strong>ERR</strong>位，为<code>1</code>表示命令出错，具体原因可见<strong>error</strong>寄存器。</li><li>第<code>3</code>位是<strong>data request</strong>位，为<code>1</code>表示硬盘已经把数据准备好了机现在可以把数据读出来。</li><li>第<code>6</code>位是<strong>DRDY</strong>，表示硬盘就绪表示硬盘检测正常，可以继续执行一些其他命令。</li><li>第<code>7</code>位是<strong>BSY</strong>位，表示硬盘是否繁忙，为<code>1</code>表示硬盘正忙。</li></ul></li><li>注释: 状态位与<strong>Error</strong>寄存器一样，在写硬盘时寄存器就变成<strong>Command</strong>，此寄存器用来存储让硬盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作。</li></ul><p>由于<strong>MBR</strong>受制于只能容纳<code>512</code>字节大小的数据，没法为内核准备好环境，更没法将内核成功加载到内存并运行，此时我们需要让<strong>MBR</strong>实现从硬盘加载<strong>Loader</strong>程序到内存，加载完成后再将接力棒交给<strong>Loader</strong>继续运行，<strong>MBR</strong>加载磁盘代码如下。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">%include &quot;boot.inc&quot;SECTION MBR vstart&#x3D;0x7c00            mov ax,cs         mov ds,ax   mov es,ax   mov ss,ax   mov fs,ax   mov sp,0x7c00   mov ax,0xb800   mov gs,ax; 清屏   mov ax, 0600h   mov bx, 0700h   mov cx, 0   mov dx, 184fh   int 10h   mov eax,LOADER_START_SECTOR ; 起始扇区lba地址   mov bx,LOADER_BASE_ADDR       ; 写入的地址   mov cx,1             ; 待读入的扇区数   call rd_disk_m_16     ; 以下读取程序的起始部分（一个扇区）     jmp LOADER_BASE_ADDR;功能:读取硬盘n个扇区rd_disk_m_16:         mov esi,eax  ;备份eax      mov di,cx  ;备份cx;读写硬盘:;第1步：设置要读取的扇区数      mov dx,0x1f2      mov al,cl      out dx,al            ;读取的扇区数      mov eax,esi   ;恢复ax;第2步：将LBA地址存入0x1f3 ~ 0x1f6      ;LBA地址7~0位写入端口0x1f3      mov dx,0x1f3                             out dx,al                                ;LBA地址15~8位写入端口0x1f4      mov cl,8      shr eax,cl      mov dx,0x1f4      out dx,al      ;LBA地址23~16位写入端口0x1f5      shr eax,cl      mov dx,0x1f5      out dx,al      shr eax,cl      and al,0x0f   ;lba第24~27位      or al,0xe0   ; 设置7～4位为1110,表示lba模式      mov dx,0x1f6      out dx,al;第3步：向0x1f7端口写入读命令，0x20       mov dx,0x1f7      mov al,0x20                              out dx,al;第4步：检测硬盘状态  .not_ready:      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态      nop      in al,dx      and al,0x88   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙      cmp al,0x08      jnz .not_ready   ;若未准备好，继续等。;第5步：从0x1f0端口读数据      mov ax, di      mov dx, 256      mul dx      mov cx, ax   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，   ; 共需di*512&#x2F;2次，所以di*256      mov dx, 0x1f0  .go_on_read:      in ax,dx      mov [bx],ax      add bx,2        loop .go_on_read      ret   times 510-($-$$) db 0   db 0x55,0xaa</code></pre></div></figure><img src="/doc/483bf2e0/1379525-20220725145646468-623819972.png" srcset="/img/loading.gif" lazyload class=""><p>至此虽然输出效果与在MBR中直接操作显卡输出结果一致，但本质是不同的，此处代码中<strong>MBR</strong>主要负责从硬盘中的第<code>3</code>个扇区中读入<strong>Loader</strong>加载器到内存，并将<strong>CPU</strong>指针指向它，后期的输出纯粹是<strong>Loader</strong>加载器所为。</p><h2 id="实模式切入保护模式"><a href="#实模式切入保护模式" class="headerlink" title="实模式切入保护模式"></a>实模式切入保护模式</h2><p>保护模式最早出现在<code>80286</code>系列处理器中，之所以会出现保护模式是因为实地址模式中存在以下问题：</p><ol><li>实模式下操作系统与用户程序属于同一特权级<code>R0</code>，无法区分系统程序与用户程序。</li><li>用户程序引用的地址都是指向真实的物理地址，所以逻辑地址就等于物理地址。</li><li>用户程序可以直接修改段基址，当访问超过<code>64KB</code>的内存区域时需要手动切换段基址。</li><li>共<code>20</code>条地址线最大可用<code>1MB</code>内存，且一次只能运行<code>1</code>个程序,无法充分利用计算资源。</li></ol><p>为了克服内存访问限制，<strong>CPU</strong>厂商则开发出保护模式，在保护模式下物理地址不能被程序直接访问，在访问时需要将虚拟地址转换为物理地址再去访问，而对于程序而言这一系列操作都是透明的。</p><p>这个地址转换过程是由操作系统与处理器共同协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程中所需要的页表。</p><h3 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a>实模式与保护模式</h3><p>相对于实地址模式，保护模式对寄存器进行了一定的扩展，<strong>CPU</strong>扩展为<code>32</code>位后，其地址总线和数据总线也变为<code>32</code>位，寻址空间达到了<code>4GB</code>，为了让一个寄存器可以访问到<code>4GB</code>空间，需要将寄存器宽度提升到<code>32</code>位。</p><p>除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的<code>16</code>位扩展到了<code>32</code>位，段寄存器<code>16</code>位就够用了。</p><p>相对于实地址模式，保护模式大大提高了对内存段的保护能力，<strong>GDT</strong>全局描述符就是对特定内存段属性进行描述的数据结构，该数据结构中的每一个表项称为段描述符，大小为<code>64</code>字节，用来描述各个内存段的起始地址、大小、权限等信息。</p><p>由于全局描述符表<strong>GDT</strong>很大，所以默认将其放在了内存中，由<strong>GDTR</strong>寄存器指向它，<strong>GDTR</strong>是个<code>48</code>位的寄存器，通常使用<code>lgdtr</code>指令操作，控制该寄存器。</p><p>这样，段寄存器中保存的再也不是段基址了，里面保存的内容叫 段选择子(<strong>selector</strong>) 该选择子其实就是个数，用这个数来索引全局描述符表中的段描述符，如果把全局描述符表当成数组，那么选择子就是数组的下标。</p><h3 id="GDT全局描述符表"><a href="#GDT全局描述符表" class="headerlink" title="GDT全局描述符表"></a>GDT全局描述符表</h3><p>全局描述符表<strong>GDT</strong>是保护模式下内存段的登记表，这是不同于实地址模式下的显著特征。<br>局部描述符表<strong>LDT</strong>是<strong>CPU</strong>厂商为了在硬件层面支持多任务的一个表，当今操作系统不使用。</p><p>在实地址模式下，寻址是按照<code>[段基址+段内偏移]</code>的形式进行，而在保护模式下为了保证兼容性，其也必须遵循这一规范。</p><p>在实地址模式下，访问内存时只要将段基址加载到段寄存器中，再结合偏移地址就行，段寄存器太小了，只能存储 <code>16</code> 位的信息，甚至连 <code>20</code> 位地址都要借助左移 <code>4</code> 位来实现。</p><p>而进入到保护模式，各个寄存器都提升到了<code>32</code>位，且还需对特定的内存段增加一些额外的安全属性，那么将这些属性放在内存中是最好的选择。</p><ul><li>之所以需要增加全局描述符表，并为每个段增加段描述符，是因为实模式下存在以下问题。</li><li>实模式下的用户程序可以破坏存储代码的内存区域，所以要添加个内存段类型属性来阻止这种行为。</li><li>实模式下的用户程序和操作系统是同一级别的，所以要添加个特权级属性来区分用户程序和系统。</li><li>内存段是一片内存区域，访问内存就要提供段基址，所以要有段基址属性。</li><li>为了限制程序访问内存的范围，还要对段大小进行约束，所以要有段界限属性。</li></ul><p><strong>段描述符</strong>: 一个段描述符只用来描述一个内存段的属性，这些描述符被依次排列在<strong>GDT</strong>中，<strong>GDT</strong>全局描述符表相当于描述符数组，数组中每个元素都是一个描述符，每个描述符大小是<code>8</code>字节，分为高<code>32</code>位与低<code>32</code>位，即两个四字节，<strong>GDT</strong>中最多可容纳的描述符数量是<code>65536/8=8192</code>个，即 <strong>GDT</strong> 中可容纳 <code>8192</code> 个段或门。</p><p>如下，段描述符结构示意参考，以及每个字段的大体含义。</p><img src="/doc/483bf2e0/1379525-20220725145700475-1833044642.png" srcset="/img/loading.gif" lazyload class=""><ul><li>段界限:第<code>0-15</code>位与<code>16-19</code>位共同构成段界限，表示段的边界，大小，范围，段界限用<code>20</code>个二进制位来表示。</li><li>段基址:第<code>0-7</code>是段基址的<code>16-23</code>位，第<code>24-31</code>位是段基址的高<code>32</code>位，加上段描述符低<code>32</code>位中的段基址<code>0-15</code>位，就构成了<code>32</code>位的基地址。</li><li>Type字段:第<code>8-11</code>位是<strong>type</strong>字段，共占用<code>4</code>位，用于表示内存段或调用门的子类型。</li><li>S字段:第<code>12</code>位是<strong>S</strong>字段，用于指示是否为系统段，为<code>0</code>是系统段，为<code>1</code>是数据段，通常与<strong>Type</strong>字段配合使用。</li><li>DPL字段:第<code>13-14</code>位是<strong>DPL</strong>，即描述符特权级，通常是指所代表的内存段的特权级。</li><li>Present字段:第<code>15</code>位是<strong>P</strong>字段，标志着指定段是否存在，如果段存在于内存中，<strong>P</strong>为<code>1</code>否则为<code>0</code>。</li><li>AVaiLable字段:第<code>20</code>位是<strong>AVL</strong>字段，无用途，可随意使用此位。</li><li>L字段:第<code>21</code>位是<strong>L</strong>字段，用于设置是否是<code>64</code>位代码段，<strong>L</strong>为<code>1</code>表示<code>64</code>位代码段，为<code>0</code>则为<code>32</code>位。</li><li>D&#x2F;B字段:第<code>22</code>位是<strong>DB</strong>字段，用来指示有效地址(段内偏移地址)及操作数的大小。</li><li>Granularity字段:第<code>23</code>位是<strong>G</strong>字段，用来指定段界限的单位大小，若<strong>G</strong>为<code>0</code>表示段界限的单位是<code>1</code>字节，若<strong>G</strong>为<code>1</code>表示段界限的单位是<code>4KB</code>。</li></ul><p><strong>段选择子</strong>: 保护模式下段寄存器中存储的就是段选择子，选择子是一个索引值，用此索引值在段描述符表中索引相应的段描述符，这样，便可以在段描述符中得到了内存段的起始地址和段界限值等相关信息。</p><p>如下，段选择子结构示意参考，以及每个字段的大体含义。</p><img src="/doc/483bf2e0/1379525-20220725145713025-788873539.png" srcset="/img/loading.gif" lazyload class=""><p>由于段寄存器是<code>16</code>位，所以选择子也是<code>16</code>位，每一个选择子都会被分为<code>3</code>块。</p><ul><li>RPL字段:第<code>0-1</code>位，用来存储<strong>RPL</strong>(请求特权级) 通常为<code>0、1、2、3</code>四种特权级。</li><li>TI字段:第<code>2</code>位，用来指示选择子是在<strong>GDT</strong>还是<strong>LDT</strong>中索引描述符，为<code>0</code>在<strong>GDT</strong>中，为<code>1</code>在<strong>LDT</strong>中。</li><li>描述符索引:第<code>3-15</code>位是描述符的索引值，此值主要用于在<strong>GDT</strong>中索引符合条件的段描述符。</li></ul><p>选择子的作用主要是确定段描述符，确定描述符的目的，一是为了特权级、界限等安全考虑，最主要的还是要确定段的基地址。</p><p>由于保护模式下段寄存器中已经默认是选择子了，在寻址时直接用选择子对应的<code>[段描述符中的段基址+段内偏移地址]</code>就是要访问的内存地址。</p><h3 id="A20Gate地址回绕线"><a href="#A20Gate地址回绕线" class="headerlink" title="A20Gate地址回绕线"></a>A20Gate地址回绕线</h3><p>地址回绕线是为了兼容8086实模式而增加的，在实模式下地址线只有<code>20</code>条，寻址空间只能是<code>1MB(0x00000 - 0xFFFFF)</code>如果超出<code>1MB</code>的寻址范围，那么在默认开启地址回绕的<strong>CPU</strong>上，会自动将超出<code>1MB</code>的部分回绕到<code>0</code>地址处，继续从<code>0</code>地址处开始映射，地址回绕如下图。</p><img src="/doc/483bf2e0/1379525-20220725145727844-2139804549.png" srcset="/img/loading.gif" lazyload class=""><p>对于只有<code>20</code>位地址线的8086系列<strong>CPU</strong>而言，<code>A20</code>地址线默认是开启的，不需要任何操作即可实现地址回绕，但80286有 <code>24</code> 条地址线，即<code>A0-A23</code>，也就是说 <code>A20</code> 地址线是开启的，如果访问<code>0x100000-0x10FFEF</code>之间的内存，系统将直接访问这块物理内存，并不会像8086那样回绕到<code>0</code>，反之如果是关闭的，则访问超出<code>0x00000 - 0xfffff</code>的地址范围后会自动回绕到<code>0</code>处。</p><blockquote><p>如果A20Gate被打开，当访问到<code>0x100000-0x10FFEF</code>之间的地址时，CPU将真正访问这块物理内存。<br>如果A20Gate被禁止，当访问<code>0x100000-0x10FFEF</code>之间的地址时，CPU将采用8086的地址回绕。</p></blockquote><p>我们想进入保护模式，就需要突破第<code>20</code>条地址线（<code>A20</code>）去访问更大的内存空间。而这一切，只有关闭了地址回绕才能实现，而关闭地址回绕，就需要打开<strong>A20Gate</strong>，打开<strong>A20Gate</strong>地址线只需要将端口<code>0x92</code>的第<code>1</code>位置<code>1</code>即可。</p><h3 id="CR0控制寄存器"><a href="#CR0控制寄存器" class="headerlink" title="CR0控制寄存器"></a>CR0控制寄存器</h3><p>想要进入保护模式还差最后一步，通过控制<strong>CR</strong>系列寄存器切换<strong>CPU</strong>模式，<strong>CR</strong>寄存器是<strong>CPU</strong>的控制窗口，即可用来查询<strong>CPU</strong>的内部状态，也可用于直接控制<strong>CPU</strong>的运行机制，切入保护模式最需要关注的是<strong>CR0</strong>寄存器中的<strong>PE</strong>位。</p><p>如下图是完整的<strong>CR0</strong>寄存器,以及重要寄存器解释:</p><img src="/doc/483bf2e0/1379525-20220725145737505-1002718591.png" srcset="/img/loading.gif" lazyload class=""><ul><li><strong>保护允许位PE (Protedted Enable)</strong>:<code>0</code>位用于启动保护模式，如果<strong>PE</strong>置<code>1</code>则保护模式启动，<strong>PE</strong>置<code>0</code>则实模式启用。</li><li><strong>监控协处理位MP (Moniter coprocessor)</strong>:<code>1</code>位与<code>3</code>位配合，当<code>TS=1</code>时操作码<code>WAIT</code>是否产生一个协处理器不能使用的出错信号。</li><li><strong>任务转换位TS (Task Switch)</strong>:<code>3</code>位当一个任务转换完成之后，自动将它置<code>1</code>，随着<code>TS=1</code>就不能使用协处理器。</li><li><strong>模拟协处理器位EM (Emulate coprocessor)</strong>:<code>2</code>位如果<code>EM=1</code>则不能使用协处理器，如果<code>EM=0</code>则允许使用协处理器。</li><li><strong>微处理器扩展类型位ET (Processor Extension Type)</strong>:<code>4</code>位保存着处理器扩展类型的信息，如果<code>ET=0</code>使用287协处理器，<code>ET=1</code>使用387浮点协处理器。</li><li><strong>写保护位WP</strong>:<code>16</code>位这一位置<code>0</code>就可以禁用写保护，置<code>1</code>则可恢复写保护。</li><li><strong>分页允许位PE (Paging Enable)</strong>:<code>31</code>位表示芯片上的分页部件是否允许工作。</li></ul><h3 id="正式切入保护模式"><a href="#正式切入保护模式" class="headerlink" title="正式切入保护模式"></a>正式切入保护模式</h3><p>在保护模式中，内存段都是平坦模式，也就是整个内存都在一个段内，进入保护模式之前我们需要手动在内存中构建出<strong>GDT</strong>及其内部的描述符，<strong>GDT</strong>只是一片内存区域，里面每隔<code>8</code>字节即是一个段描述符，<strong>GDT</strong>结构如下。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">GDT_BASE:   dd    0x00000000    dd    0x00000000CODE_DESC:  dd    0x0000FFFF    dd    DESC_CODE_HIGH4DATA_STACK_DESC:  dd    0x0000FFFF dd    DESC_DATA_HIGH4VIDEO_DESC: dd    0x80000007                  ; limit&#x3D;(0xbffff-0xb8000)&#x2F;4k&#x3D;0x7   dd    DESC_VIDEO_HIGH4             ; 此时dpl已改为0GDT_SIZE    equ   $ - GDT_BASEGDT_LIMIT   equ   GDT_SIZE -1 times 60 dq 0          ; 预留60个描述符的slotSELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)&#x2F;8 + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0     ; 同上SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0     ; 同上 ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址gdt_ptr  dw  GDT_LIMIT       dd  GDT_BASE</code></pre></div></figure><p><strong>GDT</strong>中的每个描述符简单介绍.</p><ul><li><strong>GDT_BASE</strong>:构建<strong>GDT</strong>的起始地址(此位是<code>0</code>位,不可用,所以直接填充为全<code>0</code>即可)</li><li><strong>CODE_DESC&#x2F;DATA_STACK_DESC&#x2F;VIDEO_DESC</strong>:代码段描述符,数据段和栈段描述符,显存描述符</li><li><strong>GDT_SIZE&#x2F;GDT_LIMIT</strong>:计算出<strong>GDT</strong>大小**,GDT_LIMIT<strong>得到段界限,为后续加载</strong>GDT**做准备.</li><li><strong>SELECTOR_CODE&#x2F;SELECTOR_DATA&#x2F;SELECTOR_VIDEO</strong>:分别构建代码段,数据段,显存段的选择子.</li><li><code>gdt_ptr</code>:定义<strong>GDT</strong>指针,此指针是<code>lgdt</code>加载<strong>GDT</strong>到<code>gdtr</code>寄存器用的.</li></ul><p>接下来就是进入保护模式，进入保护模式需要三步:</p><ol><li>打开<strong>A20</strong></li><li>加载<strong>GDT</strong></li><li><strong>CR0</strong>第<code>0</code>位置<code>1</code></li></ol><p>代码如下。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">in al,0x92or al,0000_0010Bout 0x92,allgdt [gdt_ptr]mov eax, cr0or eax, 0x00000001mov cr0, eax</code></pre></div></figure><p>最后还需要使用<code>jmp SELECTOR_CODE:p_mode_start</code>指令来实现刷新流水线。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">   jmp  SELECTOR_CODE:p_mode_start[bits 32]p_mode_start:   mov ax, SELECTOR_DATA   jmp $</code></pre></div></figure><p>流水线是<strong>CPU</strong>为了提高执行效率而发展起来的加速技术，通常执行指令需要经过取指令，译码，执行指令，等操作，而运用流水线技术则将当前指令及其后面的几条指令同时放在流水线中重叠执行。</p><p>由于实模式是<code>16</code>位的，而保护模式是<code>32</code>位，在切换时必须要清空当前流水线上面所有的<code>16</code>位指令集，以及错误的段属性，只有这样才能保证后面的<code>32</code>位指令能够被正确的执行。</p><p>此时我们既要改变代码段描述符缓冲寄存器的值，又要清空以前的流水线，使用<code>JMP</code>指令则可以达到这两种效果，<code>JMP</code>指令在执行无条件跳转时会自动的将所有段寄存器初始化并清空当前流水线上的指令集。</p><img src="/doc/483bf2e0/1379525-20220725145751733-1331411504.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>引导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BouncyCastle的使用</title>
    <link href="/doc/c20cb394.html"/>
    <url>/doc/c20cb394.html</url>
    
    <content type="html"><![CDATA[<p>Bouncy Castle 是用于 Java 和 C# 的最广泛使用的开源加密 API 之一。它实现了涵盖主要安全领域的一整套资源，包括密码学、公钥基础设施、数字签名、身份验证和安全通信。 对于需要高水平保证和合规性的用户，还有适用于<br>Java 和 C# 的 API 的 FIPS 认证版本。</p><span id="more"></span><h2 id="它有什么功能？"><a href="#它有什么功能？" class="headerlink" title="它有什么功能？"></a>它有什么功能？</h2><p>Bouncy Castle 项目提供了一组库，涵盖了核心加密原语，例如密码、密钥传输、密钥协商、MAC、消息摘要和签名以及更高级别的协议。</p><img src="/doc/c20cb394/Bouncy+Castle+Overview.png" srcset="/img/loading.gif" lazyload class=""><p>密码的示例包括国家标准，例如 AES、ARIA、Camellia 和 SM3。签名算法包括基于椭圆曲线 (EC)、爱德华兹曲线、DSA 和 RSA 的算法。除了 RSA 和 EC 之外，还为密钥传输和密钥协商提供了额外的公钥算法，例如<br>ElGamal 和 Diffie-Hellman。支持NIST 标准 MAC 算法，例如 CMAC、 HMAC 以及较新的 KMAC，以及 SHA-2 系列摘要、SHA-3 系列（包括<br>SHAKE128&#x2F;SHAKE256）以及其他摘要算法，例如作为 Whirlpool、RIPEMD 和 Tiger，以及 Blake2 和 Blake3。</p><p>为涉及 CRMF、CMC、CMP、EST 和 PKCS#10 的 X.509 证书生成和处理提供了高级 API。还有一些 API 用于支持其他协议，例如 CMS、DANE、PEM、S&#x2F;MIME、时间戳协议和 OpenPGP。传输层安全性 (<br>TLS) API 以及 Java 的 JSSE 提供程序也可用，并提供高达 TLS 1.3 的支持，以及 PSK 和 SRP 扩展。</p><p>有关 Bouncy Castle 的功能和支持的概述，请参阅官方的<a href="https://doc.primekey.com/bouncycastle/interoperability">互操作性</a>。</p><h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>任何证书或认证请求的起点都是密钥对，使用 JCA（Java 密码体系结构）创建密钥对非常简单，一般使用 KeyPairGenerator 类完成。 需要确认的是要使用何种算法和参数，下面描述两个比较常见的算法：RSA、EC。</p><p><strong>注：非对称加密公钥的安全性与对称加密是不同的：3072Bit的RSA密钥与128Bit的AES密钥一样安全，同样256Bit的EC密钥也是如此。</strong></p><h4 id="RSA密钥对"><a href="#RSA密钥对" class="headerlink" title="RSA密钥对"></a>RSA密钥对</h4><p>下面方法用于生成2048Bit的RSA密钥。采用<code>RSAKeyGenParameterSpec</code>封装密钥所需的大小和公共指数。 当前使用的<code>RSAKeyGenParameterSpec.F4</code><br>是指费马素数是第四个（费马素数从0开始计算），它的实际值是<code>0x10001</code>（即65537）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static KeyPair generateRSAKeyPair() throws GeneralSecurityException &#123;    KeyPairGenerator  kpGen &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;, &quot;BC&quot;);    kpGen.initialize(new RSAKeyGenParameterSpec(2048, RSAKeyGenParameterSpec.F4));    return kpGen.generateKeyPair();&#125;</code></pre></div></figure><p>根据你的操作，可以看出公共指数最少为<code>F4</code>或更大。</p><p><code>RSAKeyGenParameterSpec</code>还提供<code>F0</code>(0x3) 作为选项。但是强烈建议不要使用<code>F0</code>。 就安全强度而言，2048Bit密钥相当于112位的安全性，这是目前密钥对的最低使用要求。</p><h4 id="EC密钥对"><a href="#EC密钥对" class="headerlink" title="EC密钥对"></a>EC密钥对</h4><p>EC 密钥对从所使用的曲线参数中获取其密钥大小。例如，<code>P-256</code> 将在 EC 域中生成有效大小为 256 位的密钥。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static KeyPair generateECKeyPair() throws GeneralSecurityException &#123;    KeyPairGenerator  kpGen &#x3D; KeyPairGenerator.getInstance(&quot;EC&quot;, &quot;BC&quot;);    kpGen.initialize(new ECGenParameterSpec(&quot;P-256&quot;));    return kpGen.generateKeyPair();&#125;</code></pre></div></figure><p>EC 对于密钥协商和签名都是有用的算法。吸引力在于相对较短的钥匙尺寸。基于 P-521 曲线的密钥，其安全性超过 256 位，比需要模数至少为 15360 位的等效 RSA 密钥小得多。</p><h3 id="生成认证请求"><a href="#生成认证请求" class="headerlink" title="生成认证请求"></a>生成认证请求</h3><p>认证请求的作用即使用本地的私钥颁发公钥证书。最早的标准形式是最初为 RSA 发布的标准形式 PKCS#10。一个更新的、通用的标准是 CRMF（证书请求消息格式）。<br>以下将仅提供请求消息的示例，因为一旦发送请求，服务器返回的内容取决于服务器。通常它是包含一个或多个证书的 CMS SignedData 消息。 尽管在 CRMF 的情况下，它也可以是 CMS EnvelopedData<br>消息，其中包含包含一个或多个证书的加密 CMS SigneData 消息。</p><blockquote><p>PKCS10 和 CRMF 消息类都支持返回类的 ASN.1 编码版本的 <code>getEncoded()</code> 方法。<br>您还可以将 ASN.1 编码版本传递给两个类的 <code>byte[]</code> 构造函数。</p></blockquote><h4 id="生成-PKCS10-认证请求"><a href="#生成-PKCS10-认证请求" class="headerlink" title="生成 PKCS10 认证请求"></a>生成 PKCS10 认证请求</h4><p>PKCS10 格式最初被设计为一个标准，考虑到 RSA 的“特性”：RSA 密钥对可用于签名和加密，而签名只是使用私钥的加密操作。这种双重用途（用于签名和加密）实际上并不是一个好主意，因为它会破坏私钥的安全性。</p><p>许多标准（例如 FIPS）现在明确禁止在一般用途中双重使用，一个例外是使用 PKCS10 创建认证请求。原因是 PKCS10 的设计理念是所有权证明的主要机制是签名验证。 创建 PKCS10<br>请求主要涉及指定您希望最终证书关联的身份，然后对包含该信息的结构进行签名。这个想法是，如果随附的公钥可以在证书颁发机构 (CA) 稍后查看请求时验证签名，则必须使用相应的私钥对结构进行签名。 PKCS10<br>结构也允许一些可选数据，例如证书扩展。以下代码示例生成一个基本的 PKCS10 请求。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PKCS10CertificationRequest createPKCS10(    KeyPair keyPair, String sigAlg) throws OperatorCreationException &#123;    X500Name subject &#x3D; new X500Name(&quot;CN&#x3D;Example&quot;);    PKCS10CertificationRequestBuilder requestBuilder            &#x3D; new JcaPKCS10CertificationRequestBuilder(                                    subject, keyPair.getPublic());    ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)                            .setProvider(&quot;BC&quot;).build(keyPair.getPrivate());    return requestBuilder.build(signer);&#125;</code></pre></div></figure><p>您可以使用前面显示的示例代码来创建密钥对。两者都可以作为 RSA 和 EC 支持签名。我们建议对 RSA 和 SHA256withECDSA 尝试算法 SHA256withRSA。</p><p>请注意，指定名称后，会使用传入的密钥对中提供的私钥创建 ContentSigner，然后使用 ContentSigner 构建包含该名称的请求。</p><p>通过在请求正文中包含属性，将可选数据添加到 PKCS10 认证请求。以下示例代码显示了如何通过添加请求以在 CA 将颁发的证书中包含 SubjectAlternativeName 扩展来向认证请求添加电子邮件地址。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PKCS10CertificationRequest createPKCS10WithExtensions(        KeyPair keyPair, String sigAlg) throws OperatorCreationException, IOException &#123;    X500Name subject &#x3D; new X500Name(&quot;CN&#x3D;Example&quot;);    PKCS10CertificationRequestBuilder requestBuilder            &#x3D; new JcaPKCS10CertificationRequestBuilder(                                        subject, keyPair.getPublic());    ExtensionsGenerator extGen &#x3D; new ExtensionsGenerator();    extGen.addExtension(Extension.subjectAlternativeName, false,            new GeneralNames(                    new GeneralName(                            GeneralName.rfc822Name,                            &quot;example@primekey.com&quot;)));    Extensions extensions &#x3D; extGen.generate();    requestBuilder.addAttribute(            PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensions);    ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)                            .setProvider(&quot;BC&quot;).build(keyPair.getPrivate());    return requestBuilder.build(signer);&#125;</code></pre></div></figure><p>这是包含电子邮件地址的“正确”方式，尽管您会看到它们包含在构成主题的 X.500 名称中。请注意，第一个示例和这个示例之间的唯一区别是添加了生成扩展的代码和添加 ExtensionRequest 属性的代码。</p><h4 id="生成-CRMF-认证请求"><a href="#生成-CRMF-认证请求" class="headerlink" title="生成 CRMF 认证请求"></a>生成 CRMF 认证请求</h4><p>CRMF，（在RFC 4211)，解决所有权证明的问题，或者用 RFC 的语言来说，所有权证明 (POP)，与 PKCS10 略有不同。它允许签名，但也允许加密和密钥协议。</p><p>第一个示例可能是与PKCS10 示例最简单的等效示例。该示例假定一个可以创建和验证签名的算法。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static byte[] generateRequestWithPOPSig(BigInteger certReqID, KeyPair kp, String sigAlg) throws CRMFException, IOException, OperatorCreationException &#123;    X500Name subject &#x3D; new X500Name(&quot;CN&#x3D;Example&quot;);    JcaCertificateRequestMessageBuilder certReqBuild        &#x3D; new JcaCertificateRequestMessageBuilder(certReqID);    certReqBuild        .setPublicKey(kp.getPublic())        .setSubject(subject)        .setProofOfPossessionSigningKeySigner(            new JcaContentSignerBuilder(sigAlg)                .setProvider(&quot;BC&quot;)                .build(kp.getPrivate()));    return certReqBuild.build().getEncoded();&#125;</code></pre></div></figure><p>certReqId 只需要是一个唯一的整数，以便发送者可以匹配返回到发送的请求的响应。</p><p>在某些方面，就功能内容而言，上述示例之间唯一真正的区别是证书请求 ID 的存在，它只是证书请求者指定的整数值，并在证书响应中回显以允许证书请求者可能需要多个证书。除此之外，您可以使用之前建议的相同算法以及所需的密钥类型。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">The following example shows how to create a CRMF certification request using encryption for the POP.&#x2F;** * Basic example for generating a CRMF certificate request with POP for * an encryption only algorithm like ElGamal. * * @param certReqID identity (for the client) of this certificate request. * @param kp key pair whose public key we are making the request for. *&#x2F;public static byte[] generateRequestWithPOPEnc(BigInteger certReqID, KeyPair kp) throws CRMFException, IOException &#123;    X500Name subject &#x3D; new X500Name(&quot;CN&#x3D;Example&quot;);    JcaCertificateRequestMessageBuilder certReqBuild        &#x3D; new JcaCertificateRequestMessageBuilder(certReqID);    certReqBuild        .setPublicKey(kp.getPublic())        .setSubject(subject)        .setProofOfPossessionSubsequentMessage(SubsequentMessage.encrCert);    return certReqBuild.build().getEncoded();&#125;</code></pre></div></figure><p>为此，您需要使用 RSA。所有权证明步骤实际上是在 CA 的响应中。在这种情况下，CA 将发回一个加密的证书，如果请求者希望能够使用它，他们需要先对其进行解密。</p><p>在加密 POP 的情况下，证书将以 EnvelopedData 结构包装返回，私钥是支持 RecipientInfo 结构所需的密钥，该结构包含用于加密包含所请求证书的消息的对称密钥。</p><h4 id="使用-CMP-生成-CRMF-认证请求"><a href="#使用-CMP-生成-CRMF-认证请求" class="headerlink" title="使用 CMP 生成 CRMF 认证请求"></a>使用 CMP 生成 CRMF 认证请求</h4><p>CRMF 消息需要包装在另一个协议中，例如证书管理协议 (CMP)。CMP 消息还包括消息发送者的附加字段，有时与证书主题字段表示的实体不同。在这种情况下，CRMF 消息可能会作为“RA 验证”发送，这意味着发送者将保证请求的真实性，而 CMP 消息可能会使用共享密钥进行验证。</p><p>以下方法显示了为“RA 验证”设置的基本认证请求消息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static byte[] generateRequestWithPOPRA(BigInteger certReqID, KeyPair kp) throws CRMFException, IOException, OperatorCreationException &#123;    X500Name subject &#x3D; new X500Name(&quot;CN&#x3D;Example&quot;);    JcaCertificateRequestMessageBuilder certReqBuild        &#x3D; new JcaCertificateRequestMessageBuilder(certReqID);    certReqBuild        .setPublicKey(kp.getPublic())        .setSubject(subject)        .setProofOfPossessionRaVerified();    return certReqBuild.build().getEncoded();&#125;</code></pre></div></figure><p>请注意，除了使用不同的 POP 方法外，它与前面的示例相同。</p><p>接下来，在将消息发送到 CA 之前，您需要对消息进行包装，以便拥有适合您正在使用的 CMP 服务的内容。</p><p>以下代码将包装您返回的 CRMF 消息，并在给定发件人和收件人的情况下生成 ProtectedPKIMessage:</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static ProtectedPKIMessage generatMacProtectedMessage(    X500Name sender, X500Name recipient,    byte[] senderNonce,    CertificateRequestMessage crmfMessage,    char[] password)    throws CRMFException, CMPException&#123;    return new ProtectedPKIMessageBuilder(new GeneralName(sender), new GeneralName(recipient))                    .setMessageTime(new Date())                    .setSenderNonce(senderNonce)                    .setBody(new PKIBody(PKIBody.TYPE_INIT_REQ, new CertReqMessages(crmfMessage.toASN1Structure())))                    .build(new PKMACBuilder(new JcePKMACValuesCalculator().setProvider(&quot;BC&quot;)).build(password));&#125;</code></pre></div></figure><p>有关使用 EJBCA 的特定示例，请参阅证书和 CRL 生成。以下代码片段显示了如何将不同的消息放在一起以及构建它们需要什么：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">SecureRandom random &#x3D; new SecureRandom();BigInteger certReqId &#x3D; BigInteger.valueOf(System.currentTimeMillis());KeyPair keyPair &#x3D; KeyPairGeneratorExamples.generateECKeyPair();byte[] senderNonce &#x3D; new byte[16];random.nextBytes(senderNonce);CertificateRequestMessage certReqMsg &#x3D; new CertificateRequestMessage(        CRMFExamples.generateRequestWithPOPRA(certReqId, keyPair));X500Name sender &#x3D; new X500Name(&quot;CN&#x3D;Cert Requester&quot;);X500Name recipient &#x3D; new X500Name(&quot;CN&#x3D;Certificate Issuer&quot;);ProtectedPKIMessage pkiMessage &#x3D; generatMacProtectedMessage(sender, recipient, senderNonce, certReqMsg, &quot;secret&quot;.toCharArray());</code></pre></div></figure><p>这表明处理这些协议的复杂性更多地在于知道参数值是什么，而不是实际的 API 调用。</p><p>请注意，代码示例使用与您要为其创建证书的 CRMF 请求中使用的主题不同的发件人。由于您希望 CA 根据您的话颁发证书，因此使用共享密钥验证请求，该密钥可用于计算 MAC。这在客户端应用程序可能为多个实体颁发证书的情况下是有意义的。在客户端应用程序不同时生成私钥的情况下，应使用确认最终使用证书的实体拥有私钥的其他 POP 模式之一。</p><p>如果需要，还可以对 ProtectedPKIMessages 进行签名。</p><p>Bouncy Castle 包含一个 ASN1Dump 类，可用于转储 ASN.1 对象树。如果您有编码的，请先调用 ASN1Primitive.fromByteArray()。</p><h3 id="生成证书和-CRL"><a href="#生成证书和-CRL" class="headerlink" title="生成证书和 CRL"></a>生成证书和 CRL</h3><h4 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h4><p>使用的标准的原始名称是 X.509，证书和 CRL 的生命周期有限，因此第一个实用程序方法只允许创建一个 Date 对象，该对象表示未来某个特定小时数的某个时间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Calculate a date in seconds (suitable for the PKIX profile - RFC 5280) * * @param hoursInFuture hours ahead of now, may be negative. * @return a Date set to now + (hoursInFuture * 60 * 60) seconds *&#x2F;public static Date calculateDate(int hoursInFuture)&#123;  long secs &#x3D; System.currentTimeMillis() &#x2F; 1000;  return new Date((secs + (hoursInFuture * 60 * 60)) * 1000);&#125;</code></pre></div></figure><p>证书也有序列号。证书颁发者不应颁发两个具有相同序列号的证书。有多种计算序列号的方法，以下示例显示了使用当前时间初始化的 long 递增。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static long serialNumberBase &#x3D; System.currentTimeMillis();&#x2F;** * Calculate a serial number using a monotonically increasing value. * * @return a BigInteger representing the next serial number in the sequence. *&#x2F;public static synchronized BigInteger calculateSerialNumber()&#123;  return BigInteger.valueOf(serialNumberBase++);&#125;</code></pre></div></figure><p>我们通常识别为识别机器、个人或其他不同“事物”的证书通常从证书链或证书路径中获得其权威出处，从而导致证书提供身份。在这个链的另一端是一个信任锚，一个必须以面值接受的证书才能被接受。</p><p>以下示例代码生成一个从现在到 365 天有效的信任锚。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static X509Certificate createTrustAnchor(  KeyPair keyPair, String sigAlg)  throws OperatorCreationException, CertificateException&#123;  X500Name name &#x3D; new X500Name(&quot;CN&#x3D;Trust Anchor&quot;);  X509v1CertificateBuilder certBldr &#x3D; new JcaX509v1CertificateBuilder(    name,    calculateSerialNumber(),    calculateDate(0),    calculateDate(24 * 365),    name,    keyPair.getPublic());  ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)    .setProvider(&quot;BC&quot;).build(keyPair.getPrivate());  JcaX509CertificateConverter converter &#x3D; new JcaX509CertificateConverter().setProvider(&quot;BC&quot;);  return converter.getCertificate(certBldr.build(signer));&#125;</code></pre></div></figure><p>该证书是自签名的，因为它是代表建立信任的东西的证书，所以需要依靠密码学以外的东西来赋予它权限。</p><p>示例代码生成版本 1 证书，最初信任锚始终是版本 1 证书。如今，使用版本 3 证书更为常见，因此可以提供最大路径长度和其他约束，从而允许信任锚的相应私钥持有者对信任锚证书的使用保持一定的控制权。下一部分概述了版本 3 证书和扩展。</p><p>信任锚本身通常不足以开始颁发识别个人的证书。由于信任锚是必须从表面上接受的一件事，因此部署它们通常需要做一些工作，并且您希望将私钥锁定并很少使用。因此，在信任锚和最终实体证书之间通常存在一个或多个证书颁发机构 (CA)证书。最终实体证书是我们通常与个人、电子邮件地址或网站相关联的证书。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static X509Certificate createCACertificate(  X509Certificate signerCert, PrivateKey signerKey,  String sigAlg, PublicKey certKey, int followingCACerts)  throws GeneralSecurityException,  OperatorCreationException, CertIOException&#123;  X500Principal subject &#x3D; new X500Principal(&quot;CN&#x3D;Certificate Authority&quot;);  X509v3CertificateBuilder certBldr &#x3D; new JcaX509v3CertificateBuilder(      signerCert.getSubjectX500Principal(),      calculateSerialNumber(),      calculateDate(0),      calculateDate(24 * 60),      subject,      certKey);  JcaX509ExtensionUtils extUtils &#x3D; new JcaX509ExtensionUtils();  certBldr.addExtension(Extension.basicConstraints,          true, new BasicConstraints(followingCACerts))      .addExtension(Extension.keyUsage,          true, new KeyUsage(KeyUsage.keyCertSign                    | KeyUsage.cRLSign));  ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)      .setProvider(&quot;BC&quot;).build(signerKey);  JcaX509CertificateConverter converter &#x3D; new JcaX509CertificateConverter().setProvider(&quot;BC&quot;);  return converter.getCertificate(certBldr.build(signer));&#125;</code></pre></div></figure><p>在此示例中，使用的构建器是版本 3 证书的构建器。使用版本 3 构建器的主要原因是利用扩展。扩展很有用，因为它们为证书颁发者提供了一种机制来描述他们希望如何使用他们正在签名的主题的公钥。</p><p>示例中使用了两个扩展：</p><ul><li>第一个扩展由 BasicConstraints 类表示，用于确定此证书是否为 CA 证书以及链中可以跟随多少个 CA 证书（0 表示链以链中的下一个证书结束）。</li><li>第二个扩展由 KeyUsage 类表示，并指定证书中的公钥可以用于什么。在这种情况下，扩展程序表示它可以用于签署其他证书和&#x2F;或签署证书撤销列表 (CRL)（请参阅证书撤销）。</li></ul><p>请注意，(true)也使用布尔值。此标志是“isCritical”标志，它告诉任何查看证书的人是否必须由寻求使用证书的人理解特定扩展。在这种情况下，通过将两个扩展的标志都设置为 true，颁发者告诉任何无法理解BasicConstraints和KeyUsage扩展是什么的人，他们不应该尝试使用证书。</p><h4 id="实体证书"><a href="#实体证书" class="headerlink" title="实体证书"></a>实体证书</h4><p>证书路径中的最后一个证书是最终实体证书。在证书路径的普通解释中，最终实体证书通常是您尝试使用并需要验证的证书。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static X509Certificate createEndEntity(    X509Certificate signerCert, PrivateKey signerKey,    String sigAlg, PublicKey certKey)  throws CertIOException, OperatorCreationException, CertificateException&#123;  X500Principal subject &#x3D; new X500Principal(&quot;CN&#x3D;End Entity&quot;);  X509v3CertificateBuilder  certBldr &#x3D; new JcaX509v3CertificateBuilder(      signerCert.getSubjectX500Principal(),      calculateSerialNumber(),      calculateDate(0),      calculateDate(24 * 31),      subject,      certKey);  certBldr.addExtension(Extension.basicConstraints,          true, new BasicConstraints(false))      .addExtension(Extension.keyUsage,          true, new KeyUsage(KeyUsage.digitalSignature));  ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)                  .setProvider(&quot;BC&quot;).build(signerKey);  JcaX509CertificateConverter converter &#x3D; new JcaX509CertificateConverter().setProvider(&quot;BC&quot;);  return converter.getCertificate(certBldr.build(signer));&#125;</code></pre></div></figure><p>该代码类似于 CA 证书的代码，但具有不同的扩展值。最重要的区别是BasicConstraints简单地用布尔值调用构造函数的值false.这告诉任何查看证书的人它不能用作 CA 证书。false 值告诉观察者该证书是路径的结尾，并且后面不能有任何其他证书。</p><h4 id="其他常见扩展"><a href="#其他常见扩展" class="headerlink" title="其他常见扩展"></a>其他常见扩展</h4><p>扩展经常出现在所有 X.509 结构中。扩展提供了一种简单的统一机制来包含现有标准甚至是内部专有标准所涵盖的附加信息。两个很好的例子是主题密钥 ID 扩展和授权密钥 ID 扩展。</p><p>主题密钥 ID 扩展允许您将简单的八位字节字符串（由 ASN.1 类型 SubjectKeyIdentifier 表示）与您的证书相关联。通常，此值是根据证书包含的公钥的 SHA-1 哈希计算的。在 Bouncy Castle 中，您可以按如下方式创建 SubjectKeyIdentier：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static SubjectKeyIdentifier createSubjectKeyIdentifier(PublicKey key)  throws NoSuchAlgorithmException&#123;  JcaX509ExtensionUtils extUtils &#x3D; new JcaX509ExtensionUtils();  return extUtils.createSubjectKeyIdentifier(key);&#125;&#x2F;&#x2F;And you can include it in your certificate using the following code:certBldr.addExtension(Extension.subjectKeyIdentifier,          false, createSubjectKeyIdentifier(certKey))</code></pre></div></figure><p>减少的哈希值总是比其相应的证书小得多，并且您会在各种 PKIX 协议中找到包含主题密钥 ID 而不是整个证书或仅包含公钥的位置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static AuthorityKeyIdentifier createAuthorityKeyIdentifier(X509Certificate issuer)  throws NoSuchAlgorithmException, CertificateEncodingException&#123;  JcaX509ExtensionUtils extUtils &#x3D; new JcaX509ExtensionUtils();  return extUtils.createAuthorityKeyIdentifier(issuer);&#125;</code></pre></div></figure><h4 id="使用-PKCS10-请求证书"><a href="#使用-PKCS10-请求证书" class="headerlink" title="使用 PKCS10 请求证书"></a>使用 PKCS10 请求证书</h4><p>通过使用 Bouncy Castle 创建证书签名请求，您现在可以从“真实” CA获得“真实”证书。</p><p>首先，您需要创建一个包含最终实体配置文件所需信息的 CSR。然后，将 CSR 包装在 JSON 中，并通过相互验证的 TLS 连接将其发送到 EJBCA。使用存储在 P12 文件中的客户端证书并使用 Java 中包含的工具来处理它。</p><p>下面显示了一个使用 Google GSON 和 Apache 的 HTTP 客户端的代码示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static KeyPair generateKeyPair() throws Exception &#123;  final KeyPairGenerator keyPairGenerator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;, BouncyCastleProvider.PROVIDER_NAME);  keyPairGenerator.initialize(2048);  return keyPairGenerator.generateKeyPair();&#125; private static PKCS10CertificationRequest generateCsr(final KeyPair keyPair) throws Exception &#123;  final X500Name subjectDN &#x3D; new X500NameBuilder(BCStyle.INSTANCE)      .addRDN(BCStyle.CN, CN)      .build();  final ExtensionsGenerator extensionsGenerator &#x3D; new ExtensionsGenerator();  extensionsGenerator.addExtension(Extension.subjectAlternativeName, false, new GeneralNames(new GeneralName(GeneralName.dNSName, &quot;pki-at-the-edge.com&quot;)));  return new JcaPKCS10CertificationRequestBuilder(subjectDN, keyPair.getPublic())    .addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate())    .build(      new JcaContentSignerBuilder(&quot;SHA256withRSA&quot;)        .build(keyPair.getPrivate()));&#125; private static void sendCsrToEjbcaAndGetCertificate(final PKCS10CertificationRequest csr) throws Exception &#123;  final KeyStore keyStore &#x3D; KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);  keyStore.load(new ByteArrayInputStream(Base64.decode(KEYSTORE)), &quot;foo123&quot;.toCharArray());  final Map&lt;String, Object&gt; jsonMap &#x3D; new HashMap&lt;&gt;();  jsonMap.put(&quot;certificate_request&quot;,    &quot;-----BEGIN CERTIFICATE REQUEST-----\n&quot; +    new String(Base64.encode(csr.getEncoded())) + &quot;\n&quot; +    &quot;-----END CERTIFICATE REQUEST-----&quot;);  jsonMap.put(&quot;certificate_profile_name&quot;, &quot;Workshop Certificate&quot;);  jsonMap.put(&quot;end_entity_profile_name&quot;, &quot;Workshop Certificate&quot;);  jsonMap.put(&quot;certificate_authority_name&quot;, &quot;Bouncy Castle Test CA&quot;);  &#x2F;&#x2F; This user will be created when requesting a certificate from EJBCA  jsonMap.put(&quot;username&quot;, CN);  jsonMap.put(&quot;password&quot;, &quot;foo123&quot;);  jsonMap.put(&quot;include_chain&quot;, false);  final SSLContext sslContext &#x3D; SSLContexts.custom()    .loadKeyMaterial(keyStore, &quot;foo123&quot;.toCharArray())    .build();  final HttpClient httpClient &#x3D; HttpClients.custom()    .setSSLContext(sslContext)    .build();  final HttpPost httpPost &#x3D; new HttpPost(URL);  final StringEntity entity &#x3D; new StringEntity(new GsonBuilder().create().toJson(jsonMap));  httpPost.setEntity(entity);  httpPost.setHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);  httpPost.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json&quot;);  out.println(&quot;Posting the following payload to &quot; + URL + &quot;: &quot; + System.lineSeparator() + new GsonBuilder().setPrettyPrinting().create().toJson(jsonMap));  final HttpResponse response &#x3D; httpClient.execute(httpPost);  out.println(&quot;Received the following response from EJBCA:&quot; + System.lineSeparator() + EntityUtils.toString(response.getEntity()));&#125;</code></pre></div></figure><h4 id="使用-CRMF-申请证书"><a href="#使用-CRMF-申请证书" class="headerlink" title="使用 CRMF 申请证书"></a>使用 CRMF 申请证书</h4><p>要在 EJBCA 中使用 CRMF 请求证书，您必须使用 CMP。</p><p>密钥对生成与 PKCS#10 相同：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">final KeyPairGenerator keyPairGenerator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;, BouncyCastleProvider.PROVIDER_NAME);keyPairGenerator.initialize(2048);final KeyPair keyPair &#x3D; keyPairGenerator.generateKeyPair(); </code></pre></div></figure><p>接下来，创建一个包含 CRMF 的 CertReqMessage。然后将 CertReqMessage 包装在使用 HMAC 进行身份验证的 ProtectedPKIMessage 中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">final SecureRandom random &#x3D; new SecureRandom();final BigInteger certReqId &#x3D; BigInteger.valueOf(System.currentTimeMillis());final byte[] senderNonce &#x3D; new byte[16];random.nextBytes(senderNonce);final CertificateRequestMessage certReqMsg &#x3D; new CertificateRequestMessage(new JcaCertificateRequestMessageBuilder(certReqId)  .setPublicKey(keyPair.getPublic())  .setSubject(subjectDn)  .setProofOfPossessionRaVerified()  .build()  .getEncoded());final X500Name sender &#x3D; new X500Name(&quot;CN&#x3D;BC&quot;);final X500Name recipient &#x3D; new X500Name(&quot;CN&#x3D;Bouncy Castle Test CA&quot;);final ProtectedPKIMessage pkiMessage &#x3D; new ProtectedPKIMessageBuilder(new GeneralName(sender), new GeneralName(recipient))      .setMessageTime(new Date())      .setSenderNonce(senderNonce)      .setBody(new PKIBody(PKIBody.TYPE_INIT_REQ, new CertReqMessages(certReqMsg.toASN1Structure())))      .build(new PKMACBuilder(new JcePKMACValuesCalculator().setProvider(BouncyCastleProvider.PROVIDER_NAME)).build(hmacPassword.toCharArray()));</code></pre></div></figure><p>最后，使用 HTTP POST 将 ProtectedPKIMessage 发送到 EJBCA。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">final HttpClient httpClient &#x3D; HttpClients.createDefault();final HttpPost httpPost &#x3D; new HttpPost(URL);final ByteArrayEntity entity &#x3D; new ByteArrayEntity(pkiMessage.toASN1Structure().getEncoded());httpPost.setEntity(entity);httpPost.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;pkixcmp&quot;);final HttpResponse response &#x3D; httpClient.execute(httpPost);System.out.println(&quot;Received the following PKIMessage from EJBCA:&quot;);final PKIMessage responsePkiMessage &#x3D; PKIMessage.getInstance(ASN1Primitive.fromByteArray(EntityUtils.toByteArray(response.getEntity())));System.out.println(ASN1Dump.dumpAsString(responsePkiMessage, true));</code></pre></div></figure><h3 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h3><p>使用数字签名对证书进行身份验证确实留下了一个问题，即如果 CA 必须改变主意，它会做什么。如果在 6 个月内发生了会破坏与之相关联的私钥的事情，那么有效期为两年的证书将没有多大用处。</p><p>这就是证书撤销列表 (CRL) 的用武之地。CRL 是 CA 已撤销其批准的证书序列号列表。实际的序列号出现在 CRL 条目中，并且 CRL 条目通常包括撤销的原因。通常，CRL 将由颁发证书的同一实体签署，但在某些情况下，CA 会提名其他一些签署者代表其颁发 CRL。</p><h4 id="创建空-CRL"><a href="#创建空-CRL" class="headerlink" title="创建空 CRL"></a>创建空 CRL</h4><p>CRL 最初不需要在其中列出任何已撤销的证书。虽然以空 CRL 开头可能看起来很奇怪，但该列表还将包含有关其更新频率的信息。更新频率决定了 CA 更新 CRL 的频率，通常它是一个初始的空 CRL 来建立它。</p><p>下面显示了创建空 CRL 的基本方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static X509CRL createEmptyCRL(  PrivateKey caKey,  String sigAlg,  X509Certificate caCert)  throws IOException, GeneralSecurityException, OperatorCreationException&#123;  X509v2CRLBuilder crlGen &#x3D; new JcaX509v2CRLBuilder(caCert.getSubjectX500Principal(),      calculateDate(0));  crlGen.setNextUpdate(calculateDate(24 * 7));  &#x2F;&#x2F; add extensions to CRL  JcaX509ExtensionUtils extUtils &#x3D; new JcaX509ExtensionUtils();  crlGen.addExtension(Extension.authorityKeyIdentifier, false,      extUtils.createAuthorityKeyIdentifier(caCert));  ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)                .setProvider(&quot;BC&quot;).build(caKey);  JcaX509CRLConverter converter &#x3D; new JcaX509CRLConverter().setProvider(&quot;BC&quot;);  return converter.getCRL(crlGen.build(signer));&#125;</code></pre></div></figure><p>调用向<code>crlGen.setNextUpdate()</code>接收此 CRL 的人提供有关您计划何时发布更新的 CRL 的信息。此示例使用 7 天，但值会根据对您的应用程序有意义的情况而有所不同。</p><p>在下一个更新日期之后，用户应该知道 CRL 现在可能会提供 CA 撤销的不完整视图，并且应该在对 CA 颁发的证书做出任何决定之前获取更新的副本。</p><h4 id="添加撤销"><a href="#添加撤销" class="headerlink" title="添加撤销"></a>添加撤销</h4><p>现在您拥有一个带有已发布更新策略的 CRL，您需要向它添加撤销。</p><p>添加 CRL 条目只需将其添加到现有 CRL，然后重新生成 CRL 签名。Bouncy Castle CRL 构建器支持获取现有 CRL，然后通过添加 CRL 条目对其进行修改，如以下示例方法所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public X509CRL addRevocationToCRL(    PrivateKey caKey,    String sigAlg,    X509CRL crl,    X509Certificate certToRevoke)    throws IOException, GeneralSecurityException, OperatorCreationException&#123;  X509v2CRLBuilder crlGen &#x3D; new JcaX509v2CRLBuilder(crl);  crlGen.setNextUpdate(calculateDate(24 * 7));  &#x2F;&#x2F; add revocation  ExtensionsGenerator extGen &#x3D; new ExtensionsGenerator();  CRLReason crlReason &#x3D; CRLReason.lookup(CRLReason.privilegeWithdrawn);  extGen.addExtension(Extension.reasonCode, false, crlReason);  crlGen.addCRLEntry(certToRevoke.getSerialNumber(),                    new Date(), extGen.generate());  ContentSigner signer &#x3D; new JcaContentSignerBuilder(sigAlg)                .setProvider(&quot;BC&quot;).build(caKey);  JcaX509CRLConverter converter &#x3D; new JcaX509CRLConverter().setProvider(&quot;BC&quot;);  return converter.getCRL(crlGen.build(signer));&#125;</code></pre></div></figure><p>原因通过 CRL 条目上的扩展与 CRL 条目相关联。在这个例子中，原因是“Privilege Withdrawn”，换句话说，改变了主意。对于私钥没有被泄露但已停止使用的情况，这是一个有用的原因。例如，由于与私钥证书相关的人员离职或更换角色。在这种情况下，生成的签名可以使用在吊销之前日期的吊销证书进行验证，但仍可能被接受。另一方面，如果给出的原因是“Key Compromise”（另一个有效值），您应该小心接受任何由被撤销证书的私钥签名的表面值。</p>]]></content>
    
    
    <categories>
      
      <category>Cryptology</category>
      
      <category>Asymmetry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密</tag>
      
      <tag>非对称加密</tag>
      
      <tag>证书</tag>
      
      <tag>公钥</tag>
      
      <tag>私钥</tag>
      
      <tag>模数</tag>
      
      <tag>指数</tag>
      
      <tag>质数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA非对称加密的应用-JetBrains</title>
    <link href="/doc/73d0dc8a.html"/>
    <url>/doc/73d0dc8a.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对哦, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~">  <script id="hbeData" type="hbeData" data-hmacdigest="82cc22582a14f67ab2bf2189c61b360dfc9dba3b26b97ced171714f5afdf269a">f2c733716ff1133bbcdc1e36c076c5868f84ef26d2f862fa0ba76256b5cc718f75bf8aaf77e9ce603a94fbb254b2b7435d50f1e53d37c3f4320dd38d7433f565c91d98cd55b212a3b105217dcb74f2c38caaeea5defe2e615ddac41c58c4500fa3d607d759d7d5ce5760eeac43c92b910b0ab91d50686502253c657b4bd1d00518ad06ebf9a88f089432600960462ca23621d731b14c439f73ecbf4626429f06480eb2fe9641ceca73b7160a1cd29636712f18bde729e0506ecf81deaae0bec4e8c5a543e0a355d257987a43e80efbabbc75c977f4f1022636493f8f1ca8742001a65cee460d8fbdd4907ece01c5eb114e7809c1808570bbabaa2c042a27b0b746259f39ae8bc441afb0375bf0233e9f58668500540c1d5e710fde43eb3a8e97607b92ac989dbf2e1da370ed6ce167961eaeca84508cc8b3d93d7a0950915628616e40753330910991746b7664d19a0805e37d8ecf86bb850a8d8e83682982ca5aac455a2afcd46978497508fd7ae5d741d91b1d69813769e365a114d0ad3621447b50f10ae51467096b1350c00bd25e85b876c81bdb85c34ee5fb406ab5730815a5b64213b1f14dd01d9edfbff0a456a2166f7d7033a0f61bbef10be842305f2cd608e42c5ef673f8e998c1613bae332e587365f31d817dc47e35ecdf940c270b8bfe22d9cadc2e0735d8c0e92839a291da2099201f964726e400ce268f9a7c49d3e5c0a3ced95fac912053eb7d28db60431ed864b212512a5d0235652be9a84fd3ac6c6088503bcd43ab4b04e34ec8edd9016a6328135c9a0c3a3c42603f90cfd1c71819cf2080dbffe504a7ed402f05e9577b3fbfd732fbfecf0c148f5beb4f2f383984ad0f9ba4b3a1c905c973cffbfb08e6f263fe494c3d98999bc904b4afde6f7a657866b9812a6e08dd27c3725610fbfa00cb55d2e3b8749d19da1c7ca75f72a45400859047fec8cb9dcc0d882443e04183072b7fb82c9ece7324183b70767ac02d494c2cd757f078d35271380f7dff75d332ae654420374cb1558bfc53c1830fe61f94bde058137328563b4369186e9141759f88742cf0060d6bcca297ca52633028f1d8858894c2e7d583bfbae852968ca1cf913a4d6107358018fe98322cc60dba78236c5b118e2f6effbbf36dc091bc5fcf5cd3773ccf87ac8d30a580e13b0652f4834b5ebbf8206249eba31e924d898f0b3598e7a8b206f99b45602c9eb0873e6ea3f8bf13de79da3de154f4f029a908d2e75ac468ecb0c1a952db9bce7b82ec0d96f67dfc1015fd5a1aebd669214d195836492f127ab0859a1a3d075ead7f106e3822fb033de096784519e4f70c8393d50e1465a68bf44e01b175d982b3053377083348e1d10234d7bcc87f187a46ccc6acd74d9216409f81e8bef3d306e8b08833796c22fb5be4344c048dbe3e8edc4750c7c7b5df21bea7b6bf0547d2af6c3fb54d1f14db81f5270715f60c2ba38273089bd081f84af5250d27c0fc80d4144d4746304687b2b09bf587a9e258a544dd0b04cc79f98036c27adc74ec57004bfbec1cdd8aace397c8e814f99cff6cfed39580035e2a0a5200d523338d061dd1d60049b4aea470cc81079cd525c3837435e003cb842596c27bf03ce835a3d6d9bf283f789034a673a7ab6f0fee6f385743d4a35babd7c31b5fd66b7c0c0a7b313450243abfb4e41052b877b41ce751ef178ca892e890c6a2856ac2ad0ae7accf848a3987fe101547b28ccb894a1646f5ac5e49d95a9d1321c206f18955d1583fc88137311cb3b7fec67789eb44c41d6a992699ab512f8c253d303a52d2e7aa02ab1691c3d8e8811598a29c3f52e6b41bf19232b589b09f24cded1f1f40510c9b4da18cd37543c2ca0946f6f356880819cfe541618fab45cfd606c9ccc1444adf967f8191eb728ff46295dabd729a31c43a2f8443ec73a5572fb2e0be9afd728849cd7f196b9d6993232047c5823c7751f1284c59f6b1289278113bdf370c61e821f4c0e9903d4787506779d69820885d950759c5e193bf3bc18cefddbb161e5971c1c6e65322012e431a4d2837d0458cc40bc9027eb281cd0beedabe6744cb394c4fce7bfb6f6a0b8ed6c05a3d62b40bede2632005a6d4db0d6b4a4539368909bec920bc959f974398b58aacc3ac85007f6dbd23d6b57b20b9aeba3c3c2e64d3b7ed74b21b7e1585b9fa3d7ab2ffd105c91e3094c5cf2c21aa8ef8041713feb9009c107133b1c6cc741b49402cf37a83317f235c9a1465f2ac188720fd458bd2421d43568fcf3fdb99b9a57440f6e1d210e59219b2162de30cbacdbd2b8a2ef56a5f82395a99e20810c23914d7b15df15108cdb923fec66cb334af6484c3972f69d6db82aeb98943de93e1ee6655f0059a783334ed5316b0f3c797d7fea52a836c958d30c0ff21325257b22cf2ff8065510baafc4f74c794fe6f187eeeb6ecebd192dbdcad6429bef177bec766b5a98ef86cb493796356b0676a40abbf44bc0774df3b310ab0a3fc4cf780be0897f19b1e78cd01938395fc7a74342162b0a3a1d59f87014d03f4f085e4e25e6e65d532bb13774e79b495115d5227d7e5c91ee682440ccd9ee7524968c4078b20de32cac1024dbed782ffd8eb4a002773cb083a62c69e0bb9b1145e0a18a95b18edf1688888295cae0e065a036a868cf7736de99bf7f6f4dd61c654b7b0ec8692a04a185d8f1d3a805ce0b8d13cbbffd390f36989d66a346a4bd4ed342193817941fba4ca016088e47b10e561177c303d57092d5d7ef7d77ce37a4e69d93c5b8c08235b72f30c4cd9e38d9b150bf4795d2b9e31728f24d2deb55a84890dcea89cd7009f88519bf403e0526c64a7d14c75fab7654a441a1c4be72b9e1a123ee22803f1f01cdabc106bdf39111c08c7b2d409eddc40457f097354d7791fba02c10fa1497f109c069934e1d9e45d71a5f06f191a43d4a2f9dc4bd26ffcb10353ae7067d01474f676384d0bb9bda0788bcc99f6041e9a1f17856cac69f597f3bf761af51eb7d198641e72f740d5baedf9c47ca748d33bdae2b239a0b05c685be1259d0c60626e0ee830b75c54e3c2e468d92cf486b88077a44a204e3e5325ce5f21713c72415fbf0abe28b3fa80fca8ffbe4be88664fbbada6e743b71d71cf4df2f45c87fa036f9dda978319f7b511a2fdeb9effcbfc6e414e02aedf6273ca407828efede852122a0f72ebcc7a05fca58fe66008c16c5d808c65ce55c6c88c0d39b55c05da87d32e43a2b96a762ea936917d6b40b5d2da6b2859b92ca8f8f63c65515bc2ce9a13469260075b21ea74ab65877d424d72bc88575de105c4b77539a3295f9a26f5a72f018ed952c27b6f810f34f4d6c5621e3d32897c2c15a0ec50a93883d1783b7dc4176d07940667b3dbd33bd9282fc2669727eb8f5261f01717aed81e35f893b19cea7dccc6aba7083310307b7f3c06061cbdae95e88a714cea619272802f8daa68fe99c5ce5925c5be4335f4bcf4418ca5b71891226cc9106e27ce66ac94b02cc94cf1951e73fb90fbb7a82e79fb6863cfdb058b5a1298713c9a06c8ba64d2441cb4a338266de9254d89bf7cfb03cbc8020073d26a1efccce895f3527f5353591ba86539aa534c602fc994754f89a4522086d2bf4a3fc490b0c1352c8e8cf1bc3d4e7fac7daff49f2fcbb1b35f7b16e5ec6fcdb44d12cc05056547949deb83423f47906e4228aa0228433a541fcaef817b42d4999a2076293f8e7a06f275c80b14df740ae5d09741609cc19ebe749328eb010aa69c1da599a81e498092c77fd1794dfadf9dbdc5a833f2d86a84cf8ba734068339e608f0d0e2aa7bc9c24d05d26bb74fe88df17214dd852b2c2fbaf48ca0aaa675f6424b7a1e4c1a8d775a8e4284196979fa52b6310c7949d31994e22769e3220d6ef4132967f3f4d569a390d6eabddfcc934bad73bf09cbb6d2d4def35ebdb95f6ba22e98ac818b78b5ee77752dea744ca63973bfa7563cac3efb652f04cc5bd8da40412aa1677022b4c3f6476ebc86c89059bf6c920260de409fa355be6e1d57fceb2a364df56a5ac813f85a7f0729679a17e5f72fd7cb4abdd6bd3ef62c52e41c97c80136688dd96eabc97f180979bb8a34afa60a39d3ee5956e84592e14dd89aade7cba9dd702385c50d420a5491fff30a9da31bc3c4d1269471a35ef4df77e305ff8cc0119bc9497e21eb968935c699aab50fa5ede3848bcf3f7f61329951fe85a6ba14e26396b17ead908d967222ad6e3aecc3bd64703cce4391a546edf17b4377af4517a047777b050ea852ac9f515b8ea7a2fa1ab11f530e847ec31c72960c8b61078e12b4e36b1ff0d8fe572f74c09d2580ddd605c1249df8d87bb29ed2b24a419412965ff52b35f64e7a78a4a026b863ef9d85236bd28ed980bff2614a3b315fdd4a9617b9c1c7ec5a52b7973b1f0ce3f8c8ea7786936b7d6032b23820a03a025f15833fe81fe1229d6d361786e7e144291e21bff9c059fa0d5a5fa134f24c162dcc90962fda5a6df260ad992bcd54581b63019749a12a794579c6836fd5e76c5a424f2bef76ba99d38af4cdceec917b1c81402494fb1c2f5d6f17c21dd376b3c71c32a1c4b492dfc9d34099ab2019be3023c45bf866080318deace4184f8084736ebc178c1e57d1b32e3c68f1fd2759d95bed3a2d0e2be564c1c0f7176b268a9372552a408ccbe0742dec59d97eb719f6215092fbf9c2ca2ecce825c22d6db46d1e2a0f768cf06c8472d57784fa531a6128fedcc5cd6e9f303cb5cc22756dc41766eef012b6ed913dc96173638238c7c6b9566187584ba91aead32f0095036b944b828e89804c80881fd768d0ad8b5e751fb6b7b1074c27406f84e1f475117d7bb3b2f913a7b9703d476b18d6d742d498dfda294d47aad759de3d155a4aa03ac1f592f1478014b1096c7f95a8ebd043d77e3aedc12b51ded36e0c8ef8a6224c7f2bd75e27261400349bad7f0d0b000cb241611f485f6ff8e21d0723f382828f938d64bbac14cc4c938f9ad59de94d3abf806220c8f781d6728b486c00b825606ba23113c88cd5131ce5e52f112fa30bd1d9712545dd12eff52362c6343e7149cab636d0d5af3da8644fae610116b917f52af80febf8e21cb32c960d177ded2fe0d9529387edf4e97cb9b2c41150bd8f4b364f7b250420fed154c043e9c91e8747ce894b36d9693cb6b412729607068e6387ba7b038750cede4dc2b2c6ce7eebc7036e2a0221d9b2f7efcf884cf942993793003e9c644a0ed286f2f02f13bed5951bc06daeb0743e9aa1fe9654bc492806a34fee3583cd89dd0ca98c7d73277348cbc21cad1fc9b26112ed18c3d2bb5ce543e6ac378f8ba308c4413eb3c3927ba32617bf6a30c7fdb34ac664d901e970a9178fb259dda812d9ebed0a98f3c9034a85a59ae647195471ad753eea84b891de0c78772629b67f94f0aff1abe62717c995b129261a1e16ae63f241d382fed07ac7ceb790d479f97452cf31d39b0f80f780e3e768655fe17be14b8f3cd435d1f5899bb8542ceb6c98d77d459d45910d521bc4ac0280ac61a5c2afc6b6d9957b32077ab3a2cc87bf4d16f85998336bb8509bd7a0f3c23c379a40f7542b78133587577fe257eee35ab2acc30ff668e8d78f70e9e642b573e151a70534ce488a4659b95502fcff8c73b25b9c748eda3e41d516b91f13e69fc7122bf76ba8db8e35ad85f2be8d13f671574a9899d4c86d9e1a683374facbe4d125dd32471a0e5f4efec00251ed038d5253a8d86804dfd04968f284be09fac9ab0c8edc3f08df58db1116580a9323bb58338600461f58d3b7a18b1edc1b67f613106ee1b73d25c7ffb8344cd28f6678f8de0d371fc98f2f3661b47af9c99953a31e1461617a76fdb04f7f89da0436c45a048fb4c3646824c115d5b64b731d8d15c4db55333a55315edc15ff908e4164933fb7c485e63eaf18ddeb55870d6ad9c2e7b0a70f54fd69967431b5c50cf86fb94d28f787becbd5206740e82b66172bc6097fbf96ddd9bca77dfaa8c3dfb1d0d97961d49a31aa04ccb81c7eef2a04f87a6460bacb0665c36484d4decca98396fcd7a268fbd206d5b5596f091811ef90709316e8fe93e951c96aabcc8988ad58f69604eef802898a55d7cf5c100954852ee55349e01f3e130734fdcad62eab939ac1d7a50c82296639befd254e794fe439f6ac9597809a18fd36b9f1a338eceff3223e1f8d0454205cd8c15361e69ed5d71f78ce515120668ca908f4184edd86ad24a5b5c8066d0b26715be8f0a5686651ef8bd336dd865b31b5618d2256016d5a338666f904d39644b067f1751e38b0982a4c8a91ca9ec0a9e76e13c6a754a2044c39886ed8d2bd4fa144cd19a6774b1ec1d53c3c0a3631ba41239ca068535ed660791310ae939bff84fc2a924fa7c8983f3c508d063e69b6a3f5a909ccc4d7e1ec2c95b0702316a345028b450bc3f5813edeb243aae5b8907a4f14044869bf14bf91e724ac266aec3cf3d92ba79b09c1e6ce859553ffed19550f82626ebd169d0638554aeffa6a105732bbe32a445910f5881a15a8e36c7e96c3456363b1e7daa34c7e0236e21d5aab6af950d367133c638c25af7b48595a466d5a36c4201d974647411a646a3e9fc4d1b2af24cd40f105b89695f6eb6bfecdddfb6cc17e75d1d8714836ea566fc836df7ba89ab192ce54172a98d0390f289266d4b53ce105f02818d2227cb57a228b67f780c9be951ab7d2fe16f356fcc7090fb6a9f83c5c9c9e1bf19a55369d75bcb721a378f9a0b129bc21e6bbb4f1f3099a826f1c469d507aed0b5be14e4513ab48779a81775a9d704c186ceddca212f0a298486da1b432b1bf5ab1601372c9cf3ac978611e929407e4052b7d0570b9468e243cb1315441fbc54cc0b8bbc583fd0a6e52c7abc21ad60df029b1af34b3e8d1741d57874ca803ebc27bf8e76d48db21ed640f530921429ce4e9d5f724f2e5f98cd4558918709c3d9f36ff4b10fce5da86c3125e53a28bfba4b0da82726c2ac26000b90bfdf8a58d3e3c65ee7f9bd502ac72469d8419e08b5f7537dfe6db7bb61e1434a4dd1054dd91bc1534ba4b9efc194392fefcaf3e3bccef1b752955810728c646a8f4d994d90bbc299d022ccd438f53a3da78f11993f840c078cf95f9d7ab2f8db36f019bc0445743a0c7feeb23f562cdbacd4d189f7b33e286eec592267d42a63b3474d74d4fab908310ca52aeb079932adaca80eac9dcd26ad9d9da6fe453177e18239174e3c2583f043d8345d374bf095e7bde682c5b894e80e72f7f121e436b9d82ffb250265e960f8f44bb6f130e887a67e7391bc0eed208d7c5b63c4e7c3722d408ed9757ab08f5ab2c48613e8a0455d847f5423682cfe21762b146a51fe6e4d66bbed9ab37f6f8dbc5d3088dab44464154775ce0be860a30eccaf3ad4f0325620573ba899b8601a13cb9319071c6cb1de6d6ee044957e561ee7cfecc22eea8c7cc2aff2f36d8deaf0fa0a4f2d381b6b24420e5c3251c3abe1672aa8ed37b13b8a94b4daed857e7239a7681b2aa8f55c01fd1ba5671ba441ab181f5e0e21eac1fefe6bb7a0e6ca897737d1d3fd541686afd4d1d1e94651821657c2a9134585815ce21b58121a42ec7cb7ea187a98395330097afd381b757924ab02615812f420bfba248117746de0910c60ce7bf502f295a3d22ffc0f26ec5c3d1c0ec461bbf894d190a1ca7ad6a1c1fe94702e0c1be7241e68586157c060c7a1d9e3d9925c10158acc26cbac96901a1a43deb52bd41eb8c712167c867551b87fda9ba897be2ecca232509b901f19fc4fd551cecaa157f68ed81fc3aeb4cc72d28b5576c1c1045b53d5cda689b29741fad8d334953caf9fa4e62f8ead2c20a7961be357f3e0bcdf10e891f167e5df253bc9000655f4edbc536e676bf74dd13bd1128027fb4f120e12a2b0d7365710866dc4f661095d324d8668c08614eb95ac2d13c9b8cf901a099080ea2ac03e2aafd53c13f5f08e43dcc77577f6c5cf8c0d6c627f5e35a6366d84254aba02d9ca89e1c09324770d86e802009a40c8c6ad172e665b9739894b10abf6b9ee9739b928a3e67c86d29c57b021ba84a469776271ccbaab6594ac67f790bcf5f9353874277158b796612284230bcf21604f2b4d3141fd9d6d3e4ff073836e9f827780ab29e122f0cb6b3d4a0d3f851c5e7376131a2aa4ae4171c6d5b25e752f2262f5f8666603ac4db75d5dadaa7ec34c053f024339b75bcf578f19f6fd6d99e59a6897c41e4b81374acf1a780dd3ca66742719d33c8538b334406cd9a05a253ab36cb9bc9d4e2e8d7580f2288eac9c1aa0340702f7ccc6ed7bf93da985ce6fc9d734a642e2b075876ece6b796990eac0a99245cd1d21e1c43049e0cf3aec3422549634f56cd3471c7aaed9cd49244a9ef0fd309935a39f39585bf290e3ccbb8bf07d4e32b52d37e8526953462b373143415142e61b46bc6907c3a2a79b0c92c85adf444650d5af9fb1e10d29bb74805875c8f3dac7f02864b8bfe9cd567b4c03e8c11b5e29cab14291113af787d6b9fa38829e91c973a45c39f1dce29fcd2a23b9ecb643e9aa9849f8d9cae6dcc5a7a6fe7136ee5bb8011f5157851c3fc8344a2fd8ac4a50154396a1f84afd0497ef6e7af00da36df3b2692d6b35875c7708b11b4b4266b2470717870df896a01bf45890a19be919f9c9cca93d2b3723aed4349fde975676e3162bd31a8ca171596737a9be82bd734c5f1a61abb6e4302055ff22a4787b2e9d55afa97e77a5310666165ddf4da722fe2b4ab1905c305590721e36b8f8ea357ff5c8ddc10ab49c589cc82eb4710814e4aefea5f735b228a6895c78abbec9e9fdb20a7bf09fb073300a3228d23bcf9ca46eeb7b36c2796969a7ed76c2c063b439bf13fa580852871e22858dbe4df39b66aeebf230e569d1599611e6bdc02fbfd79a8244c6229f25cd8c5e39635cbbfbe0214a5e27e2f5fb2606b8b70cf328bc8f0de47d905a55431193e8af8f5470d1826dbb92dad3a596b0292be241e14c15acb23f8fabafc2034921265ce893e06a02eee9e0bf39b669660104a337c40ee9b16a0aecf3150562f5eb25bc0d9fe62dd66a3dda8782c3e5c3348dc94af736814b1979ef69ae485a2233e670d7626ad54c5cd32388f40e698e8f8252db141558a3c4335c18000ec490e9c3b79517bb5d1b2048c0aa1b249a5cb2125a4b9277f15644cd5e7217a4e1b7a12439741dcef64136807d4e79b4d3bb7f4cdc52889b2bcb9991ff6eb46bc3e4e6dbb9ba17ee5132b14784bae728256e55de75c6e3b3a548a29a33ef7ccd51671b40247c67a745eb9187a5ebeec1c5e712ee1e15fa8e135646132d82a0bd1c5d6e9f8cc6e4aadaf2866be8120be3e1631fb9771e2a3ca16454cb65576bfe367e8356760f37fc4ad4180ef07d53e884f6409e2776ad5b414bd520b0838b7bcbcaa854534ac77d84ea552e8ef12959b700aab4fceda97ac5a95616e7c98296c5c6b72c2ca3661533230f6d97b1b0c765d1ee7715f4389441efcec4ac625c0328ecb8c0d744e6aa898b4de3fbb464a6a6ddaaa0c9d1c145b4b28fcef8df5d5b0b2e2498f391260a2793e64a1b89461cd081c0df422666a914fab44b6379ba73412c1adb73276957a578e791fbeef02625fae9f20cdbc773e3dbba6b108b67bb942229ef21e327972ba2fa1acdcc51f3dd1c68cc0f9dd990b7068b54b8c000da6a0769e36e3c2d825182368e67abaedf184df2288c90f71e08874926187d5fbd12078abddc1ef3e6171f8f7d20084ea86223fb59e38045fd03a88b15349635011fde6df57ddb391ad7f6e98a195a7c4eaba9c08e3b3169d2ef7e367064e9df88d2289d0a002ad25b8b63f2f3765b806d18c5782fa43b72eb1627493868ed01e399913e0105c9bbe1201dfb6ae523f5d3dcb1760b1548ea3846ea8bfbddf555a6ff2151603b192e01b079e8905c2e65b0e370dbb06fd602872cc5aa069d33a6b1e648b2809bb1074dd9b407137bf93c5bdf3882acdde2e1c7600f7e69044929bd9cef206e7f671495f9605720539831ffa964c106ab3d743f8303b118ab40d28d84500e4ef55422bd93e5aabe85c6ec7738c7958cafc32bc6035d156916f41c45d66ddfd2a4a2dd0661c21f4a916ae22893389a92f72ad094763317704fd9ff0dce619a02874b75b57570bb04194964c5adda38ad0a69874c1dfe8ee99a4deedf1fd85cfded6c719b6bd823d4dd28a97325fdce1328db6d36caa8456325b2b9c810c63641779b01d3b77fd8314a2722eca939ebc9ece0419ef7199704b86851edaa0190d20fdcc363a77543f2a51a78bfaab0fc7008ec914a583e695aa0fa2cd256f22c478c558b591f04ee574e16172dc5d9f93efc91293fc9a4bd4e1c2a2acf9338546f8403696c27930ed9f96b1069785668e5ab06af139dfb72eabf7aceef7b9e65a9d407cc75361cf2f3b0af5a4631251c6bf3dcd475caf60572b8cb89a124de32044e63e4bb537cb5236dd266fb96bcdec95cfa8bc04fe8e93094bb2dd87ce3e5dcf47fbe50b9bff870b0731212a4fc433141704bf959e2f41e5159d75705b39d47d92d696d1d6a8a70a62eb52b9c794a7137d4efb72180f9fa82ff8767fdb3f84323b573e82d7991bc41ab01222924ee535310b425e95ba7a6e44b323a782932c908680f6101f7140693156fcba5d3846d5269a24167caa7a96c225cdb4c68e6576e59e05e7f1a94ebed82fc6bcbb3f22d561a16496f7a34a7df4ca91c7906d6797ba7bdf13d56b7f92925f4fba1d6f2df53142d598b0855a0b75badb8600c1e92ca255488e5edb19910c1e0991d88db187b6800e8236087c4c3a04a260e905cdfa9aa0c482bb306c03320b5c55cc7f9aacf130d68b6df1404de266a00c25e0d6bd3f94a4d0745bd1572025177e27531a31a8668b411b520dd2cd0cc5803f625a465e1e98101b9777554975af97d8f46f685fb64affb6fdaa8c75b66d5bd2a0590e1f899495425018e4e1dc52be806b745c24c0e51a59dcb87ed697c3f7a3f61af11d62aec57cca137de2150bf710e05f987b1df1b7473d3cd67b385085fad2273cb53a7126494ce19da17e49f7a50972cfc3f4f2c08b3a4c2767485e31f233db82a6833d5560b87ef92387603d96ac687f3e6ad14c53d2dc11e659989ca08c100c1681fa71a78bbdd9fbf795fa8d6f0cf56cbac3e83b770f849a4c2e3a5245ba405926531c3e6860cae595c6e712e24e2b4ba3e7063517cf462dcad6f78e813ea78cffd7410421f27f2de21710e4d22fd7904ac9b0eb53a799c30d83a27c09d620328696ea6122922053de7cde153d5b75d0f11627bf1a95007fd6c47e796ebae82248e6a15cf6f085284ae1c9707625b7eb7e70c1b840f531f6462c2df19c52f4c2176daa73a144087da111f7ea77c740b20f7df5e22e9f91ebaa18b3fb5ab58bdae0b079d8c0e5218ff4d05a9282552c8ee65b6e405cdadfc914df9d82e8af2f0509aa075184488bdd0ec9a93450555c1f717f743287c75ed972a474c4453b06b25e25686c7b932512492c832c5aa9e8e95e7e55521dbb5baff63494d8c2782e4819d926e2538b63e4019427ae056cbfb48305569b8d4769d7589a3186147cca67d8867f6fb9c6ddbd96a10b4bbaa8f28953aca30b7f6ab3dc8fb796e6275c681787441a55361894b4bc4257bb22cf816fcd5b0f42ea19cd5c8bc1f78e5ecbd9c77a46c2e53aff18f7a96391b96a030a0d1777e94e970a1c9ce00573f5d5d3381107a99817e814daafaeef6b5516831db507901aedbf10545fba13595b82cc466c21982533300b2821ced413b1020292f426357372266e0f7daa5e0fcb6d88510c2bd307fc93b4a6a999364080476154907114bf4bd72808cf5705ffd25d61a5cdbe3b0155ca720453178706b1e6975d2c68671fd1446fc1f834c8d970fe5bc42b3e7bdf6644411631612279028d714d50ed250c06c98a8663ee7ed4ad1f18ccacd80d4aa2c15c4c9f9b8603e7b86dfb783b4bdc9d9efaea72d58e2b45fd5be99206167d54bf4f8a26b2bcc9c6fdf0ee08d4319922f2aab4e4b3bf885ffb9e508638812dc6c59d34ed4deff9bda149bfb7333a93f8f1dfc52baea49258de3c047d2d064c0471348eb16da2465e29d202e0e458887745b4818886e35d737df2b1982a157f7e3bf2572de148c93e00e88d6cd7f79da2febe2bc1384e8a647d701614c51f235ba2d41fdf9703c45c675b32ce9807d4f540feb55a6a7295886a9163e40f24a54de9591e678e6747bd1e252e8bc3a2eb71431ab96ed7d0ba8ad108fa112a66f1d13e6a00f1ada498019a16699f044c82a49d57ea5c4d72e6cb7e620c226a9a13cbe2a7eb102d74e6865c7408200291123ffe0a12f208d7a2b839ffc6815da07e7906ed812386470c694a94c986d57a5d63e177a82fed8cc1801c8f6ee6e5ffec2e5e73a070a5c8040ff2d115e6a1b52abddbe616c4a3d8989f74ad4fb0afdd21200356f471a2c7e00063cd061f718cee5c426829a1c2e803a4cb1c322ac3b97de5b73d9dd2fa7b7f5cff951d41653bf3aa2ae89c8afb2594dd012e81e72dc325ef62da31264b3b9ccfc0ba79c83d8c06510d157298133734b7886f434ab59472a02dffb7f1b142582126412f97499b7e64d02ea723087d61d39c7211cb432cb53329ac0a1adec0c7f61cb4e14d56bd1e52d22d050bf8b8bef07237ad75f65861a574a0db1d42de1eea42633867771cf799c497e68f9eb78c1bcad7273b6f154f8971888885e0202d1500e3d440d0a34b598df2211e2989e4754987999527f07ad3bc9ddbae7a6f810517497a647cb13aef5689c66c791b7e664069e67b76e7ec9d1c501a76f90162d01d5afcda053c20c9039f99fdd59a53dcd7290d2c6c2d2250892a693dd3b6a9bb8108339bd58f1d8ed07ebf3def6d359013b1b25d22c50fba0363f98f28933f77e8a3ed095d0fcdf49c9dbdb98b4b0bb90c74f81d85278f2f294e8ac841b06dd347957ed3a0f3b64f5be09c32797a1bfb3836fd7191847ce69e000b92cba777212881744a8f0362b8c3801eb225fe484bd1887b5614233bf529d219d9fc97b0c53b52fcf70aff62ce07de5ad7e7c1e2e2c34bc41f38de66b8ead548ea15c56774c69c2af658756681bbe9690a5ab09b60510a36cf7ed0667ec6b719b21c5435a94def0a5dd3692ba2e0645ef17e27c25b8c97997f1627aec31290494d1d31acdd6be9d0f61488de601553518dc0a46dca17543b5b1fa29319afaabf146bc8d9e534475a44c0a96907f0c7e54683b3d4beaa59c14b7afdf1a79d38373217a401d63339b998d3a72df7fb0d9cdc865207d07b9942b87a334b53c5c5095a94dd81569688c2cd01731b371c6b3d37a695c0776aea91fd1c87ed470ea800399b4503035acdfcdd844c9be85d0d285cc9bd9bf859e4beec3fb80f56a068a1d0408ab4e578e22017fd1f92ba73b6406dad10490f6310b275386cc0b26e96ea8dedd14797f27d036f193c3539075765222379c60cbaf71d6cbecfe5398a5a4b1864f8f124fd8f5114c4c06253230d71433c50614bd50098396152ea68c02a0c353e4afdb31c86afe6dec49614e28af9f1c21e130bb05f96a276e77f45e650357fea2ba497f1c89bb20f15434863a990e2e55946e8ce88c6b091eb30f961f32ce4696da31729e14b6c28ac4ea66565c642aba83316b5bc85a388a8e12e4c1dc24047b8e35e478d94c6c5b1b508e753b1d2065f7691113b9d707af577172f66c5e97426b3552a1e206feadca19d178c5f3711c0048ca1f4b214a7417f30b19b05b7cfa46e19d6d667e9a4d2bf9de4c317dd914e0447541f84a91d7946ba43032412f37be0d2abc9c07621196b1ce8bf47d0f2e849ef2a363b0b33ecdac543e629143a7f9a2017d5c0215f370f43bac7b0cb08f9066578b8b43509148ac1f877a4709dd0a34b328e3943bdcc28f44e3233961c6c1facfead606b57c2e95cb52103d035ba7942d541cd94716f67618cdbe91feeda874616c39fc21ff04475943a051305ff0a4fc5fbca8b5289bd61970887ced6c5cff334a3a1172ed5890093ea7782fe5e160b0fa33d73e7731ea2b0ea97f1661a25d4e3f925050a363d0f8afbe97557ebd9e4a6707919b695d24247b30ccb0e36c881f1ed8f802caaf6905d700d39c32543036d8511a5a89afc6ab1129b81b3b2fc2b813b4a1d294a71599dd3a45d88a4ff01035d0980f30ec2d79a06fe315c59409830ad4967062a6a4f2d6cb24011064c060f5651a535be410173b3b9d54400b46f13b44781480fac21560d1c85d45bd0e90d31386eac2380a61f9aaa44bb3e1ea8de204b713f34762676d026a9907c666483c201333752cedcfd14b134ee4a65893b632480595c5d76922ec89445b8dcbdd589ed6b57f91da075fe4b96ef7f769710fd1cf875dab2089bf1e1cac49e13066352bc20128bd17c801635cb7bc68f8b89cdf2cc89ab29330763abbf4970aa72421398ea7a0010b70ceb1c08b3e96910998a4cbdafb62cc65add5cf5b74269cf2d4de6c68723c563c43fd92114c46eba1fb267c0d6786dc09a3a5c5fcf8d28bd55335e4944588586a299b17f50c8599a922257e6b6c6abe8727d46a1b3ad2686f8810d1dded240a75bde4bc822e777c6cea3f8d0ca6e3b6dac901b8681fa036441284df31eb34e97e12951e6d60505fff0370db6e2cf0a4643626468abec61fe340875dc21d09d3535ef727fdeb8a86a525badb57205dca8756e4bcbb3881060d691ae688592e6834c0ef52ca17ebe0c1268dd7910f9c81e7fc80f67bdaa47e879d073103954d179152c1d0ace39f1a20b6485646d743e9b3d21a75b7a2d4f5340302735b7016fa45a15afad3cfbb933c6b8ff5a9c5bb3a73f63ea809b4dad08b8bdf74e7d9c2cdda583898da6b0ada25c91f822c68175debf499d60251ede1a944c58a8bc47daf4967bcb9868af5bc12940c7fcabce657b07fe0f0a5b93350744e3bea2baf0a5554900af73f9ffc926b429d9109ab879ebdcbaa4860f3a6982dbf42087503df462586b443ee19095185bc6f5669845f59866164271e4870101b9c8cc5a3c8988c0f8824f040c282a9d398717a7af4eecafe92ba42c3b48460d535aed35f9403d881cacf2ec6b8df6b6bf7af950471737354e250cb418810f9ce3cebc15a819d8988fdb69ae3fc4f1a5388e9b336b25e842c240e3eb45fdff6a21cd4549744039be327e77ab21e0f728d5b57be289371d498fc9a73e9427f9fdb6e4f34507ed85d395138ad2ef03d46adcc0ee520e53320970fe885666a772bdea28d130f6ef1b8f4549abd98f598793bdb872bf5e55823a3c5e6806c863adcbf5e43719a9312685a18e40a8e0755653692e5592ed34a231ac297c8ba9bdf48c54f440bf799f41be9f26e04994456a6cfb27e4a14605611acffc0757da6d4f40f188187e74f29c44248444e1d02304137927afb844361f08d0f830894462c009e102cb17144225c873d671761794a3080f53c4dd960de38ae9877b8ae382c2d42acaf894bdf4d550b03d0229f60e9cc99bce23d5428f082b44252681482a8e6435937dc0edcf52ec682c092903a8f5bb7559f01256d258a25ba8e619e291006bb46d2db41ed2250e61888fab8c55c228209392aabca5d3205511c79e120df719e5bb4fb4dea2bedc54410e4858135033ab63506a5d5e760a8f8533c392e6d6c2dad4920e24214900ee7eb749ea195db1f80ed0b8bb21842674b19ce51fb44385999e6ee223d80df4b0ef1cfdaeca054cb6a024e065aa9e00f7ac5e6be95715e51360f92086b520cb2829d7d9c3de2953ff86a9acc49ed8797ebcfa9b42b16aac9ed28b1444c069b8f959111db74f7602b664fd3d5aa1907c5a9cd0eea825ec857a774ec912b6a724aff435951b3ee72d6f6a95032c71dcae14dd43352110767e748af5d61cd51d2118ec59243b2ad73ba71735f9aee0e74b58507d4e6fade3af3d6e5d4b1aaf2b34def431358652ced59bdca720a5a8bc127a6b864d89af36502b986d228794e9f20e16887d719fe26d2b669fa8b7163fe1c7da3c401f1530529ad243cb05a6a6a8c76b58a2222dfc338c3d13e01a1607a4c8f7008593747b9978e1d34244340d715568710b1c5e9421037f733c1cc346bbadce077894f9d1b0590cd3384d79a799ee782ec93b3f6218686f1b598e835550e9d43af0300b293f04637eb2737da9b73bc80516c49aef14e1686bc70981939a804be339e56615cc46e5af3ecd784166c4b76c9d8575e0df8a2958080a534311da4c0af7d305fe7f28c6608b3ff8fb010d6f12dc818cc4585ebd5793fe91eb20e9c4d4f54acc865f3ad707e8c238ff86fa73186ba6b563ba3d17da90e9398fd66eb0b0bf48b6cd6efc50b20cd44cb3e9ec4ace0aee44c632ae36ca0d37c952759190488e1fd52839d54cfc2590837726017745a6697727fe71aa1110582c4067f295d8832b03ea945219417c9bffeffc08057221c6c14340840447dee15d602a9799277ef48457629569f88794c5eed4e735362c74ccb1d8e0bd5e5982f6bc0278d2ed47ccc81c1a6042f2570256f6dd59697879c05ffba6f4b7a4f22a5dbf2ba2cad734238f6e07203e6b88ffeb534d1f64444dd681a1f2ba0cca6c1484adfdc01f5d4f66512518078bc959f1d3ac16766ff13e0519ab43bfc94419189e4b67c92ee4051a5098295f1127ab2bfd168e37e1cfcdd41b4e7dcb5d532a3d4f382775b0fb87ce368be4a2fb8c90d2df9c73df4705d9201d334e794eb17c03afd20eedbb132bd3ee22fc4fb85d53878de9b9672338137a4d6d2d98f224f5d5d0fac4ad79db6ca7ca817008cfb4278087f873c2ed64212944b840bb34604ee7c2868b749e449aa55eb5d6b5d2cacc41f4af3c73d74e83a383cb3bcb894331b68dd17777f69d2cd41e21dfd566a4132e2ea19c6c4e3d9bf9da1c7508de248a7a3767ea28dbe43eedffc8a4a1ad17f01e7bf7e4e094aa740b1fe138c4dae7aa852c3fdc58fc00e6b96e927a2fbebcfa7656812b4ee905970ac6adba9941e6752e8f76bbbc0b89bc64308cd21cf9ac2caa269c3cdd3ca5ff9fbb733bcc6bf3c0d33ce2e19645d76835bd75448bcfdee52b11b6a7fe3d8742e59a99ec700a70c1c52893d13df7747f376406c75d102a5584f09ec5e55757d2a51478079c788d58c638aaaf1f677c586e125a4402e1d2732a5ce298e3739e5dca2b5ee2994696e297fb02d71afae8b08c2face46fd715a89b47b7c0bf2bc13fae7dc96f38babeedf098b8e1fcb22a0579111192c373bd252c9c5331458d75babb5e9dfe9715d08104bce09c7eba4f4da6d947af9d6f5a16112329081218e7f30ba549a071fe503fbb69f71eef118ac0b3ac2da984f9998b6096095de27917911cb8eef4649205e81ef618389c35597c18421d5e781303a81409d72d5c6c81a2efb40234e64c2212143a673837c0254b878c61ea129a8302fcdd1fead283fe32d246a182d509a0f04e9b5c0a1592142b1d987c7b07d083a1a238a1a063fae9e8b13b2d4938eb14d668a306a0bb1dfb96094a66231484a1f0611bfe33db0453c8e1dc6f06c74c8a6ae0e976515cdebbc0f3df5e8b341ead3c44f94a861b2ff75c22091d0255598c26f5a2cb3b5d2601a74ef336daf53527bbfe36ff8c0a8616443374a6686c9ee2c9389946b489fea74f367578cdc1c14ad92181b856fe45de684651fdccca33c85bb2d48d8658c082ebbf3f5a852f0911fc0ffc017d0e7d8cd58386e6fcb8d7535e20f673d4775a80edfbc91c194e2ab9480df79d63efa12956b6a8976e82c377b78ceb7c227c1b262fd96fa061229567cc033539ce80e3bac0802cabf8c0366be8ac9e6c424f96c4313247ee0a2b31e01e41de2b1005bd73b75a7fabc2d995267ee25280df4c6b68b34edf41344c1d4cced983b807294acd811ddc0b0cd8169e95facafcfdd1aa11566ac17ff591cfbd42914aa0e852c64597f9652071a64b3d0a1ff79f553e0927f23e7f7282e73fe0e7ccaeaa565fbd809ccfc31d757b826960e936a5041fa6ce02523b8112b9781b2fd339d995cd3770d98d03ef24073785daa98b9ca02c85535e973f117465c537341a398f1bba08c73d77486f202aeb9762c02989b1d7b2dc3bce4d16844997d77087511abdde1a981aefa3c1b6de8a77bafd22834285a7e3d28735bf1f56080c540789cf359c696ef4393ba89347f63466604c99d3b7605b3620f6bdd4af58860ff09fba78ed3af70b525e840dd777f7a02a44f6885c6664e6dee4c14158028013acc7cc864b7b60296167aad073128696c4c720d27dca5fc3087dcd8de5428ff28d6fa11ad4c2fda4fb064d2400831e37077aa02360995c8e2d09775545caea2653aeca68478e56fde5d54d88a3893480edbeefbf6bd7f0d732bac835d3cc9f82627a3a7f35ba844ad224e5c26760246933d322db744c40c9952d133df06eb4488f158d83b48168428e99e993481639ac093d7c9432c854399b9989388229f21955dbb8206396ea4cccf2717764f5075165d43d40807991c797f00751c3348d82e666f0afb032d89a65f5cb9859929e0303934ed28897d853788872d8813468b1660adccf35abf6848cecfd5c407a4f4e0ab9dd7680813ae39c53f2b8a9b3bc26de2efc46e29fce37049cb10b4d850fd4fb3ae2ce8c6551ea06e09a71dcb37d7c5318509d14cd1893457ec2e5d82a7ba140563b6d726c238d20444a52b619cb788ab314bb20b38bb8fc2e5fdb9ea469d3c642982cc336d5b3b9fd7d4029af758578a40ee7ed6025099f3189eb83060799e4302006f6433657357d2e40580c8998ecb87c12e1764b55adef55fa7ad01efaabe38238bac234c315b0de6e1918ba0e67033f699657bf34bbc8b0ece61ef8f3a631aa4494cb2ade681fd2ec68183e400b4356cf78c1906314af0a206d59309d3e875fa91858a3393309c6066f3462fae15fc92e3356aa6b0b172a5aed32c6e54a79c58ed87f54557e3f6047bfd4fd9f94b9248b9b440ef6c5cdf04f45e0e621bf7466fa7388366f55c4fc5c0476e4b3dc8db091b524cac39913489ee486f87ad93a9620d8711f771c4b00f3e422b9f607ec8f0b3f82d40bab1ea79e6cae7882f7b50852fab4f73dbaa81e7a3cb7574863ca10992e63730a3abf9b0f48a91a80b652780cebb190753a29aa903dedceec09fdb1c5c403a390c007404e3c5b73b7324954a8efa377f4cd2ca0f350ecc4c3968afc995c230e5d50216101c87a543b106782aa72f47956a771f97d9fdfb9380b92cd206098ab3cfd946057e12e096a150f0a52b73ba7f67c2824bcbeb2cadcf46bd2a8514be68b52901c13e14dc4f638eccd42d87030445785bb0844ef2d3b93b304cbf9b3e686663dc76f5924ef3a410043d68e089d0efbb6a40e420a6781dd6b68eaa1d3b64d9dc2cc5a4d5982810fa6e3608eddb272bd909475d47ccded998068bc0edf815f0ae84cbc2740a9da747ba088ab04142eb6454e6a808d20ef62a88a0d3b9ba08c44e2405b674cc69d3e9815bee9e9377edf694316df3fe1ded3e8856bfa022490828e5c20c0b3765f20720dc0280f31b3a8144e5ae0bc8af00040b9fdbba57c4e9b1ec0315f538261134037efc6fd6c936c4feec2b0eb4194d52037f30ec73686f836d23d392fb15a98f68db347941897487c0ac5311dd16ea6ae5bb6756f1c4a9985f0b3102cbfde368578f6c07fc9ab74a9d35971e272d35e926189e476300656834063d310ef84e5b4c7f21b2dfb3da8e8f27996f9dd56e6b57cf17568dc9635300ad2f3280b5707457ca84f5597994c0e1f84c0da241eb3b6979920dd4aab6f2ecc56e3cb8aa7b5ae0f1e49bb7f34524df3f32bd2ea896de441f68df950505337afa1156c2d7a4df56addc288964d589b6018b04cc48902362d09643c74e26a3d9e56b651a53263c89191303a8dd7d1a358b9108517c7fe836fb8fdd8698a96f83028b28643f44a342655cef1002205121530df7caab68b5a1616a8860c5014da3afafc8a66e22f25d436575c762f2b639793229ac15229b7ed16f1a49097948afd69323968304f22eac9cf279ba43df2ca7127f302bd228c2bd17b50d09eebc924bfca76c72c11a280561e8ae49571398ff0895223a1f968d34bdcbb1f79900e6b8c4502680ea00f93677e684a52623b6940de846c1686e9731cc79ac5f56fa62e3c73e48a3e42498b6a4e2aeb358cd325f14cb5fc35013c6ee23a1eb61e70db87caacdd89b4628896f636df94ea0f5d6cb9f645de89453447bb52df22cdc8c29fef756c5f760fef92431c4b5c2e4b9f1d70362504446e28c4ddf1f2919bcf7089a2ff983a395f31776bff42972c2dfda5f9e8a93c24f82046b8f59c89f48f4d05ca528a39238864d47569515c91c57537b32f0d3520a1714f832b7a7e057d71adc0a24c7b4e29ebbe9288b176110d53a69f69a7bfdb69893cc0585f85edfedb9a36a00ea7bba24fadb3ad817fba49df8076f7f807a15b4db18c29f6c111731e17fd8493b7f479a1a9e04ccdae3e75b679fc0180bde885d1b4571732edd9fe5127272a7bb2b178948a8adb0703560bec02cd435f5a51de2e441e4873dac1a15c4ba941aa80f666d44de017e51aeedaabc93a3caa97e98855731f13677b791094fa22b694c518e9c9905917cdc27d8ed0e483ce8c12cd60719652daf4f0c13445c69db1c53a7cd27b7726080efc8b2137da42e5dc0b9a3f809a2b642e66b6c50515f9a07b66caa319a66bcaea969017064172e7ba78fc758c02ca1df3b42913d920dcf7476e45b0235a30062eb0c83a7529885a481bc10497eabc18f7569ef8a680b92e5003e3fe3cc6c8f4572d7efecd21424162171503f75ce5be399ce03d29a966c20e828219fee5e4361a266019ac0d413a608d5a35b028bbaca1cab5b7ee4d7b4dc8cc8945e9481d6a31fff679c8e6f1723c85d2ed3cc4e974d49030029e8fde47ca640f0d5ce110de6d3414c3ec05c0285fa35ba6897455d2261c31e61ed4ea84b68d0c885b44546bfe7978fd3ad2d219c107d251977172e2ac20967f751bca7d1364b0a731fb5cd17ef0eec39551fa34c5d9cc375d151ccaa5f2b44ae071b7e02be27560425dd6051ff92b4de5d1d921b1a1eda857c523d0af83b1b8d355f4c30fdf62e05707a5dc7997a2a58f7c9ce37ba4faa1d1ee2e769401915f4d0893d61777fe72eae176f0fb8260d811c8e6f817ebe57e0ef63ed2baf060bc285428f87a314e8918bd9b3bec11ad6ee372cc8081eb2c4e0a01f1353e7da787db4d36f2e35a6babe93890198376a78d643c25eee81e595f6c8a8b32579403bf4e210e5f09e4f2a9d39cac9d7fd7c029590e6d2c32c69f438f1ca0469956209b4cc77acd6fbd0d88ded03136211c33757b7737cf66a073b6e76d665883b6c55e899aa86de0a31acd4f8981a38aeba8bfb589b0eeac55e6889eca83e7ad55ab6a9a0038229e469baeb3e8d35b0bdbf72c66dcf95c5594419c342f82d3e6d323fa9c581f2bae66952a79fc94924148317e51af6f4e48631a47f84fd084d560c4edb21b7760a3b8f1c0bab1617192e09964cf8191af304b01c6bed7e67958bb25394e6794cbb2180393532807feefbedb8471e48e9e0b9218aa4d240256e76775de9f4f64876ba91def99fa5a71c7a9cbf943d6dc8ee488480de6284ba5520e1ac1c52eb7d1955656f9837b562675ce91d0fc3cd20a0d7453451b04afed55bf3d81d3567c60953645ea3c900c84417a07faefc3f43a2e560fceba23abd2f63e5297b9b5bb58fff41878aa54fae005429f72a88f558cc8d4355ed510eaae36ca1970bb5c6ee4ce6e8d3ea8f7d656d92d3c36368523c92e97e6d196146d62fc2a0014d648455e5d5b1246cc6f29c2c19a86c006c5bc1892e316c52ace23dcd47951e224bbeb238252ab53bbb50cbd741305a57f3045a3ea0afaff874c7d8090532d8de8d0c71a6c0d4287e1d574fa9b6f97b85ca0f7864275a567f110a1a6e498eea40558e6bfa09ea180e1f8642fa96a621719ddbe46c003e5d3ad41ccee48745b383d243c53560c0c4ec27a84d06803b38cf94250f5a759f4c146a461be4ed2c7758b161ab875a3b98449a988da8983d2e298cbb9af52b67108b20c48622187ee1cdf2eb98cd465d11256c0ebbc93b26552de5356815916997d4702eb207479ad51c8786c066f5e9ebed9fe0a338bd8890c95770df023e5b9ebf8947db668f09f35c5a68135dd651430d7fbd2433019caa5ab5495224d123d351a2741dadbc1555ded60d4092f18c11152576033841502b62eb95734bd1cbd98181a0645e17b7f418a9c517b012409c6ef6d012b2989f54e8bca23d6872e08e1be12942148a2182b88e951ddd62c4cc8394c650b74cdde0b3b38439061f6c0fa633bca3b21378d8d6e085c718cbe75c50ec79a467b5d0003338f44de0042978c57e87eaa2de13998537fcafd3925e792a24e7d9a424c17257560074765f5c721dca661797033f84f19e59e59058d88ebaddfe066db997a166bb17381cd1bf74fa1903a862db4faa41b8ebbc8b59f0726e4b772ae49f5cc69080f3db520fc5d105b037e8710ea92477d8fab525c5f2f21c45309dc428bf5e412daf74c5edf6325822ec8488a299063a879ef9da980597cf2f82a78556441c06e63aca335a06c1c2ae0b838af9daf258ee420e292aee2dd8cd26e5021058fd14ddc596d647f6e10cdc638eb871724dcbb7a95ed6e0e5553bf19d78979eaca0a133dc81e23da1134307a6d3975ca802acc20f620a5f03bbbffc27f8ae5b6c961ea1c301ba26f763055223b6a87ca54a671dc1f1941dc57ff37f5237f31c23423cc971fe5624c551832728731875b6c3aa89244ad8c9dff7736c6103721fb4ee07eec76f83792c345028ea3934b951e665788481af3656858126ef8f07e7d8ea28bbab953cd8628c836ab55fcfd16c9be1a50aa6abb27b1e6961659a07bbeac445234501c016d04d04ff15bdb60fc65facebe58cdb81a486621b8072c19e86283f3c948e75ba3ac9a20f5a2924f5f97081d4a34217079c6d1318e079eeb5afcd1eaa3c187ff7e4dc4d3984b64e062f93cfc10e5efb8ce73706d05125fbb6ef44317b3337bf9e9845745c5d0a0856a5869801dbe3f105746d2225764c5c26442e29a6eb83ddc52a24d31e0c6d8bd83ef031fa5a1deed0914e9e639e528e9489e9f661de5801ade5d4746b96685e6b7335010cb2d02a313f542a2ccbe8bf690fd5ae6f860c2f3bad403df407ec7e717e4e8efcf622591e8384ead0befcb058ec61fe82d061ce4c023426b55db63ec7b73f168990eeaf868e502b5be5fae73d07ade7f77df2b90905149b784a0c08487c027fb9527009f011072ba01124fb049634246ba874db0771f99d98b1a0a45e85a867809131fc6c1c7a6736c279ac7dc4e1078453fed9780966f9cce35351f8445dcc574b35af5825f077adf9df3bc1dfd8de0b91d8b7540de511feeff5e717b8fa4657eac5d8e95a5d9f6b0ad0f775bccb326b33234900295c031aa846f182e9536f5e7245573c6ee06a9aeeb395c0617cbbba3b5871bfa22ba81b6a7c3bc927172399f2531dbe685df4459f42131e38de8331978618c189209a88b984ed6f9aea300330420aee3a5dbf3267f276d6c7afbe3879cdf5ae4da0bb4a4451873961c4d3a3f96efe25f14dba492fb97d3448d3cb233e6b013215dc71f9d51a1e76142684350349453b05f8ea409ca9fe89474cb184679fc2236b338aeb1071e44c63bd8a840e02c210fecfc6b8cfc63314120e1f579302418ea05f3a7cb8c9ea1a26a54878afd291e5b5263052e3cb8c04e4437d86681551169094e65b6cc8f860b97df3ed55d949cf6ad95dc920e651f283c21546d8f215b2c39b7dbb2d4d5f27002752458a1b845f3c6b53ce179c14c132e56ed8a5c549d3c5deabc72a278a042e2d67d63e42540d3f32a30304d5e12254f06fbb8c47759b20e35ab824785a72003af82fbcfc8e95133e9caa1071af5bb32be89b727b0cb5cc1344ecd785c6855e5f6f8ae15629404a369cfa03392e7e8eb89dc5302d72dc44a6b0699607df164728f7f36c7054139bb29af424577c40aedba36d57f06cdb7406375c4af81ce163afdb4a37c6257044db27ea1c82863e9c77c915e6e382177709b6ef90922b3bff248411bb1303988f61ed15000ce31b85cf115d9b28aa5cf9ef6a786978430779e01c97f9b131df5257990598f56cd02ae571ef96055d9005843b77b573a25d103fdd27f91d56f2cf4ba7b05401b50ad8d533226664dcdfd6adaf3c8e5129c23e3814a7cbbf65285efa2c7adbb179ecd390d83caa53e64676a9d38fd02d6812f83e63a494733431393f050e231de7963235c9342435cab595bb4ace35daa2ec3f63c5c25e6a4a14b096b72278fd49efa916ee9bcdc6473762f27a113e38d4ed122a80a36031372306532b74e31905710432aeb7ee07e9a8bfb4dae917b14d95b10edf7d1de47aa5dbe3870e3c1c1a3726be4ea5e0ceca6a9e07c8467e49dabbbdd3c8ede17335e2735a12088a230bd45c9a94b321e92e73de2ffe577a17dcc03f6b0499eb5b3bda7fb6fcdd44ddb3b8aac290fb675228fc7c8b7ef0845b6f0a085ca510dbbec644d244d659bafc8b862c1739f5ae41f9490121c0f6010956ec1fc63bd5c0a24a248b64791e339d2075780dd84bb87ddb6ed3d249463f1cb79b1e0b028b3414d85fcd5050f0ab63c33788afb87a9601b6f8f71dcf45949489fc77a0a79dbaf74161f7dafefd8157d9ddcf02e5248e6d2a95fd3b10f6eacb7e2d510d90398eca4c3125d5d72959df93ae5786201df638abf53a9c58c6aee38db2a494ae783e778cb16461bd96274eb8587b6c38cc1e786c214e775875908dd3197cba552c95a9677f56004b4b7b0254ab5c81501ad0c5844e107c775ad18e1e7e0931cc06a543da2f8dc20415d07e973716b15f227240cc493280fd8e764404585dd72c682b4824cb50cfee9fe4c6b6c2e60f4f8b95bfc365dcca4b6dd7e190cbef76eaf92033b1270e2559e3aa4ded4503e1e80ea8242abe5e83733258472f2c4da1577376762b69b358aba6c729bf0c28d640c3a523d2e2929bdf229a29201138534c129548729e48a8ad5a4dd169ff6b4d7f7e290f2552155120fc9959e8dce47caa7fbda873b212bc004b14b43eeedb7c2cc89c745dc830b6d81c245a04e0008276f44894e3f7eb57ee62c79e9dc0b495a70e8e12077781d9aa108afe607c66d7a4172dbbfdb9dec3aee618b74853edcf67627da2db9036683cc82adf25a5f717fea8e8edf4f450d66b635324065e89e417f131e153ffceb9f72fdc4a406c5ec5e972bd4126f984e9fc89377f9f7fed38079f35bc1e897c7bd35ba468069e768d21d53a001e8356ea33d3f2ddce657de6c5689b1df30f8b92bd7214535156d7a9151f01ad1aca81b86620f9d08e18dfce6b8e44058054514216238c4775e438ba742f90c1669c1a80937eb5d12fe0d9c3f50937ec74f7c65bbe9cedb471406f95a5ee5094c7f00c530c1056239e0cd3ec8972307a84ee8822ff978f7d5441c16d22e7f9304bb7ac0e2f384208f1fc22c8ef491236bbed96f8e36678005cb88b388e459049c4c878fe8b94ac8685391cd1aabe636da09d02b3c4cc5797df670802104e795e653779791f82e107a359e972d0e26119ce12a3e5eaa179f06dec0c354de84e5025cb0942d31c31d40103e41bd937f5e2a6788e797820fcfdfdeef067737366c816d6ab18d9a5dc0e4f0ae55ffbe01e39299fc1fef2b4807e7c2b28cc22badb573cc38404f9bcb6382627d6714fbd70b34347e9c587e5e9634348342b54c9e1d47f470a1191f6825858a6140d4e73cea6a6d1c0b8b62533e9f83d445206c2b17795323246eea23091ccc2cc9b3bbeb22f71a1b82a7b4201dc8da40b018e5311471cdbce7c8064cc7fdb2fc5d0db485d220a390346eb4b0854ab4ca45b6f50972cf24118f6187950508ec550bcefb29661d744278c0c1a0280b2f57b71cf6e4214bf4cad440d51e83ba79d6b6a654795005479c4dc8eeac8a17430650a0a649498cfdf5d04c90389b9b7dae7a5e7142892b1ca74fc7832771c9ce0fb1d480f228a4167da4d086be6a0b83e024007c337a0ac1b9e463a643e2545cc1fcceb9a9c374159fd47413c4dfdb600abe22db7716cbb0a5cbdf1f48589c5e826ac52f33c126408d9107a79eeb17573c5645fbaa6ac54a36bf85ef6a259fe3be96b6ed939103918a81aa99a4341210cdb0b23423502431c67760927bcb24b0229f828d741ecbc82e37f7f1be6ca58c6a83c3d7d5922cdd6376f54f899622cd9528c4d5cac05e7f5f0e21e02b0ae2595746540370e2e1ce86d795986265cd1bf2fc69d41a37cc46b308c2fe6b9c0e5e0357b8f96d6b979b1144849fa8ce36c77c7833bc5cc11143e4ca1c1041f39079559187f5e38b5498a695ebbb8ed6ec38f7376497b76487a7bdae0eab2b411cf840b36312d9668f579d84f546ea13904b444b0659d9b5ea88b2274c105aeed46414aed0e6209e023076b860a4eea72ebd922d4933ab1a7d81c0c875f59257f0646c2e0a8a15674307c335f25ad3518b7c1ef9e24e99f54fd822b2f229da43ddbc3735f7d743d3ee97f4adeb6e8b527a6a9a15535d4e1bf3091e561161effd3aab6cf453e09d5bfdb85be7b8182f47594c080d88f85b22d1ac31607186564878b14071b1f42f575092394a2d47f814ee77d905ca7d960c6a3885c925a73a434bec9ca41563939d33541ab74ea50df1179d09d40916cd483f1bc39eec6c7bbaa91f4594438b6dee0b87d84e689b57a0f69f6b4fb2060178a25bd8a9d84da929100c1c7cb1a236a188d53b2673be86e425fc2abbb6b0205b59e3541b3fa43c4be1d5b2e321c51d41a88d7845e1c3f900792143b9c900b6b2d5f6ea9fa41bbb037160d84835496cf2835958ee6ff2653c7979730b14aa5f87351b80394664544474564a5df3aeee78c0f3754bc5e770d8b5a6142343f19958a4571ac843b7c367af9edd8223d9c6e5401f76837fc51fcc97e0cd907612c15eb24c7a3becbddb58d7ce4c706bf9f886339d53d61599d2b670190071519cfba10bbc3f50c8f25fd9c3bc63cf7dd548dbb99edfe80a22b08155b3fbd5b352550d1c5775e94c586a1030d63a84dd2799585825f2b31c13d607b06d7cd69d58880448217a0fb90cef23ba26c0a0d7d14cadbadc4287c28451087cda812f1bb532c4fc902d4773525b880209cae159f1aaec99240cc6d3c2f44b9c3c28727ffc78fbfd1fe885f472e8ed3796a6d1014859d0712a3fd3dae70d53e4242773482090c317155ad4bffa894465144d2ae15e66f84aa323cfa41b388cecea2bcb5d6d60a0030d97d6a57a98d0e998917694e4a5c57a36ce65c28b6280429f664dc3a621bb9d04d89adfcdcfc26e868f17e7a343a4a9d55f39f45fc9759b506b7aafac369fc202fce3959864c1919d8a146af5fa64c4da8f23775e24c26de2bde39cad86bd5cd478f9a5244965f23243da82459769ec6eda8fdb51146adb9c303c87665d8424cd6d3ddd3edcf1df573a66c6d45be33d5839114094f3e31ab6ab398af6a102f01feebeca6ea9ab496a41f3bd98e3adcad9a069ab5741914981a778ed539fa54351d88550b6973a0f1bd82dcfb521078bbe9fcc8ae648caeeb5f3a0106f583a56a6e7f103fc724839f6877adb5f387dabfa9a4264984630570ffcf8cedf3a4c7cdee218687030d56cdd3dcf5a195904b250b1a421ef28feaf5f1ad73a02f7f43b000f41e5ba50c379d9d4e9528ef119b0c73982bd9d058c9601b4a2e6db8264c15f0dc68de6af53cbd9df82b358939c2b4c68811b194a78f07d88566b17ee190c95520473e5ad9c3a04d06c3c162e552d43ea7d6d92810c3a1bf5d6ba2a4078349828a1500c11772e7091151ff6a7f29cdca8983d204266e84d2288c61d515a8236ef82251c00dd9d8267ed4a2e10dfacf46fed0f8fe116e5a2a8e81e6498b0c31c55e1a61328933062ee439deb54f403ef0384378aa554775341f99b49f32783831a1d92a192b7bdef87ba8f2d641da9f750384c4a5cead1c41e838d6fa92e02141d7c517be9416aaa307c74da2d11c2182b1966c54ac95dfcfe1c321d180d80ff9018eaa1fe93dfa171c52bc031822db5cf844bf6599999df4b5bcc86876c6534f3c5644b277c303c84aa08da1488ae120fd935415037dd5a3191f975c8bab5772d19e88ac8e7e9953d6fd9406c26891e787fb259033cab4364eefa17136e4e356cf9dd73c60fe42907a1844d004ab70f2e475c0e5f6820021d1e4c9b09c89132d8147383c21dd0ec292dfe7b20f37dd4700557713f5cce976752ce126d78c8e3e01fbbdeb5833b44b43a9a2cfeb7be7d2e45ff59fbf522fefe9339924f97548b8b7e2b9c58df465715e0a22c881a7cf7afd6b8719775992cdd45a7ef52431ad40b2bfb83553397cc47243718809cd8ae008798819e161532b55a6fc3fe528dc9e2a5311497c0f5c77d3ce680be0c1fb71962b4d8afa6da458ef523401b4dcbfa5f8ef1cbafb2fc708706edf9742c8c92e32ee6b32d010b9a9987681280c861d8307f3c12a52d078ee03c908657908bc4a03fa7c5d17ef828f893ed01c69152c720e42dfdd9bf5ea929c7dd260fdd720afcac244f6011cae7f17bbc9bb4d61cdc9d49f4b10d67318464e7a7b7e0fd09c024d7a41122c1ca63e43359ce1a25c8d5a5660dab4e7502cf75b7fe4b505e86e0e959626b886099a22c71e9f984c53cf993015f6355d7cae3105f706765320ae157871a033a108048f4228a6b5d5f91e772d6cf75ebecdcf761ed2b559d80a1c11bf80206acc1b3ec61bbc13369d1a79816c1d4a9f64acdd5a2d5049161829d30616ae08a6d243a5c262b868101496c4d62aebbefcde6f9f64737144a5adeef2f1ace6dc944e954dec0bd52ecf3bd558e502c4994fbe8391ccfd2b666a9d0af7c4362bd026dc30096816925d4fe744651406f237f70bab5cba3136462d4736301bcd73b651b073fcadce28f695a9535237def334c6a28e227ca334be1b8103ff3b97d3b08e7cfdcf078a87454956bf70a260a22e26ed096c0defb8471d56df8ad742a2405b5d49695290379ce538780b591f85615a9d6ed95c99507daca21960afaa6c988c6bd52749691477ec5b519aec121a0a7aaba2827c8bcb3c2a74a0f5720422bc39813b1062ee464a0caf271cb79a83cb49c20da512f97b5593d108e3c682e86a30b6f5fe2036f7a7dee60f2540cb4f444bbbc92364974c44aaeec028b99050aa06832202aa1f121cd0f759173eec0e7e0992ef06e0cfd5d3660455f044848077451d45e1f39fb2cc2c65dec1bb5e14b5c3f48da2e12c10e40515f470af4747559c3bbe6cbf1c872265f95c1985d97486476dfcd286427cef0baba6da62c09eacd6424f05ba13b4b86854790d930d2e1af06fc697aa3ff973245219d8489ef38b884c68bc6ff87ceea320a649667204f76e6d13370dc43f4cddeb088f2bd5476ea7b6fe08de1162390aa9ccd9759c1449b61b180476c536f14703258e2121360079746ff72be789b2dd6db7f947d59b4d7125eb816a272a0a75bca08e07387989bc0f6ba5ec8794652ccb12eff39f01a2ca68e9e87fef8203b30c8a126dfa33a56eb030d1f51f461a65adcfcef9fdc83c9facbf7aa42fa921e71a230da7f07e2f61c72983e1fdf2bc80af7864d22d974eb1877c0afe1ba3c68d055b214dc6d9286526163404d7d4de0932cbdc402a5c6119523c1594750c95ac32aa4c4a222d281a494159f45ecc36f36b123091ac94b54da26ab6b23adff3e8556578e1e0e81d1d229b79f3eb2c69eb9ed45bdf5b6089a622a8d3f23318456cc50c6bf7013a01ebd1e8d5faf2f596548fb73fd3588acdfb9b041359efa7e8f4c43345b1ba0b4deeff9d7430eaadb8830627aaae9ab305abc25cf5cd58f42eeeb9b742554e93de197a8f54a4f2d2d87b6ba221dbd1e02bf7bfdad858f007ca9ede6d5c9fb1dcb3e5235a7cf063adec8869c4eed1acc9c244e808a3a93e285225a577bb637f95110eb5a437ae752be2687d14b60dd57fec600d3d2a42397809ae4f0533445c07c0c05be91388f401f556576cc198ed5a3809daad1b082b8ff38dc940d57d99a9cdafda39890232f6fb91647f60db842085a98d84dd25c488021384504362bb0a22224359f736f07da2009e8715078df8a49486db7489dfc8b5fc14ced86054bb1428a1a1fc34fc199df84a795478847c466e39d7a4ea0415ac34240917e7b1f3652615203e33a5c3b556f74451ea55c7bfee9e2206b72fa0d2304cb848a5c2ec7c9a74e1e65f6b848bfe032de1e05952c5472d5a8c4a642ee0ad8f187393b485603e855a8404429cce397f8bc3d3f7686d8c860c77f576860107e7a00d8523ede35fd47692ba9cf846fc3921de31218889cac4a2e816f4e4c86020c05c72e43a02559077037fca067897d01903f63297ba58427acea3bae4a81bc38b17fdd84d5ebc48bcf9b534a1fe1eb77677936860c0230bc858989b73835ea8665039b1f7ac9d736125251f71668d1c3e8f792c7d3612e358b320365bb30a57226e9100cab94b93b3f07eca6d95dc2065cc5c5ffc98fcd1f616e1f5cb359ee69151d41af4824b732deb57dcb2c812aab6f3574af156754fef6706f29c210923a6191e52020d6c45e84691ec490f17df3fb6653778d66d47127e5c84c57c31ce743003724d8da4bf122f14c8cb2f7d8c575d7c329e1622272f280332bb23c6a7f7073e9521efdcc7e69f5b89bc18ea43b01cdfe9f7031da013c626bf36d6e8a5c1d2881d88b98856c00c2fbfaa5e9f1a12041602c469513a1b8336182695e30fb8b53c69c9b474d165fed95c388730446b8b932faea50b8194d7c3317c39f257a0a4da5e37915658cedc9a171a1a50fe1542f7dcab71bc19bfcd7620523efc175c32e89e40391395c5e7f733dc80ac84dd8e583deb2fb6fa1356f73690da2d8e6214ef2aa24dfcdb706edaa7ab0a1a1d543f5d7e92cdaeaf6e6f31026a38da8ec50013e304b484d4588d96efd03f0295f27ba0dd2ec9140665a09b013c96bbb2883e9a2f8ad318170a984cbc4eddc4fad299cb40bb853b3df8faf32c6ccc5b225cbf11208d0304a4b94dd8fecd4d6ce4a9b88522e0d8fca43d7f15ade0b3a9cc3f4895ce443c599036c51f419a23e26105ef5d2879151314434373b612142d125602e633f7d13b962b9063264248d2e347c65e9843ccc816c96460b02fec7b23472978f3220f56b0bb8f9d2f64bd6f4fa393a55627678224e4d321075fbd9c1494b246b2ca90b68bdaa218c7af6a1e76f9981423f2a6b6cdcb9f1ee3ceb35893221aa442b523780a58de0f085318befee0258e14361241216aa6167ecf2111e18b25b6c4cb069d85bb0f1f7d9fbfa2f00c9a5bc09c52cc7410f9c362a3b3a4a9bc7c0c7e56235205f0367acea2d629723a01d2f6246b59b729590f2f11624d9be9ddabceee117299b2b08f9fefd71754802f60dfeb42307e35f6646545fe42f369af0d6a5c61db5a72b4933cccf6710db9b9e65e4ed1a845074eeb6db31e973d76fffd3b1393594942a76806b739bdbeeb1d80856c78ab70a9cd016246df8a93437c4d35dc836f1070cab39302539b6c8305cc4969ee442c06b815c86a60b76c18e62901bd8d03405c2ade14a4e570184e04a0208a0b6b73715695a4f676b40ca2b7da28e55af5485609c759a51cae635e38794105fa31dbd39ca3bdab8f9e1e378213233e50d7427c34009ff72e93e6e0f4a8342e8765392291efd972b2dee1c819f9853e3aa4960f091a45921d37f29719ecd16e86f838906d2a718790348c06318849e87dd122ae08d4f8f7ff7de4f52cbc1bcd2816703a8a9c0c4ebfb9a49d60434b48b19c317d685e37aa0c6b3aa1eb2ca7cbfd207b295c3c38fb388002e5db7f2c175b015bfe7e1dc06792c76586b9ec57e3f480092e3db4dd6bfc79bca212acfebea3ed7c8cc4ee88e63d4e095947dda678a997e5ce98ae442e252d701574be49070b69dd9d8e4e405ad4e5619f5e1045ff6d208dbed0a53fb8e36cf62e9092b6339f78048bbb30cfea54e0df573b5fbfc219abcbe6d90532063280c80cf8c93fb3346da7ac29bd276b3479e687611b9d744fba</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码才能查看哟~.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Cryptology</category>
      
      <category>Asymmetry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>非对称加密</tag>
      
      <tag>公钥</tag>
      
      <tag>私钥</tag>
      
      <tag>模数</tag>
      
      <tag>指数</tag>
      
      <tag>质数</tag>
      
      <tag>Cryptology</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA非对称加密原理</title>
    <link href="/doc/a3f58b37.html"/>
    <url>/doc/a3f58b37.html</url>
    
    <content type="html"><![CDATA[<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。</p><span id="more"></span><h1 id="RSA非对称加密原理"><a href="#RSA非对称加密原理" class="headerlink" title="RSA非对称加密原理"></a>RSA非对称加密原理</h1><p>RSA非堆成加密算法利用了大数求模运算实现。这里只讲加解密原理，不讲具体的推到证明。若有需要请转到<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰的网络日志</a><br>.</p><h2 id="密钥的生成步骤"><a href="#密钥的生成步骤" class="headerlink" title="密钥的生成步骤"></a>密钥的生成步骤</h2><ol><li>随机选择两个不相等的质数p和q。（一般情况下这两个质数都是非常大的。实际应用中，这两个质数越大，就越难破解。）</li><li>计算p和q的乘积n。($φ(n) &#x3D; (p-1)(q-1)$)</li><li>计算n的欧拉函数φ(n)。</li><li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</li><li>计算e对于φ(n)的模反元素d。($ed ≡ 1 (mod φ(n))$ 等价于 $ed - 1 &#x3D; kφ(n)$)</li><li>将n和e封装成公钥，n和d封装成私钥。</li></ol><h2 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h2><p>上述步骤出现的六个数字中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p><h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><ul><li>加密要用公钥 (n,e),公式为：$me ≡ c (mod n)$</li><li>解密要用私钥(n,d),公式为：$cd ≡ m (mod n)$</li></ul><h2 id="Java生成RSA密钥对"><a href="#Java生成RSA密钥对" class="headerlink" title="Java生成RSA密钥对"></a>Java生成RSA密钥对</h2><ul><li>生成KeySize为2048bit的RSA密钥对  <figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String KEY_ALGORITHM &#x3D; &quot;RSA&quot;;&#x2F;&#x2F;获得对象 KeyPairGenerator 参数 RSA 2048个字节KeyPairGenerator keyPairGen &#x3D; KeyPairGenerator.getInstance(KEY_ALGORITHM);keyPairGen.initialize(2048);&#x2F;&#x2F;通过对象 KeyPairGenerator 获取对象KeyPairKeyPair pair &#x3D; keyPairGen.generateKeyPair();&#x2F;&#x2F;通过对象 KeyPair 获取RSA公私钥对象RSAPublicKey RSAPrivateKeyPrivateKey privateKey2048 &#x3D; pair.getPrivate();PublicKey publicKey2048 &#x3D; pair.getPublic();</code></pre></div></figure></li><li>写入到文件(Hutool工具)  <figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">PemUtil.writePemObject(&quot;RSA PRIVATE KEY&quot;, privateKey2048.getEncoded(), FileUtil.getOutputStream(&quot;private_key.pem&quot;));PemUtil.writePemObject(&quot;RSA PUBLIC KEY&quot;, publicKey2048.getEncoded(), FileUtil.getOutputStream(&quot;public_key.pem&quot;));</code></pre></div></figure></li><li></li></ul><h2 id="发行证书"><a href="#发行证书" class="headerlink" title="发行证书"></a>发行证书</h2><p>CA证书（根证书）的特点就是自签发：</p><ol><li>颁发者信息与使用者信息一致</li><li>基本约束带有CA标识</li><li>使用证书含有公钥对应的私钥对自己进行证书签发</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** *  根据如下参数获取对应base64编码格式的证书文件字符串 *      issuerName 与 reqName 对象是同一个则认为生成的是CA证书 * @param issuerName 颁发者信息 * @param reqName   请求证主题信息 *                  &lt;br&gt; issuerName &#x3D;&#x3D; reqName ---&gt; CA * @param serial 证书序列号 *                 &lt;br&gt;eg: BigInteger serial &#x3D; BigInteger.valueOf(System.currentTimeMillis() &#x2F; 1000); * @param notBefore 有效期开始时间  2018-08-01 00:00:00 * @param notAfter 有效期截至时间   2028-08-01 00:00:00 * @param userPublicKey 请求者主题公钥信息 * @param rootPrivateKey   颁发者私钥信息 * @return String * @throws OperatorCreationException * @throws CertificateException * @throws IOException *&#x2F;public static String certBuilder(X500Name issuerName, X500Name reqName, BigInteger serial, Date notBefore, Date notAfter, PublicKey userPublicKey, PrivateKey rootPrivateKey) throws OperatorCreationException, CertificateException, IOException &#123;  JcaX509v3CertificateBuilder x509v3CertificateBuilder &#x3D; new JcaX509v3CertificateBuilder(          issuerName, serial, notBefore, notAfter, reqName, userPublicKey);  &#x2F;&#x2F; 签发者 与 使用者 信息一致则是CA证书生成，增加CA 基本约束属性  if(issuerName &#x3D;&#x3D; reqName)&#123;      BasicConstraints constraint &#x3D; new BasicConstraints(1);      x509v3CertificateBuilder.addExtension(Extension.basicConstraints, false, constraint);  &#125;  &#x2F;&#x2F;签名的工具  ContentSigner signer &#x3D; new JcaContentSignerBuilder(&quot;SHA256WITHRSA&quot;).setProvider(&quot;BC&quot;).build(rootPrivateKey);  &#x2F;&#x2F;触发签名产生用户证书  X509CertificateHolder x509CertificateHolder &#x3D; x509v3CertificateBuilder.build(signer);  JcaX509CertificateConverter certificateConverter &#x3D; new JcaX509CertificateConverter();  certificateConverter.setProvider(&quot;BC&quot;);  Certificate userCertificate &#x3D; certificateConverter.getCertificate(x509CertificateHolder);  String certStr &#x3D; genCert(userCertificate);  return certStr;&#125;&#x2F;** * 签发CA证书 *&#x2F;public void genCaCertTest() throws Exception&#123;  &#x2F;&#x2F;根证书Issue基本信息  X500Name issuerName &#x3D; getX500Name(&quot;Dev&quot;, &quot;VK&quot;, &quot;BeiJing&quot;, &quot;BeiJing&quot;, &quot;CN&quot;, &quot;R&amp;D&quot;);  &#x2F;&#x2F; 证书序列号  BigInteger serial &#x3D; BigInteger.valueOf(System.currentTimeMillis() &#x2F; 1000);  &#x2F;&#x2F;证书有 起始日期 与 结束日期  SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  Date notBefore &#x3D; sdf.parse(&quot;2018-08-01 00:00:00&quot;);  Date notAfter &#x3D; sdf.parse(&quot;2028-08-01 00:00:00&quot;);    &#x2F;&#x2F;构建 用户证书 对应的公钥  PublicKey userPublicKey &#x3D; getPublicKey(16,publicRootMudulus,publicRootexpoent);  &#x2F;&#x2F;构建CAroot证书 对应的私钥  PrivateKey rootPrivateKey &#x3D; getPrivateKey(16,publicRootMudulus,publicRootexpoent);  &#x2F;&#x2F;构建证书的build  String cert &#x3D; certBuilder(issuerName, issuerName, serial, notBefore, notAfter, userPublicKey, rootPrivateKey);  System.out.println(&quot;\n&quot;+cert);&#125;</code></pre></div></figure><p>签发用户证书的特点：</p><ol><li>这里要用用户证书的公钥以及请求信息，使用CA证书的私钥做签名达到证书结果。</li><li>签发证书的颁发者信息 要与生成ca证书时的签发信息一致，不然会出错。证书链验证不过。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 生成用户证书 *&#x2F;public void genUserCertTest() throws Exception&#123;   &#x2F;&#x2F;根证书Issue基本信息   X500Name issuerName &#x3D; getX500Name(&quot;Dev&quot;, &quot;Vk&quot;, &quot;BeiJing&quot;, &quot;BeiJing&quot;, &quot;CN&quot;, &quot;R&amp;D&quot;);   &#x2F;&#x2F; 用户证书 基本使用者   X500Name reqName &#x3D; getX500Name(&quot;vkuser&quot;, &quot;vkuser&quot;, &quot;BeiJing&quot;, &quot;BeiJing&quot;, &quot;CN&quot;, &quot;R&amp;D&quot;);   &#x2F;&#x2F; 证书序列号   BigInteger serial &#x3D; BigInteger.valueOf(System.currentTimeMillis() &#x2F; 1000);   &#x2F;&#x2F;证书 起始日期 与 结束日期   SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);   Date notBefore &#x3D; sdf.parse(&quot;2018-08-02 00:00:00&quot;);   Date notAfter &#x3D; sdf.parse(&quot;2028-07-01 00:00:00&quot;);   &#x2F;&#x2F;构建 用户证书 对应的公钥   PublicKey userPublicKey &#x3D; getPublicKey(16,publicUserMudulus,publicUserexpoent);   &#x2F;&#x2F;构建CAroot证书 对应的私钥   PrivateKey rootPrivateKey &#x3D; getPrivateKey(16,publicRootMudulus,privateRootexpoent);   &#x2F;&#x2F;构建证书的build   String cert &#x3D; certBuilder(issuerName, reqName, serial, notBefore, notAfter, userPublicKey, rootPrivateKey);   System.out.println(&quot;\n&quot;+cert);&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Cryptology</category>
      
      <category>Asymmetry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>非对称加密</tag>
      
      <tag>公钥</tag>
      
      <tag>私钥</tag>
      
      <tag>模数</tag>
      
      <tag>指数</tag>
      
      <tag>质数</tag>
      
      <tag>Cryptology</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Console API</title>
    <link href="/doc/66ed7485.html"/>
    <url>/doc/66ed7485.html</url>
    
    <content type="html"><![CDATA[<p>控制台由一个输入缓冲区和一个或多个屏幕缓冲区组成。 输入缓冲区包含输入记录的队列，其中每个队列都包含有关输入事件的信息。<br>输入队列始终包含按键和键释放事件。 它还可能包含鼠标事件 (指针移动、按钮按下和释放) 和事件，用户操作在此期间影响活动屏幕缓冲区的大小。<br>屏幕缓冲区是一个在控制台窗口中输出的二维字符和颜色数据数组。 任意数量的进程都可以共享控制台。</p><span id="more"></span><h2 id="对Console的理解"><a href="#对Console的理解" class="headerlink" title="对Console的理解"></a>对Console的理解</h2><p>官方一般都是长篇大论，这里记录一下我对Console的理解：</p><p>Console主要包括两个部分：</p><ul><li>InputBufferArea</li><li>OutputBufferArea</li></ul><p>所以对Console而言，其内部就是多个封装好的内存空间需求按照一定的规则使用而已。针对Console的函数主要包括以下几个：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow">GetConsoleWindow</a> 获取与调用进程关联的控制台使用的窗口句柄。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a> 获取标准输入、标准输出或标准错误设备的句柄。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 设置标准输入、标准输出或标准错误设备的句柄。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/allocconsole">AllocConsole</a> 申请新的终端</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolecp">GetConsoleCP</a> 获取控制台使用的输入代码页。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolecp">SetConsoleCP</a> 设置与调用进程关联的控制台使用的输入代码页。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsoledisplaymode">GetConsoleDisplayMode</a> 获取当前控制台的显示模式</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsoleoriginaltitle">GetConsoleOriginalTitle</a> 获取当前控制台窗口的原始标题。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsoletitle">GetConsoleTitle</a> 获取当前控制台窗口的标题。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsoletitle">SetConsoleTitle</a> 设置当前控制台窗口的标题。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsoleoutputcp">GetConsoleOutputCP</a> 获取与调用进程关联的控制台使用的输出代码页。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> 设置与调用进程关联的控制台使用的输出代码页。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsoleselectioninfo">GetConsoleSelectionInfo</a> 获取有关当前控制台选择的信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getcurrentconsolefont">GetCurrentConsoleFont</a> 获取有关当前控制台字体的信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getcurrentconsolefontex">GetCurrentConsoleFontEx</a> 获取有关当前控制台字体的扩展信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setcurrentconsolefontex">SetCurrentConsoleFontEx</a> 设置有关当前控制台字体的扩展信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getnumberofconsolemousebuttons">GetNumberOfConsoleMouseButtons</a> 获取当前控制台使用的鼠标上的按钮数。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsoleactivescreenbuffer">SetConsoleActiveScreenBuffer</a> 将指定的屏幕缓冲区设置为当前显示的控制台屏幕缓冲区。</li></ul><p>对Child Console的支持如下：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/console/createpseudoconsole">CreatePseudoConsole</a> 创建一个子终端</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/closepseudoconsole">ClosePseudoConsole</a> 关闭子终端</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/resizepseudoconsole">ResizePseudoConsole</a> 将伪容器的内部缓冲区大小调整为给定大小。</li></ul><h2 id="BufferArea-缓冲区"><a href="#BufferArea-缓冲区" class="headerlink" title="BufferArea(缓冲区)"></a>BufferArea(缓冲区)</h2><p>缓冲区，也就是内存。数据通过缓冲区传递到各个地方，比如：文件中、屏幕上、打印机打印等。</p><p>当然上述例子中都是输出缓冲区，输入缓冲区所做的就是对数据的一个暂存。以方便我们来读取而已。<br>这里的读取也就是事件处理（键盘事件、鼠标事件等），根据事件类型来实现不同的效果。<br>像在屏幕上输入文字、写入到文件、作为控制信号（比如按<code>ESC</code>退出程序等）等。</p><h3 id="InputBufferArea-输入缓冲区"><a href="#InputBufferArea-输入缓冲区" class="headerlink" title="InputBufferArea(输入缓冲区)"></a>InputBufferArea(输入缓冲区)</h3><p>在Console中输入缓冲区就只有一个，所以针对输入缓冲区的操作而言就很简单，主要包括以下几个函数：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/console/flushconsoleinputbuffer">FlushConsoleInputBuffer</a> 刷新控制台输入缓冲区。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getnumberofconsoleinputevents">GetNumberOfConsoleInputEvents</a> 获取控制台输入缓冲区中未读的输入记录数。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/peekconsoleinput">PeekConsoleInput</a> 从指定的控制台输入缓冲区读取数据，而无需将其从缓冲区中删除。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsole">ReadConsole</a> 从控制台输入缓冲区读取字符输入，并将其从缓冲区中删除。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleinput">ReadConsoleInput</a> 从控制台输入缓冲区读取数据，并将其从缓冲区中删除。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleinput">WriteConsoleInput</a> 将数据直接写入控制台输入缓冲区。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleinputex">ReadConsoleInputEx</a> 从控制台输入缓冲区读取数据，并将其从缓冲区中删除，并具有可配置的行为。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a> 从调用进程的处理程序函数列表中添加或删除应用程序定义的 HandlerRoutine 。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/handlerroutine">HandlerRoutine</a> 与 SetConsoleCtrlHandler 函数一起使用的应用程序定义函数。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolemode">GetConsoleMode</a> 获取主机输入缓冲区的当前输入模式或控制台屏幕缓冲区的当前输出模式。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolemode">SetConsoleMode</a> 设置控制台输入缓冲区的输入模式或控制台屏幕缓冲区的输出模式。</li></ul><h3 id="OutputBufferArea-输出缓冲区"><a href="#OutputBufferArea-输出缓冲区" class="headerlink" title="OutputBufferArea(输出缓冲区)"></a>OutputBufferArea(输出缓冲区)</h3><p>输出缓冲区，我把它成为Console的场景，因为我们可以手动的创建多个输出缓冲区，并给终端更换当前显示的缓冲区，达到一个游戏进入下一关切换场景的效果。输出缓冲区主要包括以下几个函数：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/console/createconsolescreenbuffer">CreateConsoleScreenBuffer</a> 创建控制台屏幕缓冲区。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/fillconsoleoutputattribute">FillConsoleOutputAttribute</a> 设置指定数量的字符单元格的文本和背景色属性。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/fillconsoleoutputcharacter">FillConsoleOutputCharacter</a> 将字符按指定数量写入输出缓冲区。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolecursorinfo">GetConsoleCursorInfo</a> 获取指定控制台屏幕缓冲区游标的大小和可见性信息</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolecursorinfo">SetConsoleCursorInfo</a> 设置指定控制台屏幕缓冲区的游标的大小和可见性。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolefontsize">GetConsoleFontSize</a> 获取指定控制台屏幕缓冲区使用的字体大小</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolescreenbufferinfo">GetConsoleScreenBufferInfo</a> 获取有关指定控制台屏幕缓冲区的信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolescreenbufferinfoex">GetConsoleScreenBufferInfoEx</a> 获取有关指定控制台屏幕缓冲区的扩展信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolescreenbufferinfoex">SetConsoleScreenBufferInfoEx</a> 设置有关指定控制台屏幕缓冲区的扩展信息。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getlargestconsolewindowsize">GetLargestConsoleWindowSize</a> 获取最大可能控制台窗口的大小。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/scrollconsolescreenbuffer">ScrollConsoleScreenBuffer</a> 在屏幕缓冲区中移动数据块。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolecursorposition">SetConsoleCursorPosition</a> 设置指定控制台屏幕缓冲区中的光标位置。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsoledisplaymode">SetConsoleDisplayMode</a> 设置指定控制台屏幕缓冲区的显示模式。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolemode">GetConsoleMode</a> 获取主机输入缓冲区的当前输入模式或控制台屏幕缓冲区的当前输出模式。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolemode">SetConsoleMode</a> 设置控制台输入缓冲区的输入模式或控制台屏幕缓冲区的输出模式。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolescreenbuffersize">SetConsoleScreenBufferSize</a> 更改指定控制台屏幕缓冲区的大小。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsoletextattribute">SetConsoleTextAttribute</a> 设置写入控制台屏幕缓冲区的字符的前景 (文本) 和背景色属性。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/setconsolewindowinfo">SetConsoleWindowInfo</a> 设置控制台屏幕缓冲区窗口的当前大小和位置。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/writeconsole">WriteConsole</a> 从当前光标位置开始，将字符串写入控制台屏幕缓冲区。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleoutput">ReadConsoleOutput</a> 从控制台屏幕缓冲区中字符单元格的矩形块读取字符和颜色属性数据。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleoutput">WriteConsoleOutput</a> 将字符和颜色属性数据写入控制台屏幕缓冲区中字符单元格的指定矩形块。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleoutputattribute">ReadConsoleOutputAttribute</a> 从控制台屏幕缓冲区的连续单元格复制指定的前景和背景色属性。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleoutputattribute">WriteConsoleOutputAttribute</a> 将许多前景和背景色属性复制到控制台屏幕缓冲区的连续单元格。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleoutputcharacter">ReadConsoleOutputCharacter</a> 从控制台屏幕缓冲区的连续单元格复制多个字符。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleoutputcharacter">WriteConsoleOutputCharacter</a> 将多个字符复制到控制台屏幕缓冲区的连续单元格。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>kernel API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Windows</tag>
      
      <tag>Console</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile的使用</title>
    <link href="/doc/fd3c199a.html"/>
    <url>/doc/fd3c199a.html</url>
    
    <content type="html"><![CDATA[<p><code>Dockerfile</code>是一个文本文档，其中包含了用户自定义镜像组装的打包规则，之后用户使用<code>docker build</code>指令就可以完成镜像的构建。</p><span id="more"></span><h2 id="Dockerfile格式"><a href="#Dockerfile格式" class="headerlink" title="Dockerfile格式"></a>Dockerfile格式</h2><p><code>Dockerfile</code>的格式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"># 注释INSTRUCTION arguments</code></pre></div></figure><p>在<code>Dockerfile</code>中，指令是不区分大小写的。但是我们通常会以大写来表示指令，这样更容易区分。<br><code>Dockerfile</code>中的指令是按顺序执行的。并且开头必须是<code>FROM</code>指令（当然解析器指令、<code>ARG</code>指令和注释除外），<code>FROM</code>指令代表本次打包的镜像以什么镜像为基础。<br>例如：<code>FROM nginx</code> 就代表我们要以Nginx镜像为基础去构建我们的镜像</p><blockquote><p>常见的基础镜像：</p></blockquote><table><thead><tr><th>指令</th><th>意义</th></tr></thead><tbody><tr><td>FROM scratch</td><td>不以任何镜像为基础，俗称空镜像</td></tr><tr><td>FROM alpine</td><td>以alpine Linux镜像为基础</td></tr><tr><td>FROM ubuntu</td><td>以ubuntu Linux镜像为基础</td></tr><tr><td>FROM nginx</td><td>以Nginx镜像为基础</td></tr><tr><td>FROM redis</td><td>以Redis镜像为基础</td></tr><tr><td>FROM mongo</td><td>以MongoDB镜像为基础</td></tr><tr><td>FROM mysql</td><td>以Mysql镜像为基础</td></tr><tr><td>FROM httpd</td><td>以Httpd镜像为基础</td></tr><tr><td>FROM php</td><td>以PHP镜像为基础</td></tr><tr><td>FROM tomcat</td><td>以Tomcat镜像为基础</td></tr><tr><td>FROM node</td><td>以NodeJs环境镜像为基础</td></tr><tr><td>FROM oraclejdk</td><td>以OracleJDK环境镜像为基础</td></tr><tr><td>FROM openjdk</td><td>以OpenJDK环境镜像为基础</td></tr><tr><td>FROM python</td><td>以Python环境镜像为基础</td></tr><tr><td>FROM ruby</td><td>以Ruby环境镜像为基础</td></tr><tr><td>FROM golang</td><td>以Go环境镜像为基础</td></tr><tr><td>FROM eclipse-temurin</td><td>以开源Java运行环境镜像为基础</td></tr></tbody></table><h3 id="解析器指令介绍"><a href="#解析器指令介绍" class="headerlink" title="解析器指令介绍"></a>解析器指令介绍</h3><p>解析器指令会影响后续<code>Dockerfile</code>中指令的处理方式。解析器指令不会添加到层的构建中，并且不会在构建步骤中显示。<br>解析器指令以<code># directive=value</code>。一个指令只能使用一次。一旦处理了注释、空行或构建器指令，Docker 就不再寻找解析器指令。<br>它会将任何类似于<code># directive=value</code>这样的指令视为注释，并且不会验证它是否可能是解析器指令。因此，所有解析器指令都必须位于<code>Dockerfile</code>行首。<br>解析器指令不区分大小写。我们一般是小写的。约定也是在任何解析器指令之后包含一个空行。并且解析器指令不支持换行符。<br>解析器指令目前只提供了两个<code>syntax</code>和<code>escape</code>，这些指令几乎用不上，所以在这里就不在说明使用方法了。需要了解的可以去<a href="https://docs.docker.com/engine/reference/builder/#parser-directives">官网查看</a></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量（用<code>ENV</code>指令声明）可以在<code>Dockerfile</code>中做到类似于变量的效果。<br>在<code>Dockerfile</code>中我们可以通过<code>$variable_name</code>或<code>$&#123;variable_name&#125;</code>去使用变量。</p><blockquote><p><code>$&#123;variable_name&#125;</code> 还支持一些<code>bash</code>语法：</p><ul><li><code>$&#123;variable:-word&#125;</code>表示如果<code>variable</code>已设置，则结果将是该值。如果<code>variable</code>未设置，则将是<code>word</code>。 </li><li><code>$&#123;variable:+word&#125;</code>表示如果<code>variable</code>设置则值为<code>word</code>，否则为空字符串。</li></ul><p>在所有情况下，<code>word</code>都可以是任何字符串，包括附加的环境变量。<br>可以通过在变量之前添加<code>\</code>来进行转义：<code>\$fooor</code>、<code>\$&#123;foo&#125;</code>，例如，将分别转换为<code>$foo</code>和<code>$&#123;foo&#125;</code>。</p></blockquote><p>环境变量可支持以下指令：</p><ul><li>ADD</li><li>COPY</li><li>ENV</li><li>EXPOSE</li><li>FROM</li><li>LABEL</li><li>STOPSIGNAL</li><li>USER</li><li>VOLUME</li><li>WORKDIR</li><li>ONBUILD（与上述支持的指令之一结合使用时）</li></ul><h3 id="dockerignore文件"><a href="#dockerignore文件" class="headerlink" title=".dockerignore文件"></a><code>.dockerignore</code>文件</h3><p>与<code>.gitignore</code>类似，可以排除一些匹配的文件，使其不存在与构建空间内。</p><blockquote><p>指令相关介绍请参考<a href="https://docs.docker.com/engine/reference/builder/#from">官方介绍</a></p></blockquote><h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><blockquote><p>当前场景为go服务器部署，此时有两种方案进行镜像生成及运行</p></blockquote><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM alpine:latestWORKDIR &#x2F;usr&#x2F;local&#x2F;bin# 拷贝编译好的二进制文件COPY .&#x2F;main &#x2F;usr&#x2F;local&#x2F;bin&#x2F;&lt;filename&gt;# 暴露端口EXPOSE 8899# 执行指令CMD [&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;&lt;filename&gt;&quot;]</code></pre></div></figure><h3 id="交叉编译运行"><a href="#交叉编译运行" class="headerlink" title="交叉编译运行"></a>交叉编译运行</h3><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"># 第一个阶段：编译 Go 程序FROM golang:alpine AS builderWORKDIR $GOPATH&#x2F;src&#x2F;&lt;project-name&gt;# 将代码加入到镜像中ADD . .&#x2F;# 设置交叉编译环境ENV CGO_ENABLED&#x3D;0ENV GOOS&#x3D;linuxENV GOARCH&#x3D;amd64ENV GO111MODULE&#x3D;onENV GOPROXY&#x3D;&quot;https:&#x2F;&#x2F;goproxy.io&quot;# 编译程序RUN go build -o &lt;filename&gt; .# 第二个阶段：运行程序FROM alpine:latest# 拷贝编译好的二进制文件COPY --from&#x3D;builder &#x2F;go&#x2F;src&#x2F;&lt;project-name&gt;&#x2F;&lt;filename&gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;&lt;filename&gt;# 暴露端口EXPOSE 8899# 执行指令CMD [&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;&lt;filename&gt;&quot;]</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-高效打包Images</title>
    <link href="/doc/83b87764.html"/>
    <url>/doc/83b87764.html</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-高效打包Images"><a href="#SpringBoot-高效打包Images" class="headerlink" title="SpringBoot-高效打包Images"></a>SpringBoot-高效打包Images</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>虽然将一个Jar打包为镜像很容易，只需一个基础JRE镜像就可生成一个SpringBoot项目镜像。<br>但这种方式创建出的镜像过于臃肿，升级下一个版本仍需重新将Jar打包到镜像中。</p><p>我们知道Docker镜像是分层打包的，所以我们可以将一些基础内容封装到基镜像中，之后更新部分用另一层处理。</p><h2 id="解析SpringBoot-Jar"><a href="#解析SpringBoot-Jar" class="headerlink" title="解析SpringBoot Jar"></a>解析SpringBoot Jar</h2><p>一般情况下，我们运行SpringBoot项目就是打一个Jar包并通过<code>java -jar *.jar</code>指令去运行。<br>但其实我们还可以将Jar包解压后再运行，这样的话方便我们对项目进行热部署和分层打包。</p><p>我们来打一个样例Jar来看看里面的内容，只要一个基础的接口功能即可：</p><figure><div class="code-wrapper"><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">qz-demo.jar├─BOOT-INF│  ├─classes│  │  └─com│  │      └─example│  │          └─qz│  │              └─config│  └─lib├─META-INF│  └─maven│      └─com.example│          └─qz└─org    └─springframework        └─boot            └─loader                ├─archive                ├─data                ├─jar                ├─jarmode                └─util</code></pre></div></figure><p>解压后是上述样子，我们可以看一下 <strong>BOOT-INF</strong> 是我们真正的项目代码、<br><strong>META-INF</strong> 是一些源信息、剩下的就是SpringBoot编译出来的基础文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA&#x2F;&#x2F; (powered by FernFlower decompiler)&#x2F;&#x2F;package org.springframework.boot.loader;import org.springframework.boot.loader.archive.Archive;public class JarLauncher extends ExecutableArchiveLauncher &#123;    static final Archive.EntryFilter NESTED_ARCHIVE_ENTRY_FILTER &#x3D; (entry) -&gt; &#123;        return entry.isDirectory() ? entry.getName().equals(&quot;BOOT-INF&#x2F;classes&#x2F;&quot;) : entry.getName().startsWith(&quot;BOOT-INF&#x2F;lib&#x2F;&quot;);    &#125;;    public JarLauncher() &#123;    &#125;    protected JarLauncher(Archive archive) &#123;        super(archive);    &#125;    protected boolean isPostProcessingClassPathArchives() &#123;        return false;    &#125;    protected boolean isNestedArchive(Archive.Entry entry) &#123;        return NESTED_ARCHIVE_ENTRY_FILTER.matches(entry);    &#125;    protected String getArchiveEntryPathPrefix() &#123;        return &quot;BOOT-INF&#x2F;&quot;;    &#125;    public static void main(String[] args) throws Exception &#123;        (new JarLauncher()).launch(args);    &#125;&#125;</code></pre></div></figure><p>从<code>org.springframework.boot.loader.JarLauncher</code>这个类中我们可以看到，它是我们程序的入口。<br>也就是我们通过<code>java -jar</code>执行的入口。不难看出这里定义了代码与依赖的文件位置。</p><p>打开<code>BOOT-INF</code>可以看到有两个<code>*.idx</code>文件，<code>classpath.idx</code>文件中定义了所有依赖的 <em>lib</em> :</p><figure><div class="code-wrapper"><pre class="line-numbers language-idx" data-language="idx"><code class="language-idx">- &quot;BOOT-INF&#x2F;lib&#x2F;lombok-1.18.24.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-boot-2.7.1.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-boot-autoconfigure-2.7.1.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;logback-classic-1.2.11.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;logback-core-1.2.11.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;log4j-to-slf4j-2.17.2.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;log4j-api-2.17.2.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jul-to-slf4j-1.7.36.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jakarta.annotation-api-1.3.5.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;snakeyaml-1.30.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-context-support-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-beans-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-context-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-tx-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;quartz-2.3.2.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;mchange-commons-java-0.2.15.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;slf4j-api-1.7.36.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-databind-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-annotations-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-core-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-datatype-jdk8-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-datatype-jsr310-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;jackson-module-parameter-names-2.13.3.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;tomcat-embed-core-9.0.64.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;tomcat-embed-el-9.0.64.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;tomcat-embed-websocket-9.0.64.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-web-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-webmvc-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-aop-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-expression-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-core-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-jcl-5.3.21.jar&quot;- &quot;BOOT-INF&#x2F;lib&#x2F;spring-boot-jarmode-layertools-2.7.1.jar&quot;</code></pre></div></figure><p>可以看到这些都是我们初始创建SpringBoot项目所依赖的基础Jar。<br><code>layers.idx</code>文件中定义了项目的一些依赖信息:</p><figure><div class="code-wrapper"><pre class="line-numbers language-idx" data-language="idx"><code class="language-idx">- &quot;dependencies&quot;:  - &quot;BOOT-INF&#x2F;lib&#x2F;&quot;- &quot;spring-boot-loader&quot;:  - &quot;org&#x2F;&quot;- &quot;snapshot-dependencies&quot;:- &quot;application&quot;:  - &quot;BOOT-INF&#x2F;classes&#x2F;&quot;  - &quot;BOOT-INF&#x2F;classpath.idx&quot;  - &quot;BOOT-INF&#x2F;layers.idx&quot;  - &quot;META-INF&#x2F;&quot;</code></pre></div></figure><p>剩下的两个文件相信都很熟悉，这里我就不在赘述。</p><p>Java提供了解压Jar包的功能，我们可以用<code>jar -xf *.jar</code>来解压Jar包。<br>并通过<code>java org.springframework.boot.loader.JarLauncher</code>的方式来运行我们的项目。<br>这样的运行方式，相对与Jar的运行要快上一些，当然也方便我们以后做热部署之类的功能。</p><p>当然除了上述的启动方式外，你还可以直接运行自己写好的<code>SpringBootApplication</code>类来启动。<br><code>java -cp BOOT-INF/classes:BOOT-INF/lib/* com.example.qz.SpringbootQzDemoApplication</code>像这样。</p><blockquote><p>当然用 JarLauncher 运行具有可预测的类路径顺序的好处。<br>Jar 包含一个 classpath.idx 文件，JarLauncher 在构建类路径时使用该文件。</p></blockquote><h2 id="分层打包Image"><a href="#分层打包Image" class="headerlink" title="分层打包Image"></a>分层打包Image</h2><p>为了更容易创建优化的 Docker 镜像，Spring Boot 支持向 Jar 中添加层索引文件。<br>它提供了层列表和应包含在其中的 Jar 的部分。索引中的层列表是根据应将层添加到 Docker&#x2F;OCI 映像的顺序进行排序的。<br>也就是之前提到的<code>layers.idx</code>这个文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM eclipse-temurin:11-jre as builderWORKDIR applicationARG JAR_FILE&#x3D;target&#x2F;*.jarCOPY $&#123;JAR_FILE&#125; application.jarRUN java -Djarmode&#x3D;layertools -jar application.jar extractFROM eclipse-temurin:11-jreWORKDIR applicationCOPY --from&#x3D;builder application&#x2F;dependencies&#x2F; .&#x2F;COPY --from&#x3D;builder application&#x2F;spring-boot-loader&#x2F; .&#x2F;COPY --from&#x3D;builder application&#x2F;snapshot-dependencies&#x2F; .&#x2F;COPY --from&#x3D;builder application&#x2F;application&#x2F; .&#x2F;ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]</code></pre></div></figure><p>假设Dockerfile的路径为项目根路径，我们可以通过<code>docker build .</code>来开始编译过程。</p><blockquote><p>或者使用<code>docker build --build-arg JAR_FILE=path/to/myapp.jar .</code>来编译也是可以的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>镜像打包</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BunJS环境搭建</title>
    <link href="/doc/206111a7.html"/>
    <url>/doc/206111a7.html</url>
    
    <content type="html"><![CDATA[<p>Build faster with Bun.</p><span id="more"></span><blockquote><p>官网: <a href="https://bun.sh/">https://bun.sh/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Develop, test, run, and bundle JavaScript &amp; TypeScript projects—all with Bun. Bun is an all-in-one JavaScript runtime &amp; toolkit designed for speed, complete with a bundler, test runner, and Node.js-compatible package manager.</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Mac、Linux-or-WSL"><a href="#Mac、Linux-or-WSL" class="headerlink" title="Mac、Linux or WSL"></a>Mac、Linux or WSL</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -fsSL https:&#x2F;&#x2F;bun.sh&#x2F;install | bash</code></pre></div></figure><h3 id="Windows-Docker"><a href="#Windows-Docker" class="headerlink" title="Windows + Docker"></a>Windows + Docker</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull oven&#x2F;bun#绑定了当前路径，可以直接运行当前路径下的代码docker run --rm --init --ulimit memlock&#x3D;-1:-1 -v &quot;$&#123;PWD&#125;:&#x2F;home&#x2F;bun&#x2F;app&quot; oven&#x2F;bun</code></pre></div></figure><blockquote><p>举一反三</p><p>类似这样的Docker环境，我们都可以用这种方式来实现无需安装即可完成环境的搭建部署<br>例如Python：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull python:3.9.17docker volume create pip-cachedocker run --rm --init --ulimit memlock&#x3D;-1:-1 -v pip-cache:&#x2F;root&#x2F;.cache&#x2F;pip -v &quot;$&#123;PWD&#125;:&#x2F;usr&#x2F;src&#x2F;app&quot; -w &#x2F;usr&#x2F;src&#x2F;app python:3.9.17 pip install -r .&#x2F;requirements.txtdocker run --rm --init --ulimit memlock&#x3D;-1:-1 -v pip-cache:&#x2F;root&#x2F;.cache&#x2F;pip -v &quot;$&#123;PWD&#125;:&#x2F;usr&#x2F;src&#x2F;app&quot; -w &#x2F;usr&#x2F;src&#x2F;app python:3.9.17 python demo.py</code></pre></div></figure><p>Nice！效果极佳！赞👍</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>BunJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BunJS</tag>
      
      <tag>JS</tag>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell函数别名</title>
    <link href="/doc/a85ec818.html"/>
    <url>/doc/a85ec818.html</url>
    
    <content type="html"><![CDATA[<p>为PowerShell函数起别名，方便操作</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>别名是命令的备用名称。 一个命令可以具有多个别名，并且原始名称及其所有别名都可互换使用。<br>可以重新分配别名。一个别名可以分配给另一个别名；但是，新别名不是原始命令的别名。</p><p>以下 cmdlet 处理别名：</p><ul><li>New-Alias：创建别名</li><li>Set-Alias：创建或更改一个或多个别名</li><li>Get-Alias：获取有关一个或多个别名的信息</li><li>Export-Alias：将一个或多个别名导出到文件</li></ul><p>你可以通过上述指令对现有函数指令设置别名！</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>PowerShell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Choco常用工具指令</title>
    <link href="/doc/92246a81.html"/>
    <url>/doc/92246a81.html</url>
    
    <content type="html"><![CDATA[<p>Choco工具自带的工具指令。</p><span id="more"></span><h2 id="shimgen"><a href="#shimgen" class="headerlink" title="shimgen"></a>shimgen</h2><p>该指令可以为应用程序创建软映射</p><h3 id="指令帮助"><a href="#指令帮助" class="headerlink" title="指令帮助"></a>指令帮助</h3><figure><div class="code-wrapper"><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">ShimGen generates an executable that will call a file relative to its location. Think of it as batch redirect 2.0.To use shimgen, supply an output path for the shim executable, relative path to executable, and whether it is a GUI you are callingExample: shimgen --output&#x3D;bob --path&#x3D;&quot;the\ relative \path&quot;Example: shimgen -o&#x3D;&quot;..\bob.exe&quot; -p&#x3D;&quot;the\ relative \path&quot; --gui  -?, --help, -h             Prints out the options.  -o, --output&#x3D;VALUE         REQUIRED: output - The is the name of the shim                               (e.g. rh.exe for rh.exe). This can also contain                               the path to the output file  -p, --path&#x3D;VALUE           REQUIRED: path - The path to the executable. Can                               be relative or absolute.  -i, --iconpath&#x3D;VALUE       : path of executable for icon - The path to the                               executable for resolving the icon. Can be                               relative or absolute (suggest absolute).  -c, --command&#x3D;VALUE        command - The command you want to pass to the                               executable.      --gui                  GUI - This instructs ShimGen that the underlying                               executable is a GUI and it should not wait for                               it to finish execution.      --debug                debug - This instructs ShimGen to write out all                               messages. Defaults to false.</code></pre></div></figure><h2 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h2><p>该指令用于检验文件是否被恶意更改</p><h3 id="指令帮助-1"><a href="#指令帮助-1" class="headerlink" title="指令帮助"></a>指令帮助</h3><figure><div class="code-wrapper"><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">checksum - File CheckSum Validator - Apache v2checksum checks a file and returns a check sum for md5, sha1, sha256 and sha512.To use checksum you would simply provide a file path and it will return the sum for the file.  Example: checksum -f&#x3D;&quot;a\relative\path&quot;  Example: checksum -f&#x3D;&quot;a\relative\path&quot;  Example: checksum &quot;a\relative\path&quot; -t&#x3D;sha256You can also check against an existing signature.To validate against an existing signature (hash) you would simply provide the file and the expected signature. When checking a signature, if the signature is valid it exits with 0, otherwise it exits with a non-zero exit code.  Example: checksum -f&#x3D;&quot;c:\\path\to\somefile.exe&quot; -c&#x3D;&quot;thehash&quot;  Example: checksum &quot;c:\\path\to\somefile.exe&quot; -c&#x3D;&quot;thehash&quot; -t&#x3D;sha256 &#x3D;&#x3D; Synopsis &#x3D;&#x3D;  checksum [-t&#x3D;sha1|sha256|sha512|md5] [-c&#x3D;signature] [-f&#x3D;]filepath&#x3D;&#x3D; Options &#x3D;&#x3D;  -?, --help, -h             Prints out the options.  -f, --file&#x3D;VALUE           REQUIRED: file - The is the name of the file.                               The file should exist. You do not need to                               specify -f or -file in front of this argument.  -t, --type, --hashtype&#x3D;VALUE                             Optional: hashtype - &#39;md5&#39;, &#39;sha1&#39;, &#39;sha256&#39; or                               &#39;sha512&#39;. Defaults to &#39;md5&#39; or is determined by                               length of passed check value.  -c, --check&#x3D;VALUE          Optional: check - the signature you want to                               check. Not case sensitive.</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>Choco</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Choco</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Choco安装常用环境</title>
    <link href="/doc/b6fbec3e.html"/>
    <url>/doc/b6fbec3e.html</url>
    
    <content type="html"><![CDATA[<p>针对开发人员的常用环境安装。不建议使用Choco免费版，推荐<a href="/doc/155f072e.html">Scoop</a>。</p><span id="more"></span><h2 id="常用环境安装列表"><a href="#常用环境安装列表" class="headerlink" title="常用环境安装列表"></a>常用环境安装列表</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;packages&gt;    &lt;!-- git ZIP版 --&gt;    &lt;package id&#x3D;&quot;git.portable&quot; installArguments&#x3D;&quot;-o &quot;E:\Temp\.choco\tools\git&quot;&quot;&#x2F;&gt;    &lt;!-- SVN x--&gt;    &lt;package id&#x3D;&quot;tortoisesvn&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\svn&quot;&quot;&#x2F;&gt;    &lt;!-- NotePad++ --&gt;    &lt;package id&#x3D;&quot;notepadplusplus.install&quot; installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\notepad++&quot;&quot;&#x2F;&gt;    &lt;!-- NVM --&gt;    &lt;package id&#x3D;&quot;nvm.install&quot;             installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\nvm&quot;&quot;&#x2F;&gt;    &lt;!-- Deno --&gt;    &lt;package id&#x3D;&quot;deno&quot;&#x2F;&gt;    &lt;!-- NodeJs --&gt;    &lt;package id&#x3D;&quot;nodejs.install&quot; version&#x3D;&quot;14.17.5&quot;             installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\nodejs&quot;&quot;&#x2F;&gt;    &lt;!-- WebStorm --&gt;    &lt;package id&#x3D;&quot;WebStorm&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\WebStorm&quot;&quot; source&#x3D;&quot;nodejs.install&quot;&#x2F;&gt;    &lt;!-- Oracle虚拟机 --&gt;    &lt;package id&#x3D;&quot;virtualbox&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\virtualbox&quot;&quot;&#x2F;&gt;    &lt;!-- VMware虚拟机 --&gt;    &lt;package id&#x3D;&quot;vmwareworkstation&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\vmware&quot; &#x2F;SERIALNUMBER&#x3D;NZ4RR-FTK5H-H81C1-Q30QH-1V2LA&quot;&#x2F;&gt;    &lt;!-- Docker客户端 --&gt;    &lt;package id&#x3D;&quot;docker-cli&quot;&#x2F;&gt;    &lt;!-- Docker编排工具 --&gt;    &lt;package id&#x3D;&quot;docker-compose&quot;&#x2F;&gt;    &lt;!-- Docker虚拟机 --&gt;    &lt;package id&#x3D;&quot;docker-machine&quot;&#x2F;&gt;    &lt;package id&#x3D;&quot;docker-machine-vmwareworkstation&quot;&#x2F;&gt;    &lt;package id&#x3D;&quot;docker-desktop&quot; installArguments&#x3D;&quot;--quiet --backend&#x3D;windows --installation-dir&#x3D;E:\Temp\.choco\tools\docker-desktop --windows-containers-default-data-root&#x3D;E:\Temp\.docker\windows --hyper-v-default-data-root&#x3D;E:\Temp\.docker\hyper-v --wsl-default-data-root&#x3D;E:\Temp\.docker\wsl --always-run-service&quot;&#x2F;&gt;    &lt;!-- PodMan编排工具 --&gt;    &lt;package id&#x3D;&quot;podman-compose&quot;&#x2F;&gt;    &lt;!-- PodMan虚拟机 --&gt;    &lt;package id&#x3D;&quot;podman-machine&quot;&#x2F;&gt;    &lt;!-- K8s搭建工具 --&gt;    &lt;package id&#x3D;&quot;Minikube&quot;&#x2F;&gt;    &lt;!-- K8s客户端 --&gt;    &lt;package id&#x3D;&quot;kubernetes-cli&quot;&#x2F;&gt;    &lt;!-- Kubernetes In Docker --&gt;    &lt;package id&#x3D;&quot;kind&quot;&#x2F;&gt;    &lt;!-- Kubernetes From Config --&gt;    &lt;package id&#x3D;&quot;kustomize&quot;&#x2F;&gt;    &lt;!-- Mysql客户端 --&gt;    &lt;package id&#x3D;&quot;mysql-cli&quot;&#x2F;&gt;    &lt;!-- Debug调试工具ZIP版 --&gt;    &lt;package id&#x3D;&quot;x64dbg.portable&quot; installArguments&#x3D;&quot;-o &quot;E:\Temp\.choco\tools\x64dbg&quot;&quot;&#x2F;&gt;    &lt;!-- NASM编译器 --&gt;    &lt;package id&#x3D;&quot;nasm&quot; installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\nasm&quot;&quot;&#x2F;&gt;    &lt;!-- Make构建工具 --&gt;    &lt;package id&#x3D;&quot;make&quot;&#x2F;&gt;    &lt;!-- CMake构建工具 --&gt;    &lt;package id&#x3D;&quot;cmake.portable&quot; installArguments&#x3D;&quot;-o &quot;E:\Temp\.choco\tools\cmake&quot;&quot;&#x2F;&gt;    &lt;!-- C&#x2F;C++编译器 --&gt;    &lt;package id&#x3D;&quot;mingw&quot;&#x2F;&gt;    &lt;!-- CLion --&gt;    &lt;package id&#x3D;&quot;clion-ide&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\CLion&quot;&quot; source&#x3D;&quot;mingw&quot;&#x2F;&gt;    &lt;!-- 开源调试软件OpenOCD --&gt;    &lt;package id&#x3D;&quot;openocd&quot;&#x2F;&gt;    &lt;!-- Dart --&gt;    &lt;package id&#x3D;&quot;dart-sdk&quot;&#x2F;&gt;    &lt;!-- Flutter --&gt;    &lt;package id&#x3D;&quot;flutter&quot;&#x2F;&gt;    &lt;!-- 本地HTTPS证书 --&gt;    &lt;package id&#x3D;&quot;mkcert&quot;&#x2F;&gt;    &lt;!-- 内网穿透 --&gt;    &lt;package id&#x3D;&quot;ngrok&quot;&#x2F;&gt;    &lt;!-- 视频编辑工具 --&gt;    &lt;package id&#x3D;&quot;ffmpeg-full&quot;&#x2F;&gt;    &lt;!-- 虚拟机构建工具 --&gt;    &lt;package id&#x3D;&quot;vagrant&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\vagrant&quot;&quot;&#x2F;&gt;    &lt;!-- 虚拟器 --&gt;    &lt;package id&#x3D;&quot;qemu&quot; installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\qemu&quot;&quot;&#x2F;&gt;    &lt;!-- SSH客户端 --&gt;    &lt;package id&#x3D;&quot;tabby&quot; installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\tabby&quot;&quot;&#x2F;&gt;    &lt;package id&#x3D;&quot;windterm.portable&quot; installArguments&#x3D;&quot;-o &quot;E:\Temp\.choco\tools\&quot;&quot;&#x2F;&gt;    &lt;!-- GoSDK --&gt;    &lt;package id&#x3D;&quot;golang&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\go&quot;&quot;&#x2F;&gt;    &lt;!-- GoLand--&gt;    &lt;package id&#x3D;&quot;goland&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\GoLand&quot;&quot;&#x2F;&gt;    &lt;!-- JDK8 --&gt;    &lt;package id&#x3D;&quot;jdk8&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\jdk8&quot;&quot;&#x2F;&gt;    &lt;!-- Eclipse 开源JDK8 --&gt;    &lt;package id&#x3D;&quot;Temurin8&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\Temurin8&quot;&quot;&#x2F;&gt;    &lt;!-- Eclipse 开源JDK8 --&gt;    &lt;package id&#x3D;&quot;Temurin17&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\Temurin17&quot;&quot;&#x2F;&gt;    &lt;!-- IDEA-U --&gt;    &lt;package id&#x3D;&quot;intellijidea-ultimate&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\IdeaU&quot;&quot; source&#x3D;&quot;jdk8&quot;&#x2F;&gt;    &lt;!-- IDEA-C --&gt;    &lt;package id&#x3D;&quot;intellijidea-community&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\IdeaC&quot;&quot; source&#x3D;&quot;jdk8&quot;&#x2F;&gt;    &lt;!-- Tomcat服务器 --&gt;    &lt;package id&#x3D;&quot;tomcat&quot; source&#x3D;&quot;jdk8&quot;&#x2F;&gt;    &lt;!-- Java反编译工具 --&gt;    &lt;package id&#x3D;&quot;jadx&quot; source&#x3D;&quot;jdk8&quot;&#x2F;&gt;    &lt;!-- 测试工具 --&gt;    &lt;package id&#x3D;&quot;jmeter&quot; source&#x3D;&quot;jdk8&quot;&#x2F;&gt;    &lt;!-- Python环境 --&gt;    &lt;package id&#x3D;&quot;python3&quot;             installArguments&#x3D;&quot;&#x2F;quiet  InstallAllUsers&#x3D;1 TargetDir&#x3D;&quot;E:\Temp\.choco\tools\python3&quot;&quot;&#x2F;&gt;    &lt;!-- PyCharm IDE --&gt;    &lt;package id&#x3D;&quot;Pycharm&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\PyCharm&quot;&quot; source&#x3D;&quot;python3&quot;&#x2F;&gt;    &lt;!-- OpenVPN客户端 --&gt;    &lt;package id&#x3D;&quot;openvpn&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\openvpn&quot;&quot;&#x2F;&gt;    &lt;!-- OpenVPN客户端 --&gt;    &lt;package id&#x3D;&quot;wireguard&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\wireguard&quot;&quot;&#x2F;&gt;    &lt;!-- 文件搜索工具 --&gt;    &lt;package id&#x3D;&quot;everything.portable&quot; installArguments&#x3D;&quot;-o &quot;E:\Temp\.choco\tools\everything&quot;&quot;&#x2F;&gt;    &lt;!-- Rider IDE --&gt;    &lt;package id&#x3D;&quot;jetbrains-rider&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\Rider&quot;&quot;&#x2F;&gt;    &lt;!-- DataGrip IDE --&gt;    &lt;package id&#x3D;&quot;datagrip&quot; version&#x3D;&quot;2022.1.4&quot;             installArguments&#x3D;&quot;&#x2F;S &#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\DataGrip&quot;&quot;&#x2F;&gt;    &lt;!-- 磁盘空间分析器 --&gt;    &lt;package id&#x3D;&quot;wiztree&quot; installArguments&#x3D;&quot;&#x2F;DIR&#x3D;&quot;E:\Temp\.choco\tools\wiztree&quot;&quot;&#x2F;&gt;    &lt;!-- 抓包工具 --&gt;    &lt;package id&#x3D;&quot;wireshark&quot; installArguments&#x3D;&quot;&#x2F;D&#x3D;&quot;E:\Temp\.choco\tools\wireshark&quot;&quot;&#x2F;&gt;    &lt;!-- Choco清理工具 --&gt;    &lt;package id&#x3D;&quot;choco-cleaner&quot;&#x2F;&gt;    &lt;!-- 图表绘制工具 --&gt;    &lt;package id&#x3D;&quot;drawio&quot;&#x2F;&gt;    &lt;!-- exif信息处理工具 --&gt;    &lt;package id&#x3D;&quot;jhead&quot;&#x2F;&gt;    &lt;!-- 终端美化工具 --&gt;    &lt;package id&#x3D;&quot;hyper&quot;&#x2F;&gt;    &lt;!-- Windows 文件夹代理 --&gt;    &lt;package id&#x3D;&quot;winfsp&quot; installArguments&#x3D;&quot;INSTALLDIR&#x3D;&quot;E:\Temp\.choco\tools\winfsp&quot;&quot;&#x2F;&gt;    &lt;!-- mitmproxy 工具 --&gt;    &lt;package id&#x3D;&quot;mitmproxy&quot; installArguments&#x3D;&quot;--prefix &quot;E:\Temp\.choco\tools\mitmproxy&quot;&quot;&#x2F;&gt;    &lt;!-- 电路模拟工具 --&gt;    &lt;package id&#x3D;&quot;logisim-evolution&quot;&#x2F;&gt;    &lt;!-- 手机投屏工具 --&gt;    &lt;package id&#x3D;&quot;scrcpy&quot;&#x2F;&gt;&lt;&#x2F;packages&gt;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>Choco</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理工具</tag>
      
      <tag>Choco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows端口转发</title>
    <link href="/doc/2b137e6e.html"/>
    <url>/doc/2b137e6e.html</url>
    
    <content type="html"><![CDATA[<p>端口转发（Port forwarding），有时被叫做隧道，是安全壳（SSH） 为网络安全通信使用的一种方法。 </p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>端口转发（Port forwarding），有时被叫做隧道，是安全壳（SSH） 为网络安全通信使用的一种方法。 </p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="新增端口转发"><a href="#新增端口转发" class="headerlink" title="新增端口转发"></a>新增端口转发</h3><p>   首先打开命令提示符(cmd)<br>   <code>netsh interface portproxy add v4tov4 listenport=监听端口 connectaddress=转发到的地址 connectport=转发到的端口</code><br>   例子: <code>netsh interface portproxy add v4tov4 listenport=9988 connectaddress=192.168.88.110 connectport=9988</code></p><h3 id="查看转发了哪些端口"><a href="#查看转发了哪些端口" class="headerlink" title="查看转发了哪些端口"></a>查看转发了哪些端口</h3><p>   <code>netsh interface portproxy show all</code></p><h3 id="删除转发规则"><a href="#删除转发规则" class="headerlink" title="删除转发规则"></a>删除转发规则</h3><p>   <code>netsh interface portproxy delete v4tov4 listenaddress=192.168.88.110 listenport=9988</code></p><h3 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h3><ol><li><p>监听端口与转发到的端口可以不同。例如想暴露公网端口为<code>19988</code>，实际服务器端口为<code>9988</code>，那么可写成<code>netsh interface portproxy add v4tov4 listenport=19988 connectaddress=192.168.88.110 connectport=9988</code></p></li><li><p>能使用DMZ的情况还是推荐使用DMZ</p></li><li><p>使用<code>netsh interface portproxy</code>记得配置Windows和出口路由器防火墙规则</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>高可用</tag>
      
      <tag>端口转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL 2数据卷迁移</title>
    <link href="/doc/dd2b8cf.html"/>
    <url>/doc/dd2b8cf.html</url>
    
    <content type="html"><![CDATA[<p>WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。</p><p>这一新的体系结构改变了这些 Linux 二进制文件与Windows 和计算机硬件进行交互的方式，但仍然提供与 WSL 1（当前广泛可用的版本）中相同的用户体验。</p><p>单个 Linux 分发版可以在 WSL 1 或 WSL 2 体系结构中运行。 每个分发版可随时升级或降级，并且你可以并行运行 WSL 1 和 WSL 2 分发版。 WSL 2 使用全新的体系结构，该体系结构受益于运行真正的 Linux 内核。</p><p>简单来说WSL2是WSL的加强版，其实现方式与WSL不同，并且WSL 2拥有完整的Linux内核、更贴近真实Linux的使用场景。</p><span id="more"></span><ol><li>以管理员身份运行PowerShell，执行：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wsl -l -v</code></pre></div></figure>查看已安装的所有WSL实例的名称及版本：<figure><div class="code-wrapper"><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">  NAME            STATE           VERSION* Ubuntu-18.04    Stopped         2</code></pre></div></figure>如果STATE不是Stopped，那么需要执行<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wsl --shutdown</code></pre></div></figure>以我的WSL实例”Ubuntu-18.04”为例，执行<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">wsl --export Ubuntu-18.04 E:\Temp\Ubuntu-18.04.tarwsl --unregister Ubuntu-18.04wsl --import Ubuntu-18.04 E:\Temp\.virtual-machines\Ubuntu-18.04 E:\Temp\Ubuntu-18.04.tar --version 2</code></pre></div></figure>上述操作完成之后能够顺利打开WSL Ubuntu-18.04，但是显示以root身份登录，这时我们需要完成最后一步——设置默认用户：在<code>C:\WINDOWS\System32</code>下以管理员身份运行PowerShell，执行：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ubuntu1804.exe config --default-user &lt;username&gt;</code></pre></div></figure>如果你的WSL Ubuntu的名称是Ubuntu-20.04，那么对应的可执行文件名为ubuntu2004.exe，具体名字可以在System32下查看。将这里的username改为之前WSL Ubuntu设置的用户名（注意不能大写）以后，重启WSL Ubuntu即可发现~路径下的文件都在，oh-my-zsh等Shell效果也都还在。</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Windows</tag>
      
      <tag>Sub Linux</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite + TS 环境搭建</title>
    <link href="/doc/c4a056ea.html"/>
    <url>/doc/c4a056ea.html</url>
    
    <content type="html"><![CDATA[<p>Vite! 下一代前端开发与构建工具</p><span id="more"></span><ol><li>首先创建一个空目录 <code>mkdir demo</code></li><li>进入创建好的文件夹中 <code>cd demo</code>并创建 <strong>src</strong> 文件夹（在该文件夹里写代码，自行创建<code>index.ts</code>）</li><li>初始化<code>package.json</code> <code>pnpm init</code></li><li>在生成的<code>package.json</code>中写入如下依赖<figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;ts-demo&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;study ts&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite --mode development&quot;,    &quot;build&quot;: &quot;vite build&quot;,    &quot;build:beta&quot;: &quot;vite build --mode beta&quot;,    &quot;build:release&quot;: &quot;vite build --mode release&quot;,    &quot;preview&quot;: &quot;vite preview&quot;  &#125;,  &quot;keywords&quot;: [    &quot;ts&quot;,    &quot;study&quot;  ],  &quot;author&quot;: &quot;Cikaros&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;devDependencies&quot;: &#123;    &quot;vite&quot;: &quot;^2.9.6&quot;  &#125;&#125;</code></pre></div></figure></li><li>运行<code>pnpm install</code>安装依赖</li><li>在目录中创建<code>index.html</code>并写入如下内容<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&#x2F;favicon.svg&quot;&#x2F;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;index.ts&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure></li><li>在目录中创建<code>vite.config.js</code>并写入如下内容<figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123;defineConfig&#125; from &#39;vite&#39;module.exports &#x3D; defineConfig(&#123;    build: &#123;        outDir: &#39;dist&#39;    &#125;,    server: &#123;        proxy: &#123;            &quot;&#x2F;api&quot;: &#123;                target: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;,                changeOrigin: true,                rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\&#x2F;api&#x2F;, &quot;&quot;),            &#125;,        &#125;,    &#125;,&#125;)</code></pre></div></figure></li><li>在目录中创建<code>tsconfig.json</code>并写入如下内容<figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;esnext&quot;,    &quot;module&quot;: &quot;esnext&quot;,    &quot;strict&quot;: true,    &quot;jsx&quot;: &quot;preserve&quot;,    &quot;importHelpers&quot;: true,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;experimentalDecorators&quot;: true,    &quot;sourceMap&quot;: true,    &quot;pretty&quot;: true,    &quot;resolveJsonModule&quot;: true,    &quot;allowJs&quot;: true,    &quot;checkJs&quot;: true,    &quot;suppressImplicitAnyIndexErrors&quot;: true,    &quot;strictPropertyInitialization&quot;: false,    &quot;downlevelIteration&quot;: true,    &quot;noUnusedLocals&quot;: false,    &quot;noImplicitAny&quot;: false,    &quot;noImplicitThis&quot;: true,    &quot;removeComments&quot;: false,    &quot;strictFunctionTypes&quot;: false,    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;types&quot;: [      &quot;vite&#x2F;client&quot;,      &quot;node&quot;    ],    &quot;typeRoots&quot;: [      &quot;.&#x2F;node_modules&#x2F;@types&#x2F;&quot;,      &quot;.&#x2F;types&quot;    ],    &quot;paths&quot;: &#123;      &quot;@&#x2F;*&quot;: [        &quot;src&#x2F;*&quot;      ]    &#125;,    &quot;lib&quot;: [      &quot;esnext&quot;,      &quot;dom&quot;,      &quot;dom.iterable&quot;,      &quot;scripthost&quot;    ]  &#125;,  &quot;include&quot;: [    &quot;src&#x2F;**&#x2F;*.ts&quot;,    &quot;src&#x2F;**&#x2F;*.d.ts&quot;,    &quot;src&#x2F;**&#x2F;*.tsx&quot;,    &quot;types&#x2F;**&#x2F;*.d.ts&quot;,    &quot;types&#x2F;**&#x2F;*.ts&quot;,    &quot;preview&#x2F;**&#x2F;*.ts&quot;,    &quot;preview&#x2F;**&#x2F;*.d.ts&quot;,    &quot;preview&#x2F;**&#x2F;*.tsx&quot;  ],  &quot;exclude&quot;: [    &quot;node_modules&quot;,    &quot;dist&quot;  ]&#125;</code></pre></div></figure></li><li>根据需要添加相应环境变量或其他所需依赖</li><li>运行<code>pnpm run dev</code>即可运行项目</li></ol>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>TS</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Allatori工具</title>
    <link href="/doc/8b667fb0.html"/>
    <url>/doc/8b667fb0.html</url>
    
    <content type="html"><![CDATA[<p>代码混淆亦称花指令，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。<br>代码混淆可以用于程序的源代码，也可以用于程序编译而成的中间代码。执行代码混淆的程序被称作代码混淆器。</p><span id="more"></span><p>研究了一段时间后发现他也并不是绝对的安全，而且有好多代码是不能进行混淆处理的，否则会造成运行报错，放弃了。</p><p>还有一个方向就是走JNI，这样能更安全一些，但是可能会破坏Java的可移植性。</p><p>继续研究吧！</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Maven-Plugin</category>
      
      <category>Allatori</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven-Plugin</tag>
      
      <tag>Allatori</tag>
      
      <tag>代码混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual IP(虚拟IP)</title>
    <link href="/doc/6c86f4ab.html"/>
    <url>/doc/6c86f4ab.html</url>
    
    <content type="html"><![CDATA[<p>虚拟IP地址(VIP) 是一个不与特定计算机或一个计算机中的网络接口卡(NIC)相连的IP地址。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>虚拟IP地址(VIP) 是一个不与特定计算机或一个计算机中的网络接口卡(NIC)相连的IP地址。<br>数据包被发送到这个VIP地址，但是所有的数据还是经过真实的网络接口。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>大部分虚拟ip基本上都用于高可用的架构上边。主机启用虚拟ip，所有访问的请求都会到主机。<br>当主机宕机的时候，高可用软件会将主机的虚拟ip down掉，然后在备机上启用虚拟ip。这样就完成了主备切换。从而保证业务的可用性。</p><h2 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h2><h3 id="怎么实现故障检测？"><a href="#怎么实现故障检测？" class="headerlink" title="怎么实现故障检测？"></a>怎么实现故障检测？</h3><p>心跳检测技术。采用定时发送一个数据包，如果机器一定时间没响应，就认为是发生故障，自动切换到热备的机器上去。</p><h3 id="怎么实现主备自动切换？"><a href="#怎么实现主备自动切换？" class="headerlink" title="怎么实现主备自动切换？"></a>怎么实现主备自动切换？</h3><p>虚拟IP技术。虚拟IP，就是一个未分配给真实主机的IP，也就是说对外提供数据库服务器的主机除了有一个真实IP外还有一个虚IP，使用这两个IP中的任意一个都可以连接到这台主机，<br>所有项目中数据库链接一项配置的都是这个虚IP，当服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用主机。</p><p>其实现原理主要是靠 TCP&#x2F;IP 的 ARP 协议。因为IP地址只是一个逻辑地址，在以太网中 MAC 地址才是真正用来进行数据传输的物理地址，每台主机中都有一个 ARP 高速缓存，<br>存储同一个网络内的 IP 地址与 MAC 地址的对应关系，以太网中的主机发送数据时会先从这个缓存中查询目标 IP 对应的 MAC 地址，会向这个 MAC 地址发送数据。<br>操作系统会自动维护这个缓存。这就是整个实现的关键，比如下面这个 ARP 缓存示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(192.168.1.219) at 00:21:5A:DB:68:E8 [ether] on bond0(192.168.1.217) at 00:21:5A:DB:68:E8 [ether] on bond0(192.168.1.218) at 00:21:5A:DB:7F:C2 [ether] on bond0</code></pre></div></figure><p>其中，<code>192.168.1.217</code>、<code>192.168.1.218</code> 是两台真实的电脑，<code>192.168.1.217</code> 为对外提供数据库服务的主机，<code>192.168.1.218</code> 为热备的机器，<code>192.168.1.219</code> 为虚IP，<br>注意<code>219</code>、<code>217</code>的 MAC 地址是相同的。当 <code>218</code> 发现 <code>217</code> 宕机后会向网络发送一个 ARP 数据包，告诉所有主机 <code>192.168.1.219</code> 这个IP对应的MAC地址是 <code>00:21:5A:DB:7F:C2</code>，<br>这样所有发送到 <code>219</code> 的数据包都会发送到 MAC 地址为 <code>00:21:5A:DB:7F:C2</code> 的机器，也就是 <code>218</code> 的机器。</p><h2 id="Linux下的虚拟IP配置"><a href="#Linux下的虚拟IP配置" class="headerlink" title="Linux下的虚拟IP配置"></a>Linux下的虚拟IP配置</h2><p>在Linux中有两种方式实现虚拟IP：</p><ul><li>别名IP</li><li>辅助IP</li></ul><h3 id="别名IP"><a href="#别名IP" class="headerlink" title="别名IP"></a>别名IP</h3><p>别名ip是通过 <code>ifconfig</code>命令去创建和操作的虚拟ip。</p><h4 id="创建虚拟IP"><a href="#创建虚拟IP" class="headerlink" title="创建虚拟IP"></a>创建虚拟IP</h4><p>假设当前网卡为<code>ethx</code>，且没有配置过虚拟IP。<br>创建一个IP为<code>192.168.0.2</code>子网掩码为<code>255.255.255.0</code>的虚拟IP。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig ethx:1 192.168.0.2 netmask 255.255.255.0 up</code></pre></div></figure><p>可通过<code>ipconfg</code>命令查看。</p><h4 id="删除别名IP"><a href="#删除别名IP" class="headerlink" title="删除别名IP"></a>删除别名IP</h4><p>删除之前设置的虚拟IP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig ethx:1 192.168.0.2 netmask 255.255.255.0 down</code></pre></div></figure><p>清除别名IP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig ethx:1 down</code></pre></div></figure><h4 id="保留网卡的IP别名信息"><a href="#保留网卡的IP别名信息" class="headerlink" title="保留网卡的IP别名信息"></a>保留网卡的IP别名信息</h4><ul><li>将增加IP别名的命令写进linux开机自动执行的执行脚本中。</li><li>在网卡的配置目录中去建立一个新的网卡的配置文件。</li></ul><h3 id="辅助IP"><a href="#辅助IP" class="headerlink" title="辅助IP"></a>辅助IP</h3><p>辅助ip是由linux的 ip命令去创建和操作的。</p><h4 id="创建辅助IP"><a href="#创建辅助IP" class="headerlink" title="创建辅助IP"></a>创建辅助IP</h4><p>条件同别名IP。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip addr add 192.168.0.2&#x2F;24 dev ethx</code></pre></div></figure><p>可通过<code>ip a</code>命令查看。</p><h4 id="删除辅助IP"><a href="#删除辅助IP" class="headerlink" title="删除辅助IP"></a>删除辅助IP</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip addr del 192.168.0.2&#x2F;24 dev ethx</code></pre></div></figure><h4 id="保留网卡的IP辅助信息"><a href="#保留网卡的IP辅助信息" class="headerlink" title="保留网卡的IP辅助信息"></a>保留网卡的IP辅助信息</h4><ul><li>将增加辅助IP的命令写进linux开机自动执行的执行脚本中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>VIP</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS协议</title>
    <link href="/doc/eac2dcda.html"/>
    <url>/doc/eac2dcda.html</url>
    
    <content type="html"><![CDATA[<p>CAS协议是专门为CAS开发的一种简单而强大的基于票据的协议。</p><span id="more"></span><img src="/doc/eac2dcda/cas.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>CAS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式架构</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps-Drone</title>
    <link href="/doc/b0c5cd20.html"/>
    <url>/doc/b0c5cd20.html</url>
    
    <content type="html"><![CDATA[<p>最近在研究DevOps，小计一下！</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DevOps(Dev + Ops),即为开发人员与维护人员的一个平台。</p><img src="/doc/b0c5cd20/introduction.png" srcset="/img/loading.gif" lazyload class=""><p>事实上，DevOps 包含了三个部分：开发、测试和运维。换句话 DevOps 希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。</p><img src="/doc/b0c5cd20/comparative_analysis.png" srcset="/img/loading.gif" lazyload class=""><p>这几年云计算技术突飞猛进, 虚拟化、容器、微服务等等, 都为DevOps提供了很好的前提条件.<br>开发环境和部署环境都可以更好地隔离了，减小了相互之间的影响。</p><ul><li><p>微服务:<br>  就是将原来黑盒化的一个整体产品进行拆分（解耦），从一个提供多种服务的整体，拆成各自提供不同服务的多个个体.</p></li><li><p>虚拟化:<br>  它从硬件上，将一个系统“划分”为多个系统，系统之间相互隔离，为微服务提供便利。</p></li><li><p>容器:<br>  在操作系统上划分为不同的“运行环境”（Container），占用资源更少，部署速度更快。</p></li></ul><h3 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h3><p>这种开发模式下带来的新问题是, 如何确保运维上线的即时, 那就是CI和CD。</p><ul><li>CI（持续集成）:<ul><li>是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起并切相互不影响工作。</li></ul></li><li>CD（持续交付与持续部署）:<ul><li>基于某种工具或平台实现代码自动化的构建、测试和部署到线上环境以实现交付高质量的产品。</li><li>持续部署在某种程度上代表了一个开发团队的更新迭代速率。</li></ul></li></ul><p>开发只需要关注代码, 业务逻辑, 测试脚本, 然后提交到代码仓库。<br>后续测试, 发布, 部署都由自动化脚本完成, 减少运维工作量, 避免人为失误。</p><h3 id="DevOps平台"><a href="#DevOps平台" class="headerlink" title="DevOps平台"></a>DevOps平台</h3><p>DevOps平台的搭建可通过如下工具进行实现:</p><ul><li>项目管理（PM）：Jira</li><li>代码管理：GitLab</li><li>持续集成（CI）：GitLab CI</li><li>镜像仓库：VMware Harbor 私服nexus</li><li>容器：Docker</li><li>容器平台： Rancher</li><li>镜像扫描：Clairctl</li><li>编排：Kubernetes</li><li>服务注册与发现：etcd</li><li>脚本语言：python</li><li>日志管理：EFK</li><li>系统监控：prometheus</li><li>Web服务器：Nginx</li><li>数据库：MySQL redis</li><li>负载均衡：Nginx。</li><li>产品和UI图：蓝湖</li><li>公司内部文档：Confluence。</li><li>报警：推送到工作群 企业微信 钉钉</li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>初期采取: gogs + drone + docker-compose<br>后期可采用: gitlab + Jenkins</p><h2 id="Gogs-Drone"><a href="#Gogs-Drone" class="headerlink" title="Gogs + Drone"></a>Gogs + Drone</h2><h3 id="Gogs-介绍"><a href="#Gogs-介绍" class="headerlink" title="Gogs 介绍"></a>Gogs 介绍</h3><p>Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。<br>使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，<br>包括 Linux、Mac OS X、Windows 以及 ARM 平台。</p><h3 id="Drone-介绍"><a href="#Drone-介绍" class="headerlink" title="Drone 介绍"></a>Drone 介绍</h3><p>Drone 是一个基于Docker容器技术的可扩展的持续集成引擎，用于自动化测试、构建、发布。<br>每个构建都在一个临时的Docker容器中执行，使开发人员能够完全控制其构建环境并保证隔离。<br>开发者只需在项目中包含 .drone.yml文件，将代码推送到 git 仓库，Drone就能够自动化的进行编译、测试、发布。<br>它可以与docker完美集成, 相对于Jenkins来说更加轻量, 可以配合 Gogs 来实现持续集成。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;3.6&quot;services:  # gogs 服务镜像  gogs:    image: gogs&#x2F;gogs:latest    container_name: gogs    restart: always    ports:      - &quot;10022:22&quot; # ssh 端口      - &quot;3000:3000&quot; # gogs仓库    volumes:      - &#x2F;data&#x2F;docker_test&#x2F;gogs:&#x2F;data # gogs 挂载卷    networks:      - drone-net  # drone server 端  drone:    image: drone&#x2F;drone:latest    container_name: drone    ports:      - &quot;8080:80&quot; # drone 服务：HTTP      - &quot;8443:443&quot; # drone 服务：HTTPS    volumes:      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock # 本地docker      - &#x2F;data&#x2F;docker_test&#x2F;drone:&#x2F;var&#x2F;lib&#x2F;drone&#x2F; # 挂载卷    restart: always    environment:      - TZ&#x3D;Asia&#x2F;Shanghai      - DRONE_AGENTS_ENABLED&#x3D;true      - DRONE_GOGS_SERVER&#x3D;http:&#x2F;&#x2F;gogs:3000 # 不同的代码仓库对应不同的key, v: 服务器仓库地址      - DRONE_GOGS_SKIP_VERIFY&#x3D;true      - DRONE_SERVER_HOST&#x3D;192.168.99.102:8080 # drone 的server端地址      - DRONE_SERVER_PROTO&#x3D;http      - DRONE_LOGS_TRACE&#x3D;true      - DRONE_LOGS_DEBUG&#x3D;true      - DRONE_RPC_SECRET&#x3D;2cbdaab90813f3743dc700816a322c62  # 秘钥与runner一致      - DRONE_USER_CREATE&#x3D;username:Cikaros,admin:true    networks:      - drone-net  # drone runner 端, 用于执行pipeline  drone-runner:    image: drone&#x2F;drone-runner-docker:latest    container_name: drone-runner # docker 与 ssh 有不同的runner    restart: always    ports:      - &quot;10082:3000&quot; # 端口映射    depends_on:      - drone # server端先构建启动    volumes:      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock # 本机docker    environment:      - TZ&#x3D;Asia&#x2F;Shanghai      - DRONE_DEBUG&#x3D;true      - DRONE_RPC_SECRET&#x3D;2cbdaab90813f3743dc700816a322c62 # 秘钥与server端一致      - DRONE_RPC_HOST&#x3D;drone # server端      - DRONE_RPC_PROTO&#x3D;http      - DRONE_RUNNER_CAPACITY&#x3D;2      - DRONE_RUNNER_NAME&#x3D;drone-runner    networks:      - drone-net  # Mysql数据库用于存放数据  gogs_mysql:    image: mysql:5.7    restart: always    container_name: gogs_mysql    ports:      - &quot;3306:3306&quot;    volumes:      # - &#x2F;data&#x2F;docker_test&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql      - &#x2F;data&#x2F;docker_test&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql      - &#x2F;data&#x2F;docker_test&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql    environment:      - MYSQL_ROOT_PASSWORD&#x3D;root      - MYSQL_DATABASE&#x3D;gogs      - MYSQL_USER&#x3D;gogs      - MYSQL_PASSWORD&#x3D;123456      - TZ&#x3D;Asia&#x2F;Shanghai    networks:      - drone-net  registry:    image: registry    container_name: registry    ports:      - &#39;5000:5000&#39;    restart: unless-stopped    networks:      - drone-net#定义统一网络networks:  drone-net:    driver: bridge</code></pre></div></figure><blockquote><p>drone runner 端也可直接使用 docker 指令来部署，假设我有一个域名或者公网IP（只要双方可以通信即可）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --detach \  --volume&#x3D;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \  --env&#x3D;DRONE_RPC_PROTO&#x3D;https \  --env&#x3D;DRONE_RPC_HOST&#x3D;example.com \  --env&#x3D;DRONE_RPC_SECRET&#x3D;2cbdaab90813f3743dc700816a322c62 \  --env&#x3D;DRONE_RUNNER_CAPACITY&#x3D;2 \  --env&#x3D;DRONE_RUNNER_NAME&#x3D;runner1 \  --publish&#x3D;3000:3000 \  --restart&#x3D;always \  --name&#x3D;runner \  drone&#x2F;drone-runner-docker</code></pre></div></figure></blockquote><h3 id="编写drone-yml文件"><a href="#编写drone-yml文件" class="headerlink" title="编写drone.yml文件"></a>编写drone.yml文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kind: pipelinetype: dockername: hellosteps:  - name: build    image: plugins&#x2F;docker    settings:      repo: 192.168.99.102:5000&#x2F;drone&#x2F;hello      tags: latest      registry: 192.168.99.102:5000      purge: true      insecure: true # http      mirror: https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn  - name: run    image: docker:dind    volumes:      - name: dockersock        path: &#x2F;var&#x2F;run&#x2F;docker.sock    commands:      - docker pull 192.168.99.102:5000&#x2F;drone&#x2F;hello:latest      - docker run --name hello -p 80:80 192.168.99.102:5000&#x2F;drone&#x2F;hello:latest      - docker rm hello      - docker rmi 192.168.99.102:5000&#x2F;drone&#x2F;hello:latestvolumes:  - name: dockersock    host:      path: &#x2F;var&#x2F;run&#x2F;docker.sock</code></pre></div></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><img src="/doc/b0c5cd20/rendering_01.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/b0c5cd20/rendering_02.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/b0c5cd20/rendering_03.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/b0c5cd20/rendering_04.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DevOps</tag>
      
      <tag>敏捷开发</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python.zip的安装</title>
    <link href="/doc/d98af7ae.html"/>
    <url>/doc/d98af7ae.html</url>
    
    <content type="html"><![CDATA[<p>Python的zip安装方法</p><span id="more"></span><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>Python官网地址：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p><h2 id="ZIP安装"><a href="#ZIP安装" class="headerlink" title="ZIP安装"></a>ZIP安装</h2><p>解压ZIP文件至合适的位置，并为其配置环境变量。</p><h2 id="配置Pip并安装"><a href="#配置Pip并安装" class="headerlink" title="配置Pip并安装"></a>配置Pip并安装</h2><ol><li>修改<code>python38._pth</code>文件，去掉 <code>#import site</code> 前的#号，即放开 <code>import site；</code>若不放开将会pip无法正确安装。</li><li>从<code>https://bootstrap.pypa.io/get-pip.py</code> 下载<code>get-pip.py</code>，放到python的安装目录下，记住不要用360浏览器，它只是打开文件而不是下载，可以用火狐或谷歌浏览器打开下载</li><li>安装pip，执行 python get-pip.py<br>注意：必须在放置该文件get-pip.py的地方执行该命令python get-pip.py，即把dos的窗口切换到这个目录才可以执行那个命令<br>安装成功后，将在python目录下新建Scripts目录放置pip相关文件，以及 Lib\site-packages目录放置pip未来下载的扩展依赖模块库。</li><li><code>python -m pip install xxx</code> 或直接使用<code>pip install xxx</code> 的方式安装自己的依赖包（xxx替换为自己想安装的模块名）</li><li>将python安装目录下的Scripts目录新建进环境变量中去，再重启下</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>minikube搭建本地k8s集群环境</title>
    <link href="/doc/a1d2365e.html"/>
    <url>/doc/a1d2365e.html</url>
    
    <content type="html"><![CDATA[<p>Minikube是一个快速搭建单节点Kubernetes集群的工具，大家可以把它和docker Machine进行类比。</p><span id="more"></span><h2 id="安装Minikube"><a href="#安装Minikube" class="headerlink" title="安装Minikube"></a>安装Minikube</h2><p>利用Choco安装Minikube</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">choco install Minikube</code></pre></div></figure><h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>自行安装即可。可参考其他安装教程。</p><h2 id="初始化Minikube"><a href="#初始化Minikube" class="headerlink" title="初始化Minikube"></a>初始化Minikube</h2><p>运行<code>minikube start --vm-driver=virtualbox</code>进行初始化。</p><p>命令执行成功后，会在 VirtualBox 中创建一个名叫 minikube 的虚拟机，k8s 就跑在这个虚拟机中。</p><p>启动Dashboard <code>minikube dashboard</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>VirtualBox</tag>
      
      <tag>Minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker配置SSL访问</title>
    <link href="/doc/b6830aac.html"/>
    <url>/doc/b6830aac.html</url>
    
    <content type="html"><![CDATA[<p>Docker开启SSL证书加密远程连接</p><span id="more"></span><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>创建RSA私钥</li><li>创建CA证书</li><li>创建服务端私钥</li><li>创建服务端签名请求证书文件</li><li>创建extfile.cnf的配置文件</li><li>创建签名生效的服务端证书文件</li><li>创建客户端私钥</li><li>创建客户端签名请求证书文件</li><li>创建签名生效的客户端证书文件</li><li>删除多余文件&amp;文件授权</li><li>配置Docker支持TSL链接</li></ol><h2 id="制作证书密钥"><a href="#制作证书密钥" class="headerlink" title="制作证书密钥"></a>制作证书密钥</h2><p>首先创建一个文件夹<code>/etc/docker</code>,并切换到该目录下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;etc&#x2F;docker &amp;&amp; cd &#x2F;etc&#x2F;docker</code></pre></div></figure><p>创建根证书RSA私钥：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa -aes256 -out ca-key.pem 4096</code></pre></div></figure><p>创建CA证书：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -subj &quot;&#x2F;CN&#x3D;*&quot; -out ca.pem</code></pre></div></figure><p>创建服务端私钥：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa -out server-key.pem 4096</code></pre></div></figure><p>创建服务端签名请求证书文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req -subj &quot;&#x2F;CN&#x3D;*&quot; -sha256 -new -key server-key.pem -out server.csr</code></pre></div></figure><p>创建<code>extfile.cnf</code>的配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo subjectAltName &#x3D; IP:自己的IP,IP:0.0.0.0 &gt;&gt; extfile.cnfecho extendedKeyUsage &#x3D; serverAuth &gt;&gt; extfile.cnf</code></pre></div></figure><p>创建签名生效的服务端证书文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf</code></pre></div></figure><p>创建客户端私钥：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa -out key.pem 4096</code></pre></div></figure><p>创建客户端签名请求证书文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req -subj &quot;&#x2F;CN&#x3D;client&quot; -new -key key.pem -out client.csr</code></pre></div></figure><p>追加<code>extfile.cnf</code>的配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">echo extendedKeyUsage &#x3D; clientAuth &gt;&gt; extfile.cnf</code></pre></div></figure><p>创建签名生效的客户端证书文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile.cnf</code></pre></div></figure><p>删除多余文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf ca.srl client.csr extfile.cnf server.csr</code></pre></div></figure><p>文件授权：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod -v 0400 ca-key.pem key.pem server-key.pemchmod -v 0444 ca.pem server-cert.pem cert.pem</code></pre></div></figure><h2 id="配置docker支持SSL"><a href="#配置docker支持SSL" class="headerlink" title="配置docker支持SSL"></a>配置docker支持SSL</h2><p>编辑<code>/etc/docker/daemon.json</code>配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;cache-disabled&quot;: &quot;false&quot;,    &quot;cache-max-file&quot;: &quot;5&quot;,    &quot;cache-max-size&quot;: &quot;20m&quot;,    &quot;cache-compress&quot;: &quot;true&quot;,    &quot;env&quot;: &quot;os,customer&quot;,    &quot;labels&quot;: &quot;somelabel&quot;,    &quot;max-file&quot;: &quot;5&quot;,    &quot;max-size&quot;: &quot;10m&quot;  &#125;,  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;ustc-edu-cn.mirror.aliyuncs.com&quot;],  &quot;tls&quot;: true,  &quot;tlscacert&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;ca.pem&quot;,  &quot;tlscert&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;server-cert.pem&quot;,  &quot;tlskey&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;server-key.pem&quot;,  &quot;tlsverify&quot;: true&#125;</code></pre></div></figure><p>编辑<code>/etc/docker/daemon.json</code>配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</code></pre></div></figure><p>修改ExecStart：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; -H tcp:&#x2F;&#x2F;0.0.0.0:2375</code></pre></div></figure><p>重启Docker：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload &amp;&amp; systemctl restart docker</code></pre></div></figure><h2 id="验证Docker远程连接"><a href="#验证Docker远程连接" class="headerlink" title="验证Docker远程连接"></a>验证Docker远程连接</h2><p>将服务器中的三个文件(<code>ca.pem</code>、<code>cert.pem</code>、<code>key.pem</code>)复制到自己的电脑中。</p><p>可以使用IDEA的docker客户端连接测试。图形化工具亦可。</p><h2 id="懒人脚本"><a href="#懒人脚本" class="headerlink" title="懒人脚本"></a>懒人脚本</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 获取服务器公网IP和用户输入的ca密码read -p &quot;请输入您的服务器公网IP地址： &quot; PUBLIC_IPread -p &quot;请输入您想要设置的CA密码： &quot; CA_PASSWORD# 生成SSL证书和密钥sudo mkdir &#x2F;etc&#x2F;dockersudo openssl genrsa -aes256 -out &#x2F;etc&#x2F;docker&#x2F;ca-key.pem -passout pass:$CA_PASSWORD 4096sudo openssl req -new -x509 -days 365 -key &#x2F;etc&#x2F;docker&#x2F;ca-key.pem -sha256 -out &#x2F;etc&#x2F;docker&#x2F;ca.pem -passin pass:$CA_PASSWORD -subj &quot;&#x2F;C&#x3D;CH&#x2F;ST&#x3D;CA&#x2F;O&#x3D;Cikaros&#x2F;OU&#x3D;Cikaros&#x2F;CN&#x3D;$PUBLIC_IP&quot;sudo openssl genrsa -out &#x2F;etc&#x2F;docker&#x2F;server-key.pem 4096sudo openssl req -subj &quot;&#x2F;CN&#x3D;$PUBLIC_IP&quot; -sha256 -new -key &#x2F;etc&#x2F;docker&#x2F;server-key.pem -out &#x2F;etc&#x2F;docker&#x2F;server.csrsudo echo subjectAltName &#x3D; DNS:$PUBLIC_IP,IP:$PUBLIC_IP,IP:0.0.0.0 &gt; &#x2F;etc&#x2F;docker&#x2F;extfile.cnfsudo openssl x509 -req -days 365 -sha256 -in &#x2F;etc&#x2F;docker&#x2F;server.csr -CA &#x2F;etc&#x2F;docker&#x2F;ca.pem -CAkey &#x2F;etc&#x2F;docker&#x2F;ca-key.pem -CAcreateserial -out &#x2F;etc&#x2F;docker&#x2F;server-cert.pem -extfile &#x2F;etc&#x2F;docker&#x2F;extfile.cnf -passin pass:$CA_PASSWORD# 生成客户端证书和密钥sudo openssl genrsa -out &#x2F;etc&#x2F;docker&#x2F;key.pem 4096sudo openssl req -subj &#39;&#x2F;CN&#x3D;client&#39; -new -key &#x2F;etc&#x2F;docker&#x2F;key.pem -out &#x2F;etc&#x2F;docker&#x2F;client.csrsudo openssl x509 -req -days 365 -sha256 -in &#x2F;etc&#x2F;docker&#x2F;client.csr -CA &#x2F;etc&#x2F;docker&#x2F;ca.pem -CAkey &#x2F;etc&#x2F;docker&#x2F;ca-key.pem \-CAcreateserial -out &#x2F;etc&#x2F;docker&#x2F;cert.pem -extfile &#x2F;etc&#x2F;docker&#x2F;extfile.cnf -passin pass:$CA_PASSWORD# 删除无用文件sudo rm -v &#x2F;etc&#x2F;docker&#x2F;client.csr &#x2F;etc&#x2F;docker&#x2F;server.csr# 为证书文件授权sudo chmod -v 0400 &#x2F;etc&#x2F;docker&#x2F;ca-key.pem &#x2F;etc&#x2F;docker&#x2F;key.pem &#x2F;etc&#x2F;docker&#x2F;server-key.pemsudo chmod -v 0444 &#x2F;etc&#x2F;docker&#x2F;ca.pem &#x2F;etc&#x2F;docker&#x2F;server-cert.pem &#x2F;etc&#x2F;docker&#x2F;cert.pem# 修改daemon.json文件sudo cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;cache-disabled&quot;: &quot;false&quot;,    &quot;cache-max-file&quot;: &quot;5&quot;,    &quot;cache-max-size&quot;: &quot;20m&quot;,    &quot;cache-compress&quot;: &quot;true&quot;,    &quot;env&quot;: &quot;os,customer&quot;,    &quot;labels&quot;: &quot;somelabel&quot;,    &quot;max-file&quot;: &quot;5&quot;,    &quot;max-size&quot;: &quot;10m&quot;  &#125;,  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;ustc-edu-cn.mirror.aliyuncs.com&quot;],  &quot;tls&quot;: true,  &quot;tlscacert&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;ca.pem&quot;,  &quot;tlscert&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;server-cert.pem&quot;,  &quot;tlskey&quot;: &quot;&#x2F;etc&#x2F;docker&#x2F;server-key.pem&quot;,  &quot;tlsverify&quot;: true&#125;EOF# 修改docker.service文件以允许远程端口访问sudo sed -i &#39;s&#x2F;-H fd:\&#x2F;\&#x2F;&#x2F;-H fd:\&#x2F;\&#x2F; -H tcp:\&#x2F;\&#x2F;0.0.0.0:2375&#x2F;g&#39; &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.servicesudo systemctl daemon-reloadsudo systemctl restart dockerecho &quot;已完成Docker的SSL配置和远程访问端口设置。&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL</tag>
      
      <tag>Docker</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Compose环境搭建及其使用</title>
    <link href="/doc/d0af4468.html"/>
    <url>/doc/d0af4468.html</url>
    
    <content type="html"><![CDATA[<p>Compose文件是一个定义Docker应用程序的服务，网络和卷的YAML文件。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Compose文件是一个定义Docker应用程序的服务，网络和卷的YAML文件。</p><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p>有几种版本的Compose文件格式 1、2、2.x和3.x</p><p>此表显示哪些Compose文件版本支持特定的Docker版本。</p><table><thead><tr><th>Compose file format</th><th>Docker Engine release</th></tr></thead><tbody><tr><td>3.3</td><td>17.06.0+</td></tr><tr><td>3.2</td><td>17.04.0+</td></tr><tr><td>3.1</td><td>1.13.1+</td></tr><tr><td>3.0</td><td>1.13.0+</td></tr><tr><td>2.3</td><td>17.06.0+</td></tr><tr><td>2.2</td><td>1.13.0+</td></tr><tr><td>2.1</td><td>1.12.0+</td></tr><tr><td>2.0</td><td>1.10.0+</td></tr><tr><td>1.0</td><td>1.9.1.+</td></tr></tbody></table><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>目前有三种版本的Compose文件格式：</p><ul><li>版本1，传统格式。这是通过省略<code>version</code>YAML根部的一个键来指定的。</li><li>版本2.x. 这是通过YAML根部的一个<code>version: &#39;2&#39;</code>或者<code>version: &#39;2.1&#39;</code>等等条目指定的。</li><li>版本3.x是最新和推荐的版本，旨在在Compose和Docker Engine的swarm模式之间交叉兼容。这是通过YAML根部的一个<code>version: &#39;3&#39;</code>或者<code>version: &#39;3.1&#39;</code>等等条目指定的。</li></ul><p>下面将一一介绍版本差异：</p><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>当在书写<code>docker-compose.yml</code>文件时不声明文件版本时，默认为<strong>版本1</strong>。这个版本中，所有的服务都是直接声明在根下的。</p><p>在<strong>版本1</strong>文件中是不能声明<code>volumes</code>、<code>network</code>和构建参数的。</p><p>在使用<strong>版本1</strong>时，<strong>Compose</strong>会将每一个容器都放置在一个默认的<code>bridge</code>环境中。</p><p><em>example:</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">web:  build: .  ports:    - &quot;5000:5000&quot;  volumes:    - .:&#x2F;code  links:    - redisredis:  image: redis:latest</code></pre></div></figure><h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>当在书写<code>docker-compose.yml</code>文件时，此时则必须在文档根目录下声明版本号。</p><p>所有的服务均需声明在<code>services:</code>目录下。</p><p>命名卷声明在<code>volumes:</code>目录下，网络声明在<code>networks:</code>目录下。</p><p>默认情况下，每个容器均会加入<strong>Project</strong>（<em>应用程序：</em>即一个<code>docker-compose.yml</code>文件的范围）范围的默认网络中，并且相互之间可以使用服务名访问对方，<code>links</code>可以弃用了。</p><p><em>example:</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;2&#39;services:  web:    build: &quot;&quot;    ports:      - &quot;5000:5000&quot;    volumes:      - .&#x2F;code  redis:    image: redis:latest</code></pre></div></figure><p><em>Full example:</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;2&#39;services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:&#x2F;code    networks:      - front-tier      - back-tier  redis:    image: redis:latest    volumes:      - redis-data:&#x2F;var&#x2F;lib&#x2F;redis    networks:      - back-tiervolumes:  redis-data:    driver: localnetworks:  front-tier:    driver: bridge  back-tier:    driver: bridge</code></pre></div></figure><h4 id="版本2-1"><a href="#版本2-1" class="headerlink" title="版本2.1"></a>版本2.1</h4><p>引入以下附加参数：</p><ul><li><code>link_local_ips</code></li><li><code>isolation</code></li><li><code>labels</code></li><li><code>name</code></li><li><code>userns_mode</code></li><li><code>healthcheck</code></li><li><code>sysctls</code></li><li><code>pids_limit</code></li></ul><h4 id="版本2-2"><a href="#版本2-2" class="headerlink" title="版本2.2"></a>版本2.2</h4><p>引入以下附加参数：</p><ul><li><code>init</code></li><li><code>scale</code></li></ul><h4 id="版本2-3"><a href="#版本2-3" class="headerlink" title="版本2.3"></a>版本2.3</h4><p>引入以下附加参数：</p><ul><li><code>target</code></li><li><code>start_period</code> 与 <code>healthchecks</code></li></ul><h4 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h4><p>为了在Compose和Docker Engine的swarm模式之间交叉兼容，版本3删除了几个选项并添加了更多选项。</p><ul><li>删除：<code>volume_driver</code>，<code>volumes_from</code>，<code>cpu_shares</code>，<code>cpu_quota</code>，<code>cpuset</code>，<code>mem_limit</code>，<code>memswap_limit</code>，<code>extends</code>，<code>group_add</code><br>。请参阅升级指南以了解如何迁移这些指南。（有关更多信息<code>extends</code>，请参阅扩展服务。）</li><li>补充：部署</li></ul><h4 id="版本3-3"><a href="#版本3-3" class="headerlink" title="版本3.3"></a>版本3.3</h4><p>引入以下附加参数：</p><ul><li>建立 <code>labels</code></li><li><code>credential_spec</code></li><li><code>configs</code></li><li>部署 <code>endpoint_mode</code></li></ul><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><h4 id="版本2-x到3-x"><a href="#版本2-x到3-x" class="headerlink" title="版本2.x到3.x"></a>版本2.x到3.x</h4><p>在版本2.x和3.x之间，yml文件的结构是相同的，但是几个选项已被删除：</p><ul><li><code>volume_driver</code>：不是在服务上设置卷驱动，而是使用顶层<code>volumes</code>选项定义卷并在那里指定驱动。版本：“3”服务：db：image：postgres卷： - data：&#x2F; var &#x2F; lib &#x2F; postgresql<br>&#x2F; data卷：data：驱动程序：mydriver</li><li><code>volumes_from</code>：要在服务之间共享卷，请使用顶级<code>volumes</code>选项对其进行定义，并从使用服务级别<code>volumes</code>选项共享服务的每个服务中引用它。</li><li><code>cpu_shares</code>，<code>cpu_quota</code>，<code>cpuset</code>，<code>mem_limit</code>，<code>memswap_limit</code>：这些已被替换下的资源键<code>deploy</code>。请注意，<code>deploy</code><br>配置仅在使用时生效<code>docker stack deploy</code>，并被忽略<code>docker-compose</code>。</li><li><code>extends</code>：对于<code>version: &quot;3.x&quot;</code>撰写文件，此选项已被删除。（有关更多信息，请参阅扩展服务。）</li><li><code>group_add</code>：对于<code>version: &quot;3.x&quot;</code>撰写文件，此选项已被删除。</li><li><code>pids_limit</code>：此选项尚未在<code>version: &quot;3.x&quot;</code>Compose文件中引入。</li><li><code>link_local_ips</code>in <code>networks</code>：该选项尚未在<code>version: &quot;3.x&quot;</code>Compose文件中引入。</li></ul><h4 id="版本1到2-x"><a href="#版本1到2-x" class="headerlink" title="版本1到2.x"></a>版本1到2.x</h4><p>在大多数情况下，从版本1移动到2是一个非常简单的过程：</p><ol><li>将整个文件缩进一层，并<code>services:</code>在顶部放置一个键。</li><li><code>version: &#39;2&#39;</code>在文件顶部添加一行。</li></ol><p>如果您使用特定的配置功能，则会更加复杂：</p><ul><li><code>dockerfile</code>：现在<code>context</code>在<code>build</code>之下：<code>build: context:</code>。dockerfile：Dockerfile-alternate</li><li><code>log_driver</code>，<code>log_opt</code>：这些现在在<code>logging</code>密钥下：<code>logging: driver: syslog options: syslog-address: &quot;tcp://192.168.0.42:123&quot;</code></li><li><code>links</code>使用环境变量：如环境变量引用中所述，由链接创建的环境变量已被弃用一段时间。在新的Docker网络系统中，它们已被删除。您应该直接连接到适当的主机名或使用链接主机名设置相关的环境变量：web：links： - db<br>environment： - DB_PORT &#x3D; tcp：&#x2F;&#x2F; db：5432</li><li><code>external_links</code><br>：Compose在运行版本2项目时使用Docker网络，因此链接的行为稍有不同。特别是，两个容器必须连接到至少一个共同的网络才能通信，即使明确地链接在一起。将外部容器连接到应用程序的默认网络，或者将外部容器和服务的容器连接到外部网络。</li><li><code>net</code>：这现在被network_mode：net：host - &gt; network_mode：host net：bridge - &gt; network_mode：bridge net：none - &gt;<br>network_mode：none 替代如果您正在使用<code>net: &quot;container:[service name]&quot;</code>，您现在必须<code>network_mode: &quot;service:[service name]&quot;</code><br>改用它。net：“container：web” - &gt; network_mode：“service：web”如果你正在使用<code>net: &quot;container:[container name/id]&quot;</code><br>，这个值不需要改变。net：“container：cont-name” - &gt; network_mode：“container：cont-name”net：“container：abc12345” - &gt;<br>network_mode：“container：abc12345”</li><li><code>volumes</code>使用命名卷：现在必须在<code>volumes</code>Compose文件的顶级部分显式声明这些命令。如果某个服务装载了一个已命名的卷<code>data</code>，则必须<code>data</code>在顶级<code>volumes</code><br>部分中声明一个卷。整个文件可能如下所示：版本：’2’服务：db：image：postgres卷： - data：&#x2F; var &#x2F; lib &#x2F; postgresql &#x2F;<br>data卷：data：默认情况下，Compose创建一个卷，其名称带有前缀与您的项目名称。如果您希望仅调用<code>data</code>它，请将其声明为external：volumes：data：external：true</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p>我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases%E3%80%82">https://github.com/docker/compose/releases。</a></p><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.24.1&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</code></pre></div></figure><p>要安装其他版本的 Compose，请替换 1.24.1。</p><p>将可执行权限应用于二进制文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</code></pre></div></figure><h3 id="Docker-Desktop-or-Docker-Toolbox"><a href="#Docker-Desktop-or-Docker-Toolbox" class="headerlink" title="Docker Desktop or Docker Toolbox"></a>Docker Desktop or Docker Toolbox</h3><p>Docker 桌面版和 Docker Toolbox 已经包括 Compose 和其他 Docker 应用程序，因此 Windows 用户不需要单独安装 Compose。</p><h2 id="Docker-Compose指令"><a href="#Docker-Compose指令" class="headerlink" title="Docker-Compose指令"></a>Docker-Compose指令</h2><ul><li><p>build</p></li><li><p>bundle</p></li><li><p>config</p></li><li><p>create</p></li><li><p>down</p></li><li><p>events</p></li><li><p>exec</p></li><li><p>help</p></li><li><p>images</p></li><li><p>kill</p></li><li><p>logs</p></li><li><p>pause</p></li><li><p>port</p></li><li><p>PS</p></li><li><p>pull</p></li><li><p>push</p></li><li><p>restart</p></li><li><p>rm</p></li><li><p>run</p></li><li><p>scale</p></li><li><p>start</p></li><li><p>stop</p></li><li><p>top</p></li><li><p>unpause</p></li><li><p>up</p></li></ul><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: build [options] [--build-arg key&#x3D;val...] [SERVICE...]Options:        --force-rm              Always remove intermediate containers.        --no-cache              Do not use cache when building the image.        --pull                  Always attempt to pull a newer version of the image.        --build-arg key&#x3D;val     Set build-time variables for one service.</code></pre></div></figure><p>构建docker-compose服务。服务名默认为<code>project_service</code>。</p><h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: bundle [options]Options:        --push-img              Automatically push img for any services                               which have a &#96;build&#96; option specified.        -o, --output PATH          Path to write the bundle file to.                               Defaults to &quot;&lt;project name&gt;.dab&quot;.</code></pre></div></figure><p>生成分布式应用程序包（DAB）。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: config [options]Options:        --resolve-image-digests  Pin image tags to digests.        -q, --quiet              Only validate the configuration, don&#39;t print                             anything.        --services               Print the service names, one per line.       --volumes                Print the volume names, one per line.</code></pre></div></figure><p>验证并查看<code>docker-compose.yml</code>文件。</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: create [options] [SERVICE...]Options:    --force-recreate       Recreate containers even if their configuration and                           image haven&#39;t changed. Incompatible with --no-recreate.    --no-recreate          If containers already exist, don&#39;t recreate them.                           Incompatible with --force-recreate.    --no-build             Don&#39;t build an image, even if it&#39;s missing.    --build                Build img before creating containers.</code></pre></div></figure><p>为服务创建容器。</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: down [options]Options:        --rmi type          Remove img. Type must be one of:                                                &#39;all&#39;: Remove all img used by any service.                                                &#39;local&#39;: Remove only img that don&#39;t have a custom tag                                                set by the &#96;image&#96; field.        -v, --volumes       Remove named volumes declared in the &#96;volumes&#96; section                                                of the Compose file and anonymous volumes                        attached to containers.        --remove-orphans    Remove containers for services not defined in the                        Compose file</code></pre></div></figure><p>停止容器并移除通过<code>up</code>创建的容器，网络，卷和图像。</p><p>默认情况下，唯一删除的内容是：</p><ul><li><p>在撰写文件中定义的服务容器</p></li><li><p>在撰写文件的部分中定义的网络<code>networks</code></p></li><li><p>默认网络（如果使用的话）</p></li></ul><p><strong>注：由用户自定义的网络和卷不会删除。</strong></p><h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: events [options] [SERVICE...]    Options:            --json      Output events as a stream of json objects</code></pre></div></figure><p>为项目中的每个容器流化容器事件。</p><p>使用该<code>--json</code>标志，每行将打印一个 json 对象，其格式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;service&quot;: &quot;web&quot;,  &quot;event&quot;: &quot;create&quot;,  &quot;container&quot;: &quot;213cf75fc39a&quot;,  &quot;image&quot;: &quot;alpine:edge&quot;,  &quot;time&quot;: &quot;2015-11-20T18:01:03.615550&quot;&#125;</code></pre></div></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: exec [options] SERVICE COMMAND [ARGS...]    Options:        -d                Detached mode: Run command in the background.        --privileged      Give extended privileges to the process.        -u, --user USER   Run the command as this user.        -T                Disable pseudo-tty allocation. By default &#96;docker-compose exec&#96;                          allocates a TTY.        --index&#x3D;index     index of the container if there are multiple                          instances of a service [default: 1]</code></pre></div></figure><p>这相当于<code>docker exec</code>。使用此子命令，您可以在服务中运行任意命令。命令默认分配一个 TTY ，所以你可以通过此命令获得交互式提示。例如:<code>docker-compose exec web bash</code>。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: img [options] [SERVICE...]    Options:        -q     Only display image IDs</code></pre></div></figure><p>列出创建的容器使用的图像。</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: kill [options] [SERVICE...]    Options:    -s SIGNAL         SIGNAL to send to the container. Default signal is SIGKILL.</code></pre></div></figure><p>运行容器的强制通过发送<code>SIGKILL</code>信号来停止。可以选择要传递的信号类型，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose kill -s SIGINT</code></pre></div></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: logs [options] [SERVICE...]    Options:    --no-color          Produce monochrome output.    -f, --follow        Follow log output    -t, --timestamps    Show timestamps    --tail&#x3D;&quot;all&quot;        Number of lines to show from the end of the logs                                            for each container.</code></pre></div></figure><p>显示服务的日志输出。</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: pause [SERVICE...]</code></pre></div></figure><p>暂停运行服务的容器。它可以与<code>docker-compose unpause</code>一起使用。</p><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: port [options] SERVICE PRIVATE_PORTOptions:    --protocol&#x3D;proto  tcp or udp [default: tcp]    --index&#x3D;index     index of the container if there are multiple                      instances of a service [default: 1]</code></pre></div></figure><p>打印端口绑定的公共端口。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: ps [options] [SERVICE...]Options:-q    Only display IDs</code></pre></div></figure><p>列出容器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose ps         Name                        Command                 State             Ports         --------------------------------------------------------------------------------------------         mywordpress_db_1          docker-entrypoint.sh mysqld      Up           3306&#x2F;tcp         mywordpress_wordpress_1   &#x2F;entrypoint.sh apache2-for ...   Restarting   0.0.0.0:8000-&gt;80&#x2F;tcp</code></pre></div></figure><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: pull [options] [SERVICE...]    Options:        --ignore-pull-failures  Pull what it can and ignores img with pull failures.        --parallel              Pull multiple img in parallel.        --quiet                 Pull without printing progress information</code></pre></div></figure><p>拉取在<code>docker-compose.yml</code>或<code>docker-stack.yml</code>文件中定义的服务相关联的映像，但不会基于这些映像启动容器。</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: push [options] [SERVICE...]Options:    --ignore-push-failures  Push what it can and ignores img with push failures.</code></pre></div></figure><p>将服务的镜像推送到它们各自的位置<code>registry/repository</code>。</p><p>做出以下假设：</p><ul><li><p>您正在推送您在本地创建的镜像</p></li><li><p>您可以访问构建密钥</p></li></ul><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: restart [options] [SERVICE...]Options:-t, --timeout TIMEOUT      Specify a shutdown timeout in seconds. (default: 10)</code></pre></div></figure><p>重新启动所有停止并正在运行的服务</p><p>如果对<code>docker-compose.yml</code>配置进行更改，则运行此命令后这些更改将不会反映出来。</p><p>例如，对环境变量（在构建容器后但在容器的命令执行之前添加）的更改在重新启动后将不会更新。</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: rm [options] [SERVICE...]Options:    -f, --force   Don&#39;t ask to confirm removal    -s, --stop    Stop the containers, if required, before removing    -v            Remove any anonymous volumes attached to containers</code></pre></div></figure><p>删除已停止的服务容器。</p><p>默认情况下，附加到容器的匿名卷不会被删除。你可以用这个覆盖它<code>-v</code>。要列出所有卷，请使用<code>docker volume ls</code>。</p><p>任何不在卷中的数据都将丢失。</p><p>运行没有选项的命令也会删除由<code>docker-compose up</code>或创建的一次性容器<code>docker-compose run</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose rmGoing to remove djangoquickstart_web_run_1Are you sure? [yN] yRemoving djangoquickstart_web_run_1 ... done</code></pre></div></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: run [options] [-v VOLUME...] [-p PORT...] [-e KEY&#x3D;VAL...] SERVICE [COMMAND] [ARGS...]Options:            -d                    Detached mode: Run container in the background, print                                                        new container name.            --name NAME           Assign a name to the container            --entrypoint CMD      Override the entrypoint of the image.            -e KEY&#x3D;VAL            Set an environment variable (can be used multiple times)            -u, --user&#x3D;&quot;&quot;         Run as specified username or uid            --no-deps             Don&#39;t start linked services.            --rm                  Remove container after run. Ignored in detached mode.            -p, --publish&#x3D;[]      Publish a container&#39;s port(s) to the host            --service-ports       Run command with the service&#39;s ports enabled and mapped                              to the host.            -v, --volume&#x3D;[]       Bind mount a volume (default [])            -T                    Disable pseudo-tty allocation. By default &#96;docker-compose run&#96;                              allocates a TTY.            -w, --workdir&#x3D;&quot;&quot;      Working directory inside the container</code></pre></div></figure><p>针对服务运行一次性命令。例如，以下命令启动该<code>web</code>服务并<code>bash</code>作为其命令运行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run web bash</code></pre></div></figure><p>您使用的命令<code>run</code>从具有由服务定义的配置的新容器中启动，包括卷，链接和其他详细信息。但是，有两个重要的区别。</p><p>首先，通过的命令将<code>run</code>覆盖服务配置中定义的命令。例如，如果<code>web</code>服务配置以<code>bash</code>开头，则将其<code>docker-compose run web python app.py</code>覆盖<code>python app.py</code>。</p><p>第二个区别是该<code>docker-compose run</code>命令不会创建服务配置中指定的任何端口。这可以防止端口与已打开的端口发生冲突。如果您<em>确实想要</em>创建服务的端口并将其映射到主机，请指定<code>--service-ports</code>标签：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run --service-ports web python manage.py shell</code></pre></div></figure><p>或者，可以使用<code>--publish</code>或<code>-p</code>选项，就像使用<code>docker run</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run --publish 8080:80 -p 2022:22 -p 127.0.0.1:2021:21 web python manage.py shell</code></pre></div></figure><p>如果启动使用链接配置的服务，则该<code>run</code>命令首先检查链接服务是否正在运行，并在服务停止时启动该服务。一旦所有链接的服务正在运行，<code>run</code>执行您通过它的命令。例如，您可以运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run db psql -h db -U docker</code></pre></div></figure><p>这将为链接<code>db</code>容器打开一个交互式 PostgreSQL shell 。</p><p>如果您不希望<code>run</code>命令启动链接容器，请使用<code>--no-deps</code>标签：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run --no-deps web python manage.py shell</code></pre></div></figure><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><blockquote><p><strong>注</strong>该命令已弃用。若需使用该命令，请用<code>--scale</code>标签代替。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: scale [SERVICE&#x3D;NUM...]</code></pre></div></figure><p>设置为服务运行的容器数量。</p><p>数字在表单中被指定为参数<code>service=num</code>。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose scale web&#x3D;2 worker&#x3D;3</code></pre></div></figure><blockquote><p><strong>提示</strong>：或者，在 Compose 文件版本3.x中，您可以将部署密钥下的副本指定为 Swarm 模式的服务配置的一部分。请注意，<code>deploy</code>密钥及其子选项（包括<code>replicas</code>）仅适用于<code>docker stack deploy</code>命令，不适用于<code>docker compose up</code>或<code>docker-compose run</code>。</p></blockquote><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: start [SERVICE...]</code></pre></div></figure><p>启动服务的现有容器。</p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: stop [options] [SERVICE...]    Options:        -t, --timeout TIMEOUT      Specify a shutdown timeout in seconds (default: 10).</code></pre></div></figure><p>停止运行容器而不删除它们。他们可以重新开始<code>docker-compose start</code>。</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: top [SERVICE...]</code></pre></div></figure><p>显示正在运行的进程。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose topcompose_service_a_1PID    USER   TIME   COMMAND----------------------------4060   root   0:00   topcompose_service_b_1PID    USER   TIME   COMMAND----------------------------4115   root   0:00   top</code></pre></div></figure><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: unpause [SERVICE...]</code></pre></div></figure><p>取消暂停服务的暂停容器。</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a><font color='red'>up</font></h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: up [options] [--scale SERVICE&#x3D;NUM...] [SERVICE...]Options:    -d              Detached mode: Run containers in the background,                       print new container names.                       Incompatible with --abort-on-container-exit.            --no-color          Produce monochrome output.            --no-deps           Don&#39;t start linked services.            --force-recreate       Recreate containers even if their configuration                       and image haven&#39;t changed.                       Incompatible with --no-recreate.            --no-recreate         If containers already exist, don&#39;t recreate them.                       Incompatible with --force-recreate.            --no-build          Don&#39;t build an image, even if it&#39;s missing.            --build            Build img before starting containers.            --abort-on-container-exit   Stops all containers if any container was stopped.                       Incompatible with -d.            -t, --timeout TIMEOUT    Use this timeout in seconds for container shutdown                       when attached or when containers are already                       running. (default: 10)            --remove-orphans       Remove containers for services not defined in                       the Compose file            --exit-code-from SERVICE   Return the exit code of the selected service container.                       Implies --abort-on-container-exit.            --scale SERVICE&#x3D;NUM     Scale SERVICE to NUM instances. Overrides the &#96;scale&#96;                       setting in the Compose file if present.</code></pre></div></figure><p>构建，（重新）创建，启动并附加到服务的容器。</p><p>除非它们已经在运行，否则该命令还会启动所有相关联的服务。</p><p>该<code>docker-compose up</code>命令汇总每个容器的输出。当命令退出时，所有容器都停止。运行<code>docker-compose up -d</code>将在后台启动容器并使其运行。</p><p>如果存在服务的现有容器，并且在创建容器后服务的配置或映像已更改，则<code>docker-compose up</code>通过停止并重新创建容器（保留已安装的卷）来提取更改。要防止撰写选取更改，请使用该<code>--no-recreate</code>标签。</p><p>如果您想强制 Compose 停止并重新创建所有容器，请使用该<code>--force-recreate</code>标签。</p><p>如果进程遇到错误，则此命令的退出代码为<code>1</code>。</p><p>如果使用<code>SIGINT</code>（<code>ctrl</code>+ <code>C</code>）中断进程或者<code>SIGTERM</code>容器停止，并且退出代码为<code>0</code>。</p><p>如果<code>SIGINT</code>或<code>SIGTERM</code>在此关闭阶段再次发送，正在运行的容器将被终止，并且退出代码为<code>2</code>。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Compose 支持在<code>.env</code>放在<code>docker-compose</code>执行该命令的文件夹<em>（</em>当前工作目录<em>）</em>中的环境文件中声明默认环境变量。</p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>这些语法规则适用于<code>.env</code>档案：</p><ul><li><p>以<code>VAR=VAL</code>格式组合期望<code>env</code>文件。</p></li><li><p>以<code>#</code>（即注释）开头的行被忽略。</p></li><li><p>空行被忽略。</p></li><li><p>没有特殊的引号处理（即<strong>它们将成为 VAL 的一部分</strong>，你已经被警告;））。</p></li></ul><h3 id="编写文件和-CLI-变量"><a href="#编写文件和-CLI-变量" class="headerlink" title="编写文件和 CLI 变量"></a>编写文件和 CLI 变量</h3><p>这里定义的环境变量将用于变量替换在撰写文件中，并且还可以用于定义以下内容 CLI 变量</p><ul><li><p><code>COMPOSE_API_VERSION</code></p></li><li><p><code>COMPOSE_CONVERT_WINDOWS_PATHS</code></p></li><li><p><code>COMPOSE_FILE</code></p></li><li><p><code>COMPOSE_HTTP_TIMEOUT</code></p></li><li><p><code>COMPOSE_TLS_VERSION</code></p></li><li><p><code>COMPOSE_PROJECT_NAME</code></p></li><li><p><code>DOCKER_CERT_PATH</code></p></li><li><p><code>DOCKER_HOST</code></p></li><li><p><code>DOCKER_TLS_VERIFY</code></p></li></ul><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li><p>运行时环境中存在的值将始终覆盖在<code>.env</code>档案。同样，通过命令行参数传递的值也优先。</p></li><li><p>中定义的环境变量。<code>.env</code>文件在容器中不自动可见。若要设置适用于容器的环境变量，请遵循本主题中的指导方针。组合中的环境变量，描述如何将 shell 环境变量传递到容器，在复合文件中定义环境变量等等。</p></li></ul><h2 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h2><p>撰写中有多个部分在某种意义上处理环境变量。这个页面应该可以帮助你找到你需要的信息。</p><h3 id="在组合文件中替换环境变量"><a href="#在组合文件中替换环境变量" class="headerlink" title="在组合文件中替换环境变量"></a>在组合文件中替换环境变量</h3><p>可以在 shell 中使用环境变量填充复合文件中的值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  image: &quot;webapp:$&#123;TAG&#125;&quot;</code></pre></div></figure><p>有关更多信息，请参见变量替换节中的“撰写文件引用”。</p><h3 id="在容器中设置环境变量"><a href="#在容器中设置环境变量" class="headerlink" title="在容器中设置环境变量"></a>在容器中设置环境变量</h3><p>可以在服务的容器中设置环境变量。“环境”键，就像<code>docker run -e VARIABLE=VALUE ...</code>*</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  environment:    - DEBUG&#x3D;1</code></pre></div></figure><h3 id="将环境变量传递到容器"><a href="#将环境变量传递到容器" class="headerlink" title="将环境变量传递到容器"></a>将环境变量传递到容器</h3><p>可以将环境变量直接从shell传递到服务的容器，“环境”键不给他们一个价值，就像<code>docker run -e VARIABLE ...</code>*</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  environment:    - DEBUG</code></pre></div></figure><p><code>DEBUG</code>容器中的变量的值将从运行复合的 shell 中相同变量的值中提取。</p><h3 id="“env-file“-配置选项"><a href="#“env-file“-配置选项" class="headerlink" title="“env_file“ 配置选项"></a>“<strong>env_file</strong>“ 配置选项</h3><p>可以将多个环境变量从外部文件传递到服务的容器，env_file</p><p>选项，就像<code>docker run --env-file=FILE ...</code>*</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  env_file:    - web-variables.env</code></pre></div></figure><h3 id="以-“docker-compose-run”设置环境变量"><a href="#以-“docker-compose-run”设置环境变量" class="headerlink" title="以 “docker-compose run”设置环境变量"></a>以 “<strong>docker-compose run</strong>”设置环境变量</h3><p>就像<code>docker run -e</code>，则可以在一次性容器上设置环境变量<code>docker-compose run -e</code>*。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run -e DEBUG&#x3D;1 web python console.py</code></pre></div></figure><p>还可以通过不给变量值从 shell 传递变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose run -e DEBUG web python console.py</code></pre></div></figure><p><code>DEBUG</code>容器中的变量的值将从运行复合的 shell 中的相同变量的值中提取。</p><h3 id="“-env”文件"><a href="#“-env”文件" class="headerlink" title="“.env”文件"></a>“.env”文件</h3><p>控件中引用的任何环境变量或用于配置撰写的任何环境变量的默认值。环境文件命名<code>.env</code>*</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat .envTAG&#x3D;v1.5$ cat docker-compose.ymlversion: &#39;3&#39;services:  web:    image: &quot;webapp:$&#123;TAG&#125;&quot;</code></pre></div></figure><p>当你运行的时候<code>docker-compose up</code>，<code>web</code>上面定义的服务使用图像<code>webapp:v1.5</code>.您可以使用配置命令，它将已解析的应用程序配置打印到终端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose configversion: &#39;3&#39;services:  web:    image: &#39;webapp:v1.5&#39;</code></pre></div></figure><p>shell 中的值优先于<code>.env</code>文件中指定的值。如果你<code>TAG</code>在你的 shell 中设置了一个不同的值，那么这个替换就会<code>image</code>使用它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ export TAG&#x3D;v2.0$ docker-compose configversion: &#39;3&#39;services:  web:    image: &#39;webapp:v2.0&#39;</code></pre></div></figure><p>当使用 shell 中 <code>environment</code>变量和<code>env_file</code>配置文件提供值时，环境变量的值将首先<strong>从环境密钥获取，然后从环境文件获取，然后从</strong> *<strong>*</strong> -entry **<br>获取：<code>**Dockerfile**</code> <code>**ENV**</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat .&#x2F;Docker&#x2F;api&#x2F;api.envNODE_ENV&#x3D;test$ cat docker-compose.ymlversion: &#39;3&#39;services:  api:    image: &#39;node:6-alpine&#39;    env_file:     - .&#x2F;Docker&#x2F;api&#x2F;api.env    environment:     - NODE_ENV&#x3D;production</code></pre></div></figure><p>你可以用它来测试例如 NodeJSCLI 中的容器：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose exec api node&gt; process.env.NODE_ENV&#39;production&#39;</code></pre></div></figure><p>有任何<code>ARG</code>或<code>ENV</code>设置在<code>Dockerfile</code>只有在否码头工人作曲进入<code>environment</code>或<code>env_file</code></p><p>NodeJS 容器专用材料：如果你有<code>package.json</code>进入<code>script:start</code>就像<code>NODE_ENV=test node server.js</code>，这将推翻你的docker-compose.yml档案中任何文件。</p><h3 id="使用环境变量配置组合"><a href="#使用环境变量配置组合" class="headerlink" title="使用环境变量配置组合"></a>使用环境变量配置组合</h3><p>有几个环境变量可供您配置 Docker Compose 命令行行为。它们以 CLI 环境变量开头<code>COMPOSE_</code>或<code>DOCKER_</code>记录在 CLI 环境变量中。</p><h3 id="由链接创建的环境变量"><a href="#由链接创建的环境变量" class="headerlink" title="由链接创建的环境变量"></a>由链接创建的环境变量</h3><p>在 v1 撰写文件中使用 ‘links’ 选项时，将为每个链接创建环境变量。它们记录在 Link 环境变量参考中。但请注意，这些变量已被弃用 - 您应该将链接别名用作主机名。</p><h2 id="通用服务配置"><a href="#通用服务配置" class="headerlink" title="通用服务配置"></a>通用服务配置</h2><p>Compose 支持两种共享通用配置的方法：</p><ol><li><p>扩展整个撰写文件使用多个组合文件</p></li><li><p>扩展个人服务大<code>extends</code>场域</p></li></ol><h3 id="多重合成文件"><a href="#多重合成文件" class="headerlink" title="多重合成文件"></a>多重合成文件</h3><p>使用多个组合文件可以使您为不同的环境或不同的工作流自定义组合应用程序。</p><h4 id="理解多重组合文件"><a href="#理解多重组合文件" class="headerlink" title="理解多重组合文件"></a>理解多重组合文件</h4><p>默认情况下，撰写读取两个文件，<code>docker-compose.yml</code>还有一个可选的<code>docker-compose.override.yml</code>档案。根据惯例，<code>docker-compose.yml</code><br>包含基本配置。正如其名称所暗示的那样，覆盖文件可以包含对现有服务或全新服务的配置重写。</p><p>如果在两个文件中都定义了服务，则使用添加和覆盖配置.</p><p>若要使用多个覆盖文件或具有不同名称的重写文件，可以使用<code>-f</code>选项指定文件列表。按照命令行中指定的顺序编写合并文件。<code>docker-compose</code>命令引用有关使用<code>-f</code></p><p>使用多个配置文件时，必须确保文件中的所有路径相对于基本组合文件。这是必需的，因为重写文件不一定是有效的组合文件。覆盖文件可以包含小的配置片段。跟踪服务的哪个片段相对于哪个路径比较困难和混乱，因此，为了使路径更容易理解，必须相对于基文件定义所有路径。</p><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>在本节中，有两个用于多个组合文件的常用用例：为不同的环境更改一个组合应用程序，以及对一个复合应用程序运行管理任务。</p><h5 id="不同环境"><a href="#不同环境" class="headerlink" title="不同环境"></a>不同环境</h5><p>多文件的常见用例是为类似生产环境（可能是生产，分段或CI）更改开发撰写应用程序。为了支持这些差异，你可以将你的 Compose 配置分成几个不同的文件：</p><p>从一个基本文件开始，它定义了服务的规范配置。</p><p><strong>Docker-Compose.yml</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  image: example&#x2F;my_web_app:latest  links:    - db    - cachedb:  image: postgres:latestcache:  image: redis:latest</code></pre></div></figure><p>在此示例中，开发配置向主机公开了一些端口，将我们的代码作为卷装入，并构建 Web 图像。</p><p><strong>docker-compose.override.yml</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  build: .  volumes:    - &#39;.:&#x2F;code&#39;  ports:    - 8883:80  environment:    DEBUG: &#39;true&#39;db:  command: &#39;-d&#39;  ports:    - 5432:5432cache:  ports:    - 6379:6379</code></pre></div></figure><p>当你运行的时候<code>docker-compose up</code>它自动读取重写。</p><p>现在，在生产环境中使用 Compose 应用程序将会很好。因此，创建另一个覆盖文件（可能存储在不同的 git 仓库或由不同的团队管理）。</p><p><strong>Docker-Compose.prod.yml</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  ports:    - 80:80  environment:    PRODUCTION: &#39;true&#39;cache:  environment:    TTL: &#39;500&#39;</code></pre></div></figure><p>要使用此产品组合文件进行部署，可以运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d</code></pre></div></figure><p>这将使用<code>docker-compose.yml</code>和<code>docker-compose.prod.yml</code>（但不包括开发配置<code>docker-compose.override.yml</code>）中的配置部署所有三个服务。</p><p>有关产品中的 Compose 的更多信息，请参阅产品。</p><h5 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h5><p>另一个常见的用例是针对组合应用程序中的一个或多个服务运行临时或管理任务。此示例演示运行数据库备份。</p><p>从 <strong>Docker-Compose.yml</strong> 开始</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  image: example&#x2F;my_web_app:latest  links:    - dbdb:  image: postgres:latest</code></pre></div></figure><p>在 <strong>docker-compose.admin.yml</strong> 中添加一个新服务来运行数据库导出或备份。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dbadmin:  build: database_admin&#x2F;  links:    - db</code></pre></div></figure><p>开始正常的环境运行<code>docker-compose up -d</code>。要运行数据库备份，也要包含<code>docker-compose.admin.yml</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f docker-compose.yml -f docker-compose.admin.yml \    run dbadmin db-backup</code></pre></div></figure><h3 id="扩展服务"><a href="#扩展服务" class="headerlink" title="扩展服务"></a>扩展服务</h3><blockquote><p><strong>注意</strong>：<code>extends</code>关键字在早期的 Compose 文件格式中支持到 Compose 文件版本2.1（请参阅v1中的扩展和第2版中的扩展），但在 Compose 版本3.x中不受支持。请参阅第3版的添加和删除键摘要以及有关如何升级的信息。请参阅 moby &#x2F; moby＃31101 以关注<code>extends</code>在未来版本中以某种形式添加支持的可能性。</p></blockquote><p>Docker Compose 的<code>extends</code>关键字可以在不同文件之间共享通用配置，甚至可以完全共享不同的项目。如果您有多个服务可以重复使用一组通用配置选项，则扩展服务很有用。使用<code>extends</code><br>您可以在一个地方定义一套通用的服务选项，并从任何地方引用它。</p><p>记住<code>links</code>，<code>volumes_from</code>和<code>depends_on</code>从不使用<code>extends</code>服务之间共享。这些例外存在以避免隐式依赖性; 你总是本地定义<code>links</code>和<code>volumes_from</code><br>。这可以确保在读取当前文件时，服务之间的依赖关系清晰可见。在本地定义这些也确保对引用文件的更改不会破坏任何内容。</p><h4 id="理解扩展配置"><a href="#理解扩展配置" class="headerlink" title="理解扩展配置"></a>理解扩展配置</h4><p>中定义任何服务时<code>docker-compose.yml</code>，您可以声明您正在扩展如下的另一个服务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  extends:    file: common-services.yml    service: webapp</code></pre></div></figure><p>此指令将编写为重用<code>webapp</code>中定义的服务。<code>common-services.yml</code>档案。假设<code>common-services.yml</code>看起来是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">webapp:  build: .  ports:    - &quot;8000:8000&quot;  volumes:    - &quot;&#x2F;data&quot;</code></pre></div></figure><p>在这种情况下，您将得到完全相同的结果，就像您编写<code>docker-compose.yml</code>用同样的<code>build</code>，<code>ports</code>和<code>volumes</code>直接定义在<code>web</code>.</p><p>您可以进一步在本地定义（或重新定义）配置<code>docker-compose.yml</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  extends:    file: common-services.yml    service: webapp  environment:    - DEBUG&#x3D;1  cpu_shares: 5important_web:  extends: web  cpu_shares: 10</code></pre></div></figure><p>您还可以编写其他服务并链接<code>web</code>向他们提供服务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web:  extends:    file: common-services.yml    service: webapp  environment:    - DEBUG&#x3D;1  cpu_shares: 5  links:    - dbdb:  image: postgres</code></pre></div></figure><h4 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h4><p>当您有多个具有公共配置的服务时，扩展单个服务非常有用。下面的示例是一个包含两个服务的撰写应用程序：一个 Web 应用程序和一个队列工作程序。这两个服务使用相同的代码库，并共享许多配置选项。</p><p>在 <strong>common.yml 中</strong>我们定义了通用配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">app:  build: .  environment:    CONFIG_FILE_PATH: &#x2F;code&#x2F;config    API_KEY: xxxyyy  cpu_shares: 5</code></pre></div></figure><p>在 <strong>docker-compose.yml</strong> 中<strong>，</strong>我们定义了使用通用配置的具体服务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">webapp:  extends:    file: common.yml    service: app  command: &#x2F;code&#x2F;run_web_app  ports:    - 8080:8080  links:    - queue    - dbqueue_worker:  extends:    file: common.yml    service: app  command: &#x2F;code&#x2F;run_worker  links:    - queue</code></pre></div></figure><h3 id="添加和覆盖配置"><a href="#添加和覆盖配置" class="headerlink" title="添加和覆盖配置"></a>添加和覆盖配置</h3><p>将副本配置从原始服务复制到本地服务。如果在原始服务和本地服务中都定义了配置选项，则本地值取代或扩展原始价值。</p><p>对于单值选项<code>image</code>，<code>command</code>或者<code>mem_limit</code>，新值替换旧值。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># original servicecommand: python app.py# local servicecommand: python otherapp.py# resultcommand: python otherapp.py</code></pre></div></figure><blockquote><p><code>build</code>和<code>image</code>在撰写文件版本1 如属<code>build</code>和<code>image</code>，使用时编写文件格式的版本1，如果在原始服务中定义了另一个选项，则使用本地服务中的一个选项将导致组合放弃另一个选项。 例如，如果原始服务定义<code>image: webapp</code>本地服务定义<code>build: .</code>则结果服务将具有<code>build: .</code>而不是<code>image</code>选择。 这是因为<code>build</code>和<code>image</code>不能在版本1文件中一起使用。</p></blockquote><p>对于<strong>多值的选项</strong> <code>ports</code>，<code>expose</code>，<code>external_links</code>，<code>dns</code>，<code>dns_search</code>，和<code>tmpfs</code>，撰写会连接两组的值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># original serviceexpose:  - &quot;3000&quot;# local serviceexpose:  - &quot;4000&quot;  - &quot;5000&quot;# resultexpose:  - &quot;3000&quot;  - &quot;4000&quot;  - &quot;5000&quot;</code></pre></div></figure><p>在<code>environment</code>，<code>labels</code>，<code>volumes</code>和<code>devices</code>情况下，撰写“合并”的条目连同本地定义的值取的优先级：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># original serviceenvironment:  - FOO&#x3D;original  - BAR&#x3D;original# local serviceenvironment:  - BAR&#x3D;local  - BAZ&#x3D;local# resultenvironment:  - FOO&#x3D;original  - BAR&#x3D;local  - BAZ&#x3D;local</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器编排</tag>
      
      <tag>Docker-Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MKCert的安装与使用</title>
    <link href="/doc/ba191453.html"/>
    <url>/doc/ba191453.html</url>
    
    <content type="html"><![CDATA[<p>在本地开发中，有时候我们经常需要模拟https环境，比如PWA应用要求必须使用https访问。在传统的解决方案中，我们需要使用自签证书，<br>然后在http server中使用自签证书。由于自签证书浏览器不信任，为了解决浏览器信任问题我们需要将自签证书使用的CA证书添加到系统或浏览器的可信CA证书中，来规避这个问题。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MKCert是一个使用go语言编写的生成本地自签证书的小程序，具有跨平台，使用简单，支持多域名，自动信任CA等一系列方便的特性可供本地开发时快速创建https环境使用。</p><p>安装方式也非常简单，由于go语言的静态编译和跨平台的特性，官方提供各平台预编译的版本，直接下载到本地，给可执行权限(Linux&#x2F;Unix需要)就可以了。下载地址: <a href="https://github.com/FiloSottile/mkcert/releases/latest">https://github.com/FiloSottile/mkcert/releases/latest</a></p><p>此外，MKCert已经推送至Homebrew, MacPorts, Linuxbrew, Chocolatey, Scoop等包管理平台中，也可以直接借助对应的包管理平台安装。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里作者使用的是Chocolatey包管理平台安装的，未安装的读者可以去阅读 <a href="/doc/83035554.html">PowerShell安装Choco</a> 这篇文章安装。</p><p>Chocolatey包管理工具安装好后，运行以下指令则可以直接安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">choco install mkcert</code></pre></div></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后，首次运行<code>mkcert</code>指令，查看环境是否安装成功。</p><p>之后运行<code>mkcert -install</code>为本机的浏览器安装CA证书。</p><p>你可以通过<code>mkcert -help</code>查看帮助文档。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>MKCert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell安装Choco</title>
    <link href="/doc/83035554.html"/>
    <url>/doc/83035554.html</url>
    
    <content type="html"><![CDATA[<p>Choco 它是一个Windows 包管理工具。不建议使用Choco免费版，推荐<a href="/doc/155f072e.html">Scoop</a>。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="choco是什么？"><a href="#choco是什么？" class="headerlink" title="choco是什么？"></a>choco是什么？</h3><p>Windows操作系统上的一个软件管理解决方案。使用PowerShell 来创建软件发布包。然后可以将他部署在任何有Windows操作系统的地方。</p><h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><ul><li>可以部署到任何有Windows&#x2F;Cloud 的地方。</li><li>可以部署任何东西。</li><li>所有软件是一等公民。</li><li>测试发布。</li><li>完全的线下与安全。</li><li>创建自己的部署包。</li><li>依赖管理变得非常简单。</li><li>开源软件许可。有apache v2 许可。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CMD安装"><a href="#CMD安装" class="headerlink" title="CMD安装"></a>CMD安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;chocolatey.org&#x2F;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH&#x3D;%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre></div></figure><h3 id="PowerShell安装"><a href="#PowerShell安装" class="headerlink" title="PowerShell安装"></a>PowerShell安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;chocolatey.org&#x2F;install.ps1&#39;))</code></pre></div></figure><h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">choco -v</code></pre></div></figure><h3 id="设置Choco包安装路径"><a href="#设置Choco包安装路径" class="headerlink" title="设置Choco包安装路径"></a>设置Choco包安装路径</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SETX ChocolateyInstall &quot;自定义安装路径&quot;SETX ChocolateyToolsLocation &quot;%ChocolateyInstall%\tools&quot;SETX Path &quot;$env:Path;%ChocolateyInstall%\bin;&quot;</code></pre></div></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>可运行<code>choco -h</code>查看帮助文档。</p><h3 id="懒人必备"><a href="#懒人必备" class="headerlink" title="懒人必备"></a>懒人必备</h3><figure><div class="code-wrapper"><pre class="line-numbers language-ps1" data-language="ps1"><code class="language-ps1">echo &quot;设置环境变量...&quot;SETX ChocolateyInstall &quot;E:\Temp\.choco&quot;SETX ChocolateyBinRoot &quot;%ChocolateyInstall%\tools&quot;SETX ChocolateyToolsLocation &quot;%ChocolateyInstall%\tools&quot;SETX Path &quot;$env:Path;%ChocolateyInstall%\bin;%ChocolateyInstall%\tools;&quot;#这一步做完后重启一下powershell再执行后面的echo &quot;设置完成!开始安装Choco...&quot;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol &#x3D; [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;community.chocolatey.org&#x2F;install.ps1&#39;))echo &quot;安装完成!&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>Choco</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Choco</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Machine问题小计</title>
    <link href="/doc/adab0e68.html"/>
    <url>/doc/adab0e68.html</url>
    
    <content type="html"><![CDATA[<p>博主换了一台电脑，在这台电脑上用<strong>VirtualBox</strong>虚拟机来创建docker虚拟机时出现了问题。一直卡在 Waiting for an IP 这里。</p><span id="more"></span><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>首先先来看一下我的环境：</p><img src="/doc/adab0e68/docker-machine-v.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/adab0e68/Virtualbox-version.png" srcset="/img/loading.gif" lazyload class=""><p>初始状态下没有任何虚拟机：</p><img src="/doc/adab0e68/docker-machine-ls1.png" srcset="/img/loading.gif" lazyload class=""><p>现在我们创建一个新的虚拟机，运行<code>docker-machine create --driver virtualbox test</code>创建一个新的docker虚拟机。</p><img src="/doc/adab0e68/docker-machine-create.png" srcset="/img/loading.gif" lazyload class=""><p>至此它一直“死”在这里了……再查看虚拟机管理平台，发现<strong>test</strong>运行正常。</p><img src="/doc/adab0e68/virtualbox-manager.png" srcset="/img/loading.gif" lazyload class=""><p>之后控制台报错了。</p><img src="/doc/adab0e68/docker-machine-create-err.png" srcset="/img/loading.gif" lazyload class=""><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>为了方便查看，这里用了<code>docker-machine</code>的<strong>DEBUG</strong>模式。</p><p>通过排查后发现，这里一直连接不到SSH。</p><img src="/doc/adab0e68/docker-machine-create-debug.png" srcset="/img/loading.gif" lazyload class=""><p>然后我通过手动连接SSH的方式，进行虚拟机连接。</p><img src="/doc/adab0e68/ssh-err.png" srcset="/img/loading.gif" lazyload class=""><p>ssh连接报错了！通过阅读错误信息，再加上百度的支持。找到了问题的所在。</p><p><font color='red'>因为我使用的用户是隶属于<code>Administrator</code>组的账户。默认所创建出的密钥文件的访问权限过大。所以SSH认为此文件不安全，禁止登录。</font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然是这个文件的权限问题，那我们<strong>在生成过程的同时修改掉这个文件的权限</strong>就可以解决这个问题了！</p><p>其实只要是权限问题，就可以事先将<code>MACHINE_STORAGE_PATH</code>的目录权限设置为非继承模式就可以解决这个问题。让其子目录权限均为当前用户即可。</p><p>完结撒花*★,°*:.☆(￣▽￣)&#x2F;$:*.°★* 。</p>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
      <category>Docker-Machine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Middleware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置详解</title>
    <link href="/doc/2f811586.html"/>
    <url>/doc/2f811586.html</url>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong>是一款轻量级的 Web 服务器&#x2F;反向代理服务器及电子邮件（<strong>IMAP&#x2F;POP3</strong>）代理服务器。</p><p><strong>Nginx</strong> (engine x) 也是一个高性能的 <strong>HTTP</strong> 和反向代理服务，也是一个 <strong>IMAP&#x2F;POP3&#x2F;SMTP</strong> 服务。</p><span id="more"></span><h2 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h2><p><strong>Nginx</strong> 的配置文件 <code>nginx.conf</code> 位于其安装目录的 <code>conf</code> 目录下。</p><p><code>nginx.conf</code> 由多个块组成，最外面的块是 <code>main</code>。<br><code>main</code> 包含 <code>Events</code> 和 <code>http</code>。<br><code>http</code> 包含 <code>upstream</code> 和多个 <code>server</code>。<br><code>server</code> 又包含多个<code>location</code>。</p><p><code>main</code>（全局设置）、<code>server</code>（主机设置）、<code>upstream</code>（负载均衡服务器设置）和 <code>location</code>（<strong>URL</strong>匹配特定位置的设置）。</p><ul><li><code>main</code> 块设置的指令将影响其他所有设置；</li><li><code>server</code> 块的指令主要用于指定主机和端口；</li><li><code>upstream</code> 指令主要用于负载均衡，设置一系列的后端服务器；</li><li><code>location</code> 块用于匹配网页位置。</li></ul><p>这四者之间的关系：<code>server</code> 继承 <code>main</code>，<code>location</code> 继承 <code>server</code>，<code>upstream</code> 既不会继承其他设置也不会被继承。<br>在这四个部分当中，每个部分都包含若干指令，这些指令主要包含 <strong>Nginx</strong> 的主模块指令、事件模块指令、<strong>HTTP</strong> 核心模块指令，同时每个部分还可以使用其他 <strong>HTTP</strong> 模块指令，例如 <strong>Http SSL</strong>模块、<strong>HttpGzip Static</strong> 模块和 <strong>Http Addition</strong> 模块等。</p><h3 id="Nginx的全局配置"><a href="#Nginx的全局配置" class="headerlink" title="Nginx的全局配置"></a>Nginx的全局配置</h3><p>每个配置选项的含义解释如下：</p><ul><li><code>user</code> 是个主模块指令，指定 <strong>Nginx Worker</strong> 进程运行用户以及用户组，默认由 <code>nobody</code> 账号运行。</li><li><code>worker_processes</code> 是个主模块指令，指定了 <strong>Nginx</strong> 要开启的进程数。每个 <strong>Nginx</strong> 进程平均耗费10M~12M内存。建议指定和 <strong>CPU</strong> 的数量一致即可。</li><li><code>error_log</code> 是个主模块指令，用来定义全局错误日志文件。日志输出级别有 <em>debug</em>、<em>info</em>、<em>notice</em>、<em>warn</em>、<em>error</em>、<em>crit</em>可供选择，其中，<em>debug</em>输出日志最为最详细，而<em>crit</em>输出日志最少。</li><li><code>pid</code> 是个主模块指令，用来指定进程 <code>pid</code> 的存储文件位置。</li><li><code>worker_rlimit_nofile</code> 用于绑定 <strong>worker</strong> 进程和 <strong>CPU</strong>，限Linux内核2.4以上可用。</li></ul><p><code>events</code> 事件指令是设定 <strong>Nginx</strong> 的工作模式及连接数上限：</p><p><code>use</code> 是个事件模块指令，用来指定 <strong>Nginx</strong> 的工作模式。<strong>Nginx</strong> 支持的工作模式有 <em>select</em>、<em>poll</em>、<em>kqueue</em>、<em>epoll</em>、<em>rtsig</em> 和 <em>&#x2F;dev&#x2F;poll</em>。其中 <em>select</em> 和 <em>poll</em> 都是标准的工作模式，<em>kqueue</em> 和 <em>epoll</em> 是高效的工作模式，不同的是 <em>epoll</em> 用在 <strong>Linux</strong> 平台上，而 <em>kqueue</em> 用在 <strong>BSD</strong> 系统中。对于 <strong>Linux</strong> 系统，<em>epoll</em> 工作模式是首选。</p><p><code>worker_connections</code> 也是个事件模块指令，用于定义 <strong>Nginx</strong> 每个进程的最大连接数，默认是1024。最大客户端连接数由 <em>worker_processes</em> 和 <em>worker_connections</em> 决定，即 <code>Max_client=worker_processes*worker_connections</code>。</p><p>在作为反向代理时，<em>max_clients</em> 变为：<code>max_clients = worker_processes * worker_connections/4</code>。</p><p>进程的最大连接数受 <strong>Linux</strong> 系统进程的最大打开文件数限制，在执行操作系统命令 <code>ulimit -n 65536</code> 后 <em>worker_connections</em> 的设置才能生效。</p><h2 id="Nginx的反向代理配置"><a href="#Nginx的反向代理配置" class="headerlink" title="Nginx的反向代理配置"></a>Nginx的反向代理配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">server &#123;        listen 80;        server_name cikaros.top;        return 301 https:&#x2F;&#x2F;$host$request_uri;&#125;server &#123;        listen 443 ssl;        server_name cikaros.top;        ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cikaros.top.crt;        ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cikaros.top.key;        client_max_body_size 10M;        location &#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;10.1.1.100:2561;                proxy_set_header Host $host:$proxy_port;        &#125;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Machine常用操作命令</title>
    <link href="/doc/d5d887b8.html"/>
    <url>/doc/d5d887b8.html</url>
    
    <content type="html"><![CDATA[<p>通过 <strong>VirtualBox</strong> 来介绍 docker-machine 的使用方法。</p><span id="more"></span><h2 id="列出可用的机器"><a href="#列出可用的机器" class="headerlink" title="列出可用的机器"></a>列出可用的机器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine ls</code></pre></div></figure><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">NAME      ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORSmanager   -        virtualbox   Stopped                 Unknownnode1     -        virtualbox   Stopped                 Unknownnode2     -        virtualbox   Stopped                 Unknown</code></pre></div></figure><p>作者这里显示了三个未运行的容器，是因为我之前已经操作过。若你是刚安装的用户，那你看到的应该是空列表。</p><h2 id="创建机器"><a href="#创建机器" class="headerlink" title="创建机器"></a>创建机器</h2><blockquote><p>注:这里需要提前安装好 <strong>VirtualBox</strong> ,若你没有安装请参考 <a href="/doc/568f192.html">Docker-Machine环境搭建</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine create --driver virtualbox test</code></pre></div></figure><ul><li><code>--driver</code>: 指定用来创建机器的驱动类型，这里是 <strong>VirtualBox</strong>。</li></ul><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">Running pre-create checks...Creating machine...(test) Copying C:\Users\HP\.docker\machine\cache\boot2docker.iso to C:\Users\HP\.docker\machine\machines\test\boot2docker.iso...(test) Creating VirtualBox VM...(test) Creating SSH key...(test) Starting the VM...(test) Check network to re-create if needed...(test) Windows might ask for the permission to configure a dhcp server. Sometimes, such confirmation window is minimized in the taskbar.(test) Waiting for an IP...Waiting for machine to be running, this may take a few minutes...Detecting operating system of created instance...Waiting for SSH to be available...Detecting the provisioner...Provisioning with boot2docker...Copying certs to the local machine directory...Copying certs to the remote machine...Setting Docker configuration on the remote daemon...Checking connection to Docker...Docker is up and running!To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: C:\Users\HP\bin\docker-machine.exe env test</code></pre></div></figure><h2 id="查看机器的IP"><a href="#查看机器的IP" class="headerlink" title="查看机器的IP"></a>查看机器的IP</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine ip test</code></pre></div></figure><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">192.168.99.101</code></pre></div></figure><h2 id="停止机器"><a href="#停止机器" class="headerlink" title="停止机器"></a>停止机器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine stop test</code></pre></div></figure><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">Stopping &quot;test&quot;...Machine &quot;test&quot; was stopped.</code></pre></div></figure><h2 id="启动机器"><a href="#启动机器" class="headerlink" title="启动机器"></a>启动机器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine start test</code></pre></div></figure><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">Starting &quot;test&quot;...(test) Check network to re-create if needed...(test) Windows might ask for the permission to configure a dhcp server. Sometimes, such confirmation window is minimized in the taskbar.(test) Waiting for an IP...Machine &quot;test&quot; was started.Waiting for SSH to be available...Detecting the provisioner...Started machines may have new IP addresses. You may need to re-run the &#96;docker-machine env&#96; command.</code></pre></div></figure><h2 id="进入机器"><a href="#进入机器" class="headerlink" title="进入机器"></a>进入机器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">docker-machine ssh test</code></pre></div></figure><p>以下是执行结果:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">   ( &#39;&gt;&#39;)   ( &#39;&gt;&#39;)  &#x2F;) TC (\   Core is distributed with ABSOLUTELY NO WARRANTY. (&#x2F;-_--_-\)           www.tinycorelinux.netdocker@test:~$</code></pre></div></figure><h2 id="docker-machine-命令参数说明"><a href="#docker-machine-命令参数说明" class="headerlink" title="docker-machine 命令参数说明"></a>docker-machine 命令参数说明</h2><ul><li><code>docker-machine active</code>:查看当前激活状态的 Docker 主机。</li><li><code>config</code>:查看当前激活状态 Docker 主机的连接信息。</li><li><code>create</code>:创建 Docker 主机</li><li><code>env</code>:显示连接到某个主机需要的环境变量</li><li><code>inspect</code>: 以 json 格式输出指定Docker的详细信息</li><li><code>ip</code>: 获取指定 Docker 主机的地址</li><li><code>kill</code>: 直接杀死指定的 Docker 主机</li><li><code>ls</code>: 列出所有的管理主机</li><li><code>provision</code>: 重新配置指定主机</li><li><code>regenerate-certs</code>: 为某个主机重新生成 TLS 信息</li><li><code>restart</code>: 重启指定的主机</li><li><code>rm</code>: 删除某台 Docker 主机，对应的虚拟机也会被删除</li><li><code>ssh</code>: 通过 SSH 连接到主机上，执行命令</li><li><code>scp</code>: 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据</li><li><code>mount</code>: 使用 SSHFS 从计算机装载或卸载目录</li><li><code>start</code>: 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动</li><li><code>status</code>: 获取指定 Docker 主机的状态(包括:Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</li><li><code>stop</code>: 停止一个指定的 Docker 主机</li><li><code>upgrade</code>: 将一个指定主机的 Docker 版本更新为最新</li><li><code>url</code>: 获取指定 Docker 主机的监听 URL</li><li><code>version</code>: 显示 Docker Machine 的版本或者主机 Docker 版本</li><li><code>help</code>: 显示帮助信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>Docker-Machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Machine环境搭建</title>
    <link href="/doc/568f192.html"/>
    <url>/doc/568f192.html</url>
    
    <content type="html"><![CDATA[<p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p><p>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p><p>Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</p><p>使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 Docker Machine 之前你需要先安装 Docker。</p><p>Docker Machine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。</p><p>这里博主推荐使用<strong>VirtualBox</strong>虚拟机来实现。这样便于快速拓展docker容器的数量。以下是安装步骤：</p><ol><li>下载并安装<strong>VirtualBox</strong>。</li><li>下载<strong>Docker Machine</strong>。</li><li>配置<strong>Docker Machine</strong>环境变量。</li></ol><p><strong>Docker Machine</strong>的最新版本，可以在这里获取：<a href="https://github.com/docker/machine/">github地址</a></p><blockquote><p>注：这里我只介绍Windows版的安装步骤，其他操作系统的安装步骤基本一致，只是操作上的不同而已。</p></blockquote><p>首先，是下载并安装<strong>VirtualBox</strong>。<a href="https://www.virtualbox.org/wiki/Downloads">下载地址</a> </p><p>这里选择合适的版本安装即可。</p><p>第二步，下载<strong>Docker Machine</strong>。同样选择合适的版本即可。注意的是这里我们需要的是windows版的。</p><p>下载完成后，将文件名更改为<code>docker-machine.exe</code>并放置在<code>%HOMEPATH%\bin</code>路径下。</p><p>然后再将<code>%HOMEPATH%\bin</code>加入到<em>Path</em>环境变量中。</p><p>安装完成！</p><p>注：若是需要修改默认的虚拟机安装位置请增加<code>MACHINE_STORAGE_PATH</code>环境变量即可。</p><h2 id="常用环境变量"><a href="#常用环境变量" class="headerlink" title="常用环境变量"></a>常用环境变量</h2><ul><li><code>DOCKER_CERT_PATH</code> Docker证书路径</li><li><code>DOCKER_HOST</code> Docker服务地址</li><li><code>DOCKER_TLS_VERIFY</code> Docker TLS验证</li><li><code>ENGINE_REGISTRY_MIRROR</code> Docker-Machine默认拉取远程仓库地址</li></ul>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>Docker-Machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot-validator的使用</title>
    <link href="/doc/c80621.html"/>
    <url>/doc/c80621.html</url>
    
    <content type="html"><![CDATA[<p>很痛苦遇到大量的参数进行校验,在业务中还要抛出异常或者 不断的返回异常时的校验信息,<br>在代码中相当冗长, 充满了if-else这种校验代码,今天我们就来学习spring的javax.validation 注解式参数校验.</p><span id="more"></span><h2 id="为什么要用validator"><a href="#为什么要用validator" class="headerlink" title="为什么要用validator"></a>为什么要用validator</h2><p><code>javax.validation</code>的一系列注解可以帮我们完成参数校验,免去繁琐的串行校验<br>不然我们的代码就像下面这样:</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 走串行校验 * * @param userVO * @return *&#x2F;@PostMapping(&quot;&#x2F;save&#x2F;serial&quot;)public Object save(@RequestBody UserVO userVO) &#123;    String mobile &#x3D; userVO.getMobile();    &#x2F;&#x2F;手动逐个 参数校验~ 写法    if (StringUtils.isBlank(mobile)) &#123;        return RspDTO.paramFail(&quot;mobile:手机号码不能为空&quot;);    &#125; else if (!Pattern.matches(&quot;^[1][3,4,5,6,7,8,9][0-9]&#123;9&#125;$&quot;, mobile)) &#123;        return RspDTO.paramFail(&quot;mobile:手机号码格式不对&quot;);    &#125;    &#x2F;&#x2F;抛出自定义异常等~写法    if (StringUtils.isBlank(userVO.getUsername())) &#123;        throw new BizException(Constant.PARAM_FAIL_CODE, &quot;用户名不能为空&quot;);    &#125;    &#x2F;&#x2F; 比如写一个map返回    if (StringUtils.isBlank(userVO.getSex())) &#123;        Map&lt;String, Object&gt; result &#x3D; new HashMap&lt;&gt;(5);        result.put(&quot;code&quot;, Constant.PARAM_FAIL_CODE);        result.put(&quot;msg&quot;, &quot;性别不能为空&quot;);        return result;    &#125;    &#x2F;&#x2F;.........各种写法 ...    userService.save(userVO);    return RspDTO.success();&#125;</code></pre></div></figure><p>这被大佬看见,一定说,都9102了还这么写,然后被劝退了…..</p><h2 id="什么是javax-validation"><a href="#什么是javax-validation" class="headerlink" title="什么是javax.validation"></a>什么是javax.validation</h2><p>JSR303 是一套JavaBean参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们JavaBean的属性上面(面向注解编程的时代)，就可以在需要校验的时候进行校验了,在SpringBoot中已经包含在starter-web中,再其他项目中可以引用依赖,并自行调整版本:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--jsr 303--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.validation&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;validation-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.0.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- hibernate validator--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.2.0.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>1.<code>@NotNull</code>：不能为null，但可以为empty(“”,” “,”   “)</p><p>2.<code>@NotEmpty</code>：不能为null，而且长度必须大于0 (“ “,”  “)</p><p>3.<code>@NotBlank</code>：只能作用在String上，不能为null，而且调用trim()后，长度必须大于0(“test”)    即：必须有实际字符</p><table><thead><tr><th align="center">验证注解</th><th align="center">验证的数据类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@AssertFalse</td><td align="center">Boolean,boolean</td><td align="center">验证注解的元素值是false</td></tr><tr><td align="center">@AssertTrue</td><td align="center">Boolean,boolean</td><td align="center">验证注解的元素值是true</td></tr><tr><td align="center">@NotNull</td><td align="center">任意类型</td><td align="center">验证注解的元素值不是null</td></tr><tr><td align="center">@Null</td><td align="center">任意类型</td><td align="center">验证注解的元素值是null</td></tr><tr><td align="center">@Min(value&#x3D;值)</td><td align="center">BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型</td><td align="center">验证注解的元素值大于等于@Min指定的value值</td></tr><tr><td align="center">@Max(value&#x3D;值)</td><td align="center">和@Min要求一样</td><td align="center">验证注解的元素值小于等于@Max指定的value值</td></tr><tr><td align="center">@DecimalMin(value&#x3D;值)</td><td align="center">和@Min要求一样</td><td align="center">验证注解的元素值大于等于@ DecimalMin指定的value值</td></tr><tr><td align="center">@DecimalMax(value&#x3D;值)</td><td align="center">和@Min要求一样</td><td align="center">验证注解的元素值小于等于@ DecimalMax指定的value值</td></tr><tr><td align="center">@Digits(integer&#x3D;整数位数, fraction&#x3D;小数位数)</td><td align="center">和@Min要求一样</td><td align="center">验证注解的元素值的整数位数和小数位数上限</td></tr><tr><td align="center">@Size(min&#x3D;下限, max&#x3D;上限)</td><td align="center">字符串、Collection、Map、数组等</td><td align="center">验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小</td></tr><tr><td align="center">@Past</td><td align="center">java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td><td align="center">验证注解的元素值（日期类型）比当前时间早</td></tr><tr><td align="center">@Future</td><td align="center">与@Past要求一样</td><td align="center">验证注解的元素值（日期类型）比当前时间晚</td></tr><tr><td align="center">@NotBlank</td><td align="center">CharSequence子类型</td><td align="center">验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的首位空格</td></tr><tr><td align="center">@Length(min&#x3D;下限, max&#x3D;上限)</td><td align="center">CharSequence子类型</td><td align="center">验证注解的元素值长度在min和max区间内</td></tr><tr><td align="center">@NotEmpty</td><td align="center">CharSequence子类型、Collection、Map、数组</td><td align="center">验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td></tr><tr><td align="center">@Range(min&#x3D;最小值, max&#x3D;最大值)</td><td align="center">BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型</td><td align="center">验证注解的元素值在最小值和最大值之间</td></tr><tr><td align="center">@Email(regexp&#x3D;正则表达式,flag&#x3D;标志的模式)</td><td align="center">CharSequence子类型（如String）</td><td align="center">验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式</td></tr><tr><td align="center">@Pattern(regexp&#x3D;正则表达式,flag&#x3D;标志的模式)</td><td align="center">String，任何CharSequence的子类型</td><td align="center">验证注解的元素值与指定的正则表达式匹配</td></tr><tr><td align="center">@Valid</td><td align="center">任何非原子类型</td><td align="center">指定递归验证关联的对象如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证</td></tr></tbody></table><p>此处只列出Hibernate Validator提供的大部分验证约束注解，请参考hibernate validator官方文档了解其他验证约束注解和进行自定义的验证约束注解定义。</p><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><p>话不多说,直接走实践路线,同样使用的是SpringBoot的快速框架.</p><ol><li><code>@Validated</code> 声明要检查的参数</li></ol><p>这里我们在控制器层进行注解声明</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 走参数校验注解    *    * @param userDTO    * @return    *&#x2F;   @PostMapping(&quot;&#x2F;save&#x2F;valid&quot;)   public RspDTO save(@RequestBody @Validated UserDTO userDTO) &#123;       userService.save(userDTO);       return RspDTO.success();   &#125;</code></pre></div></figure><ol start="2"><li>对参数的字段进行注解标注</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.Data;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.*;import java.io.Serializable;import java.util.Date;&#x2F;** * 用户传输对象 * @date 2019&#x2F;7&#x2F;30 13:55 *&#x2F;@Datapublic class UserDTO implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;*** 用户ID*&#x2F;    @NotNull(message &#x3D; &quot;用户id不能为空&quot;)    private Long userId;        &#x2F;** 用户名*&#x2F;    @NotBlank(message &#x3D; &quot;用户名不能为空&quot;)    @Length(max &#x3D; 20, message &#x3D; &quot;用户名不能超过20个字符&quot;)    @Pattern(regexp &#x3D; &quot;^[\\u4E00-\\u9FA5A-Za-z0-9\\*]*$&quot;, message &#x3D; &quot;用户昵称限制：最多20字符，包含文字、字母和数字&quot;)    private String username;        &#x2F;** 手机号*&#x2F;    @NotBlank(message &#x3D; &quot;手机号不能为空&quot;)    @Pattern(regexp &#x3D; &quot;^[1][3,4,5,6,7,8,9][0-9]&#123;9&#125;$&quot;, message &#x3D; &quot;手机号格式有误&quot;)    private String mobile;    &#x2F;**性别*&#x2F;    private String sex;    &#x2F;** 邮箱*&#x2F;    @NotBlank(message &#x3D; &quot;联系邮箱不能为空&quot;)    @Email(message &#x3D; &quot;邮箱格式不对&quot;)    private String email;    &#x2F;** 密码*&#x2F;    private String password;    &#x2F;*** 创建时间 *&#x2F;    @Future(message &#x3D; &quot;时间必须是将来时间&quot;)    private Date createTime;&#125;</code></pre></div></figure><ol start="3"><li>在全局校验中增加校验异常</li></ol><p><code>MethodArgumentNotValidException</code>是springBoot中进行绑定参数校验时的异常,需要在springBoot中处理,其他需要<br>处理<code>ConstraintViolationException</code>异常进行处理.</p><p>为了优雅一点,我们将参数异常,业务异常,统一做了一个全局异常,将控制层的异常包装到我们自定义的异常中</p><p>我们还做了一个统一的结构体,将请求的code,和msg,data一起统一封装到结构体中,增加了代码的复用性</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.boot.lea.mybot.dto.RspDTO;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.dao.DuplicateKeyException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import org.springframework.web.servlet.NoHandlerFoundException;import javax.validation.ConstraintViolationException;import javax.validation.ValidationException;&#x2F;** * 全局异常处理器 * @date 2019&#x2F;7&#x2F;30 13:57 *&#x2F;@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    private Logger logger &#x3D; LoggerFactory.getLogger(getClass());    private static int DUPLICATE_KEY_CODE &#x3D; 1001;    private static int PARAM_FAIL_CODE &#x3D; 1002;    private static int VALIDATION_CODE &#x3D; 1003;    &#x2F;**     * 处理自定义异常     *&#x2F;    @ExceptionHandler(BizException.class)    public RspDTO handleRRException(BizException e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(e.getCode(), e.getMessage());    &#125;    &#x2F;**     * 方法参数校验     *&#x2F;    @ExceptionHandler(MethodArgumentNotValidException.class)    public RspDTO handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(PARAM_FAIL_CODE, e.getBindingResult().getFieldError().getDefaultMessage());    &#125;    &#x2F;**     * ValidationException     *&#x2F;    @ExceptionHandler(ValidationException.class)    public RspDTO handleValidationException(ValidationException e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(VALIDATION_CODE, e.getCause().getMessage());    &#125;    &#x2F;**     * ConstraintViolationException     *&#x2F;    @ExceptionHandler(ConstraintViolationException.class)    public RspDTO handleConstraintViolationException(ConstraintViolationException e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(PARAM_FAIL_CODE, e.getMessage());    &#125;    @ExceptionHandler(NoHandlerFoundException.class)    public RspDTO handlerNoFoundException(Exception e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(404, &quot;路径不存在，请检查路径是否正确&quot;);    &#125;    @ExceptionHandler(DuplicateKeyException.class)    public RspDTO handleDuplicateKeyException(DuplicateKeyException e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(DUPLICATE_KEY_CODE, &quot;数据重复，请检查后提交&quot;);    &#125;    @ExceptionHandler(Exception.class)    public RspDTO handleException(Exception e) &#123;        logger.error(e.getMessage(), e);        return new RspDTO(500, &quot;系统繁忙,请稍后再试&quot;);    &#125;&#125;</code></pre></div></figure><ol start="4"><li>测试</li></ol><p>如下文:确实做到了参数校验时返回异常信息和对应的code,方便了我们不再繁琐的处理参数校验</p><p>在<code>ValidationMessages.properties</code> 就是校验的<code>message</code>,有着已经写好的默认的<code>message</code>,且是支持i18n的,大家可以阅读源码赏析<br>自定义参数注解</p><ol><li>比如我们来个 自定义身份证校验 注解</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Target(&#123;ElementType.PARAMETER, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy &#x3D; IdentityCardNumberValidator.class)public @interface IdentityCardNumber &#123;    String message() default &quot;身份证号码不合法&quot;;    Class&lt;?&gt;[] groups() default &#123;&#125;;    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;</code></pre></div></figure><p>这个注解是作用在<code>Field</code>字段上，运行时生效，触发的是<code>IdentityCardNumber</code>这个验证类。</p><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>定制化的提示信息，主要是从<code>ValidationMessages.properties</code>里提取，也可以依据实际情况进行定制</p><h4 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h4><p>这里主要进行将<code>validator</code>进行分类，不同的类<code>group</code>中会执行不同的<code>validator</code>操作</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>主要是针对bean的，使用不多。</p><ol start="2"><li>然后自定义<code>Validator</code></li></ol><p>这个是真正进行验证的逻辑代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IdentityCardNumberValidator implements ConstraintValidator&lt;IdentityCardNumber, Object&gt; &#123;    @Override    public void initialize(IdentityCardNumber identityCardNumber) &#123;    &#125;    @Override    public boolean isValid(Object o, ConstraintValidatorContext constraintValidatorContext) &#123;        return IdCardValidatorUtils.isValidate18Idcard(o.toString());    &#125;&#125;</code></pre></div></figure><ol start="3"><li>使用自定义的注解<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@NotBlank(message &#x3D; &quot;身份证号不能为空&quot;)@IdentityCardNumber(message &#x3D; &quot;身份证信息有误,请核对后提交&quot;)private String clientCardNo;</code></pre></div></figure>4.使用groups的校验</li></ol><p>有的宝宝说同一个对象要复用,比如<code>UserDTO</code>在更新时候要校验<code>userId</code>,在保存的时候不需要校验<code>userId</code>,在两种情况下都要校验<code>username</code>,那就用上<code>groups</code>了:</p><p>先定义<code>groups</code>的分组接口<code>Create</code>和<code>Update</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.validation.groups.Default;public interface Create extends Default &#123;&#125;import javax.validation.groups.Default;public interface Update extends Default&#123;&#125;</code></pre></div></figure><p>再在需要校验的地方<code>@Validated</code>声明校验组</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 走参数校验注解的 groups 组合校验    *    * @param userDTO    * @return    *&#x2F;   @PostMapping(&quot;&#x2F;update&#x2F;groups&quot;)   public RspDTO update(@RequestBody @Validated(Update.class) UserDTO userDTO) &#123;       userService.updateById(userDTO);       return RspDTO.success();   &#125;</code></pre></div></figure><p>在DTO中的字段上定义好<code>groups = &#123;&#125;</code>的分组类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class UserDTO implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;*** 用户ID*&#x2F;    @NotNull(message &#x3D; &quot;用户id不能为空&quot;, groups &#x3D; Update.class)    private Long userId;    &#x2F;**     * 用户名     *&#x2F;    @NotBlank(message &#x3D; &quot;用户名不能为空&quot;)    @Length(max &#x3D; 20, message &#x3D; &quot;用户名不能超过20个字符&quot;, groups &#x3D; &#123;Create.class, Update.class&#125;)    @Pattern(regexp &#x3D; &quot;^[\\u4E00-\\u9FA5A-Za-z0-9\\*]*$&quot;, message &#x3D; &quot;用户昵称限制：最多20字符，包含文字、字母和数字&quot;)    private String username;    &#x2F;**     * 手机号     *&#x2F;    @NotBlank(message &#x3D; &quot;手机号不能为空&quot;)    @Pattern(regexp &#x3D; &quot;^[1][3,4,5,6,7,8,9][0-9]&#123;9&#125;$&quot;, message &#x3D; &quot;手机号格式有误&quot;, groups &#x3D; &#123;Create.class, Update.class&#125;)    private String mobile;    &#x2F;**     * 性别     *&#x2F;    private String sex;    &#x2F;**     * 邮箱     *&#x2F;    @NotBlank(message &#x3D; &quot;联系邮箱不能为空&quot;)    @Email(message &#x3D; &quot;邮箱格式不对&quot;)    private String email;    &#x2F;**     * 密码     *&#x2F;    private String password;    &#x2F;*** 创建时间 *&#x2F;    @Future(message &#x3D; &quot;时间必须是将来时间&quot;, groups &#x3D; &#123;Create.class&#125;)    private Date createTime;&#125;</code></pre></div></figure><p>注意:在声明分组的时候尽量加上 <code>extend javax.validation.groups.Default</code> 否则,在你声明<code>@Validated(Update.class)</code><br>的时候,就会出现你在默认没添加<code>groups = &#123;&#125;</code>的时候的校验组<code>@Email(message = &quot;邮箱格式不对&quot;)</code>,会不去校验,因为默认的校验组是<code>groups = &#123;Default.class&#125;.</code></p><p>5.restful风格用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> @GetMapping(&quot;&#x2F;get&quot;)    public RspDTO getUser(@RequestParam(&quot;userId&quot;) @NotNull(message &#x3D; &quot;用户id不能为空&quot;) Long userId) &#123;        User user &#x3D; userService.selectById(userId);        if (user &#x3D;&#x3D; null) &#123;            return new RspDTO&lt;User&gt;().nonAbsent(&quot;用户不存在&quot;);        &#125;        return new RspDTO&lt;User&gt;().success(user);    &#125;@RestController@RequestMapping(&quot;user&#x2F;&quot;)@Validatedpublic class UserController extends AbstractController &#123;....圣洛代码...&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参数验证</tag>
      
      <tag>Validator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-zip版环境搭建</title>
    <link href="/doc/129cd0a6.html"/>
    <url>/doc/129cd0a6.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去官方下载Redis.zip文件。<br>下载地址：<a href="https://github.com/MicrosoftArchive/redis">https://github.com/MicrosoftArchive/redis</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将下载好的zip文件进行解压，这里我的解压环境为<code>D:\Program\</code><br>文件夹名称为<code>redis-x64-3.2.100</code>。<br>以下是目录结构：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">redis-x64-3.2.100├─dump.rdb├─EventLog.dll├─Redis on Windows Release Notes.docx├─Redis on Windows.docx├─redis-benchmark.exe├─redis-benchmark.pdb├─redis-check-aof.exe├─redis-check-aof.pdb├─redis-cli.exe├─redis-cli.pdb├─redis-server.exe├─redis-server.pdb├─redis.windows-service.conf├─redis.windows.conf├─server_log.txt└─Windows Service Documentation.docx</code></pre></div></figure><p>可对<code>redis.windows.conf</code>或<code>redis.windows-service.conf</code>进行相关配置。</p><p>一般情况下<code>redis.windows.conf</code>用于直接启动的配置文件<br><code>redis.windows-service.conf</code>用于安装服务的配置文件</p><h2 id="windows服务安装"><a href="#windows服务安装" class="headerlink" title="windows服务安装"></a>windows服务安装</h2><p>接下来安装服务，在cmd中输入<code> redis-server --service-install redis.windows-service.conf</code>安装服务。需要管理员权限</p><p>若已经执行了安装操作，可以使用<code>redis-server --service-uninstall</code>删除之前安装的服务，再执行初始化操作。</p><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">setx &quot;Path&quot; &quot;%path_%;newpath1;newpath2&quot; &#x2F;m</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql.zip版环境搭建</title>
    <link href="/doc/1242f29d.html"/>
    <url>/doc/1242f29d.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去官方下载mysql.zip文件。<br>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.7.html">https://dev.mysql.com/downloads/mysql/5.7.html</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将下载好的zip文件进行解压，这里我的解压环境为<code>D:\Program\</code><br>文件夹名称为<code>mysql-5.7.35-winx64</code>。<br>以下是目录结构：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mysql-5.7.35-winx64├─bin├─data├─docs├─include├─lib└─share</code></pre></div></figure><p>默认解压后没有<code>data</code>文件夹，需要手动创建<code>data</code>文件夹。</p><p>创建好后再创建一个叫<code>my.ini</code>的文件，并在里面增加如下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">[mysql]# 设置mysql客户端默认字符集default-character-set &#x3D; utf8mb4 [mysqld]#允许客户端通过内存共享连接shared-memory#设置3306端口port &#x3D; 3306 # 设置mysql的安装目录basedir &#x3D; E:\\Temp\\.mysql# 设置mysql数据库的数据的存放目录datadir &#x3D; E:\\Temp\\.mysql\\data# 允许最大连接数max_connections &#x3D; 100# 服务端使用的字符集默认为UTF8character-set-server &#x3D; utf8mb4# 排序规则collation-server &#x3D; utf8mb4_general_ci# 大小写是否敏感lower_case_table_names &#x3D; 1# 创建新表时将使用的默认存储引擎default-storage-engine &#x3D; INNODB# INNODB语法检查innodb_strict_mode &#x3D; OFF# INNODB日志设置innodb_log_file_size &#x3D; 30Minnodb_log_buffer_size &#x3D; 512M# 内存设置## 指定MySQL最小内存#key_buffer_size&#x3D;5M## 包大小限制max_allowed_packet &#x3D; 2000Mwait_timeout&#x3D;2880000interactive_timeout &#x3D; 2880000## 指定服务器每个连接可使用的最大排序空间sort_buffer_size&#x3D;2M# INNODB内存配置innodb_page_size &#x3D; 32Kinnodb_buffer_pool_size &#x3D; 2048M# INNODB事务锁超时时长innodb_lock_wait_timeout &#x3D; 1500# binlog日志disable-log-bin# 信任生成函数log_bin_trust_function_creators &#x3D; 1explicit_defaults_for_timestamp &#x3D; true# 解决Group By的报错sql_mode&#x3D;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</code></pre></div></figure><p><strong>注意</strong>：这里的路径需要与自己设置的路径相匹配。</p><h2 id="windows服务安装"><a href="#windows服务安装" class="headerlink" title="windows服务安装"></a>windows服务安装</h2><p>接下来安装服务，在cmd中输入<code>mysqld install [服务名]</code>安装服务。需要管理员权限</p><p>在5.7.6版本开始需要执行初始化<code>mysqld --initialize</code>命令。</p><p>若已经执行了安装操作，可以使用<code>mysqld -remove</code>删除之前安装的服务，再执行初始化操作。</p><p>安装完成后，今后启动就可使用<code>net start [服务名]</code>指令去启动mysql了，例如：<code>net start mysql</code></p><p>顺便一提，停止服务可使用<code>net stop [服务名]</code>。</p><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>首先要启动服务，输入<code>mysqld --initialize --console</code>,注意输出数据中会存在类似这样一行的数据：</p><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">[Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E</code></pre></div></figure><p>其中<code>root@localhost:</code>后面的<code>rI5rvf5x5G,E</code>就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。<br>执行<code>mysql -u root -p</code>回车然后输入密码，即可登录mysql</p><p>现在就可以通过密码更新的指令进行数据库密码修改了，完成后记得刷新缓存即可。</p><p>MySQL版本5.7.6版本以前用户可以使用如下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SET PASSWORD &#x3D; PASSWORD(&#39;root&#39;);</code></pre></div></figure><p>MySQL版本5.7.6版本开始的用户可以使用如下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER USER USER() IDENTIFIED BY &#39;root&#39;;</code></pre></div></figure><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">setx &quot;Path&quot; &quot;%path_%;newpath1;newpath2&quot; &#x2F;m</code></pre></div></figure><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>在实际线上使用过程中发现，用同一个SQL查询相同的数据，返回的时间有很大的差异：</p><ul><li>在<code>8.0.13</code>版数据库中查询：15.32 sec</li><li>在<code>8.0.32</code>版数据库中查询：0.04 sec</li></ul><p><del>所以在选择数据库版本时，需要进行详细的调查，目前在本地使用<code>8.0.32</code>版本较为高效，可参考使用该版本！</del></p><p>因存在拒绝服务漏洞，建议选择<code>8.0.35</code>及以上版本进行安装！！！</p><h2 id="Linux版安装脚本"><a href="#Linux版安装脚本" class="headerlink" title="Linux版安装脚本"></a>Linux版安装脚本</h2><p>所需环境：</p><ul><li><code>wget</code></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# Function to get user input with a default valueget_input() &#123;    local prompt&#x3D;&quot;$1&quot;    local default&#x3D;&quot;$2&quot;    read -p &quot;$prompt [$default]: &quot; input    echo &quot;$&#123;input:-$default&#125;&quot;&#125;# Function to install Mysql Serverinstall_mysql() &#123;    # Prompt user for MySQL version    MYSQL_VERSION&#x3D;$(get_input &quot;Enter MySQL version to install&quot; &quot;8.0.36&quot;)    # Prompt user for installation directory    INSTALL_DIR&#x3D;$(get_input &quot;Enter installation directory&quot; &quot;&#x2F;usr&#x2F;local&#x2F;mysql&quot;)    # Prompt user for data directory    DATA_DIR&#x3D;$(get_input &quot;Enter data directory&quot; &quot;&#x2F;var&#x2F;lib&#x2F;mysql&quot;)        # Prompt user for glibc version        GLIBC_VERSION&#x3D;$(get_input &quot;Enter glibc version&quot; &quot;2.28&quot;)    # Determine the download URL and checksum URL    MYSQL_TAR&#x3D;&quot;mysql-$&#123;MYSQL_VERSION&#125;-linux-glibc$&#123;GLIBC_VERSION&#125;-$&#123;ARCH&#125;.tar.xz&quot;    MYSQL_URL&#x3D;&quot;https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-$MYSQL_VERSION&#x2F;$MYSQL_TAR&quot;    CHECKSUM_URL&#x3D;&quot;https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-$MYSQL_VERSION&#x2F;$&#123;MYSQL_TAR&#125;.md5&quot;    # Download MySQL tarball and checksum    echo &quot;Downloading MySQL $MYSQL_VERSION...&quot;    if [ ! -f &quot;$&#123;MYSQL_TAR&#125;&quot; ];then        wget -q --show-progress $MYSQL_URL    fi    if [ ! -f &quot;$&#123;CHECKSUM_URL&#125;&quot; ];then        wget -q --show-progress $CHECKSUM_URL    fi        # Verify checksum    echo &quot;Verifying checksum...&quot;    md5sum -c $&#123;MYSQL_TAR&#125;.md5    if [ $? -ne 0 ]; then        echo &quot;Checksum verification failed. Exiting.&quot;        exit 1    fi    # Extract MySQL tarball    echo &quot;Extracting MySQL package...&quot;    tar -xf $MYSQL_TAR    # Move MySQL to the installation directory    sudo mv mysql-$&#123;MYSQL_VERSION&#125;-linux-glibc$&#123;GLIBC_VERSION&#125;-$&#123;ARCH&#125; $INSTALL_DIR    # Create data directory    sudo mkdir -p $DATA_DIR    sudo chown -R mysql:mysql $DATA_DIR    # Install necessary dependencies    if [ &quot;$OS&quot; &#x3D;&#x3D; &quot;ubuntu&quot; ]; then        sudo apt-get update        sudo apt-get install -y libaio1 libncurses5    elif [ &quot;$OS&quot; &#x3D;&#x3D; &quot;centos&quot; ]; then        sudo yum install -y libaio ncurses-libs    elif [ &quot;$OS&quot; &#x3D;&#x3D; &quot;arch&quot; ]; then        sudo pacman -S --noconfirm libaio ncurses    fi    # Initialize MySQL    sudo $INSTALL_DIR&#x2F;bin&#x2F;mysqld --initialize-insecure --user&#x3D;mysql --basedir&#x3D;$INSTALL_DIR --datadir&#x3D;$DATA_DIR    # Create MySQL service file    sudo bash -c &#39;cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;mysql.service &lt;&lt;EOF[Unit]Description&#x3D;MySQL ServerAfter&#x3D;network.target[Service]ExecStart&#x3D;&#39;$INSTALL_DIR&#39;&#x2F;bin&#x2F;mysqld --basedir&#x3D;&#39;$INSTALL_DIR&#39; --datadir&#x3D;&#39;$DATA_DIR&#39;User&#x3D;mysqlGroup&#x3D;mysqlRestart&#x3D;on-failureLimitNOFILE&#x3D;5000[Install]WantedBy&#x3D;multi-user.targetEOF&#39;    sudo systemctl enable mysql    sudo systemctl start mysql    echo &quot;MySQL $MYSQL_VERSION has been installed successfully!&quot;&#125;# supported OS arraySUPPORTED_OS&#x3D;(&quot;ubuntu&quot; &quot;centos&quot; &quot;arch&quot;)# Determine the OS typeif [ -f &#x2F;etc&#x2F;os-release ]; then    . &#x2F;etc&#x2F;os-release    OS&#x3D;$ID    VERSION_ID&#x3D;$VERSION_ID    ARCH&#x3D;$(uname -m)else    echo &quot;Unsupported operating system.&quot;    exit 1fiif [[ &quot;$&#123;SUPPORTED_OS[@]&#125;&quot; &#x3D;~ &quot;$OS&quot; ]] ; then    install_mysqlelse    echo &quot;The current script does not support your system.&quot;    exit 1fi</code></pre></div></figure><h2 id="拓展知识-Mysql通信协议"><a href="#拓展知识-Mysql通信协议" class="headerlink" title="拓展知识: Mysql通信协议"></a>拓展知识: Mysql通信协议</h2><img src="/doc/1242f29d/001.png" srcset="/img/loading.gif" lazyload class=""><p>Mysql 通信协议主要有这几种：Unix套接字、内存共享、命名管道、TCP&#x2F;IP套接字…</p><p>绝大部分情况下，我们使用的是TCP&#x2F;IP套接字进行通信的，这种方式最通用，但也会带了通信方面的性能瓶颈。</p><p>若是本地通信，Windows建议使用内存共享，Unix&#x2F;Linux建议使用Unix套接字</p><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><p>其交互过程主要分为两个部分：握手认证和指令执行</p><p>这里用TCP&#x2F;IP协议模式进行讲解：</p><ol><li><p>三次握手建立 TCP 连接。</p></li><li><p>建立 MySQL 连接，也就是认证阶段。<br>服务端 -&gt; 客户端：发送握手初始化包 (Handshake Initialization Packet)。<br>客户端 -&gt; 服务端：发送验证包 (Client Authentication Packet)。<br>服务端 -&gt; 客户端：认证结果消息。</p></li><li><p>认证通过之后，客户端开始与服务端之间交互，也就是命令执行阶段。<br>客户端 -&gt; 服务端：发送命令包 (Command Packet)。<br>服务端 -&gt; 客户端：发送回应包 (OK Packet, or Error Packet, or Result Set Packet)。</p></li><li><p>断开 MySQL 连接。<br>客户端 -&gt; 服务器：发送退出命令包。</p></li><li><p>四次握手断开 TCP 连接。</p></li></ol><img src="/doc/1242f29d/002.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot源码-StopWatch工具</title>
    <link href="/doc/8fc7af.html"/>
    <url>/doc/8fc7af.html</url>
    
    <content type="html"><![CDATA[<p>StopWatch，这个单词应该不陌生吧，没错就是秒表。</p><p>秒表，顾名思义就是一个计时器。在Springboot中它是一个计时工具。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>StopWatch是位于org.springframework.util包下的一个工具类，通过它可方便的对程序部分代码进行计时(ms级别)，适用于同步单线程代码块。</p><p>一般情况下我们计时会选用System提供的<code>System.currentTimeMillis()</code>来记录开始与结束时的时间戳，然后做减法得到时间间隔。</p><p>这种方法简单直接有效，但想必写多了也是比较烦人的，尤其是碰到不可描述的代码时，会更加的让人忍不住多写几个bug聊表敬意，而且该结果也不够直观，此时会想是否有一个工具类，提供了这些方法，或者自己写个工具类，刚好可以满足这种场景，并且把结果更加直观的展现出来。<br>这就是StopWatch。用法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">StopWatch sw &#x3D; new StopWatch(&quot;test&quot;);sw.start(&quot;task1&quot;);&#x2F;&#x2F; do somethingThread.sleep(100);sw.stop();sw.start(&quot;task2&quot;);&#x2F;&#x2F; do somethingThread.sleep(200);sw.stop();System.out.println(&quot;sw.prettyPrint()~~~~~~~~~~~~~~~~~&quot;);System.out.println(sw.prettyPrint());运行结果：sw.prettyPrint()~~~~~~~~~~~~~~~~~StopWatch &#39;test&#39;: running time (millis) &#x3D; 308-----------------------------------------ms     %     Task name-----------------------------------------00104  034%  task100204  066%  task2</code></pre></div></figure><p>start开始记录，stop停止记录，然后通过StopWatch的prettyPrint方法，可直观的输出代码执行耗时，以及执行时间百分比，瞬间感觉比之前的方式高大上了一个档次。</p><p>除此之外，还有以下两个方法<code>shortSummary()</code>,<code>getTotalTimeMillis()</code>，查看程序执行时间。</p><h2 id="StopWatch优缺点："><a href="#StopWatch优缺点：" class="headerlink" title="StopWatch优缺点："></a>StopWatch优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>spring自带工具类，可直接使用</li><li>代码实现简单，使用更简单</li><li>统一归纳，展示每项任务耗时与占用总时间的百分比，展示结果直观</li><li>性能消耗相对较小，并且最大程度的保证了start与stop之间的时间记录的准确性</li><li>可在start时直接指定任务名字，从而更加直观的显示记录结果</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>一个StopWatch实例一次只能开启一个task，不能同时start多个task，并且在该task未stop之前不能start一个新的task，必须在该task stop之后才能开启新的task，若要一次开启多个，需要new不同的StopWatch实例</li><li>代码侵入式使用，需要改动多处代码</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Ubuntu扩展/dev/mapper/ubuntu--vg-ubuntu--lv空间</title>
    <link href="/doc/9b0527d8.html"/>
    <url>/doc/9b0527d8.html</url>
    
    <content type="html"><![CDATA[<p>在一次docker镜像拉取的过程中出错，提示信息大概意思是说，磁盘内存空间不足无法下载数据了。</p><span id="more"></span><p>根据我所查询到的资料显示是，docker分配的磁盘空间只有3.8GB的空间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">root@root:~# df -hFilesystem                         Size  Used Avail Use% Mounted onudev                               1.9G     0  1.9G   0% &#x2F;devtmpfs                              393M  2.1M  391M   1% &#x2F;run&#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv    4G  3.6G  3.8G 100% &#x2F;tmpfs                              2.0G     0  2.0G   0% &#x2F;dev&#x2F;shmtmpfs                              5.0M  4.0K  5.0M   1% &#x2F;run&#x2F;locktmpfs                              2.0G     0  2.0G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;loop0                          90M   90M     0 100% &#x2F;snap&#x2F;core&#x2F;8268&#x2F;dev&#x2F;sda2                          976M   82M  828M   9% &#x2F;boottmpfs                              393M   20K  393M   1% &#x2F;run&#x2F;user&#x2F;125tmpfs                              393M   56K  393M   1% &#x2F;run&#x2F;user&#x2F;1000</code></pre></div></figure><p>为了解决这个问题，我扩展了<code>/dev/mapper/ubuntu--vg-ubuntu--lv</code>的空间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">lvextend -L 120G &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv     &#x2F;&#x2F;增大至120Glvextend -L +20G &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv     &#x2F;&#x2F;增加20Glvreduce -L 50G &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv      &#x2F;&#x2F;减小至50Glvreduce -L -8G &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv      &#x2F;&#x2F;减小8Glvresize -L  30G &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv     &#x2F;&#x2F;调整为30Gresize2fs &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv            &#x2F;&#x2F;执行调整</code></pre></div></figure><p>完美解决！</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>存储空间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合二维码生成器</title>
    <link href="/doc/2eb205b2.html"/>
    <url>/doc/2eb205b2.html</url>
    
    <content type="html"><![CDATA[<p>我们使用两种方式，去生成二维码，但是其实，二维码的生成基础，都是zxing包，这是Google开源的一个包，第一种是使用原始的zxing方式去实现，<br>第二种是使用hutool来实现，hutool其实也是对于zxing的一个封装，但是封装前后，确实比较简单了。</p><span id="more"></span><h2 id="Zxing原生方式"><a href="#Zxing原生方式" class="headerlink" title="Zxing原生方式"></a>Zxing原生方式</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.zxing&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;core&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.3.3&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;com.google.zxing&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;javase&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.3.3&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></figure><h3 id="新增二维码工具类"><a href="#新增二维码工具类" class="headerlink" title="新增二维码工具类"></a>新增二维码工具类</h3><p>下面是把生成二维码的方法，封装到了QRCodeUtil的类之中，这个方法看起来还是比较多的，但是也谈不上太复杂，主要是对于BufferedImage生成图片，<br>然后就是ImageIO.write()方法，write的位置，可以是普通的磁盘文件，也可以是web的流，我们使用web流的时候，就需要添加com.google.zxing-javase的依赖。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class QRCodeUtil &#123;    &#x2F;**     * CODE_WIDTH：二维码宽度，单位像素     * CODE_HEIGHT：二维码高度，单位像素     * FRONT_COLOR：二维码前景色，0x000000 表示黑色     * BACKGROUND_COLOR：二维码背景色，0xFFFFFF 表示白色     * 演示用 16 进制表示，和前端页面 CSS 的取色是一样的，注意前后景颜色应该对比明显，如常见的黑白     *&#x2F;    private static final int CODE_WIDTH &#x3D; 400;    private static final int CODE_HEIGHT &#x3D; 400;    private static final int FRONT_COLOR &#x3D; 0x000000;    private static final int BACKGROUND_COLOR &#x3D; 0xFFFFFF;    &#x2F;**     * @param codeContent        二维码参数内容，如果是一个网页地址，如 https:&#x2F;&#x2F;www.baidu.com&#x2F; 则 微信扫一扫会直接进入此地址， 如果是一些参数，如     *                           1541656080837，则微信扫一扫会直接回显这些参数值     * @param codeImgFileSaveDir 二维码图片保存的目录,如 D:&#x2F;codes     * @param fileName           二维码图片文件名称，带格式,如 123.png     *&#x2F;    public static void createCodeToFile(String codeContent, File codeImgFileSaveDir, String fileName) &#123;        try &#123;            if (codeContent &#x3D;&#x3D; null || &quot;&quot;.equals(codeContent)) &#123;                log.info(&quot;二维码内容为空，不进行操作...&quot;);                return;            &#125;            codeContent &#x3D; codeContent.trim();            if (codeImgFileSaveDir &#x3D;&#x3D; null || codeImgFileSaveDir.isFile()) &#123;                codeImgFileSaveDir &#x3D; FileSystemView.getFileSystemView().getHomeDirectory();                log.info(&quot;二维码图片存在目录为空，默认放在桌面...&quot;);            &#125;            if (!codeImgFileSaveDir.exists()) &#123;                codeImgFileSaveDir.mkdirs();                log.info(&quot;二维码图片存在目录不存在，开始创建...&quot;);            &#125;            if (fileName &#x3D;&#x3D; null || &quot;&quot;.equals(fileName)) &#123;                fileName &#x3D; new Date().getTime() + &quot;.png&quot;;                log.info(&quot;二维码图片文件名为空，随机生成 png 格式图片...&quot;);            &#125;            BufferedImage bufferedImage &#x3D; getBufferedImage(codeContent);            &#x2F;*             * javax.imageio.ImageIO：java扩展的图像IO             * write(RenderedImage im, String formatName, File output)             *       im：待写入的图像， formatName：图像写入的格式，output：写入的图像文件，文件不存在时会自动创建             *&#x2F;            File codeImgFile &#x3D; new File(codeImgFileSaveDir, fileName);            ImageIO.write(bufferedImage, &quot;png&quot;, codeImgFile);            log.info(&quot;二维码图片生成成功：&quot; + codeImgFile.getPath());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;**     * 生成二维码并输出到输出流, 通常用于输出到网页上进行显示     * 输出到网页与输出到磁盘上的文件中，区别在于最后一句 ImageIO.write     * write(RenderedImage im,String formatName,File output)：写到文件中     * write(RenderedImage im,String formatName,OutputStream output)：输出到输出流中     *     * @param codeContent  ：二维码内容     * @param outputStream ：输出流，比如 HttpServletResponse 的 getOutputStream     *&#x2F;    public static void createCodeToOutputStream(String codeContent, OutputStream outputStream) &#123;        try &#123;            if (codeContent &#x3D;&#x3D; null || &quot;&quot;.equals(codeContent.trim())) &#123;                log.info(&quot;二维码内容为空，不进行操作...&quot;);                return;            &#125;            codeContent &#x3D; codeContent.trim();            BufferedImage bufferedImage &#x3D; getBufferedImage(codeContent);            &#x2F;*             * 区别就是以一句，输出到输出流中，如果第三个参数是 File，则输出到文件中             *&#x2F;            ImageIO.write(bufferedImage, &quot;png&quot;, outputStream);            log.info(&quot;二维码图片生成到输出流成功...&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();            log.error(&quot;发生错误: &#123;&#125;!&quot;, e.getMessage());        &#125;    &#125;    private static BufferedImage getBufferedImage(String codeContent) throws WriterException &#123;        &#x2F;*         * com.google.zxing.EncodeHintType：编码提示类型,枚举类型         * EncodeHintType.CHARACTER_SET：设置字符编码类型         * EncodeHintType.ERROR_CORRECTION：设置误差校正         * ErrorCorrectionLevel：误差校正等级，L &#x3D; ~7% correction、M &#x3D; ~15% correction、Q &#x3D; ~25% correction、H &#x3D; ~30% correction         *   不设置时，默认为 L 等级，等级不一样，生成的图案不同，但扫描的结果是一样的         * EncodeHintType.MARGIN：设置二维码边距，单位像素，值越小，二维码距离四周越近         *&#x2F;        Map&lt;EncodeHintType, Object&gt; hints &#x3D; new HashMap();        hints.put(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);        hints.put(EncodeHintType.MARGIN, 1);        &#x2F;*         * MultiFormatWriter:多格式写入，这是一个工厂类，里面重载了两个 encode 方法，用于写入条形码或二维码         *      encode(String contents,BarcodeFormat format,int width, int height,Map&lt;EncodeHintType,?&gt; hints)         *      contents:条形码&#x2F;二维码内容         *      format：编码类型，如 条形码，二维码 等         *      width：码的宽度         *      height：码的高度         *      hints：码内容的编码类型         * BarcodeFormat：枚举该程序包已知的条形码格式，即创建何种码，如 1 维的条形码，2 维的二维码 等         * BitMatrix：位(比特)矩阵或叫2D矩阵，也就是需要的二维码         *&#x2F;        MultiFormatWriter multiFormatWriter &#x3D; new MultiFormatWriter();        BitMatrix bitMatrix &#x3D; multiFormatWriter.encode(codeContent, BarcodeFormat.QR_CODE, CODE_WIDTH, CODE_HEIGHT, hints);        &#x2F;*         * java.awt.image.BufferedImage：具有图像数据的可访问缓冲图像，实现了 RenderedImage 接口         * BitMatrix 的 get(int x, int y) 获取比特矩阵内容，指定位置有值，则返回true，将其设置为前景色，否则设置为背景色         * BufferedImage 的 setRGB(int x, int y, int rgb) 方法设置图像像素         *      x：像素位置的横坐标，即列         *      y：像素位置的纵坐标，即行         *      rgb：像素的值，采用 16 进制,如 0xFFFFFF 白色         *&#x2F;        BufferedImage bufferedImage &#x3D; new BufferedImage(CODE_WIDTH, CODE_HEIGHT, BufferedImage.TYPE_INT_BGR);        for (int x &#x3D; 0; x &lt; CODE_WIDTH; x++) &#123;            for (int y &#x3D; 0; y &lt; CODE_HEIGHT; y++) &#123;                bufferedImage.setRGB(x, y, bitMatrix.get(x, y) ? FRONT_COLOR : BACKGROUND_COLOR);            &#125;        &#125;        return bufferedImage;    &#125;    &#x2F;**     * 根据本地二维码图片解析二维码内容 注：图片必须是二维码图片，但也可以是微信用户二维码名片，上面有名称、头像也是可以的）     *     * @param file 本地二维码图片文件,如 E:\\logs\\2.jpg     * @return     * @throws Exception     *&#x2F;    public static String parseQRCodeByFile(File file) &#123;        String resultStr &#x3D; null;        if (file &#x3D;&#x3D; null || file.isDirectory() || !file.exists()) &#123;            return resultStr;        &#125;        try &#123;            &#x2F;*             * ImageIO的BufferedImage read(URL input)方法用于读取网络图片文件转为内存缓冲图像             * 同理还有：read(File input)、read(InputStream input)、、read(ImageInputStream stream)             *&#x2F;            BufferedImage bufferedImage &#x3D; ImageIO.read(file);            &#x2F;*             * com.google.zxing.client.j2se.BufferedImageLuminanceSource：缓冲图像亮度源             * 将 java.awt.image.BufferedImage 转为 zxing 的 缓冲图像亮度源             * 关键就是下面这几句：HybridBinarizer 用于读取二维码图像数据，BinaryBitmap 二进制位图             *&#x2F;            BufferedImageLuminanceSource source &#x3D; new BufferedImageLuminanceSource(bufferedImage);            BinaryBitmap bitmap &#x3D; new BinaryBitmap(new HybridBinarizer(source));            Hashtable hints &#x3D; new Hashtable();            hints.put(DecodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);            &#x2F;*             * 如果图片不是二维码图片，则 decode 抛异常：com.google.zxing.NotFoundException             * MultiFormatWriter 的 encode 用于对内容进行编码成 2D 矩阵             * MultiFormatReader 的 decode 用于读取二进制位图数据             *&#x2F;            Result result &#x3D; new MultiFormatReader().decode(bitmap, hints);            resultStr &#x3D; result.getText();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (NotFoundException e) &#123;            e.printStackTrace();            log.error(&quot;图片非二维码图片, 路径是: &#123;&#125;!&quot;, file.getPath());        &#125;        return resultStr;    &#125;    &#x2F;**     * 根据网络二维码图片解析二维码内容, 区别仅仅在于 ImageIO.read(url); 这一个重载的方法）     *     * @param url 二维码图片网络地址，如 https:&#x2F;&#x2F;res.wx.qq.com&#x2F;mpres&#x2F;htmledition&#x2F;images&#x2F;mp_qrcode3a7b38.gif     * @return     * @throws Exception     *&#x2F;    public static String parseQRCodeByUrl(URL url) &#123;        String resultStr &#x3D; null;        if (url &#x3D;&#x3D; null) &#123;            return resultStr;        &#125;        try &#123;            &#x2F;*             * ImageIO 的 BufferedImage read(URL input) 方法用于读取网络图片文件转为内存缓冲图像             * 同理还有：read(File input)、read(InputStream input)、、read(ImageInputStream stream)             * 如果图片网络地址错误，比如不能访问，则 read 抛异常：javax.imageio.IIOException: Can&#39;t get input stream from URL!             *&#x2F;            BufferedImage bufferedImage &#x3D; ImageIO.read(url);            &#x2F;*             * com.google.zxing.client.j2se.BufferedImageLuminanceSource：缓冲图像亮度源             * 将 java.awt.image.BufferedImage 转为 zxing 的 缓冲图像亮度源             * 关键就是下面这几句：HybridBinarizer 用于读取二维码图像数据，BinaryBitmap 二进制位图             *&#x2F;            BufferedImageLuminanceSource source &#x3D; new BufferedImageLuminanceSource(bufferedImage);            BinaryBitmap bitmap &#x3D; new BinaryBitmap(new HybridBinarizer(source));            Hashtable hints &#x3D; new Hashtable();            &#x2F;*             * 如果内容包含中文，则解码的字符集格式应该和编码时一致             *&#x2F;            hints.put(DecodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);            &#x2F;*             * 如果图片不是二维码图片，则 decode 抛异常：com.google.zxing.NotFoundException             * MultiFormatWriter 的 encode 用于对内容进行编码成 2D 矩阵             * MultiFormatReader 的 decode 用于读取二进制位图数据             *&#x2F;            Result result &#x3D; new MultiFormatReader().decode(bitmap, hints);            resultStr &#x3D; result.getText();        &#125; catch (IOException e) &#123;            e.printStackTrace();            log.error(&quot;二维码图片地址错误, 地址是: &#123;&#125;!&quot;, url);        &#125; catch (NotFoundException e) &#123;            e.printStackTrace();            log.error(&quot;图片非二维码图片, 地址是: &#123;&#125;!&quot;, url);        &#125;        return resultStr;    &#125;&#125;</code></pre></div></figure><h3 id="添加控制层"><a href="#添加控制层" class="headerlink" title="添加控制层"></a>添加控制层</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class QRCodeController &#123;    @GetMapping(&quot;qrCode&quot;)    public void getQRCode(String codeContent, HttpServletResponse response) &#123;        System.out.println(&quot;codeContent&#x3D;&quot; + codeContent);        try &#123;            &#x2F;*             * 调用工具类生成二维码并输出到输出流中             *&#x2F;            QRCodeUtil.createCodeToOutputStream(codeContent, response.getOutputStream());            log.info(&quot;成功生成二维码!&quot;);        &#125; catch (IOException e) &#123;            log.error(&quot;发生错误， 错误信息是：&#123;&#125;！&quot;, e.getMessage());        &#125;    &#125;&#125;</code></pre></div></figure><h3 id="添加测试页面"><a href="#添加测试页面" class="headerlink" title="添加测试页面"></a>添加测试页面</h3><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;        &lt;title&gt;二维码生成器&lt;&#x2F;title&gt;        &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;            textarea &#123;                font-size: 16px;                width: 300px;                height: 100px;            &#125;            .hint &#123;                color: red;                display: none;            &#125;            .qrCodeDiv &#123;                width: 200px;                height: 200px;                border: 2px solid sandybrown;            &#125;            .qrCodeDiv img &#123;                max-height: 100%;                max-width: 100%;            &#125;        &lt;&#x2F;style&gt;        &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;2.1.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;            $(function () &#123;                $(&quot;button&quot;).click(function () &#123;                    var codeContent &#x3D; $(&quot;textarea&quot;).val();                    console.log(codeContent);                    if (codeContent.trim() &#x3D;&#x3D; &quot;&quot;) &#123;                        $(&quot;.hint&quot;).text(&quot;二维码内容不能为空&quot;).fadeIn(500);                    &#125; else &#123;                        $(&quot;.hint&quot;).text(&quot;&quot;).fadeOut(500);                        $(&quot;#codeImg&quot;).attr(&quot;src&quot;, &quot;&#x2F;qrCode?codeContent&#x3D;&quot; + codeContent);                    &#125;                &#125;);            &#125;);        &lt;&#x2F;script&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;textarea placeholder&#x3D;&quot;二维码内容...&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&gt;        &lt;button&gt;生成二维码&lt;&#x2F;button&gt;        &lt;span class&#x3D;&quot;hint&quot;&gt;&lt;&#x2F;span&gt;        &lt;div class&#x3D;&quot;qrCodeDiv&quot;&gt;            &lt;img src&#x3D;&quot;&quot; id&#x3D;&quot;codeImg&quot;&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="Hutool工具"><a href="#Hutool工具" class="headerlink" title="Hutool工具"></a>Hutool工具</h2><p>Hutool的是非强制依赖性，因此zxing需要用户自行引入，我们需要加入依赖。使用hutool的时候，com.google.zxing-javase的依赖可以不需要。</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;        &lt;version&gt;5.3.10&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.zxing&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;core&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.3.3&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></figure><h3 id="创建QRCodeService"><a href="#创建QRCodeService" class="headerlink" title="创建QRCodeService"></a>创建QRCodeService</h3><p>QRCodeService其实就是对QrCodeUtil的功能的封装，QrCodeUtil此处的类是hutool工具提供的，和我们在上面与自己与自己提供的QRCodeUtil类，不是同一个，这个需要注意一下。QrCodeUtil的功能此处主要使用到了的是生成二维码，到文件或者流之中，QrConfig是Hutool工具QrCodeUtil的配置类。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service@Slf4jpublic class QRCodeService &#123;    &#x2F;&#x2F; 自定义参数，这部分是Hutool工具封装的    private static QrConfig initQrConfig() &#123;        QrConfig config &#x3D; new QrConfig(300, 300);        &#x2F;&#x2F; 设置边距，既二维码和背景之间的边距        config.setMargin(3);        &#x2F;&#x2F; 设置前景色，既二维码颜色（青色）        config.setForeColor(Color.CYAN.getRGB());        &#x2F;&#x2F; 设置背景色（灰色）        config.setBackColor(Color.GRAY.getRGB());        return config;    &#125;    &#x2F;**     * 生成到文件     *     * @param content     * @param filepath     *&#x2F;    public void createQRCode2File(String content, String filepath) &#123;        try &#123;            QrCodeUtil.generate(content, initQrConfig(), FileUtil.file(filepath));            log.info(&quot;生成二维码成功, 位置在：&#123;&#125;！&quot;, filepath);        &#125; catch (QrCodeException e) &#123;            log.error(&quot;发生错误！ &#123;&#125;！&quot;, e.getMessage());        &#125;    &#125;    &#x2F;**     * 生成到流     *     * @param content     * @param response     *&#x2F;    public void createQRCode2Stream(String content, HttpServletResponse response) &#123;        try &#123;            QrCodeUtil.generate(content, initQrConfig(), &quot;png&quot;, response.getOutputStream());            log.info(&quot;生成二维码成功!&quot;);        &#125; catch (QrCodeException | IOException e) &#123;            log.error(&quot;发生错误！ &#123;&#125;！&quot;, e.getMessage());        &#125;    &#125;&#125;</code></pre></div></figure><h3 id="添加Controller"><a href="#添加Controller" class="headerlink" title="添加Controller"></a>添加Controller</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@Slf4jpublic class QRCodeController &#123;    @Autowired    private QRCodeService qrCodeService;    @GetMapping(&quot;qrCode&quot;)    public void getQRCode(String codeContent, HttpServletResponse response) &#123;        try &#123;            qrCodeService.createQRCode2Stream(codeContent, response);            log.info(&quot;成功生成二维码！&quot;);        &#125; catch (Exception e) &#123;            log.error(&quot;发生错误， 错误信息是：&#123;&#125;！&quot;, e.getMessage());        &#125;    &#125;&#125;</code></pre></div></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合来说，还是使用hutool的这种方式吧，更加方便简洁。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QrCode</tag>
      
      <tag>二维码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot对接支付宝支付沙盒</title>
    <link href="/doc/c3ab6d87.html"/>
    <url>/doc/c3ab6d87.html</url>
    
    <content type="html"><![CDATA[<p>支付宝小程序是一种全新的开放模式，让合作伙伴有机会分享支付宝及阿里集团多端流量和商业能力，为用户提供更好的体验，助力商家经营升级。</p><!-- more --><h2 id="通用接入流程简介"><a href="#通用接入流程简介" class="headerlink" title="通用接入流程简介"></a>通用接入流程简介</h2><p>第一步，申请支付宝沙箱测试。<br>第二步，设置支付宝沙箱的基本密钥信息，并给沙箱账号充值你想要的金额。<br>第三步，下载支付宝沙箱版APP，目前只有Android版本。<br>第四步，编码。<br>第五步，测试。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>支付</tag>
      
      <tag>AliPay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8-Nginx安装与配置</title>
    <link href="/doc/713e0cfc.html"/>
    <url>/doc/713e0cfc.html</url>
    
    <content type="html"><![CDATA[<p>Nginx发音为”engine x”，是一种开源的高性能HTTP和反向代理服务器，负责处理Internet上一些最大站点的负载。它可用作HTTP和非HTTP服务器的独立Web服务器，负载平衡器，内容缓存和反向代理。</p><span id="more"></span><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">#安装方法yum install nginx#启用服务systemctl enable nginx#启动服务器systemctl start nginx#查看服务状态sytemctl status nginx</code></pre></div></figure><h2 id="调整防火墙"><a href="#调整防火墙" class="headerlink" title="调整防火墙"></a>调整防火墙</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">firewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;httpfirewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;httpsfirewall-cmd --reload</code></pre></div></figure><p>现在，您可以通过<a href="http://your_ip在web浏览器中打开来测试nginx的安装.您应该看到默认的nginx欢迎页面了./">http://YOUR_IP在Web浏览器中打开来测试Nginx的安装。您应该看到默认的Nginx欢迎页面了。</a></p><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><ul><li>所有有关nginx的配置文件均在<code>/etc/nginx</code>目录中。</li><li>Nginx的主要配置文件是<code>/etc/nginx/nginx.conf</code>。</li><li>为每个域创建一个单独的配置文件使服务器易于维护。</li><li>Nginx服务器阻止文件必须以<code>.conf</code>结尾并存储在<code>/etc/nginx/conf.d</code>目录中。您可以根据需要拥有任意数量的服务器块。</li><li>遵循标准命名规范。如果域名为<code>mydomain.com</code>，则配置文件名称应为<code>mydomain.com.conf</code>.</li><li>如果在域服务器块中使用可重复的配置段，则最好将这些段重构为片段。</li><li>Nginx日志文件（access.log和error.log）位于&#x2F;var&#x2F;log&#x2F;nginx&#x2F;目录中。建议有不同access和error日志文件每个服务器模块。</li><li>您可以将域文档的根目录设置为所需的任何位置。webroot的最常见位置包括：<ul><li>&#x2F;home&#x2F;<code>&lt;user_name&gt;</code>&#x2F;<code>&lt;site_name&gt;</code></li><li>&#x2F;var&#x2F;www&#x2F;<code>&lt;site_name&gt;</code></li><li>&#x2F;var&#x2F;www&#x2F;html&#x2F;<code>&lt;site_name&gt;</code></li><li>&#x2F;opt&#x2F;<code>&lt;site_name&gt;</code></li><li>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</li></ul></li></ul><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p>打开conf文件夹的nginx.conf文件，Nginx服务器的基础配置，默认的配置也存放在此。</p><p>在 nginx.conf 的注释符号为： #</p><p>默认的 nginx 配置文件 nginx.conf 内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#user  nobody;worker_processes  1;#error_log  logs&#x2F;error.log;#error_log  logs&#x2F;error.log  notice;#error_log  logs&#x2F;error.log  info;#pid        logs&#x2F;nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs&#x2F;host.access.log  main;        location &#x2F; &#123;            root   html;            index  index.html index.htm;        &#125;        #error_page  404              &#x2F;404.html;        # redirect server error pages to the static page &#x2F;50x.html        #        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ &#123;        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ &#x2F;\.ht &#123;        #    deny  all;        #&#125;    &#125;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server &#123;    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;    # HTTPS server    #    #server &#123;    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;&#125;</code></pre></div></figure><p><strong>文件结构大致如下：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">... ##全局块events&#123; #events块...&#125;http&#123; #http块    ... #http全局块    server&#123; # server块    ... # server全局块        location [PATTERN] &#123; # location块        ...            &#125;        location [PATTERN] &#123; # location块        ...            &#125;    &#125;    server&#123; # server块    ... # server全局块        location [PATTERN] &#123; # location块        ...            &#125;        location [PATTERN] &#123; # location块        ...            &#125;    &#125;&#125;</code></pre></div></figure><ul><li><strong>全局块：</strong>配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li><strong>events块：</strong>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li><strong>http块：</strong>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li><strong>server块：</strong>配置虚拟主机的相关参数，一个http中可以有多个server。</li><li><strong>location块：</strong>配置请求的路由，以及各种页面的处理情况。</li></ul><p>以下为常见配置与解释：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">########### 每个指令必须有分号结束。##################user administrator administrators;  #配置用户或者组，默认为nobody nobody。#worker_processes 2;  #允许生成的进程数，默认为1#pid &#x2F;nginx&#x2F;pid&#x2F;nginx.pid;   #指定nginx进程运行文件存放地址error_log log&#x2F;error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents &#123;    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|&#x2F;dev&#x2F;poll|eventport    worker_connections  1024;    #最大连接数，默认为512&#125;http &#123;    include       mime.types;   #文件扩展名与文件类型映射表    default_type  application&#x2F;octet-stream; #默认文件类型，默认为text&#x2F;plain    #access_log off; #取消服务日志        log_format myFormat &#39;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#39;; #自定义格式    access_log log&#x2F;access.log myFormat;  #combined为日志格式的默认值    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。    upstream mysvr &#123;         server 127.0.0.1:7878;      server 192.168.10.121:3333 backup;  #热备    &#125;    error_page 404 https:&#x2F;&#x2F;www.baidu.com; #错误页    server &#123;        keepalive_requests 120; #单连接请求上限次数。        listen       4545;   #监听端口        server_name  127.0.0.1;   #监听地址               location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。           #root path;  #根目录           #index vv.txt;  #设置默认页           proxy_pass  http:&#x2F;&#x2F;mysvr;  #请求转向mysvr 定义的服务器列表           deny 127.0.0.1;  #拒绝的ip           allow 172.18.5.54; #允许的ip                   &#125;     &#125;&#125;</code></pre></div></figure><p><strong>几个常见的配置项：</strong></p><ul><li><code>$remote_addr</code> 与 <code>$http_x_forwarded_for</code> 用以记录客户端的ip地址；</li><li><code>$remote_user</code> ：用来记录客户端用户名称；</li><li><code>$time_local</code> ： 用来记录访问时间与时区；</li><li><code>$request</code> ： 用来记录请求的url与http协议；</li><li><code>$status</code> ： 用来记录请求状态；成功是200；</li><li><code>$body_bytes_sent</code> ：记录发送给客户端文件主体内容大小；</li><li><code>$http_referer</code> ：用来记录从那个页面链接访问过来的；</li><li><code>$http_user_agent</code> ：记录客户端浏览器的相关信息；</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>CentOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-8安装并配置防火墙</title>
    <link href="/doc/619ca886.html"/>
    <url>/doc/619ca886.html</url>
    
    <content type="html"><![CDATA[<p>防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，<br>同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，<br>为用户提供更好、更安全的计算机网络使用体验。</p><span id="more"></span><p>这里主要记录CentOS-8中遇到的防火墙常用命令。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">yum install iptables-services #安装iptables</code></pre></div></figure><h2 id="服务管理命令"><a href="#服务管理命令" class="headerlink" title="服务管理命令"></a>服务管理命令</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">systemctl unmask firewalld #执行命令，即可实现取消服务的锁定systemctl mask firewalld # 下次需要锁定该服务时执行systemctl start firewalld.service #启动防火墙systemctl stop firewalld.service #停止防火墙systemctl reloadt firewalld.service #重载配置systemctl restart firewalld.service #重启服务systemctl status firewalld.service #显示服务的状态systemctl enable firewalld.service #在开机时启用服务systemctl disable firewalld.service #在开机时禁用服务systemctl is-enabled firewalld.service #查看服务是否开机启动systemctl list-unit-files|grep enabled #查看已启动的服务列表systemctl --failed #查看启动失败的服务列表</code></pre></div></figure><h2 id="防火墙命令"><a href="#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">firewall-cmd --state #查看防火墙状态firewall-cmd --reload #更新防火墙规则firewall-cmd --state #查看防火墙状态firewall-cmd --reload #重载防火墙规则firewall-cmd --list-ports #查看所有打开的端口firewall-cmd --list-services #查看所有允许的服务firewall-cmd --get-services #获取所有支持的服务#区域相关firewall-cmd --list-all-zones #查看所有区域信息firewall-cmd --get-active-zones #查看活动区域信息firewall-cmd --set-default-zone&#x3D;public #设置public为默认区域firewall-cmd --get-default-zone #查看默认区域信息firewall-cmd --zone&#x3D;public --add-interface&#x3D;eth0 #将接口eth0加入区域public#接口相关firewall-cmd --zone&#x3D;public --remove-interface&#x3D;eth0 #从区域public中删除接口eth0firewall-cmd --zone&#x3D;default --change-interface&#x3D;eth0 #修改接口eth0所属区域为defaultfirewall-cmd --get-zone-of-interface&#x3D;eth0 #查看接口eth0所属区域#用例firewall-cmd --query-port&#x3D;8080&#x2F;tcp # 查询端口是否开放firewall-cmd --add-port&#x3D;80&#x2F;tcp --permanent #永久添加80端口例外(全局)firewall-cmd --remove-port&#x3D;80&#x2F;tcp --permanent #永久删除80端口例外(全局)firewall-cmd --add-port&#x3D;65001-65010&#x2F;tcp --permanent #永久增加65001-65010例外(全局)firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent #永久添加80端口例外(区域public)firewall-cmd --zone&#x3D;public --remove-port&#x3D;80&#x2F;tcp --permanent #永久删除80端口例外(区域public)firewall-cmd --zone&#x3D;public --add-port&#x3D;65001-65010&#x2F;tcp --permanent #永久增加65001-65010例外(区域public)firewall-cmd --reload #重启防火墙(修改配置后要重启防火墙)</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>CentOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iptables</tag>
      
      <tag>防火墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java源码解析——RegisterNatives()方法</title>
    <link href="/doc/7a5e4e12.html"/>
    <url>/doc/7a5e4e12.html</url>
    
    <content type="html"><![CDATA[<p>在学习JDK的反射机制与底层源码的时候，常常会看到一个私有本地方法<code>private static native void registerNatives();</code>。<br>那么它究竟是做什么的呢？</p><span id="more"></span><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>首先你需要了解如下基础知识：</p><ul><li>了解C语言或C++语言的基础知识</li><li>具备JavaSE的基础</li><li>了解Java的JNI技术</li></ul><h2 id="registerNatives-介绍"><a href="#registerNatives-介绍" class="headerlink" title="registerNatives()介绍"></a><code>registerNatives()</code>介绍</h2><p>这个方法主要的目的就是为了注册本地的方法，具体怎么注册呢。就是将Java中的本地方法与C或C++语言编写的函数进行映射关联。</p><p>在做JNI开发的时候，你可能会使用<code>javah</code>生成头文件。在C代码中<code>include</code>生成的头文件。利用这种方式实现的库，就不需要去做函数映射。<br>Java JNI实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.aijiao.test;public class JNIDemo &#123;        &#x2F;&#x2F;定义一个方法，该方法在C中实现    public native void testHello();        public static void main(String[] args)&#123;        &#x2F;&#x2F;加载C文件        System.loadLibrary(&quot;TestJNI&quot;);        JNIDemo jniDemo &#x3D; new JNIDemo();        jniDemo.testHello();    &#125;&#125;</code></pre></div></figure><p>利用<code>javah</code>生成的头文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include &quot;com_aijiao_test_JNIDemo.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;JNIEXPORT void JNICALL Java_com_aijiao_test_JNIDemo_testHello(JNIEnv *, jobject) &#123;    printf(&quot;this is C++ print&quot;);&#125;</code></pre></div></figure><p>从上面的代码中可以看到，它们之间默认就有一种一一对应的映射协议，这样的JNI就不需要去做注册。只需要在开始阶段加载这个Library文件（windows一般为dll，Linux一般为so）即可。<br>若您在开发的过程中没有按照这种映射协议去生成Library文件，那么就需要使用<code>registerNatives()</code>来进行注册了。</p><p>例如，java.lang.Object.registerNatives对应的C函数被命名Java_java_lang_Object_registerNatives。通过使用registerNatives（或者说，JNI函数RegisterNatives），你可以任意指定你的C函数。</p><p>这是关联的C代码（来自OpenJDK 6）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">static JNINativeMethod methods[] &#x3D; &#123;    &#123;&quot;hashCode&quot;,    &quot;()I&quot;,                    (void *)&amp;JVM_IHashCode&#125;,    &#123;&quot;wait&quot;,        &quot;(J)V&quot;,                   (void *)&amp;JVM_MonitorWait&#125;,    &#123;&quot;notify&quot;,      &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotify&#125;,    &#123;&quot;notifyAll&quot;,   &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotifyAll&#125;,    &#123;&quot;clone&quot;,       &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;,   (void *)&amp;JVM_Clone&#125;,&#125;;JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)&#123;    (*env)-&gt;RegisterNatives(env, cls,                            methods, sizeof(methods)&#x2F;sizeof(methods[0]));&#125;</code></pre></div></figure><p>现在你应该能明白，<code>registerNatives()</code>方法的主要目的就是为了建立JVNM与C语言库交互的映射关系，使JVM可以得到操作系统的支持。这也是Java实现跨平台的主要原理。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>源码解析</tag>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CLion-CMakeLists.txt 语法介绍与实例演练</title>
    <link href="/doc/8936b525.html"/>
    <url>/doc/8936b525.html</url>
    
    <content type="html"><![CDATA[<p>CMake 是一个跨平台、开源的构建系统。<br>它是一个集软件构建、测试、打包于一身的软件。<br>它使用与平台和编译器独立的配置文件来对软件编译过程进行控制。</p><span id="more"></span><h1 id="CMakeLists-txt-语法介绍"><a href="#CMakeLists-txt-语法介绍" class="headerlink" title="CMakeLists.txt 语法介绍"></a>CMakeLists.txt 语法介绍</h1><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="指定-cmake-的最小版本"><a href="#指定-cmake-的最小版本" class="headerlink" title="指定 cmake 的最小版本"></a>指定 cmake 的最小版本</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">cmake_minimum_required(VERSION 3.4.1)</code></pre></div></figure><p>这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><h3 id="设置项目名称"><a href="#设置项目名称" class="headerlink" title="设置项目名称"></a>设置项目名称</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">project(demo)</code></pre></div></figure><p>这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><h3 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">add_executable(demo demo.cpp) # 生成可执行文件add_library(common STATIC util.cpp) # 生成静态库add_library(common SHARED util.cpp) # 生成动态库或共享库</code></pre></div></figure><p>add_library 默认生成是静态库，通过以上命令生成文件名字:</p><p>在 Linux 下是：</p><ul><li>demo</li><li>libcommon.a</li><li>libcommon.so<br>在 Windows 下是：</li><li>demo.exe</li><li>common.lib</li><li>common.dll</li></ul><h3 id="指定编译包含的源文件"><a href="#指定编译包含的源文件" class="headerlink" title="指定编译包含的源文件"></a>指定编译包含的源文件</h3><h4 id="明确指定包含哪些源文件"><a href="#明确指定包含哪些源文件" class="headerlink" title="明确指定包含哪些源文件"></a>明确指定包含哪些源文件</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">add_library(demo demo.cpp test.cpp util.cpp)</code></pre></div></figure><h4 id="搜索所有的-cpp-文件"><a href="#搜索所有的-cpp-文件" class="headerlink" title="搜索所有的 cpp 文件"></a>搜索所有的 cpp 文件</h4><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件add_library(demo $&#123;SRC_LIST&#125;)</code></pre></div></figure><h4 id="自定义搜索规则"><a href="#自定义搜索规则" class="headerlink" title="自定义搜索规则"></a>自定义搜索规则</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">file(GLOB SRC_LIST &quot;*.cpp&quot; &quot;protocol&#x2F;*.cpp&quot;)add_library(demo $&#123;SRC_LIST&#125;)# 或者file(GLOB SRC_LIST &quot;*.cpp&quot;)file(GLOB SRC_PROTOCOL_LIST &quot;protocol&#x2F;*.cpp&quot;)add_library(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)# 或者aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</code></pre></div></figure><h3 id="查找指定的库文件"><a href="#查找指定的库文件" class="headerlink" title="查找指定的库文件"></a>查找指定的库文件</h3><p>find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br>默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">find_library( # Sets the name of the path variable.              log-lib               # Specifies the name of the NDK library that              # you want CMake to locate.              log )</code></pre></div></figure><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><h3 id="设置包含的目录"><a href="#设置包含的目录" class="headerlink" title="设置包含的目录"></a>设置包含的目录</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">include_directories(    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include)</code></pre></div></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</code></pre></div></figure><h3 id="设置链接库搜索目录"><a href="#设置链接库搜索目录" class="headerlink" title="设置链接库搜索目录"></a>设置链接库搜索目录</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">link_directories(    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;libs)</code></pre></div></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;libs&quot;)</code></pre></div></figure><h3 id="设置-target-需要链接的库"><a href="#设置-target-需要链接的库" class="headerlink" title="设置 target 需要链接的库"></a>设置 target 需要链接的库</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">target_link_libraries( # 目标库                       demo                        # 目标库需要链接的库                       # log-lib 是上面 find_library 指定的变量名                       $&#123;log-lib&#125; )</code></pre></div></figure><p>在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><h4 id="指定链接动态库或静态库"><a href="#指定链接动态库或静态库" class="headerlink" title="指定链接动态库或静态库"></a>指定链接动态库或静态库</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">target_link_libraries(demo libface.a) # 链接libface.atarget_link_libraries(demo libface.so) # 链接libface.so</code></pre></div></figure><h4 id="指定全路径"><a href="#指定全路径" class="headerlink" title="指定全路径"></a>指定全路径</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">target_link_libraries(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;libs&#x2F;libface.a)target_link_libraries(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;libs&#x2F;libface.so)</code></pre></div></figure><h4 id="指定链接多个库"><a href="#指定链接多个库" class="headerlink" title="指定链接多个库"></a>指定链接多个库</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">target_link_libraries(demo    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;libs&#x2F;libface.a    boost_system.a    boost_thread    pthread)</code></pre></div></figure><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><h4 id="set-直接设置变量的值"><a href="#set-直接设置变量的值" class="headerlink" title="set 直接设置变量的值"></a>set 直接设置变量的值</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(SRC_LIST main.cpp test.cpp)add_executable(demo $&#123;SRC_LIST&#125;)</code></pre></div></figure><h4 id="set-追加设置变量的值"><a href="#set-追加设置变量的值" class="headerlink" title="set 追加设置变量的值"></a>set 追加设置变量的值</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(SRC_LIST main.cpp)set(SRC_LIST $&#123;SRC_LIST&#125; test.cpp)add_executable(demo $&#123;SRC_LIST&#125;)</code></pre></div></figure><h4 id="list-追加或者删除变量的值"><a href="#list-追加或者删除变量的值" class="headerlink" title="list 追加或者删除变量的值"></a>list 追加或者删除变量的值</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(SRC_LIST main.cpp)list(APPEND SRC_LIST test.cpp)list(REMOVE_ITEM SRC_LIST main.cpp)add_executable(demo $&#123;SRC_LIST&#125;)</code></pre></div></figure><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h4 id="if…elseif…else…endif"><a href="#if…elseif…else…endif" class="headerlink" title="if…elseif…else…endif"></a>if…elseif…else…endif</h4><p>逻辑判断和比较：<br><code>if (expression)</code>：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br><code>if (not exp)</code>：与上面相反<br><code>if (var1 AND var2)</code><br><code>if (var1 OR var2)</code><br><code>if (COMMAND cmd)</code>：如果 cmd 确实是命令并可调用为真<br><code>if (EXISTS dir)</code> <code>if (EXISTS file)</code>：如果目录或文件存在为真<br><code>if (file1 IS_NEWER_THAN file2)</code>：当 file1 比 file2 新，或 file1&#x2F;file2 中有一个不存在时为真，文件名需使用全路径<br><code>if (IS_DIRECTORY dir)</code>：当 dir 是目录时为真<br><code>if (DEFINED var)</code>：如果变量被定义为真<br><code>if (var MATCHES regex)</code>：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br><code>if (string MATCHES regex)</code></p><p>数字比较：<br><code>if (variable LESS number)</code>：LESS 小于<br><code>if (string LESS number)</code><br><code>if (variable GREATER number)</code>：GREATER 大于<br><code>if (string GREATER number)</code><br><code>if (variable EQUAL number)</code>：EQUAL 等于<br><code>if (string EQUAL number)</code></p><p>字母表顺序比较：<br><code>if (variable STRLESS string)</code><br><code>if (string STRLESS string)</code><br><code>if (variable STRGREATER string)</code><br><code>if (string STRGREATER string)</code><br><code>if (variable STREQUAL string)</code><br><code>if (string STREQUAL string)</code><br>示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">if(MSVC)    set(LINK_LIBS common)else()    set(boost_thread boost_log.a boost_system.a)endif()target_link_libraries(demo $&#123;LINK_LIBS&#125;)# 或者if(UNIX)    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std&#x3D;c++11 -fpermissive -g&quot;)else()    add_definitions(-D_SCL_SECURE_NO_WARNINGS    D_CRT_SECURE_NO_WARNINGS    -D_WIN32_WINNT&#x3D;0x601    -D_WINSOCK_DEPRECATED_NO_WARNINGS)endif() if($&#123;CMAKE_BUILD_TYPE&#125; MATCHES &quot;debug&quot;)    ...else()    ...endif()</code></pre></div></figure><h4 id="while…endwhile"><a href="#while…endwhile" class="headerlink" title="while…endwhile"></a>while…endwhile</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">while(condition)    ...endwhile()</code></pre></div></figure><h4 id="foreach…endforeach"><a href="#foreach…endforeach" class="headerlink" title="foreach…endforeach"></a>foreach…endforeach</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">foreach(loop_var RANGE start stop [step])    ...endforeach(loop_var)</code></pre></div></figure><p>start 表示起始数，stop 表示终止数，step 表示步长，示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">foreach(i RANGE 1 9 2)    message($&#123;i&#125;)endforeach(i)# 输出：13579</code></pre></div></figure><h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">message($&#123;PROJECT_SOURCE_DIR&#125;)message(&quot;build with debug mode&quot;)message(WARNING &quot;this is warnning message&quot;)message(FATAL_ERROR &quot;this build has many error&quot;) # FATAL_ERROR 会导致编译失败</code></pre></div></figure><h3 id="包含其它-cmake-文件"><a href="#包含其它-cmake-文件" class="headerlink" title="包含其它 cmake 文件"></a>包含其它 cmake 文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">include(.&#x2F;common.cmake) # 指定包含文件的全路径include(def) # 在搜索路径中搜索def.cmake文件set(CMAKE_MODULE_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;cmake) # 设置include的搜索路径</code></pre></div></figure><h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><code>PROJECT_SOURCE_DIR</code>：工程的根目录<br><code>PROJECT_BINARY_DIR</code>：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}&#x2F;build<br><code>PROJECT_NAME</code>：返回通过 project 命令定义的项目名称<br><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前处理的 CMakeLists.txt 所在的路径<br><code>CMAKE_CURRENT_BINARY_DIR</code>：target 编译目录<br><code>CMAKE_CURRENT_LIST_DIR</code>：CMakeLists.txt 的完整路径<br><code>CMAKE_CURRENT_LIST_LINE</code>：当前所在的行<br><code>CMAKE_MODULE_PATH</code>：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}&#x2F;cmake)，然后可以用INCLUDE命令来调用自己的模块<br><code>EXECUTABLE_OUTPUT_PATH</code>：重新定义目标二进制可执行文件的存放位置<br><code>LIBRARY_OUTPUT_PATH</code>：重新定义目标链接库文件的存放位置</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>使用环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">$ENV&#123;Name&#125;</code></pre></div></figure><p>写入环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">set(ENV&#123;Name&#125; value) # 这里没有“$”符号</code></pre></div></figure><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p><code>CMAKE_MAJOR_VERSION</code>：cmake 主版本号，比如 3.4.1 中的 3<br><code>CMAKE_MINOR_VERSION</code>：cmake 次版本号，比如 3.4.1 中的 4<br><code>CMAKE_PATCH_VERSION</code>：cmake 补丁等级，比如 3.4.1 中的 1<br><code>CMAKE_SYSTEM</code>：系统名称，比如 Linux-­2.6.22<br><code>CMAKE_SYSTEM_NAME</code>：不包含版本的系统名，比如 Linux<br><code>CMAKE_SYSTEM_VERSION</code>：系统版本，比如 2.6.22<br><code>CMAKE_SYSTEM_PROCESSOR</code>：处理器名称，比如 i686<br><code>UNIX</code>：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin<br><code>WIN32</code>：在所有的 win32 平台下该值为 TRUE，包括 cygwin</p><h3 id="主要开关选项"><a href="#主要开关选项" class="headerlink" title="主要开关选项"></a>主要开关选项</h3><p><code>BUILD_SHARED_LIBS</code>：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br><code>CMAKE_C_FLAGS</code>：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br><code>CMAKE_CXX_FLAGS</code>：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔</code></pre></div></figure><h2 id="项目示例"><a href="#项目示例" class="headerlink" title="项目示例"></a>项目示例</h2><h3 id="简单项目（单个源文件）"><a href="#简单项目（单个源文件）" class="headerlink" title="简单项目（单个源文件）"></a>简单项目（单个源文件）</h3><p>一个经典的 C 程序，如何通过 cmake 来编译呢？</p><h4 id="新建文件-main-c"><a href="#新建文件-main-c" class="headerlink" title="新建文件 main.c"></a>新建文件 main.c</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;Hello World!\n&quot;);    return 0;&#125;</code></pre></div></figure><h4 id="新建文件-CMakeLists-txt（命名必须是-CMakeLists-txt，注意大小写和不要漏字母）"><a href="#新建文件-CMakeLists-txt（命名必须是-CMakeLists-txt，注意大小写和不要漏字母）" class="headerlink" title="新建文件 CMakeLists.txt（命名必须是 CMakeLists.txt，注意大小写和不要漏字母）"></a>新建文件 CMakeLists.txt（命名必须是 CMakeLists.txt，注意大小写和不要漏字母）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">project(HELLO)add_executable(hello main.c)</code></pre></div></figure><h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h4><p>新建一个 build 文件夹，目录情况如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">.&#x2F;demo|+-- bulid|+-- CMakeLists.txt</code></pre></div></figure><p><em>为什么要新建一个 build 文件夹？</em></p><p><em>一般我们采用 cmake 的 out-of-source 方式来构建（即生成的中间产物和源代码分离），这样做可以让生成的文件和源文件不会弄混，且目录结构看起来也会清晰明了。所以推荐使用这种方式，至于这个文件夹的命名并无限制，我们习惯命名为 build。</em></p><p>依次执行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">cd buildcmake ..</code></pre></div></figure><p>首先进入到 build 目录，然后就是 cmake .. 命令，另外要注意将 cmake 配置到环境变量中去才可直接使用，否则需要使用绝对路径，.. 表示上一级目录，cmake 会在上一级目录下找到 CMakeLists.txt 文件并编译，并生成如下图所示的一些中间文件：</p><p>直接执行 make 命令，生成可执行程序，如下图：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">.&#x2F;demo|+-- bulid|+-- CMakeLists.txt|+-- cmake_install.cmake|+-- hello.exe #或linux的可执行程序|+-- Makefile</code></pre></div></figure><p>运行程序，如下所示：运行程序，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">HelloWorld!</code></pre></div></figure><h3 id="复杂项目（多个目录，多个源文件，多个项目）"><a href="#复杂项目（多个目录，多个源文件，多个项目）" class="headerlink" title="复杂项目（多个目录，多个源文件，多个项目）"></a>复杂项目（多个目录，多个源文件，多个项目）</h3><p>目录结构如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">.&#x2F;demo|+-- CMakeLists.txt|+-- main.c|+-- math    |    +-- CMakeLists.txt    |    +-- MathFunctions.c    |    +-- MathFunctions.h</code></pre></div></figure><p><strong>demo 根目录下的 CMakeLists.txt 文件如下：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">cmake_minimum_required (VERSION 2.8)project(demo)aux_source_directory(. DIR_SRCS)# 添加math子目录add_subdirectory(math)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;)# 添加链接库target_link_libraries(demo MathFunctions)</code></pre></div></figure><p><strong>math 目录下的 CMakeLists.txt 文件如下：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library(MathFunctions $&#123;DIR_LIB_SRCS&#125;)</code></pre></div></figure><h3 id="自定义编译选项"><a href="#自定义编译选项" class="headerlink" title="自定义编译选项"></a>自定义编译选项</h3><p>cmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。<br>例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算，否则就调用标准库中的数学函数库。<br><strong>修改根目录下的 CMakeLists.txt 文件如下：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo)# 加入一个配置头文件，用于处理 CMake 对源码的设置configure_file (    &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;config.h.in&quot;    &quot;$&#123;PROJECT_BINARY_DIR&#125;&#x2F;config.h&quot;    )# 是否使用自己的 MathFunctions 库option (USE_MYMATH        &quot;Use provided math implementation&quot; ON)# 是否加入 MathFunctions 库if (USE_MYMATH)    include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;math&quot;)    add_subdirectory (math)    set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif (USE_MYMATH)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;)target_link_libraries (Demo $&#123;EXTRA_LIBS&#125;)</code></pre></div></figure><ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</li></ul><p><strong>修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是MathFunctions 库：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#include &quot;config.h&quot;#ifdef USE_MYMATH    #include &quot;math&#x2F;MathFunctions.h&quot;#else    #include &lt;math.h&gt;#endif int main(int argc, char *argv[])&#123;    if (argc &lt; 3)&#123;        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);        return 1;    &#125;    double base &#x3D; atof(argv[1]);    int exponent &#x3D; atoi(argv[2]); #ifdef USE_MYMATH    printf(&quot;Now we use our own Math library. \n&quot;);    double result &#x3D; power(base, exponent);#else    printf(&quot;Now we use the standard library. \n&quot;);    double result &#x3D; pow(base, exponent);#endif    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);    return 0;&#125;</code></pre></div></figure><p><strong>编写 config.h.in 文件</strong></p><p>注意 main.cc 的第一行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#cmakedefine USE_MYMATH</code></pre></div></figure><p>这样 cmake 会自动根据 CMakeLists.txt 配置文件中的设置自动生成 config.h 文件。</p>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>CLion</category>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDE</tag>
      
      <tag>CLion</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali安装谷歌拼音输入法</title>
    <link href="/doc/ca797342.html"/>
    <url>/doc/ca797342.html</url>
    
    <content type="html"><![CDATA[<p>如何在kali linux中安装中文输入法,由于kali linux中默认是没有中文输入法的，所以我教大家如何安装谷歌输入法</p><span id="more"></span><h2 id="所需准备"><a href="#所需准备" class="headerlink" title="所需准备"></a>所需准备</h2><p>请确定你已经完成了对<code>apt</code>源的修改和中文的设置。<br>若你还未做该设置，请转至 <a href="/doc/21e14d01.html">Kali v2020.0设置源与中文</a><br>做好对源和中文的设置(这里的<code>apt</code>源，若你更新官方源较快，可不做源的修改)。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>打开命令行终端准备安装(kali linux默认是超级管理员，所以以下命令无需添加<code>sudo</code>)，#后面为注释，非命令,不用理会</p></li><li><p><code>apt update</code> #更新软件源</p></li><li><p><code>apt install fcitx</code>  #安装谷歌输入法所依赖的包,</p></li><li><p><code>apt install fcitx-googlepinyin</code>    #安装谷歌输入法</p></li><li><p>注销或者重新启动计算机</p></li><li><p>重新启动后在左下角出现输入法配置，然后右键选择配置(configure)，输入法配置,选择左下角的+添加谷歌输入法</p></li><li><p>取消勾选复选框，然后在输入框中输入法google,即可看到谷歌拼音</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>输入法</tag>
      
      <tag>中文输入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu调试命令strace</title>
    <link href="/doc/d85b22db.html"/>
    <url>/doc/d85b22db.html</url>
    
    <content type="html"><![CDATA[<p>在Linux系统中， strace是一种相当有效的跟踪工具，它的主要特点是可以被用来监视系统调用。<br>我们不仅可以用strace调试一个新开始的程序，也可以调试一个已经在运行的程序（这意味着把strace绑定到一个已有的PID上）。</p><span id="more"></span><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. -d 输出strace关于标准错误的调试信息. -f 跟踪由fork调用所产生的子进程. -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. -h 输出简要的帮助信息. -i 输出系统调用的入口指针. -q 禁止输出关于脱离的消息. -r 打印出相对时间关于,,每一个系统调用. -t 在输出中的每一行前加上时间信息. -tt 在输出中的每一行前加上时间信息,微秒级. -ttt 微秒级输出,以秒了表示时间. -T 显示每一调用所耗的时间. -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. -V 输出strace的版本信息. -x 以十六进制形式输出非标准字符串 -xx 所有字符串以十六进制形式输出. -a column 设置返回值的输出位置.默认 为40. -e expr 指定一个表达式,用来控制如何跟踪.格式如下: [qualifier&#x3D;][!]value1[,value2]... qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: -eopen等价于 -e trace&#x3D;open,表示只跟踪open调用.而-etrace!&#x3D;open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\. -e trace&#x3D;set 只跟踪指定的系统 调用.例如:-e trace&#x3D;open,close,rean,write表示只跟踪这四个系统调用.默认的为set&#x3D;all. -e trace&#x3D;file 只跟踪有关文件操作的系统调用. -e trace&#x3D;process 只跟踪有关进程控制的系统调用. -e trace&#x3D;network 跟踪与网络有关的所有系统调用. -e strace&#x3D;signal 跟踪所有与系统信号有关的 系统调用 -e trace&#x3D;ipc 跟踪所有与进程通讯有关的系统调用 -e abbrev&#x3D;set 设定 strace输出的系统调用的结果集.-v 等与 abbrev&#x3D;none.默认为abbrev&#x3D;all. -e raw&#x3D;set 将指 定的系统调用的参数以十六进制显示. -e signal&#x3D;set 指定跟踪的系统信号.默认为all.如 signal&#x3D;!SIGIO(或者signal&#x3D;!io),表示不跟踪SIGIO信号. -e read&#x3D;set 输出从指定文件中读出 的数据.例如: -e read&#x3D;3,5 -e write&#x3D;set 输出写入到指定文件中的数据. -o filename 将strace的输出写入文件filename -p pid 跟踪指定的进程pid. -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. -u username 以username 的UID和GID执行被跟踪的命令</code></pre></div></figure><p>常用用法：</p><blockquote><p>常与javaIO操作相结合研究Java与内核的相互调用。</p><p><code>strace -ff -o out java xxx</code></p><p>这里也经常和<code>man</code>指令一起使用，学习系统函数。</p></blockquote><p><strong>注意：</strong>若出现<code>No manual entry for XXX</code>的情况请先安装<code>apt-get install manpages-dev</code>。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>strace</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot底层-snakeyaml自定义转储格式</title>
    <link href="/doc/ef82d306.html"/>
    <url>/doc/ef82d306.html</url>
    
    <content type="html"><![CDATA[<h2 id="YAML文档自定义转储"><a href="#YAML文档自定义转储" class="headerlink" title="YAML文档自定义转储"></a>YAML文档自定义转储</h2><p>在SnakeYAML中进行转储的主要目的是生成可以反序列化实例的YAML文档。在某些情况下，创建的YAML文档可能并不符合你的需求：</p><ul><li>不可变的对象。不可变对象可能拥有<code>getter</code>方法，但不存在<code>setter</code>方法。默认情况下，映射时会调用<code>setter</code>方法或构造方法。若属性的顺序不一致，致使对象无法解析。因此对象属性的顺序尤为重要，必须按照指定顺序序列化属性。</li><li>注释。注释可以帮助我们更好的理解和编辑YAML文档。</li><li>跳过一些JavaBean属性（例如：空集合、null、计算属性等）。</li><li>定义JavaBean属性顺序。这个顺序可能非常有用：比如，我们通常会将id或name作为第一个属性。（默认情况下按照字母顺序排序。）</li><li>由于标准类型具有一个以上的值，因此可以将<code>Representer</code>配置为使用不同的值。</li></ul><p>YAML文档就是一个普通的文本文档，因此你可以使用任意的模板处理器来处理它。</p><p>默认算法：</p><ol><li>判断是否可以仅使用<code>DumperOptions</code>。</li><li>若不是则使用<code>yaml.dumpAs(obj,Tag.MAP)</code>来解析它。</li><li>选择您指定的模板引擎，然后继续解析。</li><li>自行编写一个对象类存储数据，然后通过YAML解析生成对象类实例进行测试。测试过程中会提示该对象类不符合规范的地方并提醒您修改。</li><li>您也可以考虑扩展SnakeYAML的<code>org.yaml.snakeyaml.representer.Representer</code>。</li><li>实现你自己的模板引擎，将实例序列化为YAML文档。</li></ol><p>以下是使用模板的示例。</p><h3 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h3><p>这个规范说明：“JavaBeans体系结构的主要目的是提供一种平台无关的组件体系结构。”</p><p>避免使用全局标记可以提高不同平台和语言之间公用YAML文档的能力。简单点来说就是跨平台和跨语言的能力。</p><p>若您自定义的Java类符合JavaBean规范，则可无需其他额外的代码支持，就可实现对象的序列化与反序列化。</p><p>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CarWithWheel &#123;    private String plate;    private String year;    private Wheel wheel;    private Object part;    private Map&lt;String, Integer&gt; map;    public String getPlate() &#123;        return plate;    &#125;    public void setPlate(String plate) &#123;        this.plate &#x3D; plate;    &#125;    public Wheel getWheel() &#123;        return wheel;    &#125;    public void setWheel(Wheel wheel) &#123;        this.wheel &#x3D; wheel;    &#125;    public Map&lt;String, Integer&gt; getMap() &#123;        return map;    &#125;    public void setMap(Map&lt;String, Integer&gt; map) &#123;        this.map &#x3D; map;    &#125;    public Object getPart() &#123;        return part;    &#125;    public void setPart(Object part) &#123;        this.part &#x3D; part;    &#125;    public String getYear() &#123;        return year;    &#125;    public void setYear(String year) &#123;        this.year &#x3D; year;    &#125;&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">CarWithWheel car1 &#x3D; new CarWithWheel();car1.setPlate(&quot;12-XP-F4&quot;);Wheel wheel &#x3D; new Wheel();wheel.setId(2);car1.setWheel(wheel);Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;String, Integer&gt;();map.put(&quot;id&quot;, 3);car1.setMap(map);car1.setPart(new Wheel(4));car1.setYear(&quot;2008&quot;);String output &#x3D; new Yaml().dump(car1);</code></pre></div></figure><p>以上代码会输出如下文档：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">!!package.CarWithWheelmap: &#123;id: 3&#125;part: !!org.yaml.snakeyaml.constructor.Wheel &#123;id: 4&#125;plate: 12-XP-F4wheel: &#123;id: 2&#125;year: &#39;2008&#39;</code></pre></div></figure><p><strong>注意：</strong> ‘part’属性存在全局标记。而‘wheel’则没有（因为wheel的运行时类与CarWithWheel类中定义的相同）。</p><p>转储时首选的方法是使用<code>yaml.dumpAs(obj,Tag.MAP)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>snakeyaml</tag>
      
      <tag>yaml</tag>
      
      <tag>yml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot底层-snakeyaml的使用</title>
    <link href="/doc/5d12e6ae.html"/>
    <url>/doc/5d12e6ae.html</url>
    
    <content type="html"><![CDATA[<h2 id="所用依赖"><a href="#所用依赖" class="headerlink" title="所用依赖"></a>所用依赖</h2><p>目前最稳定的版本为1.25版，最新版为1.28版。</p><p>下载链接：</p><ul><li><p>来源：http：&#x2F;&#x2F;bitbucket.org&#x2F;asomov&#x2F;snakeyaml&#x2F;src</p></li><li><p>JAR包：https：&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;yaml&#x2F;snakeyaml&#x2F;1.25&#x2F;snakeyaml-1.25.jar</p></li><li><p>Android包：https：&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;yaml&#x2F;snakeyaml&#x2F;1.25&#x2F;snakeyaml-1.25-android.jar</p></li><li><p>储存库：<a href="http://search.maven.org/#search|ga|1|snakeyaml">http://search.maven.org/#search|ga|1|snakeyaml</a></p></li></ul><p>发行版在中央存储库中可用。</p><p>依赖项定义（在pom.xml中）</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;  ...  &lt;dependency&gt;    &lt;groupId&gt;org.yaml&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;snakeyaml&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.26-SNAPSHOT&lt;&#x2F;version&gt;  &lt;&#x2F;dependency&gt;  ...&lt;&#x2F;dependencies&gt;</code></pre></div></figure><p>Android项目的依赖项定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;  &lt;groupId&gt;org.yaml&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;snakeyaml&lt;&#x2F;artifactId&gt;  &lt;version&gt;1.26-SNAPSHOT&lt;&#x2F;version&gt;  &lt;classifier&gt;android&lt;&#x2F;classifier&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>首先实例化org.yaml.snakeyaml.Yaml实例。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Yaml yaml &#x3D; new Yaml();</code></pre></div></figure><h3 id="加载YAML"><a href="#加载YAML" class="headerlink" title="加载YAML"></a>加载YAML</h3><p>方法<code>yaml.load()</code>可以将YAML文档转换为Java对象。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Yaml yaml &#x3D; new Yaml();String document &#x3D; &quot;\n- Hesperiidae\n- Papilionidae\n- Apatelodidae\n- Epiplemidae&quot;;List&lt;String&gt; list &#x3D; (List&lt;String&gt;) yaml.load(document);System.out.println(list);</code></pre></div></figure><p><code>yaml.load()</code>接受String或InputStream对象。<code>yaml.load(InputStream stream)</code>通过检查流开始处的BOM（字节顺序标记）序列来检测编码。如果没有BOM，则假定为utf-8编码。</p><p><code>yaml.load()</code>返回一个Java对象。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testLoadFromString() &#123;    Yaml yaml &#x3D; new Yaml();    String document &#x3D; &quot;hello: 25&quot;;    Map map &#x3D; (Map) yaml.load(document);    assertEquals(&quot;&#123;hello&#x3D;25&#125;&quot;, map.toString());    assertEquals(new Long(25), map.get(&quot;hello&quot;));&#125;public void testLoadFromStream() throws FileNotFoundException &#123;    InputStream input &#x3D; new FileInputStream(new File(&quot;src&#x2F;test&#x2F;resources&#x2F;reader&#x2F;utf-8.txt&quot;));    Yaml yaml &#x3D; new Yaml();    Object data &#x3D; yaml.load(input);    assertEquals(&quot;test&quot;, data);    &#x2F;&#x2F;    data &#x3D; yaml.load(new ByteArrayInputStream(&quot;test2&quot;.getBytes()));    assertEquals(&quot;test2&quot;, data);&#125;</code></pre></div></figure><p>如果字符串或流包含多个文档，则可以使用<code>yaml.loadAll()</code>方法将它们全部加载。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---Time: 2001-11-23 15:01:42 -5User: edWarning:  This is an error message  for the log file---Time: 2001-11-23 15:02:31 -5User: edWarning:  A slightly different error  message.---Date: 2001-11-23 15:03:17 -5User: edFatal:  Unknown variable &quot;bar&quot;Stack:  - file: TopClass.py    line: 23    code: |      x &#x3D; MoreObject(&quot;345\n&quot;)  - file: MoreClass.py    line: 58    code: |-      foo &#x3D; bar</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testLoadManyDocuments() throws FileNotFoundException &#123;    InputStream input &#x3D; new FileInputStream(new File(            &quot;src&#x2F;test&#x2F;resources&#x2F;specification&#x2F;example2_28.yaml&quot;));    Yaml yaml &#x3D; new Yaml();    int counter &#x3D; 0;    for (Object data : yaml.loadAll(input)) &#123;        System.out.println(data);        counter++;    &#125;    assertEquals(3, counter);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;Time&#x3D;Fri Nov 23 21:01:42 CET 2001, User&#x3D;ed, Warning&#x3D;This is an error message for the log file&#125;&#123;Time&#x3D;Fri Nov 23 21:02:31 CET 2001, User&#x3D;ed, Warning&#x3D;A slightly different error message.&#125;&#123;Date&#x3D;Fri Nov 23 21:03:17 CET 2001, User&#x3D;ed, Fatal&#x3D;Unknown variable &quot;bar&quot;, Stack&#x3D;[&#123;file&#x3D;TopClass.py, line&#x3D;23, code&#x3D;x &#x3D; MoreObject(&quot;345\n&quot;)&#125;, &#123;file&#x3D;MoreClass.py, line&#x3D;58, code&#x3D;foo &#x3D; bar&#125;]&#125;</code></pre></div></figure><p>仅在调用迭代器时才对文档进行解析（懒加载）。</p><p>SnakeYAML允许您构造任何类型的Java对象。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">none: [~, null]bool: [true, false, on, off]int: 42float: 3.14159list: [LITE, RES_ACID, SUS_DEXT]map: &#123;hp: 13, sp: 5&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testLoad() throws IOException &#123;    String doc &#x3D; Util.getLocalResource(&quot;examples&#x2F;any-object-example.yaml&quot;);    Yaml yaml &#x3D; new Yaml();    Map&lt;String, Object&gt; object &#x3D; (Map&lt;String, Object&gt;) yaml.load(doc);    System.out.println(object);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;none&#x3D;[null, null], bool&#x3D;[true, false, true, false], int&#x3D;42, float&#x3D;3.14159, list&#x3D;[LITE, RES_ACID, SUS_DEXT], map&#x3D;&#123;hp&#x3D;13, sp&#x3D;5&#125;&#125;</code></pre></div></figure><p>甚至可以构造自定义Java类的实例。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * create JavaBean *&#x2F;public void testGetBeanAssumeClass() &#123;    String data &#x3D; &quot;--- !org.yaml.snakeyaml.constructor.Person\nfirstName: Andrey\nage: 99&quot;;    Object obj &#x3D; construct(data);    assertNotNull(obj);    assertTrue(&quot;Unexpected: &quot; + obj.getClass().toString(), obj instanceof Person);    Person person &#x3D; (Person) obj;    assertEquals(&quot;Andrey&quot;, person.getFirstName());    assertNull(person.getLastName());    assertEquals(99, person.getAge().intValue());&#125;&#x2F;** * create instance using constructor arguments *&#x2F;public void testGetConstructorBean() &#123;    String data &#x3D; &quot;--- !org.yaml.snakeyaml.constructor.Person [ Andrey, Somov, 99 ]&quot;;    Object obj &#x3D; construct(data);    assertNotNull(obj);    assertTrue(obj.getClass().toString(), obj instanceof Person);    Person person &#x3D; (Person) obj;    assertEquals(&quot;Andrey&quot;, person.getFirstName());    assertEquals(&quot;Somov&quot;, person.getLastName());    assertEquals(99, person.getAge().intValue());&#125;&#x2F;** * create instance using scalar argument *&#x2F;public void testGetConstructorFromScalar() &#123;    String data &#x3D; &quot;--- !org.yaml.snakeyaml.constructor.Person &#39;Somov&#39;&quot;;    Object obj &#x3D; construct(data);    assertNotNull(obj);    assertTrue(obj.getClass().toString(), obj instanceof Person);    Person person &#x3D; (Person) obj;    assertNull(&quot;Andrey&quot;, person.getFirstName());    assertEquals(&quot;Somov&quot;, person.getLastName());    assertNull(person.getAge());&#125;</code></pre></div></figure><p>注意：如果要将对象限制为标准Java对象（如List或Long），则需要使用SafeConstructor。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Yaml yaml &#x3D; new Yaml(new SafeConstructor());</code></pre></div></figure><h4 id="提供顶级类型"><a href="#提供顶级类型" class="headerlink" title="提供顶级类型"></a>提供顶级类型</h4><p>它可以加载没有任何显式标签的YAML文档。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">invoice: 34843date: 2001-01-23billTo: &amp;id001    given  : Chris    family : Dumars    address:        lines: |            458 Walkman Dr.            Suite #292        city    : Royal Oak        state   : MI        postal  : 48046shipTo: *id001product:    - sku         : BL394D      quantity    : 4      description : Basketball      price       : 450.00    - sku         : BL4438H      quantity    : 1      description : Super Hoop      price       : 2392.00tax  : 251.42total: 4443.52comments:    Late afternoon is best.    Backup contact is Nancy    Billsmer @ 338-4338.</code></pre></div></figure><p>在“Invoice”，“Person”，“,Address”，“Product”实例中，必须提供对象层次结构中的顶级类：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Yaml yaml &#x3D; new Yaml(new Constructor(Invoice.class));</code></pre></div></figure><p>SnakeYAML使用Reflection API查找发票上所有属性（设置程序和公共字段）的类。不幸的是，您无法在运行时对<strong>类型安全集合</strong>进行删除操作。<code>&lt;&gt;</code>之间的类信息仅在编译时可用。</p><h4 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h4><p>当未明确定义标量节点的标签时，SnakeYAML会尝试检测将正则表达式应用于标量节点内容的类型。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1.0 -&gt; Float42 -&gt; Integer2009-03-30 -&gt; Date</code></pre></div></figure><h4 id="类型安全集合"><a href="#类型安全集合" class="headerlink" title="类型安全集合"></a>类型安全集合</h4><p>当类型安全（通用）集合是JavaBean的属性时，SnakeYAML会动态检测所需的类。</p><p>如果泛型类型是抽象类（接口），则它将不起作用。</p><p>您必须在YAML中放置一个显式标签或提供显式<code>TypeDescription</code>。 <code>TypeDescription</code>的目标是收集更多信息并在加载&#x2F;转储时使用它。</p><p>假设文档为如下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">plate: 12-XP-F4wheels:- &#123;id: 1&#125;- &#123;id: 2&#125;- &#123;id: 3&#125;- &#123;id: 4&#125;- &#123;id: 5&#125;</code></pre></div></figure><p>现在我们想加载这个类型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Car &#123;    private String plate;    private List&lt;Wheel&gt; wheels;    public String getPlate() &#123;        return plate;    &#125;    public void setPlate(String plate) &#123;        this.plate &#x3D; plate;    &#125;    public List&lt;Wheel&gt; getWheels() &#123;        return wheels;    &#125;    public void setWheels(List&lt;Wheel&gt; wheels) &#123;        this.wheels &#x3D; wheels;    &#125;&#125;</code></pre></div></figure><p>其中“wheels”属性是<code>List&lt;Wheel&gt;</code>。为了加载<code>Car</code>(并创建<code>List&lt;Wheel&gt;</code>)，您必须提供<code>TypeDescription</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Constructor constructor &#x3D; new Constructor(Car.class);&#x2F;&#x2F;Car.class is rootTypeDescription carDescription &#x3D; new TypeDescription(Car.class);carDescription.putListPropertyType(&quot;wheels&quot;, Wheel.class);constructor.addTypeDescription(carDescription);Yaml yaml &#x3D; new Yaml(constructor);</code></pre></div></figure><p>这种方式也适用于<code>Map</code>。注意，<code>Map</code>的key和value都可以是任意类型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">plate: 00-FF-Q2wheels:  ? &#123;brand: Pirelli, id: 1&#125;  : 2008-01-16  ? &#123;brand: Dunkel, id: 2&#125;  : 2002-12-24  ? &#123;brand: Pirelli, id: 3&#125;  : 2008-01-16  ? &#123;brand: Pirelli, id: 4&#125;  : 2008-01-16  ? &#123;brand: Pirelli, id: 5&#125;  : 2008-01-16</code></pre></div></figure><p>以下是要加载的类：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyCar &#123;    private String plate;    private Map&lt;MyWheel, Date&gt; wheels;    public String getPlate() &#123;        return plate;    &#125;    public void setPlate(String plate) &#123;        this.plate &#x3D; plate;    &#125;    public Map&lt;MyWheel, Date&gt; getWheels() &#123;        return wheels;    &#125;    public void setWheels(Map&lt;MyWheel, Date&gt; wheels) &#123;        this.wheels &#x3D; wheels;    &#125;&#125;</code></pre></div></figure><p>主要代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Constructor constructor &#x3D; new Constructor(MyCar.class);TypeDescription carDescription &#x3D; new TypeDescription(MyCar.class);carDescription.putMapPropertyType(&quot;wheels&quot;, MyWheel.class, Object.class);constructor.addTypeDescription(carDescription);Yaml yaml &#x3D; new Yaml(constructor);MyCar car &#x3D; (MyCar) yaml.load(&lt;文件流&gt;);</code></pre></div></figure><h3 id="转储YAML"><a href="#转储YAML" class="headerlink" title="转储YAML"></a>转储YAML</h3><p><code>Yaml.dump(Object data)</code>方法接受一个Java对象并生成一个YAML文档。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDump() &#123;    Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;String, Object&gt;();    data.put(&quot;name&quot;, &quot;Silenthand Olleander&quot;);    data.put(&quot;race&quot;, &quot;Human&quot;);    data.put(&quot;traits&quot;, new String[] &#123; &quot;ONE_HAND&quot;, &quot;ONE_EYE&quot; &#125;);    Yaml yaml &#x3D; new Yaml();    String output &#x3D; yaml.dump(data);    System.out.println(output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">name: Silenthand Olleandertraits: [ONE_HAND, ONE_EYE]race: Human</code></pre></div></figure><p><code>Yaml.dump(Object data, Writer output)</code>会将生成的YAML文档写入指定的文件&#x2F;流。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumpWriter() &#123;    Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;String, Object&gt;();    data.put(&quot;name&quot;, &quot;Silenthand Olleander&quot;);    data.put(&quot;race&quot;, &quot;Human&quot;);    data.put(&quot;traits&quot;, new String[] &#123; &quot;ONE_HAND&quot;, &quot;ONE_EYE&quot; &#125;);    Yaml yaml &#x3D; new Yaml();    StringWriter writer &#x3D; new StringWriter();    yaml.dump(data, writer);    System.out.println(writer.toString());&#125;</code></pre></div></figure><p>如果需要将多个YAML文档转储在同一个文件&#x2F;流中，请使用<code>yaml.dumpAll(Iterator&lt;Object&gt; data)</code>方法。它接受要序列化为YAML文档的Java对象的迭代器。也可以使用Writer。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumpMany() &#123;    List&lt;Integer&gt; docs &#x3D; new LinkedList&lt;Integer&gt;();    for (int i &#x3D; 1; i &lt; 4; i++) &#123;        docs.add(i);    &#125;    DumperOptions options &#x3D; new DumperOptions();    options.explicitStart(true);    Yaml yaml &#x3D; new Yaml(options);    System.out.println(yaml.dump(docs));    System.out.println(yaml.dumpAll(docs.iterator()));&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">--- [1, 2, 3]--- 1--- 2--- 3</code></pre></div></figure><p>您也可以转储JavaBean。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumpCustomJavaClass() &#123;    Hero hero &#x3D; new Hero(&quot;Galain Ysseleg&quot;, -3, 2);    Yaml yaml &#x3D; new Yaml();    String output &#x3D; yaml.dump(hero);    System.out.println(output);    assertEquals(&quot;!!examples.Hero &#123;hp: -3, name: Galain Ysseleg, sp: 2&#125;\n&quot;, output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">!!examples.Hero &#123;hp: -3, name: Galain Ysseleg, sp: 2&#125;</code></pre></div></figure><p>如你所见，JavaBean的属性按字母顺序排列。</p><p><code>DumperOptions</code>指定转储的格式信息。例如，您可以设置优先级和宽度，使用规范的YAML格式或者对常量和集合强制使用首选样式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumperOptions() &#123;    List&lt;Integer&gt; data &#x3D; new LinkedList&lt;Integer&gt;();    for (int i &#x3D; 0; i &lt; 50; i++) &#123;        data.add(i);    &#125;    Yaml yaml &#x3D; new Yaml();    String output &#x3D; yaml.dump(data);    System.out.println(output);    &#x2F;&#x2F;    DumperOptions options &#x3D; new DumperOptions();    options.setWidth(50);    options.setIndent(4);    yaml &#x3D; new Yaml(options);    output &#x3D; yaml.dump(data);    System.out.println(output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,  23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,  43, 44, 45, 46, 47, 48, 49][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,    28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,    40, 41, 42, 43, 44, 45, 46, 47, 48, 49]</code></pre></div></figure><p>规范格式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumperOptionsCanonical() &#123;    List&lt;Integer&gt; data &#x3D; new LinkedList&lt;Integer&gt;();    for (int i &#x3D; 0; i &lt; 5; i++) &#123;        data.add(i);    &#125;    DumperOptions options &#x3D; new DumperOptions();    options.setCanonical(true);    Yaml yaml &#x3D; new Yaml(options);    String output &#x3D; yaml.dump(data);    System.out.println(output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---!!seq [  !!int &quot;0&quot;,  !!int &quot;1&quot;,  !!int &quot;2&quot;,  !!int &quot;3&quot;,  !!int &quot;4&quot;,]</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumperOptionsFlowStyle() &#123;    List&lt;Integer&gt; data &#x3D; new LinkedList&lt;Integer&gt;();    for (int i &#x3D; 0; i &lt; 5; i++) &#123;        data.add(i);    &#125;    DumperOptions options &#x3D; new DumperOptions();    options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);    Yaml yaml &#x3D; new Yaml(options);    String output &#x3D; yaml.dump(data);    System.out.println(output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">- 0- 1- 2- 3- 4</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testDumperOptionsStyle() &#123;    List&lt;Integer&gt; data &#x3D; new LinkedList&lt;Integer&gt;();    for (int i &#x3D; 0; i &lt; 5; i++) &#123;        data.add(i);    &#125;    DumperOptions options &#x3D; new DumperOptions();    options.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);    Yaml yaml &#x3D; new Yaml(options);    String output &#x3D; yaml.dump(data);    System.out.println(output);&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">- !!int &quot;0&quot;- !!int &quot;1&quot;- !!int &quot;2&quot;- !!int &quot;3&quot;- !!int &quot;4&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>snakeyaml</tag>
      
      <tag>yaml</tag>
      
      <tag>yml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongodb.zip版环境搭建</title>
    <link href="/doc/72ae87ce.html"/>
    <url>/doc/72ae87ce.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去官方下载mongodb.zip文件。<br>下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将下载好的zip文件进行解压，这里我的解压环境为<code>D:\Program\</code><br>文件夹名称为<code>mongodb-win32-x86_64-windows-4.4.4</code>。<br>以下是目录结构：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mongodb-win32-x86_64-windows-4.4.4│  LICENSE-Community.txt│  mongo.conf #自定义新增项│  MPL-2│  README│  THIRD-PARTY-NOTICES│├─bin│      Install-Compass.ps1│      mongo.exe│      mongo.pdb│      mongod.exe│      mongod.pdb│      mongos.exe│      mongos.pdb│├─data #自定义新增项│  │  collection-0--4706583398678029279.wt│  │  collection-0-8934722653277117748.wt│  │  collection-2-8934722653277117748.wt│  │  collection-4-8934722653277117748.wt│  │  index-1--4706583398678029279.wt│  │  index-1-8934722653277117748.wt│  │  index-2--4706583398678029279.wt│  │  index-3-8934722653277117748.wt│  │  index-5-8934722653277117748.wt│  │  index-6-8934722653277117748.wt│  │  mongod.lock│  │  sizeStorer.wt│  │  storage.bson│  │  WiredTiger│  │  WiredTiger.lock│  │  WiredTiger.turtle│  │  WiredTiger.wt│  │  WiredTigerHS.wt│  │  _mdb_catalog.wt│  ││  ├─diagnostic.data│  │      metrics.2021-04-02T06-00-55Z-00000│  │      metrics.2021-04-02T06-01-57Z-00000│  │      metrics.2021-04-02T06-13-57Z-00000│  │      metrics.interim│  ││  └─journal│          WiredTigerLog.0000000003│          WiredTigerPreplog.0000000001│          WiredTigerPreplog.0000000002│└─logs #自定义新增项        mongo.log  </code></pre></div></figure><p>默认解压后没有其他文件夹只存在<code>bin</code>文件夹，需要手动创建<code>data</code>和<code>logs</code>文件夹。</p><p>创建好后再创建一个叫<code>mongo.conf</code>的文件，并在里面增加如下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">dbpath&#x3D;D:\Program\mongodb-win32-x86_64-windows-4.4.4\data #数据库路径  logpath&#x3D;D:\Program\mongodb-win32-x86_64-windows-4.4.4\logs\mongo.log  #日志输出文件路径  logappend&#x3D;true #错误日志采用追加模式  journal&#x3D;true #启用日志文件，默认启用  quiet&#x3D;true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false  port&#x3D;27017 #端口号 默认为27017#auth&#x3D;true #启用密码登录-修改这里serviceName&#x3D;mongodb4.4.4 #windows服务名</code></pre></div></figure><p><strong>注意</strong>：这里的路径需要与自己设置的路径相匹配。<br>这一步完成后，就已经可以运行服务器了。<br>初次安装没有用户密码，所以这里不需要启动<code>auth</code>配置项。</p><p>运行<code>mongod --config &quot;D:\Program\mongodb-win32-x86_64-windows-4.4.4\mongo.conf&quot;</code>命令，关联配置文件。</p><p>之后就可以通过<code>mongod</code>启动服务器了。</p><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>利用上述方式启动服务器后，运行<code>mongo</code>命令，进行匿名登录。</p><p>运行<code>use admin</code>,使用系统数据库。</p><p>然后运行<code>db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;root&quot;]&#125;)</code>创建用户。</p><p>现在停止运行mongodb服务器，修改配置文件。将<code>auth</code>配置项开启。</p><h2 id="windows服务安装"><a href="#windows服务安装" class="headerlink" title="windows服务安装"></a>windows服务安装</h2><p>运行<code>mongod --config D:\Program\mongodb-win32-x86_64-windows-4.4.4\mongo.conf --install</code>为windows安装服务。</p><p>之后就可通过<code>net</code>命令来启动服务器了。</p><p>删除则使用<code>mongod --config D:\Program\mongodb-win32-x86_64-windows-4.4.4\mongo.conf --remove</code>删除即可。</p>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea测试篇http工具的使用</title>
    <link href="/doc/b1e46e75.html"/>
    <url>/doc/b1e46e75.html</url>
    
    <content type="html"><![CDATA[<h2 id="Idea-Http-Test-Util介绍"><a href="#Idea-Http-Test-Util介绍" class="headerlink" title="Idea-Http-Test-Util介绍"></a>Idea-Http-Test-Util介绍</h2><p>在intellij idea2017.3版本中，增加了一个类VS Code的Rest-client的工具，通过这个工具我们可以完成绝大部分http请求，是一个不错的post-man替代工具，接下来详细讲讲它如何简化你的操作。</p><h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><p>所有HTTP请求需要在后缀为.http的文件中进行，新建一个test.http文件。基本格式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">请求类型(如：GET， POST，PUT) +  请求地址(http:\\www.baidu.com)请求头...请求体</code></pre></div></figure><p>写完以后，点击左侧三角符号，即可完成测试。</p><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">#### 一般GET请求GET http:&#x2F;&#x2F;www.baidu.com?hi&#x3D;helloAccept: application&#x2F;json### 带状态的GET请求GET http:&#x2F;&#x2F;127.0.0.1:9085&#x2F;api&#x2F;item&#x2F;listCookie: JessionId&#x3D;TG4OKFVOZP6A9ML4Authorization: Bearer TG4OKFVOZP6A9ML4</code></pre></div></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">### 带body体的POST请求POST http:&#x2F;&#x2F;127.0.0.1:9085&#x2F;loginContent-Type: application&#x2F;json&#123;  &quot;username&quot;:&quot;zhangsan&quot;,  &quot;password&quot;:&quot;123456&quot;&#125;### 模仿form表单POST请求POST http:&#x2F;&#x2F;127.0.0.1:9085&#x2F;loginContent-Type: application&#x2F;x-www-form-urlencodedusername&#x3D;zhangsan&amp;password&#x3D;123### POST请求上传多类型POST http:&#x2F;&#x2F;127.0.0.1:9085&#x2F;uploadContent-Type: multipart&#x2F;form-data; boundary&#x3D;WebAppBoundary### text域--WebAppBoundaryContent-Disposition: form-data; name&#x3D;&quot;element-name&quot;Content-Type: text&#x2F;plainusername&#x3D;zhangsan### json文件域--WebAppBoundaryContent-Disposition: form-data; name&#x3D;&quot;data&quot;; filename&#x3D;&quot;data.json&quot;Content-Type: application&#x2F;json&lt; .&#x2F;data.json</code></pre></div></figure><h2 id="快捷键介绍"><a href="#快捷键介绍" class="headerlink" title="快捷键介绍"></a>快捷键介绍</h2><p>同样有内置快捷键帮你简化这些操作，内置的快捷键需要版本2018 +，2017.3版本的同样也可以在live templates设置中手写快捷键，下面简单说下这几个快捷键。</p><ul><li><code>gtr</code>:创建一个普通的<code>GET</code>请求，通过<code>tab键</code>一步一步填写即可。<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">GET http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;itemAccept: application&#x2F;json###</code></pre></div></figure></li><li><code>gtrp</code>:功能与<code>gtr</code>一致，在此基础上增加了一个参数的位置。<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">GET http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;item?id&#x3D;99Accept: application&#x2F;json###</code></pre></div></figure></li><li><code>ptr</code>:创建一个普通的<code>POST</code>请求，内置地址、请求头、json体。<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">POST http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;itemContent-Type: application&#x2F;json&#123;&#125;###</code></pre></div></figure></li><li><code>ptrp</code>:与<code>ptr</code>基本一致，唯一不同的就是json体，这里使用了键值对参数。<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">POST http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;itemContent-Type: application&#x2F;x-www-form-urlencodedid&#x3D;99&amp;content&#x3D;new-element</code></pre></div></figure></li><li><code>mptr</code>:多类型<code>POST</code>请求，内置地址、请求头、一种请求体类型（form-data）<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">POST http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;itemContent-Type: multipart&#x2F;form-data; boundary&#x3D;WebAppBoundary--WebAppBoundaryContent-Disposition: form-data; name&#x3D;&quot;field-name&quot;field-value--WebAppBoundary--###</code></pre></div></figure></li><li><code>fptr</code>:文件上传<code>POST</code>请求，样式与<code>mptr</code>基本一致，将请求类型换成了文件<figure><div class="code-wrapper"><pre class="line-numbers language-http" data-language="http"><div class="caption"><span>request</span></div><code class="language-http">POST http:&#x2F;&#x2F;localhost:80&#x2F;api&#x2F;itemContent-Type: multipart&#x2F;form-data; boundary&#x3D;WebAppBoundary--WebAppBoundaryContent-Disposition: form-data; name&#x3D;&quot;field-name&quot; filename&#x3D;&quot;file.txt&quot;&lt; .&#x2F;relative&#x2F;path&#x2F;to&#x2F;local_file.txt--WebAppBoundary--###</code></pre></div></figure></li></ul><h2 id="变量机制"><a href="#变量机制" class="headerlink" title="变量机制"></a>变量机制</h2><p>这项功能能帮你省很多力气，比如现在你已经完成了很多测试接口的书写，在测试环境需要切换所有写好的接口测试地址的域名，这个时候变量就能帮你把这些相同的东西抽离出来，方便代码修改。</p><p>变量文件存放的文件名字为：<code>http-client.env.json</code>，隐私变量可以存放到<code>http-client.private.env.json</code>文件中，变量文件名为固定这两个，变量重复时以隐私变量为准。</p><p>变量的定义格式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;product&quot;: &#123;    &quot;host&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8675&quot;  &#125;,  &quot;test&quot;: &#123;    &quot;host&quot;: &quot;http:&#x2F;&#x2F;192.168.28.90:9023&quot;  &#125;&#125;</code></pre></div></figure><p>在使用时可以用<code>&#123;&#123;var&#125;&#125;</code>引用即可。</p>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装telnet服务</title>
    <link href="/doc/b91941fa.html"/>
    <url>/doc/b91941fa.html</url>
    
    <content type="html"><![CDATA[<p>这个东西吧，其实习惯使用了Ubuntu以后，非常简单！</p><p>第一步，更新源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo apt-get update</code></pre></div></figure><p>第二步，安装服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo apt-get install xinetd telnetd</code></pre></div></figure><p>第三步，重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo &#x2F;etc&#x2F;init.d&#x2F;xinetd restart</code></pre></div></figure><p>第四步，测试服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">netstat -a | grep telnet</code></pre></div></figure><p>第五步，开始链接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">telnet ip地址</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>telnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装SVN</title>
    <link href="/doc/f7bfd3d5.html"/>
    <url>/doc/f7bfd3d5.html</url>
    
    <content type="html"><![CDATA[<h2 id="检查是否已经安装SVN"><a href="#检查是否已经安装SVN" class="headerlink" title="检查是否已经安装SVN"></a>检查是否已经安装SVN</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">svn help</code></pre></div></figure><p>若有帮助命令输出，则已安装了SVN服务器，若输出<code>bash: svn: command not found</code>则未安装SVN。</p><h3 id="卸载SVN"><a href="#卸载SVN" class="headerlink" title="卸载SVN"></a>卸载SVN</h3><p>已经安装了SVN就无法继续安装了，这里提供卸载指令。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo apt-get remove --purge subversion</code></pre></div></figure><h2 id="安装SVN"><a href="#安装SVN" class="headerlink" title="安装SVN"></a>安装SVN</h2><p>安装前先更新apt</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo apt-get update</code></pre></div></figure><p>更新较慢的朋友，可以参考如何为apt换源，这里不再赘述。</p><p>接下来进行安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo apt-get install subversion</code></pre></div></figure><h2 id="创建SVN版本库"><a href="#创建SVN版本库" class="headerlink" title="创建SVN版本库"></a>创建SVN版本库</h2><p>位置可以自己选，这里目录为<code>/home/svn/repository</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo mkdir -p &#x2F;home&#x2F;svn&#x2F;repository</code></pre></div></figure><p>更改<code>/home/svn/repository</code>的权限</p><p>注：这里不修改会导致客户端无法访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo chmod -R 777 &#x2F;home&#x2F;svn&#x2F;repository</code></pre></div></figure><p>之后就可以创建版本库了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo svnadmin create &#x2F;home&#x2F;svn&#x2F;repository</code></pre></div></figure><p>创建完成后会生成若干文件和文件夹，这里需要对<code>db</code>文件进行权限设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo chmod -R 777 db</code></pre></div></figure><p>这里需要对conf文件夹下的文件进行修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">vim &#x2F;home&#x2F;svn&#x2F;repository&#x2F;conf&#x2F;svnserve.conf</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-editorconfig" data-language="editorconfig"><code class="language-editorconfig">#匿名用户可读anon-access &#x3D; read（可改成none，即不可读）#权限用户可写auth-access &#x3D; write#密码文件为passwdpassword-db &#x3D; passwd#权限文件为authzauthz-db &#x3D; authz</code></pre></div></figure><p>然后添加访问用户<code>conf/passwd</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo vim &#x2F;home&#x2F;svn&#x2F;repository&#x2F;conf&#x2F;passwd</code></pre></div></figure><p>很好理解，不用解释了</p><p>然后再设置用户权限<code>conf/authz</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">sudo vim &#x2F;home&#x2F;svn&#x2F;repository&#x2F;conf&#x2F;authz</code></pre></div></figure><p>在[groups]里设置用户角色</p><figure><div class="code-wrapper"><pre class="line-numbers language-editorconfig" data-language="editorconfig"><code class="language-editorconfig">admin &#x3D; smwang &#x2F;&#x2F;用户smwang属于admin权限组@admin &#x3D; rw &#x2F;&#x2F;admin权限组的权限是读和写* &#x3D; rw 所有的组都具有读权限和写权限</code></pre></div></figure><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>现在就可以启动服务器了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">svnserve -d -r &#x2F;home&#x2F;svn</code></pre></div></figure><p>可用如下命令查看是否已经启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">ps -aux | grep svnserve</code></pre></div></figure><p>如需停止服务器请使用以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">killall svnserve</code></pre></div></figure><p>以上就是SVN服务器的安装过程里，完结撒花*★,°*:.☆(￣▽￣)&#x2F;$:*.°★* 。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVN服务器小记</title>
    <link href="/doc/102feb90.html"/>
    <url>/doc/102feb90.html</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-下重新启动SVN服务器"><a href="#Linux-下重新启动SVN服务器" class="headerlink" title="Linux 下重新启动SVN服务器"></a>Linux 下重新启动SVN服务器</h2><p>公司SVN服务器，老是挂，这里记录一下，遇到SVN服务器无法访问该如何操作。</p><ol><li>查询svn服务器进程是否存在</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">ps -aux|grep svnserve</code></pre></div></figure><p>若服务器已经启动，则需要终止服务进程，否则无法重新启动。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">kill -9 [PID]</code></pre></div></figure><ol start="2"><li>启动SVN服务器</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">svnserve -d -r &#x2F;usr&#x2F;svn </code></pre></div></figure><p><strong>解释：</strong></p><ul><li>-d 表示守护进程</li><li>-r 表示在后台执行</li><li>&#x2F;usr&#x2F;svn 为所在路径</li></ul><p><strong>指定其他端口号启动服务器</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">svnserve -d -r &#x2F;usr&#x2F;svn –listen-port 3391</code></pre></div></figure><h2 id="自动重启SVN"><a href="#自动重启SVN" class="headerlink" title="自动重启SVN"></a>自动重启SVN</h2><ol><li>创建执行脚本svn.sh（&#x2F;root路径下，随便哪个路径），其内容很简单，如下：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">#!&#x2F;bin&#x2F;bashsvnserve -d --listen-port 8080 -r &#x2F;home&#x2F;svnroot&#x2F;repository（svn资源库路径）</code></pre></div></figure></li><li>添加可执行权限<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">chmod ug+x &#x2F;root&#x2F;svn.sh</code></pre></div></figure></li><li>添加自动运行<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local</code></pre></div></figure></li><li>在最后添加一行内容如下：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">&#x2F;root&#x2F;svn.sh</code></pre></div></figure></li></ol><p>完结，撒花*★,°*:.☆(￣▽￣)&#x2F;$:*.°★* 。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVN</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习Ruoyi框架源码——RepeatedlyRequestWrapper</title>
    <link href="/doc/977fcdfb.html"/>
    <url>/doc/977fcdfb.html</url>
    
    <content type="html"><![CDATA[<p>在看源码之前首先来回顾一下，装饰着模式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>装饰者模式</strong> 在不改动对象的情况下，动态地将功能附加到对象上。若要扩展功能，应该提供一个包装器，把要扩展的对象包装起来，以提供更加强大的功能。</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol><li>Component 被包装的组件，可单独使用。</li><li>Decorator 包装器，扩展包装的对象。</li></ol><img src="/doc/977fcdfb/5fa15f5a0791291e95ca19f3.png" srcset="/img/loading.gif" lazyload class=""><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>扩展一个类的功能（这个继承也可以做到）。</li><li>动态增加功能，动态撤销功能。</li></ol><h2 id="RepeatedlyRequestWrapper类"><a href="#RepeatedlyRequestWrapper类" class="headerlink" title="RepeatedlyRequestWrapper类"></a>RepeatedlyRequestWrapper类</h2><p>接下来我们正式学习<code>RepeatedlyRequestWrapper</code><br>开发javaweb的时候我们经常会获取 ServletRequest 这个对象，这个对象里面有一个方法叫 getInputStream()，他是用来获取用户提交在body里面的数据流，这个数据流一旦读取就没了。</p><img src="/doc/977fcdfb/Snipaste_2021-03-17_09-16-41.jpg" srcset="/img/loading.gif" lazyload class=""><p>如果我们在过滤器或者拦截器之类的地方直接或者间接调用了getInputStream()这个方法，那么在controller控制层就会获取不到数据。</p><p>现在假设我们有一个过滤器就是要过滤body中的数据，这该怎么处理？基于现在的 ServletRequest 的对象明显是做不了这件事的。</p><p>这时我们就可以使用 <strong>装饰者模式</strong> 动态的扩展 ServletRequest 对象，以实现我们现在的需求。</p><h3 id="扩展步骤"><a href="#扩展步骤" class="headerlink" title="扩展步骤"></a>扩展步骤</h3><ol><li>我们创建一个类 RepeatedlyRequestWrapper 继承 HttpServletRequestWrapper（HttpServletRequestWrapper 是一个实现 ServletRequest 接口的装饰者，我们也可以直接实现ServletRequest 接口，但是那样我们要实现的方法太多了）。</li></ol><img src="/doc/977fcdfb/Snipaste_2021-03-17_09-19-01.jpg" srcset="/img/loading.gif" lazyload class=""><ol start="2"><li>我们在 RepeatedlyRequestWrapper 中把结果保存下来，让getInputStream()方法去获取我们保存下来的内容，而不是去调用原始的方法，这样getInputStream()就可以一直获取到内容了。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import cn.hutool.extra.servlet.ServletUtil;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStreamReader;&#x2F;** * 构建可重复读取inputStream的request *&#x2F;public class RepeatedlyRequestWrapper extends HttpServletRequestWrapper &#123;    private final byte[] body;    RepeatedlyRequestWrapper(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        super(request);        request.setCharacterEncoding(&quot;UTF-8&quot;);        response.setCharacterEncoding(&quot;UTF-8&quot;);        body &#x3D; ServletUtil.getBodyBytes(request);    &#125;    @Override    public BufferedReader getReader() &#123;        return new BufferedReader(new InputStreamReader(getInputStream()));    &#125;    @Override    public ServletInputStream getInputStream() &#123;        ByteArrayInputStream bais &#x3D; new ByteArrayInputStream(body);        return new ServletInputStream() &#123;            @Override            public int read() &#123;                return bais.read();            &#125;            @Override            public boolean isFinished() &#123;                return false;            &#125;            @Override            public boolean isReady() &#123;                return false;            &#125;            @Override            public void setReadListener(ReadListener readListener) &#123;            &#125;        &#125;;    &#125;&#125;</code></pre></div></figure><p>现在我们只需要在需要获取 body 里面的内容的时候，创建一个 RepeatedlyRequestWrapper ，传入HttpServletRequest，然后调用调用getInputStream()就可以获取到body数据流了。</p><p>当然传入的HttpServletRequest对象必须要还存在body数据流，如果之前被获取了，再包装也不会有数据，所以我们应该在数据进来就立刻把HttpServletRequest进行包装，以确保数据能准确的包装。</p><p>这时我们定义一个权重最大的过滤器，在里面包装一下，让后面调用getInputStream()能一值获取到值。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import cn.hutool.core.util.StrUtil;import org.springframework.http.MediaType;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** * Repeatable 过滤器 *&#x2F;public class RepeatableFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        ServletRequest requestWrapper &#x3D; null;        if (request instanceof HttpServletRequest &amp;&amp; StrUtil.equalsAnyIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE, MediaType.TEXT_PLAIN_VALUE)) &#123;            requestWrapper &#x3D; new RepeatedlyRequestWrapper((HttpServletRequest) request, (HttpServletResponse) response);        &#125;        if (null &#x3D;&#x3D; requestWrapper) &#123;            chain.doFilter(request, response);        &#125; else &#123;            chain.doFilter(requestWrapper, response);        &#125;    &#125;&#125;</code></pre></div></figure><p>我们现在注册这个过滤器，把权重调到最大</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic FilterRegistrationBean&lt;RepeatableFilter&gt; someFilterRegistration() &#123;    FilterRegistrationBean&lt;RepeatableFilter&gt; registration &#x3D; new FilterRegistrationBean&lt;&gt;();    registration.setFilter(new RepeatableFilter());    registration.addUrlPatterns(&quot;&#x2F;*&quot;);    registration.setName(&quot;repeatableFilter&quot;);    &#x2F;&#x2F; 权重调到最大值    registration.setOrder(FilterRegistrationBean.LOWEST_PRECEDENCE);    return registration;&#125;</code></pre></div></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建一个测试接口，在接口中获取两次body中的内容。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;get&#x2F;body&quot;)public void testRepeatedlyRequest(HttpServletRequest request) &#123;    System.out.println(&quot;第1次：&quot; + ServletUtil.getBody(request));    System.out.println(&quot;第2次：&quot; + ServletUtil.getBody(request));&#125;</code></pre></div></figure><p>在没有注册Repeatable过滤器前：</p><img src="/doc/977fcdfb/image-20201103235828397.png" srcset="/img/loading.gif" lazyload class=""><p>在注册了Repeatable过滤器后：</p><img src="/doc/977fcdfb/image-20201104000059876.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>JavaEE</tag>
      
      <tag>Spring脚手架</tag>
      
      <tag>装饰者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK的选择</title>
    <link href="/doc/f7ea7089.html"/>
    <url>/doc/f7ea7089.html</url>
    
    <content type="html"><![CDATA[<h1 id="JDK的选取"><a href="#JDK的选取" class="headerlink" title="JDK的选取"></a>JDK的选取</h1><p>首先说一下JDK的版本变化，科普科普。</p><h2 id="JDK版本变化"><a href="#JDK版本变化" class="headerlink" title="JDK版本变化"></a>JDK版本变化</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>Java 语言源于 1991 年 Sun 公司 James Gosling 领导的的 Ork 项目，1995 年 Sun 公司正式起名为 Java，并提出“Write once, Run anywhere”的口号。</p><h3 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h3><p>开发代号为Oak（橡树），于1996年1月23发行。特点有：</p><ul><li>提供了一个解释执行的 Java 虚拟机；</li><li>Applet 能在 Mozilla 浏览器中运行。</li></ul><p>Java 的 Applet 能在 Mozilla 浏览器中运行，被看作是未来的互联网语言。</p><h3 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h3><p>于 1997年2月19日发行，新特性有：</p><ul><li>引入JDBC（Java Database Connectivity）；</li><li>支持内部类；</li><li>引入Java Bean；</li><li>引入RMI（Remote Method Invocation）；</li><li>引入反射（仅用于内省）。</li></ul><p>Java 语言的基本形态基本确定了，比如反射 (reflection), JavaBean, 接口和类的关系等等，一直到今天都保持一致。然而，Java 最初的一些目标，如在浏览器中执行 Applet，以及跨平台的图形界面 Awt 很快遭遇到负面的评价。</p><h3 id="JDK-1-2"><a href="#JDK-1-2" class="headerlink" title="JDK 1.2"></a>JDK 1.2</h3><p>开发代号为 Playground（操场），于1998年12月8日发行。新特性有：</p><ul><li>引入集合（Collection）框架；</li><li>对字符串常量做内存映射；</li><li>引入 JIT（Just In Time） 编译器；</li><li>引入对打包的 Java 文件进行数字签名；</li><li>引入控制授权访问系统资源的策略工具；</li><li>引入 JFC（Java Foundation Classes），包括 Swing 1.0、拖放和 Java 2D 类库；</li><li>引入 Java 插件；</li><li>在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；</li><li>在 Applet 中添加声音支持。</li></ul><p>Java 第一个里程碑式的版本。JIT（Just in time）编译器技术，使得语言的可迁移性和执行效率达到最优的平衡，同时 Collections 集合类设计优良，在企业应用开发中迅速得到了广泛使用。</p><p>Sun 公司把 Java 技术体系分成三个方向，分别是 J2SE（面向桌面和通用应用开发），J2EE（面向企业级应用开发），J2ME（面向移动终端开发）。这个分类影响非常久远，体现出主流语言设计者的思想：针对于不同的应用领域，在形态，API 集合等进行划分。</p><h3 id="JDK-1-3"><a href="#JDK-1-3" class="headerlink" title="JDK 1.3"></a>JDK 1.3</h3><p>开发代号为 Kestrel（红隼），于2000年5月08日发行。新特性有：</p><ul><li>引入Java Sound API；</li><li>jar 文件索引；</li><li>对 Java 的各个方面都做了大量优化和增强。</li></ul><p>J2EE 中的 Servlet 规范获得了极大的成功，伴随着互联网的兴起，和浏览器直接通过 HTTP 协议交互的 Servlet，和众多的 MVC 框架，成为 Web1.0 的网红。</p><h3 id="JDK-1-4"><a href="#JDK-1-4" class="headerlink" title="JDK 1.4"></a>JDK 1.4</h3><p>开发代号为 Merlin（隼），于2004年2月06日发行（首次在JCP下发行）。新特性有:</p><ul><li>XML 处理；</li><li>Java 打印服务；</li><li>引入 Logging API；</li><li>引入 Java Web Start；</li><li>引入 JDBC 3.0 API；</li><li>引入断言；</li><li>引入 Preferences API；</li><li>引入链式异常处理；</li><li>支持 IPv6；</li><li>支持正则表达式；</li><li>引入 Image I&#x2F;O slot machine API。</li></ul><p>Java 语言真正走向成熟，提供了非常完备的语言特性，如 NIO，正则表达式，XML 处理器等。</p><p>同年微软的.NET 框架发布，两者开始了为期十几年的暗自竞争。从语言特性上来说，.NET 后发先至，一直处于优势。但 Java 依赖良好的开发者生态，绝大多数大型软件公司的使用者众多和不断贡献，以及对 Linux 操作系统良好的支持，渐渐的在服务器端获得优势地位。</p><h3 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK 5"></a>JDK 5</h3><p>开发代号为Tiger（老虎），于2004年9月30日发行。新特性包有:</p><ul><li>引入泛型；</li><li>增强循环，可以使用迭代方式；</li><li>自动装箱与自动拆箱；</li><li>类型安全的枚举；</li><li>可变参数；</li><li>静态引入；</li><li>元数据（注解）；</li><li>引入 Instrumentation。</li></ul><p>Sun 不再采用 J2SE, J2EE 这种命名方式，而使用 Java SE 5, Java EE 5 这样的名称。</p><p>Java 5 是第二个里程碑式的版本。Java 语言语法发生很大的变化，如注解 (Annotation)，装箱 (Autoboxing)，泛型 (Generic)，枚举 (Enum)，foreach 等被加入，提供了 java.util.concurrent 并发包。</p><p>Java 5 对于 Java 语言的推动是巨大的，特别是注解的加入，使得语言定义灵活了很多，程序员可以写出更加符合领域定义的描述性程序。</p><h3 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h3><p>开发代号为 Mustang（野马），于2006年12月11日发行。新特性有：</p><ul><li>支持脚本语言；</li><li>引入 JDBC 4.0 API；</li><li>引入 Java Compiler API；</li><li>可插拔注解；</li><li>增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持；</li><li>继承 Web Services；</li><li>做了很多优化。</li></ul><p>这个语言语法改进不多，但在虚拟机内部做了大量的改进，成为一个相当成熟稳定的版本，时至今日国内的很多公司依然以 Java6 作为主要 Java 开发版本来使用。</p><p>同年 Sun 公司做出一个伟大的决定，将 Java 开源。OpenJDK 从 Sun JDK 1.7 版本分支出去，成为今天 OpenJDK 的基础。</p><h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h3><p>开发代号是 Dolphin（海豚），于2011年7月28日发行。新特性有：</p><ul><li><code>switch</code> 语句块中允许以字符串作为分支条件；</li><li>在创建泛型对象时应用类型推断；</li><li>在一个语句块中捕获多种异常；</li><li>支持动态语言；</li><li>支持 <code>try-with-resources</code>；</li><li>引入 Java NIO.2 开发包；</li><li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li><li>钻石型语法；</li><li><code>null</code> 值的自动处理。</li></ul><p>这个版本中的主要的特性是 NIO2 和 Fork&#x2F;Join 并发包，Java 虚拟机的稳定性真正做到的工业级，成为一个计算平台而服务于全世界。</p><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h3><p><a href="http://openjdk.java.net/projects/jdk8/">JDK 8</a> 于2014年3月14号发布。从 Java 8 开始开发代号已经弃用了。新特性有:</p><ul><li>Lambda 表达式</li><li>Pipelines 和 Streams</li><li>Date 和 Time API</li><li>Default 方法</li><li>Type 注解</li><li>Nashhorn JavaScript 引擎</li><li>并发计数器</li><li>Parallel 操作</li><li>移除 PermGen Error</li><li>TLS SNI</li></ul><p>第三个有里程碑意义的 Java 版本。其中最引人注目的便是 Lambda 表达式了，从此 Java 语言原生提供了函数式编程能力。Java 8 更加适应海量云计算的需要。</p><p>具体的特性包括：</p><ul><li><a href="http://openjdk.java.net/jeps/117">JEP 117</a>: 移除注解处理工具（Annotation-Processing Tool，apt）。</li><li><a href="http://openjdk.java.net/jeps/124">JEP 124</a>: 增强证书撤销检查 API。</li><li><a href="http://openjdk.java.net/jeps/130">JEP 130</a>: 实现 SHA-224 消息摘要算法。</li><li><a href="http://openjdk.java.net/jeps/131">JEP 131</a>: 在 64-bit Windows 中支持 PKCS#11。</li><li><a href="http://openjdk.java.net/jeps/112">JEP 112</a>: Charset 实现改善。</li><li><a href="http://openjdk.java.net/jeps/129">JEP 129</a>: 实现 NSA Suite B 加密算法。</li><li><a href="http://openjdk.java.net/jeps/105">JEP 105</a>: DocTree API。</li><li><a href="http://openjdk.java.net/jeps/106">JEP 106</a>: 扩展 <code>javax.tools</code> API 来支持 javadoc 的访问。</li><li><a href="http://openjdk.java.net/jeps/113">JEP 113</a>: 在 JDK 的 Kerberos 5 中添加 MS-SFU 扩展。</li><li><a href="http://openjdk.java.net/jeps/114">JEP 114</a>: TLS Server Name Indication (SNI) 扩展。</li><li><a href="http://openjdk.java.net/jeps/121">JEP 121</a>: 提供更强的 Password-Based-Encryption (PBE) 算法实现。</li><li><a href="http://openjdk.java.net/jeps/122">JEP 122</a>: 移除永久带（Permanent Generation）。</li><li><a href="http://openjdk.java.net/jeps/127">JEP 127</a>: 改善 Locale Data Packaging，并且采用 Unicode CLDR Data。</li><li><a href="http://openjdk.java.net/jeps/128">JEP 128</a>: Unicode BCP 47 本地匹配。</li><li><a href="http://openjdk.java.net/jeps/133">JEP 133</a>: 支持 Unicode 6.2。</li><li><a href="http://openjdk.java.net/jeps/136">JEP 136</a>: 增强错误验证。</li><li><a href="http://openjdk.java.net/jeps/153">JEP 153</a>: 启动 JavaFX 应用。</li><li><a href="http://openjdk.java.net/jeps/177">JEP 177</a>: 优化 <code>java.text.DecimalFormat.format</code>。</li><li><a href="http://openjdk.java.net/jeps/103">JEP 103</a>: 并行数组排序。</li><li><a href="http://openjdk.java.net/jeps/135">JEP 135</a>: Base64 编码和解码。</li><li><a href="http://openjdk.java.net/jeps/138">JEP 138</a>: 基于 Autoconf 的自动构建系统。</li><li><a href="http://openjdk.java.net/jeps/139">JEP 139</a>: 增强 javac 来提高构建速度。</li><li><a href="http://openjdk.java.net/jeps/142">JEP 142</a>: 减少对于特定域的高速缓存的争夺。</li><li><a href="http://openjdk.java.net/jeps/147">JEP 147</a>: 减少类元数据占用。</li><li><a href="http://openjdk.java.net/jeps/148">JEP 148</a>: 支持小虚拟机（不超过3M）的创建。</li><li><a href="http://openjdk.java.net/jeps/149">JEP 149</a>: 减少核心库的内存使用。</li><li><a href="http://openjdk.java.net/jeps/150">JEP 150</a>: 新的 Date 和 Time API。</li><li><a href="http://openjdk.java.net/jeps/160">JEP 160</a>: lambda 函数表达式。</li><li><a href="http://openjdk.java.net/jeps/164">JEP 164</a>: 利用 CPU 指令进行 AES 加密。</li><li><a href="http://openjdk.java.net/jeps/166">JEP 166</a>: 针对JKS、JCEKS、PKCS12秘钥存储的修改。</li><li><a href="http://openjdk.java.net/jeps/170">JEP 170</a>: JDBC 4.2。</li><li><a href="http://openjdk.java.net/jeps/172">JEP 172</a>: DocLint。</li><li><a href="http://openjdk.java.net/jeps/173">JEP 173</a>: 放弃一些很少使用的 GC 组合。</li><li><a href="http://openjdk.java.net/jeps/101">JEP 101</a>: 泛华目标类型接口。</li><li><a href="http://openjdk.java.net/jeps/104">JEP 104</a>: 在 Java 类型上加注解。</li><li><a href="http://openjdk.java.net/jeps/107">JEP 107</a>: 增加集合的批量数据操作。</li><li><a href="http://openjdk.java.net/jeps/109">JEP 109</a>: 在核心库中增加 Lambda 表达式。</li><li><a href="http://openjdk.java.net/jeps/115">JEP 115</a>: 认证加密的密码套件。</li><li><a href="http://openjdk.java.net/jeps/118">JEP 118</a>: 在运行时访问参数名称。</li><li><a href="http://openjdk.java.net/jeps/119">JEP 119</a>: 通过反射实现  <code>javax.lang.model.*</code> API。</li><li><a href="http://openjdk.java.net/jeps/120">JEP 120</a>: 重复注解。</li><li><a href="http://openjdk.java.net/jeps/123">JEP 123</a>: 可配置的安全随机数生成。</li><li><a href="http://openjdk.java.net/jeps/126">JEP 126</a>: lambda 表达式和虚拟扩展方法。</li><li><a href="http://openjdk.java.net/jeps/140">JEP 140</a>: 限制的 doPrivileged。</li><li><a href="http://openjdk.java.net/jeps/155">JEP 155</a>: 并发库更新。</li><li><a href="http://openjdk.java.net/jeps/161">JEP 161</a>: 紧凑版本。</li><li><a href="http://openjdk.java.net/jeps/162">JEP 162</a>: 为模块化做准备。</li><li><a href="http://openjdk.java.net/jeps/171">JEP 171</a>: 在 <code> sun.misc.Unsafe</code> 中增加三个内存排序相关的指令。</li><li><a href="http://openjdk.java.net/jeps/174">JEP 174</a>: Nashorn JavaScript 引擎。</li><li><a href="http://openjdk.java.net/jeps/176">JEP 176</a>: 提供调用者敏感的检测机制。</li><li><a href="http://openjdk.java.net/jeps/178">JEP 178</a>: 静态链接的 jni 库。</li><li><a href="http://openjdk.java.net/jeps/179">JEP 179</a>: JDK API 的文档的支持和稳定。</li><li><a href="http://openjdk.java.net/jeps/180">JEP 180</a>: 对于频繁冲突的 HashMap 使用平衡树。</li><li><a href="http://openjdk.java.net/jeps/184">JEP 184</a>: HTTP URL的权限。</li><li><a href="http://openjdk.java.net/jeps/">JEP 185</a>: 限制外部 XML 资源的获取。</li></ul><h3 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK 9"></a>JDK 9</h3><p><a href="http://openjdk.java.net/projects/jdk9/">JDK 9</a> 于2017年9月21日发布。新特性有：</p><ul><li>模块化 —— Jigsaw</li><li>交互式命令行 —— JShell</li><li>默认的垃圾回收器 —— G1</li><li>进程操作改进</li><li>竞争锁的性能优化</li><li>分段代码缓存</li><li>优化字符串占用空间</li></ul><p>这个版本中最引人注目的时候模块化，通过这个工作，可以构建更小的运行时环境，只需要包括Java平台中任务依赖的部分。这可以更好地适应云端的开发。</p><p>具体的特性包括：</p><ul><li><a href="http://openjdk.java.net/jeps/102">JEP 102</a>: 改善了控制和管理操作系统进程的 API。</li><li><a href="http://openjdk.java.net/jeps/110">JEP 110</a>: 定义了一个新的 Http 客户端 API，它实现了 <code>HTTP/2</code> 和 <code>WebSocket</code>，并且可以替代遗留的 <code> HttpURLConnection</code> API。该 API 将会以一个 incubator 模块的形式进行交付。</li><li><a href="http://openjdk.java.net/jeps/143">JEP 143</a>: 提高竞争 Java 对象的监视性能。</li><li><a href="http://openjdk.java.net/jeps/158">JEP 158</a>: 统一 JVM 的日志。</li><li><a href="http://openjdk.java.net/jeps/165">JEP 165</a>: 通过支持运行时管理来增加对 JVM 编译器的管理。</li><li><a href="http://openjdk.java.net/jeps/193">JEP 193</a>: 对变量处理的改进。</li><li><a href="http://openjdk.java.net/jeps/197">JEP 197</a>: 将代码缓存划分成不同的段。</li><li><a href="http://openjdk.java.net/jeps/200">JEP 200</a>: 采用 Java 平台模块化系统（Java Platform Module System，JPMS）对JDK进行模块化。</li><li><a href="http://openjdk.java.net/jeps/201">JEP 201</a>: 源代码模块化。</li><li><a href="http://openjdk.java.net/jeps/211">JEP 211</a>: 在 import 语句中 省略 <code>deprecation</code> 的警告。</li><li><a href="http://openjdk.java.net/jeps/212">JEP 212</a>: 解决 lint 和 doclint 警告。</li><li><a href="http://openjdk.java.net/jeps/213">JEP 213</a>: Project Coin 的改变</li><li><a href="http://openjdk.java.net/jeps/214">JEP 214</a>: 移除 JDK 8 中 GC 组合器的废弃说明。</li><li><a href="http://openjdk.java.net/jeps/215">JEP 215</a>: 在 javac 中实现了一个新的类型检测策略。</li><li><a href="http://openjdk.java.net/jeps/216">JEP 216</a>: 正确地处理导入声明。</li><li><a href="http://openjdk.java.net/jeps/217">JEP 217</a>: 注解流水线 2.0。</li><li><a href="http://openjdk.java.net/jeps/219">JEP 219</a>: 定义了数据传输层安全（Datagram Transport Layer Security, DTLS）API。</li><li><a href="http://openjdk.java.net/jeps/220">JEP 220</a>: 模块化运行时镜像。</li><li><a href="http://openjdk.java.net/jeps/221">JEP 221</a>: 简化 <code>Doclet</code> API。</li><li><a href="http://openjdk.java.net/jeps/222">JEP 222</a>: jshell - Java 中的交互式命令行。</li><li><a href="http://openjdk.java.net/jeps/223">JEP 223</a>: 新的版本字符串模式。</li><li><a href="http://openjdk.java.net/jeps/224">JEP 224</a>: 增强了 javadoc 工具来生成 HTML5 标记。</li><li><a href="http://openjdk.java.net/jeps/225">JEP 225</a>: 增加了 javadoc 搜索。</li><li><a href="http://openjdk.java.net/jeps/226">JEP 226</a>: UTF-8 属性文件资源的Bundle相关变化。</li><li><a href="http://openjdk.java.net/jeps/227">JEP 227</a>: Unicode 7.0。</li><li><a href="http://openjdk.java.net/jeps/228">JEP 228</a>: 增加更多可诊断的命令。</li><li><a href="http://openjdk.java.net/jeps/229">JEP 229</a>: 将默认的秘钥库从 JKS 替换为 PKCS12。</li><li><a href="http://openjdk.java.net/jeps/231">JEP 231</a>: 移除运行时 JRE 版本选择。</li><li><a href="http://openjdk.java.net/jeps/232">JEP 232</a>: 增强了安全相关应用的性能。</li><li><a href="http://openjdk.java.net/jeps/233">JEP 233</a>: 开发了一个工具来自动测试运行时编译器。</li><li><a href="http://openjdk.java.net/jeps/235">JEP 235</a>: 增加关于 javac 生成类文件属性的 测试。</li><li><a href="http://openjdk.java.net/jeps/236">JEP 236</a>: 定义了解析 API 来支持 Nashorn 的 ECMAScript 抽象语法树。</li><li><a href="http://openjdk.java.net/jeps/237">JEP 237</a>: Linux&#x2F;AArch64 端口相关。</li><li><a href="http://openjdk.java.net/jeps/238">JEP 238</a>: 多版本 JAR 文件。</li><li><a href="http://openjdk.java.net/jeps/240">JEP 240</a>: 移除 JVM 的 TI hprof 客户端。</li><li><a href="http://openjdk.java.net/jeps/241">JEP 241</a>: 移除 jhat 工具。</li><li><a href="http://openjdk.java.net/jeps/243">JEP 243</a>: 提供 Java 语言级的 JVM 编译接口。</li><li><a href="http://openjdk.java.net/jeps/244">JEP 244</a>: TLS 应用层协议协商。</li><li><a href="http://openjdk.java.net/jeps/245">JEP 245</a>: 验证 JVM 命令行标志参数。</li><li><a href="http://openjdk.java.net/jeps/246">JEP 246</a>: 利用 CPU 指令提升 GHASH 和 RSAd 的性能。</li><li><a href="http://openjdk.java.net/jeps/247">JEP 247</a>: 对老平台版本的编译支持。</li><li><a href="http://openjdk.java.net/jeps/248">JEP 248</a>: G1 作为默认的垃圾回收器。</li><li><a href="http://openjdk.java.net/jeps/249">JEP 249</a>: 基于 TLS 实现 OCSP Stapling。</li><li><a href="http://openjdk.java.net/jeps/250">JEP 250</a>: 在类数据分享（CDS）归档中存储 interned 字符串。</li><li><a href="http://openjdk.java.net/jeps/251">JEP 251</a>: 多方案镜像。</li><li><a href="http://openjdk.java.net/jeps/252">JEP 252</a>: 默认使用 CLDR Locale Data。</li><li><a href="http://openjdk.java.net/jeps/253">JEP 253</a>: 为 JavaFX UI 控制 和 CSS API 的模块化做准备。</li><li><a href="http://openjdk.java.net/jeps/254">JEP 254</a>: 采用一个空间更加高效的 String 内部表示。</li><li><a href="http://openjdk.java.net/jeps/255">JEP 255</a>: 合并 Xerces 2.11.0 中的更新。</li><li><a href="http://openjdk.java.net/jeps/256">JEP 256</a>: BeanInfo 注解调整。</li><li><a href="http://openjdk.java.net/jeps/257">JEP 257</a>: 更新 JavaFX&#x2F;Media 中 GStreamer 的版本。</li><li><a href="http://openjdk.java.net/jeps/258">JEP 258</a>: 使用 HarfBuzz 作为字体布局引擎。</li><li><a href="http://openjdk.java.net/jeps/259">JEP 259</a>: 定义了一个高效标准的 Stack-Walking API。</li><li><a href="http://openjdk.java.net/jeps/260">JEP 260</a>: 封装大部分的内部 API。</li><li><a href="http://openjdk.java.net/jeps/261">JEP 261</a>: 实现模块化系统。</li><li><a href="http://openjdk.java.net/jeps/262">JEP 262</a>: 支持 TIFF 图像 I&#x2F;O。</li><li><a href="http://openjdk.java.net/jeps/263">JEP 263</a>: 实现 Windows 和 Linux 高分辨率图像接口。</li><li><a href="http://openjdk.java.net/jeps/264">JEP 264</a>: 平台日志 API 和 服务。</li><li><a href="http://openjdk.java.net/jeps/265">JEP 265</a>: Java 2D 使用 Marlin Graphics Renderer。</li><li><a href="http://openjdk.java.net/jeps/266">JEP 266</a>: 并发相关的一些更新。</li><li><a href="http://openjdk.java.net/jeps/267">JEP 267</a>: 支持 Unicode 8.0。</li><li><a href="http://openjdk.java.net/jeps/268">JEP 268</a>: 支持 XML 目录。</li><li><a href="http://openjdk.java.net/jeps/269">JEP 269</a>: 增加一些集合类创建的工厂方法。</li><li><a href="http://openjdk.java.net/jeps/270">JEP 270</a>: 为临界区预留栈的某些区域。</li><li><a href="http://openjdk.java.net/jeps/271">JEP 271</a>: 统一 GC 日志。</li><li><a href="http://openjdk.java.net/jeps/272">JEP 272</a>: 增加特定平台的桌面特性。</li><li><a href="http://openjdk.java.net/jeps/273">JEP 273</a>: Deterministic Random Bit Generator (DRBG) 的实现。</li><li><a href="http://openjdk.java.net/jeps/274">JEP 274</a>: 增强方法处理器。</li><li><a href="http://openjdk.java.net/jeps/275">JEP 275</a>: Java 应用模块化打包。</li><li><a href="http://openjdk.java.net/jeps/276">JEP 276</a>: 语言定义对象模型的动态链接。</li><li><a href="http://openjdk.java.net/jeps/277">JEP 277</a>: 改善 Deprecation。</li><li><a href="http://openjdk.java.net/jeps/278">JEP 278</a>: 为 G1 中的巨大对象增加测试。</li><li><a href="http://openjdk.java.net/jeps/279">JEP 279</a>: 改进测试故障排除。</li><li><a href="http://openjdk.java.net/jeps/280">JEP 280</a>: 指示字符串串联。</li><li><a href="http://openjdk.java.net/jeps/281">JEP 281</a>: HotSpot C++ 单元测试框架。</li><li><a href="http://openjdk.java.net/jeps/282">JEP 282</a>: Java连接器 jlink。</li><li><a href="http://openjdk.java.net/jeps/283">JEP 283</a>: 在 Linux 上支持 GTK 3。</li><li><a href="http://openjdk.java.net/jeps/284">JEP 284</a>: 新的 HotSpot 构建系统。</li><li><a href="http://openjdk.java.net/jeps/285">JEP 285</a>: 自旋等待提示。</li><li><a href="http://openjdk.java.net/jeps/287">JEP 287</a>: 实现 SHA-3 Hash 算法。</li><li><a href="http://openjdk.java.net/jeps/288">JEP 288</a>: 禁止 SHA-1 验证。</li><li><a href="http://openjdk.java.net/jeps/289">JEP 289</a>: 废弃 Applet API。</li><li><a href="http://openjdk.java.net/jeps/290">JEP 290</a>: 过滤输入的序列化数据。</li><li><a href="http://openjdk.java.net/jeps/291">JEP 291</a>: 废弃 Concurrent Mark Sweep (CMS) 垃圾收集器。</li><li><a href="http://openjdk.java.net/jeps/292">JEP 292</a>: 在 Nashorn 中支持 ECMAScript 6 特征。</li><li><a href="http://openjdk.java.net/jeps/294">JEP 294</a>: Linux&#x2F;s390x 端口。</li><li><a href="http://openjdk.java.net/jeps/295">JEP 295</a>: 提前编译。</li><li><a href="http://openjdk.java.net/jeps/297">JEP 297</a>: 统一 arm32&#x2F;arm64 端口。</li><li><a href="http://openjdk.java.net/jeps/298">JEP 298</a>: 移除过时的例子。</li><li><a href="http://openjdk.java.net/jeps/299">JEP 299</a>: 重新组织文档。</li></ul><h3 id="JDK-10"><a href="#JDK-10" class="headerlink" title="JDK 10"></a>JDK 10</h3><p><a href="http://openjdk.java.net/projects/jdk/10/">JDK 10</a> 按计划将于2018年3月20日发布。新特性有：</p><ul><li><a href="http://openjdk.java.net/jeps/286">JEP 286</a>: 局部变量的类型推导。该特性在社区讨论了很久并做了调查，可查看 JEP 286 调查结果。</li><li><a href="http://openjdk.java.net/jeps/296">JEP 296</a>: 将 JDK 的多个代码仓库合并到一个储存库中。</li><li><a href="http://openjdk.java.net/jeps/304">JEP 304</a>: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。</li><li><a href="http://openjdk.java.net/jeps/307">JEP 307</a>: 向 G1 引入并行 Full GC。</li><li><a href="http://openjdk.java.net/jeps/310">JEP 310</a>: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中。</li><li><a href="http://openjdk.java.net/jeps/312">JEP 312</a>: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程。</li><li><a href="http://openjdk.java.net/jeps/313">JEP 313</a>: 移除 Native-Header Generation Tool (javah)</li><li><a href="http://openjdk.java.net/jeps/314">JEP 314</a>: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等。</li><li><a href="http://openjdk.java.net/jeps/316">JEP 316</a>: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆。</li><li><a href="http://openjdk.java.net/jeps/317">JEP 317</a>: 基于 Java 的 JIT 编译器（试验版本）。</li><li><a href="http://openjdk.java.net/jeps/319">JEP 319</a>: 根证书。开源 Java SE Root CA 程序中的根证书。</li><li><a href="http://openjdk.java.net/jeps/322">JEP 322</a>: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug 。</li></ul><h3 id="JDK-11"><a href="#JDK-11" class="headerlink" title="JDK 11"></a>JDK 11</h3><p><a href="http://openjdk.java.net/projects/jdk/11/">JDK 11</a> 目前出现了4个JEP，计划于 2018 年 9 月发布。</p><ul><li><a href="http://openjdk.java.net/jeps/309">JEP 309</a>: 动态类文件常量。</li><li><a href="http://openjdk.java.net/jeps/318">JEP 318</a>: 低开销垃圾收集器 Epsilon。</li><li><a href="http://openjdk.java.net/jeps/320">JEP 320</a>: 移除 Java EE 和 CORBA 模块。</li><li><a href="http://openjdk.java.net/jeps/323">JEP 323</a>: Lambda 参数的本地变量语法。</li></ul><h3 id="JDK-14-等更多版本…"><a href="#JDK-14-等更多版本…" class="headerlink" title="JDK 14 等更多版本…"></a>JDK 14 等更多版本…</h3><p>版本很多，我们根据需要去选择。一般情况下，企业集开发多数使用 JDK 1.8 版本的JDK。<br>主要原因是它经得住长期运行的考验，新版的JDK有更多不可控因素，企业经不住这样的折腾。<br>所以选择 JDK 1.8。</p><h2 id="JDK版本选择"><a href="#JDK版本选择" class="headerlink" title="JDK版本选择"></a>JDK版本选择</h2><p>现在的JAVA JDK 主要有以下版本：</p><ul><li>Oracle JDK</li><li>Open JDK</li><li>IBM IDK</li><li>Harmony JDK</li><li>HP JDK</li><li>Alibaba Dragonwell</li></ul><p>个人比较偏向于Ali，久经大型电商平台的考验，以下是官网地址：</p><p><a href="http://dragonwell-jdk.io/">http://dragonwell-jdk.io/</a></p><p>具体选择看个人。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu防火墙的注意事项</title>
    <link href="/doc/c7be4c2f.html"/>
    <url>/doc/c7be4c2f.html</url>
    
    <content type="html"><![CDATA[<h2 id="发现Ubuntu服务器被暴力连接"><a href="#发现Ubuntu服务器被暴力连接" class="headerlink" title="发现Ubuntu服务器被暴力连接"></a>发现Ubuntu服务器被暴力连接</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Dec  4 12:34:24 9238588565e3 postfix&#x2F;smtpd[4474]: warning: unknown[45.142.120.138]: SASL LOGIN authentication failed: authentication failureDec  4 12:34:24 9238588565e3 postfix&#x2F;smtpd[4469]: warning: unknown[45.142.120.138]: SASL LOGIN authentication failed: authentication failureDec  4 12:34:24 9238588565e3 postfix&#x2F;smtpd[4469]: disconnect from unknown[45.142.120.138]......</code></pre></div></figure><p>反正有很多。。。我很无奈！</p><p>为此我设置了端口禁用和ip禁用但都没效果！</p><p>通过网上查找资料发现，原来ufw的规则是从上往下匹配的，只要在这之前有一个匹配规则，就会结束向下匹配！资料如下：</p><blockquote><h2 id="Ubuntu防火墙ufw不生效的bug？"><a href="#Ubuntu防火墙ufw不生效的bug？" class="headerlink" title="Ubuntu防火墙ufw不生效的bug？"></a>Ubuntu防火墙ufw不生效的bug？</h2><p><em>作者: wingwy    发表于:2020年02月18日</em></p><p>服务器老是有ip不停尝试连接，看了下没造成大问题也没管他。今天偶然发现某个ip疯狂连接，想想还是把他封了算了。以前用Ubuntu和Debian系的iptables用起来不是很方便，现在正好是试一下新的ufw。</p><p>系统ubuntu 18.04，ufw禁止ip A.B.C.D的访问</p><p><code>ufw deny from A.B.C.D to any</code></p><p>结果监控里面A.B.C.D的ip还是在大量连接。</p><p>然后ufw status 看了下状态，规则生效了啊，甚至重新reload也没用，怎么回事呢？</p><p>上网一搜发现有类似的问题。比如 <a href="http://www.sohu.com/a/112544764_457968">http://www.sohu.com/a/112544764_457968</a></p><p>UFW(iptables)规则的匹配基于规则出现的顺序，<br>一旦匹配某个规则，检查便会停止。因此，如果某个规则允许访问TCP端口22(如使用<code>udo ufw allow 22</code>)，<br>后面另一个规则指示拦截某个IP地址(如使用 <code>ufw deny proto tcp from A.B.C.D to any port 22</code>)。<br>最终，允许访问TCP端口22的规则会被使用，而后一个拦截黑客IP地址 <code>A.B.C.D</code> 却没有被使用。<br>这都是由于规则的顺序造成的。为避免这类问题，<br>你需要编辑 <code>/etc/ufw/before.rules</code>文件，<br>在“# End required lines”之后”Block an IP Address”添加规则。</p><p>所以 <code>vi /etc/ufw/before.rules</code></p><p>查找如下所示的行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># End required lines添加规则来拦截黑客或垃圾信息传播者：# Block spammers-A ufw-before-input -s A.B.C.D -j DROP</code></pre></div></figure><p>保存并关闭文件。最后，让防火墙重新加载配置信息：</p><p><code>ufw reload</code></p><p>这样折腾一圈，果然生效了。不过不理解这ufw的设计逻辑，也许有其他需求会这样，但对于大多数简单的拦截ip等应用环境，这个逻辑更像一个bug。</p></blockquote><p>原来如此，所以为了防止此事件再次发生，这里注意先禁用IP，再禁用端口，最后开放IP和端口。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防火墙</tag>
      
      <tag>ufw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flex语法</title>
    <link href="/doc/d8763b60.html"/>
    <url>/doc/d8763b60.html</url>
    
    <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。</p><img src="/doc/d8763b60/bg2015071001.gif" srcset="/img/loading.gif" lazyload class=""><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><img src="/doc/d8763b60/bg2015071002.png" srcset="/img/loading.gif" lazyload class=""><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><img src="/doc/d8763b60/bg2015071003.jpg" srcset="/img/loading.gif" lazyload class=""><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box&#123;  display: flex;&#125;</code></pre></div></figure><p>行内元素也可以使用 Flex 布局。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box&#123;  display: inline-flex;&#125;</code></pre></div></figure><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box&#123;  display: -webkit-flex; &#x2F;* Safari *&#x2F;  display: flex;&#125;</code></pre></div></figure><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><img src="/doc/d8763b60/bg2015071004.png" srcset="/img/loading.gif" lazyload class=""><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071005.png" srcset="/img/loading.gif" lazyload class=""><p>它可能有4个值。</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><img src="/doc/d8763b60/bg2015071006.png" srcset="/img/loading.gif" lazyload class=""><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box&#123;  flex-wrap: nowrap | wrap | wrap-reverse;&#125;</code></pre></div></figure><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><img src="/doc/d8763b60/bg2015071007.png" srcset="/img/loading.gif" lazyload class=""><p>（2）<code>wrap</code>：换行，第一行在上方。</p><img src="/doc/d8763b60/bg2015071008.jpg" srcset="/img/loading.gif" lazyload class=""><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><img src="/doc/d8763b60/bg2015071009.jpg" srcset="/img/loading.gif" lazyload class=""><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre></div></figure><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  justify-content: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071010.png" srcset="/img/loading.gif" lazyload class=""><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  align-items: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071011.png" srcset="/img/loading.gif" lazyload class=""><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071012.png" srcset="/img/loading.gif" lazyload class=""><p>该属性可能取6个值。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  order: &lt;integer&gt;;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071013.png" srcset="/img/loading.gif" lazyload class=""><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  flex-grow: &lt;number&gt;; &#x2F;* default 0 *&#x2F;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071014.png" srcset="/img/loading.gif" lazyload class=""><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  flex-shrink: &lt;number&gt;; &#x2F;* default 1 *&#x2F;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071015.jpg" srcset="/img/loading.gif" lazyload class=""><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  flex-basis: &lt;length&gt; | auto; &#x2F;* default auto *&#x2F;&#125;</code></pre></div></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]&#125;</code></pre></div></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.item &#123;  align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div></figure><img src="/doc/d8763b60/bg2015071016.png" srcset="/img/loading.gif" lazyload class=""><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><blockquote><p>这里声明一下文章来源：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css</tag>
      
      <tag>Flex</tag>
      
      <tag>响应式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali v2020.0设置源与中文</title>
    <link href="/doc/21e14d01.html"/>
    <url>/doc/21e14d01.html</url>
    
    <content type="html"><![CDATA[<h2 id="设置更新源"><a href="#设置更新源" class="headerlink" title="设置更新源"></a>设置更新源</h2><p>使用<code>vim /etc/apt/sources.list</code>命令修改源列表文件。<br>这里推荐使用阿里源</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#中科大deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib #阿里云deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib #清华大学deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-freedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free #浙大deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free #东软大学deb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</code></pre></div></figure><p>添加源之后sudo 或者 在root下执行:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y </code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>script</span></div><code class="language-bash">apt-get clean          #清除缓存索引 apt-get update         #更新索引文件 apt-get upgrade        #更新实际的软件包文件 apt-get dist-upgrade   #根据依赖关系更新</code></pre></div></figure><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><p>首先，更新一波<code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</code></p><p>之后用命令<code>dpkg-reconfigure locales</code>设置为中文即可。</p><p>这里要选择<code>zh_CN.UTF_8</code></p><p><strong>注意：不要使用root账户完成设置，会出现<code>command not found</code>错误！</strong></p><p>重启后会出现乱码，再次打开终端，输入<code>apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</code>下载中文字体</p><p>再重启一边就OK了！</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kali源</tag>
      
      <tag>语言设置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mermaid流程图文档</title>
    <link href="/doc/7be41d9.html"/>
    <url>/doc/7be41d9.html</url>
    
    <content type="html"><![CDATA[<h1 id="graph-声明"><a href="#graph-声明" class="headerlink" title="graph 声明"></a>graph 声明</h1><p><code>graph</code> 关键字声明了流程图的走向。</p><p>这两种声明了图的方向是从上到下（<code>TD</code> 或 <code>TB</code>）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TDstart --&gt; stop</code></pre></div></figure><pre><code class="mermaid">graph TDstart --&gt; stop</code></pre><p>这声明了图的方向是从左到右（<code>LR</code>）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    Start --&gt; Stop</code></pre></div></figure><pre><code class="mermaid">graph LR    Start --&gt; Stop</code></pre><h2 id="流程图方向"><a href="#流程图方向" class="headerlink" title="流程图方向"></a>流程图方向</h2><p>可选的流程图方向为：</p><ul><li>TB-从上到下</li><li>TD-自顶向下与从上到下相同</li><li>BT-从下到上</li><li>RL-从右到左</li><li>LR-从左到右</li></ul><h1 id="节点和形状"><a href="#节点和形状" class="headerlink" title="节点和形状"></a>节点和形状</h1><h2 id="节点（默认）"><a href="#节点（默认）" class="headerlink" title="节点（默认）"></a>节点（默认）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id</code></pre></div></figure><blockquote><p><strong>注意</strong> 默认会将 id 做为框中的内容</p></blockquote><h3 id="带有文本的节点"><a href="#带有文本的节点" class="headerlink" title="带有文本的节点"></a>带有文本的节点</h3><p>你也可以为框中设置自定义的内容，只需使用 <code>id[Text]</code> 语法即可：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1[This is the text in the box]</code></pre></div></figure><pre><code class="mermaid">graph LR    id1[This is the text in the box]</code></pre><h2 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h2><h3 id="具有圆边的节点"><a href="#具有圆边的节点" class="headerlink" title="具有圆边的节点"></a>具有圆边的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1(This is the text in the box)</code></pre></div></figure><pre><code class="mermaid">graph LR    id1(This is the text in the box)</code></pre><h3 id="体育场形状的节点"><a href="#体育场形状的节点" class="headerlink" title="体育场形状的节点"></a>体育场形状的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1([This is the text in the box])</code></pre></div></figure><pre><code class="mermaid">graph LR    id1([This is the text in the box])</code></pre><h3 id="子例程形状的节点"><a href="#子例程形状的节点" class="headerlink" title="子例程形状的节点"></a>子例程形状的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1[[This is the text in the box]]</code></pre></div></figure><p>本网页暂时不支持此节点</p><h3 id="圆柱状的节点"><a href="#圆柱状的节点" class="headerlink" title="圆柱状的节点"></a>圆柱状的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1[(Database)]</code></pre></div></figure><pre><code class="mermaid">graph LR    id1[(Database)]</code></pre><h3 id="圆形式的节点"><a href="#圆形式的节点" class="headerlink" title="圆形式的节点"></a>圆形式的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1((This is the text in the circle))</code></pre></div></figure><pre><code class="mermaid">graph LR    id1((This is the text in the circle))</code></pre><h3 id="非对称形状的节点"><a href="#非对称形状的节点" class="headerlink" title="非对称形状的节点"></a>非对称形状的节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1&gt;This is the text in the box]</code></pre></div></figure><pre><code class="mermaid">graph LR    id1&gt;This is the text in the box]</code></pre><p>目前，只有上面的形状是用的，与它对称的图形暂不可用。<em>未来也许可行！</em></p><h3 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1&#123;This is the text in the box&#125;</code></pre></div></figure><pre><code class="mermaid">graph LR    id1&#123;This is the text in the box&#125;</code></pre><h3 id="六角形节点"><a href="#六角形节点" class="headerlink" title="六角形节点"></a>六角形节点</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1&#123;&#123;This is the text in the box&#125;&#125;</code></pre></div></figure><pre><code class="mermaid">graph LR    id1&#123;&#123;This is the text in the box&#125;&#125;</code></pre><h3 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TD    id1[\This is the text in the box\]</code></pre></div></figure><pre><code class="mermaid">graph TD    id1[\This is the text in the box\]</code></pre><h3 id="梯形"><a href="#梯形" class="headerlink" title="梯形"></a>梯形</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TD    A[&#x2F;Christmas\]</code></pre></div></figure><pre><code class="mermaid">graph TD    A[&#x2F;Christmas\]</code></pre><h3 id="梯形-alt"><a href="#梯形-alt" class="headerlink" title="梯形 alt"></a>梯形 alt</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TD    B[\Go shopping&#x2F;]</code></pre></div></figure><pre><code class="mermaid">graph TD    B[\Go shopping&#x2F;]</code></pre><h1 id="节点之间的连接线"><a href="#节点之间的连接线" class="headerlink" title="节点之间的连接线"></a>节点之间的连接线</h1><p>节点可以通过连接线连接。可以具有不同类型的连接线，也可以将文本字符串附加到连接线上。</p><h2 id="带箭头的直线"><a href="#带箭头的直线" class="headerlink" title="带箭头的直线"></a>带箭头的直线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA--&gt;B</code></pre></div></figure><pre><code class="mermaid">graph LRA--&gt;B</code></pre><h2 id="普通直线"><a href="#普通直线" class="headerlink" title="普通直线"></a>普通直线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA---B</code></pre></div></figure><pre><code class="mermaid">graph LRA---B</code></pre><h2 id="带文本的直线"><a href="#带文本的直线" class="headerlink" title="带文本的直线"></a>带文本的直线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA--This is the text---B</code></pre></div></figure><pre><code class="mermaid">graph LRA--This is the text---B</code></pre><p>或者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA---|This is a text|B</code></pre></div></figure><pre><code class="mermaid">graph LRA---|This is a text|B</code></pre><h2 id="带箭头和文本的直线"><a href="#带箭头和文本的直线" class="headerlink" title="带箭头和文本的直线"></a>带箭头和文本的直线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA--&gt;|Text|B</code></pre></div></figure><pre><code class="mermaid">graph LRA--&gt;|Text|B</code></pre><p>或者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA-- Text--&gt;B</code></pre></div></figure><pre><code class="mermaid">graph LRA-- Text--&gt;B</code></pre><h2 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA-.-B</code></pre></div></figure><pre><code class="mermaid">graph LRA-.-B</code></pre><h2 id="带文本虚线"><a href="#带文本虚线" class="headerlink" title="带文本虚线"></a>带文本虚线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA-. text.-B</code></pre></div></figure><pre><code class="mermaid">graph LRA-. text.-B</code></pre><h2 id="带箭头和文本的虚线"><a href="#带箭头和文本的虚线" class="headerlink" title="带箭头和文本的虚线"></a>带箭头和文本的虚线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA-.Text.-&gt;B</code></pre></div></figure><pre><code class="mermaid">graph LRA-.Text.-&gt;B</code></pre><h2 id="粗直线"><a href="#粗直线" class="headerlink" title="粗直线"></a>粗直线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA&#x3D;&#x3D;&gt;BB&#x3D;&#x3D;text&#x3D;&#x3D;&#x3D;CC&#x3D;&#x3D;Text&#x3D;&#x3D;&gt;D</code></pre></div></figure><pre><code class="mermaid">graph LRA&#x3D;&#x3D;&gt;BB&#x3D;&#x3D;text&#x3D;&#x3D;&#x3D;CC&#x3D;&#x3D;Text&#x3D;&#x3D;&gt;D</code></pre><h2 id="多重连线"><a href="#多重连线" class="headerlink" title="多重连线"></a>多重连线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA--Test--&gt;B--Test--&gt;C</code></pre></div></figure><pre><code class="mermaid">graph LRA--Test--&gt;B--Test--&gt;C</code></pre><p>也可以按照以下方式在同一行声明多个节点连接：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TBA--&gt;B &amp; C --&gt;Da &amp; b --&gt; c &amp; d</code></pre></div></figure><pre><code class="mermaid">graph TBA--&gt;B &amp; C --&gt;Da &amp; b --&gt; c &amp; d</code></pre><h1 id="箭头样式"><a href="#箭头样式" class="headerlink" title="箭头样式"></a>箭头样式</h1><p>当声明为 <code>flowchart</code> 而不是 <code>graph</code> 时，支持如下的新箭头：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">flowchart LRA --o BB --x Ca o--o bb x--x cc &lt;--&gt; d</code></pre></div></figure><pre><code class="mermaid">flowchart LRA --o BB --x Ca o--o bb x--x cc &lt;--&gt; d</code></pre><h1 id="连接线长度"><a href="#连接线长度" class="headerlink" title="连接线长度"></a>连接线长度</h1><p>流程图中的连接线是由 Graph 中的等级决定的，即垂直或水平级别（也就是说它取决于流程图的方向）。默认情况下，连接线可以跨越任意数量的节点的，但是您可以通过在连接线的定义中添加额外的破折号，使得该连接线比其他的连接线更长。</p><p>在下面的示例中，在节点 <em>B</em> 到节点 <em>E</em> 的连接线中添加了两个额外的破折号，因此与一般的连接线相比，其跨越的节点更多：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TD    A[Start] --&gt; B&#123;Is it?&#125;;    B --&gt;|Yes| C[OK];    C --&gt; D[Rethink];    D --&gt; B;    B -----&gt;|No| E[End];</code></pre></div></figure><p>本网页暂时不支持此特性</p><blockquote><p><strong>注意</strong>渲染引擎可能会调节连接线的长度，以适应其他的节点连接线。</p></blockquote><p>当一个文本写在连接线的中间时，必须在连接线的右侧添加多余的破折号。下面的示例与上一个示例类似：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TD    A[Start] --&gt; B&#123;Is it?&#125;;    B -- Yes --&gt; C[OK];    C --&gt; D[Rethink];    D --&gt; B;    B -- No ----&gt; E[End];</code></pre></div></figure><p>本网页暂时不支持此特性</p><p>对于点或粗链接，要添加的字符是等号或点，如下表所示：</p><table><thead><tr><th>长度</th><th align="center">1 个</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td>正常</td><td align="center"><code>---</code></td><td align="center"><code>----</code></td><td align="center"><code>-----</code></td></tr><tr><td>普通带箭头</td><td align="center"><code>--&gt;</code></td><td align="center"><code>---&gt;</code></td><td align="center"><code>----&gt;</code></td></tr><tr><td>厚</td><td align="center"><code>===</code></td><td align="center"><code>====</code></td><td align="center"><code>=====</code></td></tr><tr><td>粗箭头</td><td align="center"><code>==&gt;</code></td><td align="center"><code>===&gt;</code></td><td align="center"><code>====&gt;</code></td></tr><tr><td>点缀</td><td align="center"><code>-.-</code></td><td align="center"><code>-..-</code></td><td align="center"><code>-...-</code></td></tr><tr><td>点缀箭头</td><td align="center"><code>-.-&gt;</code></td><td align="center"><code>-..-&gt;</code></td><td align="center"><code>-...-&gt;</code></td></tr></tbody></table><h1 id="具有特殊意义的字符"><a href="#具有特殊意义的字符" class="headerlink" title="具有特殊意义的字符"></a>具有特殊意义的字符</h1><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>可以将文本放在引号中，用于呈现更麻烦的字符。如下例所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR    id1[&quot;This is the (text) in the box&quot;]</code></pre></div></figure><pre><code class="mermaid">graph LR    id1[&quot;This is the (text) in the box&quot;]</code></pre><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>可以使用此处示例的语法对字符进行转义。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR       A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;]</code></pre></div></figure><pre><code class="mermaid">graph LR       A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;]</code></pre><h1 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h1><p>以下是子图的语法定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">subgraph titlegraph definitionend</code></pre></div></figure><p>以下是示例用法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TBc1--&gt;a2subgraph onea1--&gt;a2endsubgraph twob1--&gt;b2endsubgraph threec1--&gt;c2end</code></pre></div></figure><pre><code class="mermaid">graph TBc1--&gt;a2subgraph onea1--&gt;a2endsubgraph twob1--&gt;b2endsubgraph threec1--&gt;c2end</code></pre><p>你也可以为子图设置一个明确的 id。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph TB    c1--&gt;a2    subgraph ide1 [one]    a1--&gt;a2    end</code></pre></div></figure><pre><code class="mermaid">graph TB    c1--&gt;a2    subgraph ide1 [one]    a1--&gt;a2    end</code></pre><h1 id="flowcharts-声明"><a href="#flowcharts-声明" class="headerlink" title="flowcharts 声明"></a>flowcharts 声明</h1><p>若你使用了 flowcharts 声明，则你可以使子图之间进行连接，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">flowchart TBc1--&gt;a2subgraph onea1--&gt;a2endsubgraph twob1--&gt;b2endsubgraph threec1--&gt;c2endone --&gt; twothree --&gt; twotwo --&gt; c2</code></pre></div></figure><p>本网页暂时不支持此特性</p><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>可以将 click 事件绑定到节点上，单击可能导致 javascript 回调或页面跳转，该跳转将在新的浏览器选项卡中打开。<strong>注意</strong>：使用 <code>securityLevel=&#39;strict&#39;</code> 时将禁用此功能，使用时将启用此功能 <code>securityLevel=&#39;loose&#39;</code>。</p><p><code>click nodeId callback</code></p><ul><li>nodeId 是节点 id</li><li>callback 是在显示图形的页面上定义的 JavaScript 函数的名称，该函数会将 nodeId 作为参数回调。</li></ul><p>以下是使用示例：</p><p>JavaScript：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var callback &#x3D; function(id)&#123;alert(&#39;A callback was triggered&#39;);&#125;</code></pre></div></figure><p>Mermaid：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR;    A--&gt;B;    click A callback &quot;Tooltip for a callback&quot;    click B &quot;https:&#x2F;&#x2F;blog.cikaros.top&quot; &quot;This is a tooltip for a link&quot;</code></pre></div></figure><pre><code class="mermaid">graph LR;    A--&gt;B;    click A callback &quot;Tooltip for a callback&quot;    click B &quot;https:&#x2F;&#x2F;blog.cikaros.top&quot; &quot;This is a tooltip for a link&quot;</code></pre><blockquote><p>该功能从 0.5.2 版本开始支持</p></blockquote><p>默认情况下，链接在同一浏览器选项卡&#x2F;窗口中打开。它可以通过添加链接目标的点击定义来改变这种（<code>_self</code>，<code>_blank</code>，<code>_parent</code> 和 <code>_top</code> 支持）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LR;    A--&gt;B;    B--&gt;C;    click A &quot;http:&#x2F;&#x2F;www.github.com&quot; _blank    click B &quot;http:&#x2F;&#x2F;www.github.com&quot; &quot;Open this in a new tab&quot; _blank</code></pre></div></figure><p>给初学者的提示，一个在 html 上下文中使用交互式链接的完整示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;body&gt;  &lt;div class&#x3D;&quot;mermaid&quot;&gt;    graph LR;        A--&gt;B;        click A callback &quot;Tooltip&quot;        click B &quot;http:&#x2F;&#x2F;www.github.com&quot; &quot;This is a link&quot;  &lt;&#x2F;div&gt;  &lt;script&gt;    var callback &#x3D; function()&#123;        alert(&#39;A callback was triggered&#39;);    &#125;    var config &#x3D; &#123;        startOnLoad:true,        flowchart:&#123;            useMaxWidth:true,            htmlLabels:true,            curve:&#39;cardinal&#39;,        &#125;,        securityLevel:&#39;loose&#39;,    &#125;;    mermaid.initialize(config);  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>可以在流程图中输入注释，解析器将忽略它们。注释必须自己一行，并且必须以 <code>%%</code>（双百分号）开头。注释开始到下一个换行符之后的所有文本都将被视为注释，包括任何流语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">graph LRA -- text --&gt; B&#123;node&#125;%% A -- text --&gt; B -- text2 --&gt; C</code></pre></div></figure><pre><code class="mermaid">graph LRA -- text --&gt; B&#123;node&#125;%% A -- text --&gt; B -- text2 --&gt; C</code></pre>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mermaid</tag>
      
      <tag>流程图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入学习Servlet</title>
    <link href="/doc/93a9a5ba.html"/>
    <url>/doc/93a9a5ba.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>Servlet（Servlet Applet），全称为Java Servlet，未有中文翻译。它是用Java编写的服务端程序。其主要功能在于交互式浏览和修改数据并生成动态的Web内容。狭义的Servlet是指Java语言所实现的一个接口，广义的Servlet是指任何实现了这个Sevlet接口的类，一般情况下均认为是后者。</p><p>Servlet运行与支持Java的应用服务器中，例如Tomcat。从实现上来说，Servlet可以响应任何类型的请求，但绝大多数情况用来扩展基于HTTP协议的Web服务器。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><pre><code class="mermaid">sequenceDiagramparticipant Clientparticipant Serverparticipant ServletClient-&gt;&gt;Server:Http请求Server-&gt;&gt;Servlet:启动并调用ServletServlet-&gt;&gt;Server:根据Http请求，返回生成的响应内容Server-&gt;&gt;Client:将Servlet返回的响应内容，处理并返回</code></pre><h2 id="Servlet-API简介"><a href="#Servlet-API简介" class="headerlink" title="Servlet API简介"></a>Servlet API简介</h2><p>Servlet API 包含以下4个Java Package：</p><ol><li><code>javax.servlet</code> 其中包含定义Servlet和Servlet容器之间契约的类和接口。</li><li><code>javax.servlet.http</code> 其中包含定义HTTP Servlet和Servlet容器之间的关系。</li><li><code>javax.servlet.annotation</code> 其中包含标注Servlet、Filter、Listener的注解。它还为被标注的元件定义元数据。</li><li><code>javax.servlet.descriptor</code>，其中包含提供程序化登录Web应用程序的配置信息类型。</li></ol><h2 id="Servlet的主要类型"><a href="#Servlet的主要类型" class="headerlink" title="Servlet的主要类型"></a>Servlet的主要类型</h2><pre><code class="mermaid">classDiagramclass Servlet&#123;init(ServletConfig) voidservice(ServletRequest,ServletResponse) voiddestroy() voidgetServletConfig() ServletConfig&#125;&lt;&lt;interface&gt;&gt; ServletServletConfig&lt;--Servlet : 依赖ServletConfig&lt;..Servlet : 关联class ServletConfig&#123; getInitParameter(String) StringgetParameterNames() EnumerationgetServletContext() ServletContext&#125;&lt;&lt;interface&gt;&gt; ServletConfigclass GenericServlet&lt;&lt;abstruct&gt;&gt; GenericServletServlet&lt;|..GenericServlet:实现class ServletRequest&lt;&lt;interface&gt;&gt; ServletRequestServletRequest&lt;..Servletclass ServletResponse&lt;&lt;interface&gt;&gt; ServletResponseServletResponse&lt;..Servletclass ServletContext&lt;&lt;interface&gt;&gt; ServletContextServletContext&lt;--ServletConfigclass HttpServletRequest&lt;&lt;interface&gt;&gt; HttpServletRequestServletRequest&lt;|--HttpServletRequestclass HttpServletResponse&lt;&lt;interface&gt;&gt; HttpServletResponseServletResponse&lt;|--HttpServletResponseclass HttpServletGenericServlet&lt;--HttpServlet:继承HttpServletRequest&lt;..HttpServletHttpServletResponse&lt;..HttpServlet</code></pre><h2 id="Servlet的工作原理"><a href="#Servlet的工作原理" class="headerlink" title="Servlet的工作原理"></a>Servlet的工作原理</h2><p>Servlet接口定义了Servlet与Servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用他具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。</p><p>用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p><p> ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p><p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p><h2 id="Servlet接口中定义的方法"><a href="#Servlet接口中定义的方法" class="headerlink" title="Servlet接口中定义的方法"></a>Servlet接口中定义的方法</h2><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Servlet &#123;    &#x2F;&#x2F;初始化方法    void init(ServletConfig var1) throws ServletException; &#x2F;&#x2F;获取ServletConfig对象    ServletConfig getServletConfig(); &#x2F;&#x2F;服务方法，也是业务的核心处理方法    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; &#x2F;&#x2F;获取Servlet信息    String getServletInfo(); &#x2F;&#x2F;销毁方法    void destroy();&#125;</code></pre></div></figure><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：</p><ol><li><p>init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。</p></li><li><p>service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。</p></li><li><p>destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</p></li></ol><h2 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a>ServletRequest接口</h2><p> Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。</p><p>让我们来看一看ServletRequest接口的部分内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ServletRequest &#123;     int getContentLength();&#x2F;&#x2F;返回请求主体的字节数     String getContentType();&#x2F;&#x2F;返回主体的MIME类型     String getParameter(String var1);&#x2F;&#x2F;返回请求参数的值 &#125;</code></pre></div></figure><p>其中，getParameter是在ServletRequest中最常用的方法，可用于获取查询字符串的值。</p><h2 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h2><p>javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p><p>让我们也来看看ServletResponse内部定义了哪些方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ServletResponse &#123;    String getCharacterEncoding();     String getContentType();     ServletOutputStream getOutputStream() throws IOException;     PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;</code></pre></div></figure><p>其中的getWriter方法，它返回了一个可以向客户端发送文本的的Java.io.PrintWriter对象。默认情况下，PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。</p><p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。</p><p>还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送二进制数据的。</p><p>在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text&#x2F;html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset&#x3D;UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p><h2 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h2><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。</p><p>其中几个方法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取在Web.xml中配置的Servlet-Name的值String getServletName();&#x2F;&#x2F;获取Servlet的初始化参数String getInitParameter(String name);&#x2F;&#x2F;获取所有的Servlet初始化参数的名称Enumeration getInitParameterNames();</code></pre></div></figure><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p>ServletContext对象表示Servlet应用程序。每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。</p><p>通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。</p><p>那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</p><p>ServletContext中的下列方法负责处理属性：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取属性Object getAttribute(String var1);&#x2F;&#x2F;获取属性名枚举Enumeration&lt;String&gt; getAttributeNames();&#x2F;&#x2F;设置属性void setAttribute(String var1, Object var2);&#x2F;&#x2F;删除属性void removeAttribute(String var1);</code></pre></div></figure><p>上述方法是四大域对象特有的方法，域对象包括Page、Request、Session、Application。</p><h2 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h2><p>我们编写Servlet类需要实现Servlet接口的所有方法，即使某些方法不需要使用也必须要全部实现，并且还需要自己手动维护ServletConfig这个对象的引用。所有这样实现Servlet是很麻烦的一件事。</p><p>GenericService抽象类帮我们解决了这个问题。本着尽可能使代码简洁的原则，GenericServlet实现了Servlet和ServletConfig接口，下面是GenericServlet抽象类的具体代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;    private static final String LSTRING_FILE &#x3D; &quot;javax.servlet.LocalStrings&quot;;    private static ResourceBundle lStrings &#x3D; ResourceBundle.getBundle(&quot;javax.servlet.LocalStrings&quot;);    private transient ServletConfig config;     public GenericServlet() &#123;    &#125;     public void destroy() &#123;    &#125;     public String getInitParameter(String name) &#123;        ServletConfig sc &#x3D; this.getServletConfig();        if (sc &#x3D;&#x3D; null) &#123;            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));        &#125; else &#123;            return sc.getInitParameter(name);        &#125;    &#125;     public Enumeration&lt;String&gt; getInitParameterNames() &#123;        ServletConfig sc &#x3D; this.getServletConfig();        if (sc &#x3D;&#x3D; null) &#123;            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));        &#125; else &#123;            return sc.getInitParameterNames();        &#125;    &#125;     public ServletConfig getServletConfig() &#123;        return this.config;    &#125;     public ServletContext getServletContext() &#123;        ServletConfig sc &#x3D; this.getServletConfig();        if (sc &#x3D;&#x3D; null) &#123;            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));        &#125; else &#123;            return sc.getServletContext();        &#125;    &#125;     public String getServletInfo() &#123;        return &quot;&quot;;    &#125;     public void init(ServletConfig config) throws ServletException &#123;        this.config &#x3D; config;        this.init();    &#125;     public void init() throws ServletException &#123;    &#125;     public void log(String msg) &#123;        this.getServletContext().log(this.getServletName() + &quot;: &quot; + msg);    &#125;     public void log(String message, Throwable t) &#123;        this.getServletContext().log(this.getServletName() + &quot;: &quot; + message, t);    &#125;     public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;     public String getServletName() &#123;        ServletConfig sc &#x3D; this.getServletConfig();        if (sc &#x3D;&#x3D; null) &#123;            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));        &#125; else &#123;            return sc.getServletName();        &#125;    &#125;&#125;</code></pre></div></figure><p>其中，GenericServlet抽象类相比于直接实现Servlet接口，有以下几个好处：</p><ol><li><p>为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。</p></li><li><p>提供方法，包围ServletConfig对象中的方法。</p></li><li><p>将init( )方法中的ServletConfig参数赋给了一个内部的ServletConfig引用从而来保存ServletConfig对象，不需要程序员自己去维护ServletConfig了。</p></li></ol><p>但是，我们发现在GenericServlet抽象类中还存在着另一个没有任何参数的init()方法：</p><p>设计者的初衷到底是为了什么呢？在第一个带参数的init（）方法中就已经把ServletConfig对象传入并且通过引用保存好了，完成了Servlet的初始化过程，那么为什么后面还要加上一个不带任何参数的init（）方法呢？这不是多此一举吗？</p><p>当然不是多此一举了，存在必然有存在它的道理。我们知道，抽象类是无法直接产生实例的，需要另一个类去继承这个抽象类，那么就会发生方法覆盖的问题，如果在类中覆盖了GenericServlet抽象类的init（）方法，那么程序员就必须手动的去维护ServletConfig对象了，还得调用super.init(servletConfig）方法去调用父类GenericServlet的初始化方法来保存ServletConfig对象，这样会给程序员带来很大的麻烦。GenericServlet提供的第二个不带参数的init( )方法，就是为了解决上述问题的。</p><p>这个不带参数的init（）方法，是在ServletConfig对象被赋给ServletConfig引用后，由第一个带参数的init(ServletConfig servletconfig)方法调用的，那么这意味着，当程序员如果需要覆盖这个GenericServlet的初始化方法，则只需要覆盖那个不带参数的init( )方法就好了，此时，servletConfig对象仍然有GenericServlet保存着。</p><p>说了这么多，通过扩展GenericServlet抽象类，就不需要覆盖没有计划改变的方法。因此，代码将会变得更加的简洁，程序员的工作也会减少很多。</p><p>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p><h2 id="Javax-servlet-http包内容"><a href="#Javax-servlet-http包内容" class="headerlink" title="Javax.servlet.http包内容"></a>Javax.servlet.http包内容</h2><p> 之所以所HttpServlet要比GenericServlet强大，其实也是有道理的。HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class HttpServlet extends GenericServlet implements Serializable </code></pre></div></figure><p>HttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax。servlet.http包是Servlet API中的第二个包，其中包含了用于编写Servlet应用程序的类和接口。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。</p><pre><code class="mermaid">classDiagramclass Servlet&lt;&lt;interface&gt;&gt; Servletclass GenericServlet&lt;&lt;abstruct&gt;&gt; GenericServletServlet&lt;|..GenericServlet:实现class HttpServlet&lt;&lt;abstruct&gt;&gt; HttpServletGenericServlet&lt;|--HttpServlet:继承class ServletRequest&lt;&lt;interface&gt;&gt; ServletRequestclass HttpServletRequest&lt;&lt;interface&gt;&gt; HttpServletRequestServletRequest&lt;|--HttpServletRequest:继承class ServletResponse&lt;&lt;interface&gt;&gt; ServletResponseclass HttpServletResponse&lt;&lt;interface&gt;&gt; HttpServletResponseServletResponse&lt;|--HttpServletResponse:继承class HttpSession&lt;&lt;interface&gt;&gt; HttpSessionclass Coookie</code></pre><h3 id="HttpServlet抽象类"><a href="#HttpServlet抽象类" class="headerlink" title="HttpServlet抽象类"></a>HttpServlet抽象类</h3><p>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</p><p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p><p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。</p><p>让我们来具体的看一看HttpServlet抽象类是如何实现自己的service方法吧：</p><p>首先来看GenericServlet抽象类中是如何定义service方法的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;</code></pre></div></figure><p>我们看到是一个抽象方法，也就是HttpServlet要自己去实现这个service方法，我们在看看HttpServlet是怎么覆盖这个service方法的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request &#x3D; (HttpServletRequest)req;        response &#x3D; (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;    this.service(request, response);&#125;</code></pre></div></figure><p>我们发现，HttpServlet中的service方法把接收到的ServletRequsest类型的对象转换成了HttpServletRequest类型的对象，把ServletResponse类型的对象转换成了HttpServletResponse类型的对象。之所以能够这样强制的转换，<strong>是因为在调用Servlet的Service方法时，Servlet容器总会传入一个HttpServletRequest对象和HttpServletResponse对象，预备使用HTTP</strong>。因此，转换类型当然不会出错了。</p><p>转换之后，service方法把两个转换后的对象传入了另一个service方法，那么我们再来看看这个方法是如何实现的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method &#x3D; req.getMethod();    long lastModified;    if (method.equals(&quot;GET&quot;)) &#123;        lastModified &#x3D; this.getLastModified(req);        if (lastModified &#x3D;&#x3D; -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince &#x3D; req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified &#x3D; this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;))         this.doTrace(req, resp);    &#125; else &#123;        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs &#x3D; new Object[]&#123;method&#125;;        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;</code></pre></div></figure><p>我们发现，这个service方法的参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象。</p><p>接下来我们再看看service方法是如何工作的，我们会发现在service方法中还是没有任何的服务逻辑，但是却在解析HttpServletRequest中的方法参数，并调用以下方法之一：doGet,doPost,doHead,doPut,doTrace,doOptions和doDelete。这7种方法中，每一种方法都表示一个Http方法。doGet和doPost是最常用的。所以，如果我们需要实现具体的服务逻辑，不再需要覆盖service方法了，只需要覆盖doGet或者doPost就好了。</p><p>总之，HttpServlet有两个特性是GenericServlet所不具备的：</p><ol><li><p>不用覆盖service方法，而是覆盖doGet或者doPost方法。在少数情况，还会覆盖其他的5个方法。</p></li><li><p>使用的是HttpServletRequest和HttpServletResponse对象。</p></li></ol><h3 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p> HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getContextPath();&#x2F;&#x2F;返回请求上下文的请求URI部分Cookie[] getCookies();&#x2F;&#x2F;返回一个cookie对象数组String getHeader(String var1);&#x2F;&#x2F;返回指定HTTP标题的值String getMethod();&#x2F;&#x2F;返回生成这个请求HTTP的方法名称String getQueryString();&#x2F;&#x2F;返回请求URL中的查询字符串HttpSession getSession();&#x2F;&#x2F;返回与这个请求相关的会话对象</code></pre></div></figure><h3 id="HttpServletRequest内封装的请求"><a href="#HttpServletRequest内封装的请求" class="headerlink" title="HttpServletRequest内封装的请求"></a>HttpServletRequest内封装的请求</h3><p>因为Request代表请求，所以我们可以通过该对象分别获得HTTP请求的请求行，请求头和请求体。</p><p>关于HTTP具体的详细解释，可以参考我的另一篇博文：JavaWeb——HTTP。</p><img src="/doc/93a9a5ba/20180513130638615" srcset="/img/loading.gif" lazyload class=""><h3 id="通过request获得请求行"><a href="#通过request获得请求行" class="headerlink" title="通过request获得请求行"></a>通过request获得请求行</h3><p>假设查询字符串为：username&#x3D;zhangsan&amp;password&#x3D;123</p><p>获得客户端的请求方式：<code>String getMethod()</code></p><p>获得请求的资源：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getRequestURI() &#x2F;&#x2F;获取uriStringBuffer getRequestURL() &#x2F;&#x2F;获取urlString getContextPath() &#x2F;&#x2F;获取web应用的名称String getQueryString() &#x2F;&#x2F;获取提交url地址后的参数字符串</code></pre></div></figure><h3 id="通过request获得请求头"><a href="#通过request获得请求头" class="headerlink" title="通过request获得请求头"></a>通过request获得请求头</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">long getDateHeader(String name) &#x2F;&#x2F;获取头数据String getHeader(String name) &#x2F;&#x2F;获取头信息Enumeration getHeaderNames() &#x2F;&#x2F;获取头信息名枚举Enumeration getHeaders(String name) &#x2F;&#x2F;获取头信息枚举int getIntHeader(String name) &#x2F;&#x2F;获取整型数头信息</code></pre></div></figure><p>referer头的作用：执行该此访问的的来源，做防盗链</p><h3 id="通过request获得请求体"><a href="#通过request获得请求体" class="headerlink" title="通过request获得请求体"></a>通过request获得请求体</h3><p>请求体中的内容是通过post提交的请求参数，格式是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">username&#x3D;zhangsan&amp;password&#x3D;123&amp;hobby&#x3D;football&amp;hobby&#x3D;basketball</code></pre></div></figure><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>username</td><td>zhangsan</td></tr><tr><td>password</td><td>123</td></tr><tr><td>hobby</td><td>football，basketball</td></tr></tbody></table><p>以上面参数为例，通过一下方法获得请求参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getParameter(String name) &#x2F;&#x2F;获取参数String[] getParameterValues(String name) &#x2F;&#x2F;获取参数数组Enumeration getParameterNames() &#x2F;&#x2F;获取参数名枚举Map&lt;String,String[]&gt; getParameterMap() &#x2F;&#x2F;获取参数Map</code></pre></div></figure><p><strong>注意：get请求方式的请求参数 上述的方法一样可以获得。</strong></p><h3 id="Request乱码问题的解决方法"><a href="#Request乱码问题的解决方法" class="headerlink" title="Request乱码问题的解决方法"></a>Request乱码问题的解决方法</h3><p>在前面我们讲过，在service中使用的编码解码方式默认为：ISO-8859-1编码，但此编码并不支持中文，因此会出现乱码问题，所以我们需要手动修改编码方式为UTF-8编码，才能解决中文乱码问题，下面是发生乱码的具体细节：</p><img src="/doc/93a9a5ba/20180513195355316" srcset="/img/loading.gif" lazyload class=""><p>解决post提交方式的乱码：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p><p>解决get提交的方式的乱码：<code>parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</code></p><h3 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h3><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。  由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p><h3 id="HttpServletResponse内封装的响应"><a href="#HttpServletResponse内封装的响应" class="headerlink" title="HttpServletResponse内封装的响应"></a>HttpServletResponse内封装的响应</h3><img src="/doc/93a9a5ba/20180513203525684" srcset="/img/loading.gif" lazyload class=""><h3 id="通过Response设置响应"><a href="#通过Response设置响应" class="headerlink" title="通过Response设置响应"></a>通过Response设置响应</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">void addCookie(Cookie var1);&#x2F;&#x2F;给这个响应添加一个cookievoid addHeader(String var1, String var2);&#x2F;&#x2F;给这个请求添加一个响应头void sendRedirect(String var1) throws IOException;&#x2F;&#x2F;发送一条响应码，讲浏览器跳转到指定的位置void setStatus(int var1);&#x2F;&#x2F;设置响应行的状态码void addHeader(String name, String value)void addIntHeader(String name, int value)void addDateHeader(String name, long date)void setHeader(String name, String value)void setDateHeader(String name, long date)void setIntHeader(String name, int value)</code></pre></div></figure><p>其中，add表示添加，而set表示设置</p><p>PrintWriter getWriter()</p><p>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response  缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p><p>ServletOutputStream getOutputStream()</p><p>获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。</p><img src="/doc/93a9a5ba/2018051320493643" srcset="/img/loading.gif" lazyload class=""><p>注意：虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。</p><img src="/doc/93a9a5ba/2018051320525170" srcset="/img/loading.gif" lazyload class=""><h3 id="Response的乱码问题"><a href="#Response的乱码问题" class="headerlink" title="Response的乱码问题"></a>Response的乱码问题</h3><hr><img src="/doc/93a9a5ba/20180513205522756" srcset="/img/loading.gif" lazyload class=""><p>原因：response缓冲区的默认编码是iso8859-1，此码表中没有中文。所以需要更改response的编码方式：</p><img src="/doc/93a9a5ba/20180513210445501" srcset="/img/loading.gif" lazyload class=""><img src="/doc/93a9a5ba/20180513205620262" srcset="/img/loading.gif" lazyload class=""><p>通过更改response的编码方式为UTF-8，任然无法解决乱码问题，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。</p><img src="/doc/93a9a5ba/20180513210539156" srcset="/img/loading.gif" lazyload class=""><p>上面通过调用两个方式分别改变服务端对于Response的编码方式以及浏览器的解码方式为同样的UTF-8编码来解决编码方式不一样发生乱码的问题。</p><p>response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)方法即可。</p><img src="/doc/93a9a5ba/20180513210927639" srcset="/img/loading.gif" lazyload class=""><img src="/doc/93a9a5ba/20180513204459256" srcset="/img/loading.gif" lazyload class=""><h3 id="Response的工作流程"><a href="#Response的工作流程" class="headerlink" title="Response的工作流程"></a>Response的工作流程</h3><img src="/doc/93a9a5ba/20180513204718428" srcset="/img/loading.gif" lazyload class=""><h3 id="Servlet的工作流程"><a href="#Servlet的工作流程" class="headerlink" title="Servlet的工作流程"></a>Servlet的工作流程</h3><img src="/doc/93a9a5ba/20180513204808318" srcset="/img/loading.gif" lazyload class=""><h3 id="ServletContextListener（Servlet全局监听器）"><a href="#ServletContextListener（Servlet全局监听器）" class="headerlink" title="ServletContextListener（Servlet全局监听器）"></a>ServletContextListener（Servlet全局监听器）</h3><p>首先要说明的是，ServletContextListener是一个接口，我们随便写一个类，只要这个类实现了ServletContextListener接口，那么这个类就实现了【监听ServletContext】的功能。那么，这个神奇的接口是如何定义的呢？我们来看一下这个接口的内部情况：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javax.servlet;import java.util.EventListener;public interface ServletContextListener extends EventListener &#123;       void contextInitialized(ServletContextEvent var1);void contextDestroyed(ServletContextEvent var1); &#125;</code></pre></div></figure><p>我们发现，在这个接口中只声明了两个方法，分别是<code>void contextInitialized(ServletContextEvent var1)</code>和<code>void contextDestroyed(ServletContextEvent var1)</code>方法，所以，我们很容易的就能猜测到，ServletContext的生命只有两种，分别是：</p><p>1.ServletContext初始化。（应用start时）———-&gt;Servlet容器调用<code>void contextInitialized(ServletContextEvent var1)</code></p><p>2.ServletContext销毁。（应用stop时）———-&gt;Servlet容器调用<code> void contextDestroyed(ServletContextEvent var1)</code></p><p>因此，我们大概能够猜到ServletContextListener的工作机制了，当应用启动时，ServletContext进行初始化，然后Servlet容器会自动调用正在监听ServletContext的ServletContextListener的<code>void contextInitialized(ServletContextEvent var1)</code>方法，并向其传入一个ServletContextEvent对象。当应用停止时，ServletContext被销毁，此时Servlet容器也会自动地调用正在监听ServletContext的ServletContextListener的<code>void contextDestroyed(ServletContextEvent var1)</code>方法。</p><p>为了验证我们的猜测，我们来随便写一个类，并且实现ServletContextListener接口，即实现监听ServletContext的功能：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class MyListener implements ServletContextListener &#123;  @Override  public void contextInitialized(ServletContextEvent servletContextEvent) &#123;    System.out.println(&quot;ServletContextListener.contextInitialized方法被调用&quot;);  &#125;  @Override  public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;    System.out.println(&quot;ServletContextListener.contextDestroyed方法被调用&quot;);  &#125;&#125;</code></pre></div></figure><p>然后，在web.xml中注册我们自己写的这个MyListener:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;version&#x3D;&quot;4.0&quot;&gt;    &lt;listener&gt;        &lt;listener-class&gt;MyListener&lt;&#x2F;listener-class&gt;    &lt;&#x2F;listener&gt;&lt;&#x2F;web-app&gt;</code></pre></div></figure><p>接下来，让我们启动一下Tomcat，看一看会发生什么吧！控制台打印信息如下：</p><img src="/doc/93a9a5ba/20181222161836740.png" srcset="/img/loading.gif" lazyload class=""><p><img src="/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Servlet/20181222161836740.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>我们发现，当应用启动时，ServletContextListener.contextInitialized（）方法被调用了。这其实是Servlet容器偷偷干的事情。那么，当我们停止Tomcat时，按照猜想，Servlet容器应该也会偷偷调用void contextDestroyed(ServletContextEvent var1)方法，来通知ServletContextListener监听器：ServletContext已经被销毁了。那么，事实是不是和我们猜想的一模一样呢？让我们来停止Tomcat的运行，看一看控制台的情况吧：</p><img src="/doc/93a9a5ba/20181222162311326.png" srcset="/img/loading.gif" lazyload class=""><p>我们发现，<code>void contextDestroyed(ServletContextEvent var1)</code>方法确实被Servlet容器调用了。因此，我们的猜想得到了证实。</p><h3 id="【进阶】ServletContextListener在Spring中的应用"><a href="#【进阶】ServletContextListener在Spring中的应用" class="headerlink" title="【进阶】ServletContextListener在Spring中的应用"></a>【进阶】ServletContextListener在Spring中的应用</h3><p>如果基础好一点的童鞋，或者已经学过Spring框架的同学，建议阅读下面的内容，没有学过Spring也没有关系，可以先学或者学完之后再回头来看一看，Spring容器是如何借用ServletContextListener这个接口来实例化的。</p><p>首先让我们再来回顾一下ServletContext的概念，ServletContext翻译成中文叫做“Servlet上下文”或者“Servlet全局”，但是这个翻译我认为翻译的实在是有点牵强，也导致了许多的开发者不明白这个变量到底具体代表了什么。其实ServletContext就是一个“域对象”，它存在于整个应用中，并在在整个应用中有且仅有1份，它表示了当前整个应用的“状态”，你也可以理解为某个时刻的ServletContext代表了这个应用在某个时刻的“一张快照”，这张“快照”里面包含了有关应用的许多信息，应用的所有组件都可以从ServletContext获取当前应用的状态信息。ServletContext随着程序的启动而创建，随着程序的停止而销毁。通俗点说，我们可以往这个ServletContext域对象中“存东西”，然后也可以在别的地方中“取出来”。</p><p>我们知道，Spring容器可以通过：</p><p><code>ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;配置文件的路径&quot;）;</code></p><p>显示地实例化一个Spring IOC容器。也可以像下面一样，在web.xml中注册Spring IOC容器：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;</code></pre></div></figure><p>其中的监听器类【org.springframework.web.context.ContextLoaderListener】实现了ServletContextListener接口，能够监听ServletContext的生命周期中的“初始化”和“销毁”。注意，这个【org.springframework.web.context.ContextLoaderListener】监听器类当然不是我们自己写的哦，是人家Spring团队写的，我们只要拿来用就行了。当然，别忘记导入相关的Jar包。（<strong>spring-web-4.2.4.RELEASE.jar</strong>）</p><p>那么，Spring团队给我们提供的这个监听器类是如何实现：当ServletContext初始化后，Spring IOC容器也能跟着初始化的呢？怀着好奇心，让我们再来看一看【org.springframework.web.context.ContextLoaderListener】的内部实现情况吧。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.springframework.web.context;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;    public ContextLoaderListener() &#123;&#125;    public ContextLoaderListener(WebApplicationContext context) &#123;    super(context);  &#125;&#x2F;&#x2F;--------------------------------------------------------重点关注下面这里哦！-----------------------------------------------------------------------  public void contextInitialized(ServletContextEvent event) &#123;    this.initWebApplicationContext(event.getServletContext());  &#125;&#x2F;&#x2F;--------------------------------------------------------重点关注上面这里哦！-----------------------------------------------------------------------  public void contextDestroyed(ServletContextEvent event) &#123;    this.closeWebApplicationContext(event.getServletContext());    ContextCleanupListener.cleanupAttributes(event.getServletContext());  &#125;&#125;</code></pre></div></figure><p>我们发现，【org.springframework.web.context.ContextLoaderListener】这个类实现了ServletContextListener接口中的两个方法，其中，当ServletContext初始化后， <code>public void contextInitialized(ServletContextEvent event)</code>方法被调用，接下来执行<code>initWebApplicationContext(event.getServletContext())</code>方法，但是我们发现这个方法并没有在这个类中声明，因此，我们再看一下其父类中是如何声明的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) !&#x3D; null) &#123;         throw new IllegalStateException(&quot;Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!&quot;); &#125; else &#123;      Log logger &#x3D; LogFactory.getLog(ContextLoader.class);     servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);     if (logger.isInfoEnabled()) &#123;         logger.info(&quot;Root WebApplicationContext: initialization started&quot;);        &#125;     long startTime &#x3D; System.currentTimeMillis();     try &#123;         if (this.context &#x3D;&#x3D; null) &#123;              this.context &#x3D; this.createWebApplicationContext(servletContext);         &#125;         if (this.context instanceof ConfigurableWebApplicationContext) &#123;             ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext)this.context;                if (!cwac.isActive()) &#123;                 if (cwac.getParent() &#x3D;&#x3D; null) &#123;                     ApplicationContext parent &#x3D; this.loadParentContext(servletContext);                     cwac.setParent(parent);                  &#125;                 this.configureAndRefreshWebApplicationContext(cwac, servletContext);             &#125;         &#125;            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);        ClassLoader ccl &#x3D; Thread.currentThread().getContextClassLoader();         if (ccl &#x3D;&#x3D; ContextLoader.class.getClassLoader()) &#123;             currentContext &#x3D; this.context;          &#125; else if (ccl !&#x3D; null) &#123;             currentContextPerThread.put(ccl, this.context);         &#125;         if (logger.isDebugEnabled()) &#123;                logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);         &#125;         if (logger.isInfoEnabled()) &#123;             long elapsedTime &#x3D; System.currentTimeMillis() - startTime;              logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);         &#125;         return this.context;     &#125; catch (RuntimeException var8) &#123;            logger.error(&quot;Context initialization failed&quot;, var8);         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var8);         throw var8;     &#125; catch (Error var9) &#123;          logger.error(&quot;Context initialization failed&quot;, var9);         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var9);         throw var9;     &#125;    &#125;&#125;</code></pre></div></figure><p>分析到这一步，我们发现Spring容器在这个方法中被实例化了。接下来，就让我们整理一下整体的思路：</p><p>当Servlet容器启动时，ServletContext对象被初始化，然后Servlet容器调用web.xml中注册的监听器的</p><p>public void contextInitialized(ServletContextEvent event)</p><p>方法，而在监听器中，调用了this.initWebApplicationContext(event.getServletContext())方法，在这个方法中实例化了Spring IOC容器。即ApplicationContext对象。</p><p>因此，当ServletContext创建时我们可以创建applicationContext对象，当ServletContext销毁时，我们可以销毁applicationContext对象。这样applicationContext就和ServletContext“共生死了”。</p><h2 id="博文来源"><a href="#博文来源" class="headerlink" title="博文来源"></a>博文来源</h2><p>为防止所需博文丢失，所以<strong>copy</strong>了大佬的博文，这里重点标注一下博文来源：</p><blockquote><p>版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。</p><p>本文链接：<a href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu防火墙常用命令</title>
    <link href="/doc/af559c1b.html"/>
    <url>/doc/af559c1b.html</url>
    
    <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install ufw</code></pre></div></figure><h2 id="启用-禁用ufw防火墙"><a href="#启用-禁用ufw防火墙" class="headerlink" title="启用&#x2F;禁用ufw防火墙"></a>启用&#x2F;禁用ufw防火墙</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ufw enablesudo ufw disable</code></pre></div></figure><h2 id="默认关闭所有端口"><a href="#默认关闭所有端口" class="headerlink" title="默认关闭所有端口"></a>默认关闭所有端口</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ufw default deny</code></pre></div></figure><p>若是通过<strong>ssh</strong>访问Ubuntu运行上述命令，请先禁用防火墙再运行本命令！</p><h2 id="打开-关闭端口"><a href="#打开-关闭端口" class="headerlink" title="打开&#x2F;关闭端口"></a>打开&#x2F;关闭端口</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ufw allow|deny [service]#打开或关闭某个端口，例如：sudo ufw allow smtp　#允许所有的外部IP访问本机的25&#x2F;tcp (smtp)端口sudo ufw allow 22&#x2F;tcp #允许所有的外部IP访问本机的22&#x2F;tcp (ssh)端口sudo ufw allow 53 #允许外部访问53端口(tcp&#x2F;udp)sudo ufw allow from 192.168.1.100 #允许此IP访问所有的本机端口</code></pre></div></figure><h2 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo ufw status</code></pre></div></figure><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#先查询规则号：sudo ufw status numbered#然后再根据号来删除sudo ufw delete 2</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防火墙</tag>
      
      <tag>ufw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker环境搭建Minio分布式文件服务器</title>
    <link href="/doc/5b796dca.html"/>
    <url>/doc/5b796dca.html</url>
    
    <content type="html"><![CDATA[<p>分布式模式下的 MinIO 允许您将多个驱动器（甚至在不同的机器上）汇集到单个对象存储服务器中。由于驱动器分布在多个节点上，分布式 MinIO 可以承受多个节点故障，同时确保完整的数据保护。</p><span id="more"></span><h2 id="Docker部署分布式MinIO"><a href="#Docker部署分布式MinIO" class="headerlink" title="Docker部署分布式MinIO"></a>Docker部署分布式MinIO</h2><p>分布式 MinIO 可以通过Docker Compose部署。这意味着 Docker Compose 可以让您在计算机上快速开始使用分布式 MinIO - 非常适合开发、测试、登台环境。</p><p>以下是<code>docker-compose.yml</code>配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3.7&#39;# Settings and configurations that are common for all containersx-minio-common: &amp;minio-common  image: quay.io&#x2F;minio&#x2F;minio:RELEASE.2022-08-26T19-53-15Z  command: server --console-address &quot;:9001&quot; http:&#x2F;&#x2F;minio&#123;1...4&#125;&#x2F;data&#123;1...2&#125;  expose:    - &quot;9000&quot;    - &quot;9001&quot;  # environment:    # MINIO_ROOT_USER: minioadmin    # MINIO_ROOT_PASSWORD: minioadmin  healthcheck:    test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;minio&#x2F;health&#x2F;live&quot;]    interval: 30s    timeout: 20s    retries: 3# starts 4 docker containers running minio server instances.# using nginx reverse proxy, load balancing, you can access# it through port 9000.services:  minio1:    &lt;&lt;: *minio-common    hostname: minio1    volumes:      - data1-1:&#x2F;data1      - data1-2:&#x2F;data2  minio2:    &lt;&lt;: *minio-common    hostname: minio2    volumes:      - data2-1:&#x2F;data1      - data2-2:&#x2F;data2  minio3:    &lt;&lt;: *minio-common    hostname: minio3    volumes:      - data3-1:&#x2F;data1      - data3-2:&#x2F;data2  minio4:    &lt;&lt;: *minio-common    hostname: minio4    volumes:      - data4-1:&#x2F;data1      - data4-2:&#x2F;data2  nginx:    image: nginx:1.19.2-alpine    hostname: nginx    volumes:      - .&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro    ports:      - &quot;9000:9000&quot;      - &quot;9001:9001&quot;    depends_on:      - minio1      - minio2      - minio3      - minio4## By default this config uses default local driver,## For custom volumes replace with volume driver configuration.volumes:  data1-1:  data1-2:  data2-1:  data2-2:  data3-1:  data3-2:  data4-1:  data4-2:</code></pre></div></figure><p>因为需要借助负载均衡访问分布式MinIO，以下是<code>nginx.conf</code>配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">user  nginx;worker_processes  auto;error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123;    worker_connections  4096;&#125;http &#123;    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;    default_type  application&#x2F;octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;    sendfile        on;    keepalive_timeout  65;    # include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;    upstream minio &#123;        server minio1:9000;        server minio2:9000;        server minio3:9000;        server minio4:9000;    &#125;    upstream console &#123;        ip_hash;        server minio1:9001;        server minio2:9001;        server minio3:9001;        server minio4:9001;    &#125;    server &#123;        listen       9000;        listen  [::]:9000;        server_name  localhost;        # To allow special characters in headers        ignore_invalid_headers off;        # Allow any size file to be uploaded.        # Set to a value such as 1000m; to restrict file size to a specific value        client_max_body_size 0;        # To disable buffering        proxy_buffering off;        proxy_request_buffering off;        location &#x2F; &#123;            proxy_set_header Host $http_host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;            proxy_connect_timeout 300;            # Default is HTTP&#x2F;1, keepalive is only enabled in HTTP&#x2F;1.1            proxy_http_version 1.1;            proxy_set_header Connection &quot;&quot;;            chunked_transfer_encoding off;            proxy_pass http:&#x2F;&#x2F;minio;        &#125;    &#125;    server &#123;        listen       9001;        listen  [::]:9001;        server_name  localhost;        # To allow special characters in headers        ignore_invalid_headers off;        # Allow any size file to be uploaded.        # Set to a value such as 1000m; to restrict file size to a specific value        client_max_body_size 0;        # To disable buffering        proxy_buffering off;        proxy_request_buffering off;        location &#x2F; &#123;            proxy_set_header Host $http_host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;            proxy_set_header X-NginX-Proxy true;            # This is necessary to pass the correct IP to be hashed            real_ip_header X-Real-IP;            proxy_connect_timeout 300;                        # To support websocket            proxy_http_version 1.1;            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;                        chunked_transfer_encoding off;            proxy_pass http:&#x2F;&#x2F;console;        &#125;    &#125;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MinIO</tag>
      
      <tag>Docker</tag>
      
      <tag>分布式</tag>
      
      <tag>文件服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记：在Docker上搭建postfix并用javaMail测试</title>
    <link href="/doc/b0f10df4.html"/>
    <url>/doc/b0f10df4.html</url>
    
    <content type="html"><![CDATA[<h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul><li>一台可连外网的ubuntu服务器</li><li>一个可用的域名</li></ul><p><strong>注意事项：</strong></p><ul><li>请检查服务是是否可以使用25端口（主要是出口端口）</li></ul><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li>设置域名解析</li><li>搭建服务器</li><li>编写javaMail</li><li>测试发送</li></ol><h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><p>假设你的主域名为example.com</p><p>这里需要设置以下几个域名：</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>mail</td><td>A</td><td>你的邮箱服务器IP</td></tr><tr><td>pop</td><td>A</td><td>你的邮箱服务器IP</td></tr><tr><td>stmp</td><td>A</td><td>你的邮箱服务器IP</td></tr><tr><td>pop3</td><td>A</td><td>你的邮箱服务器IP</td></tr><tr><td>imap</td><td>A</td><td>你的邮箱服务器IP</td></tr><tr><td>@</td><td>MX</td><td>mail.example.com</td></tr><tr><td>@</td><td>TXT</td><td>v&#x3D;spf1 a mx ~all</td></tr></tbody></table><p>这里你可以使用以下命令进行测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">nslookup -qt&#x3D;mx example.comnslookup -qt&#x3D;txt example.com</code></pre></div></figure><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><p><strong>这里我们使用的是ubuntu系统，安装环境为Docker环境，我们假设读者已拥有以上环境。</strong></p><ol><li>拉取<strong>catatnight&#x2F;docker-postfix</strong></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull catatnight&#x2F;postfix</code></pre></div></figure><ol start="2"><li>运行docker</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p 25:25 \-e maildomain&#x3D;example.com -e smtp_user&#x3D;user:pwd \--name postfix -d catatnight&#x2F;postfix</code></pre></div></figure><h2 id="编写代码测试"><a href="#编写代码测试" class="headerlink" title="编写代码测试"></a>编写代码测试</h2><p>这里我使用的是Springboot+JavaMail</p><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--邮件发送--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h3 id="编写Mail工具"><a href="#编写Mail工具" class="headerlink" title="编写Mail工具"></a>编写Mail工具</h3><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  mail:    default-encoding: UTF-8    host: smtp.example.com    username: 账号@example.com    password: 密码    port: 25    protocol: smtp    properties:      mail:        smtp:          # 邮件接收时间的限制，单位毫秒          timeout: 10000          # 连接时间的限制，单位毫秒          connectiontimeout: 10000          # 邮件发送时间的限制，单位毫秒          writetimeout: 10000</code></pre></div></figure><h4 id="EmailTool-Java"><a href="#EmailTool-Java" class="headerlink" title="EmailTool.Java"></a>EmailTool.Java</h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.cikaros.util;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;&#x2F;** * 邮箱工具类 * * @author Cikaros QQ:1032325640 * @date 2020&#x2F;6&#x2F;12 4:24 *&#x2F;@Componentpublic class EmailTool &#123;  @Resource  private JavaMailSender javaMailSender;  @Value(&quot;$&#123;spring.mail.username&#125;&quot;)  private String from;  public void sendSimpleMail(String to, String subject, StringBuilder httpText) throws MessagingException &#123;    MimeMessage message &#x3D; null;    message &#x3D; javaMailSender.createMimeMessage();    MimeMessageHelper helper &#x3D; new MimeMessageHelper(message, true);    helper.setFrom(from);    helper.setTo(to);    helper.setSubject(subject);    helper.setText(httpText.toString(), true);    javaMailSender.send(message);  &#125;&#125;</code></pre></div></figure><h4 id="MailTest-Java"><a href="#MailTest-Java" class="headerlink" title="MailTest.Java"></a>MailTest.Java</h4><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.cikaros.test;import org.cikaros.util.EmailTool;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;import javax.mail.MessagingException;&#x2F;** * 邮件发送测试 * * @author Cikaros QQ：1032325640 * @date 2020&#x2F;11&#x2F;5 13:31 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class MailTest &#123;  @Resource  private EmailTool emailTool;  @Test  public void test() throws MessagingException &#123;    StringBuilder stringBuilder &#x3D; new StringBuilder();    stringBuilder.append(&quot;欢迎使用小纸条!这是你的验证码：1101&quot;);    emailTool.sendSimpleMail(&quot;1032325640@qq.com&quot;,&quot;欢迎使用小纸条&quot;,stringBuilder);    System.out.println(&quot;end&quot;);  &#125;&#125;</code></pre></div></figure><p>完成上述操作后运行即可！</p><img src="/doc/b0f10df4/image-20201109220821238.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>postfix</tag>
      
      <tag>邮箱服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack的学习</title>
    <link href="/doc/4c5630d8.html"/>
    <url>/doc/4c5630d8.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Webpack 是一个前端资源加载&#x2F;打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p>官方介绍如下：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><p>从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是<a href="https://www.webpackjs.com/configuration">高度可配置的</a>。</p></blockquote><p>从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，解决了模块化开发的一些困难，也减少了页面的请求。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>在开始前你需要先理解四个<strong>核心概念</strong>：</p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件(plugins)</li></ul><h4 id="入口【entry】"><a href="#入口【entry】" class="headerlink" title="入口【entry】"></a>入口【entry】</h4><p>就像是C语言的<code>Main</code>函数一样，webpack同样也需要一个模块的入口，以下是官方解释：</p><blockquote><p>**入口起点(entry point)*<em>指示 webpack 应该使用哪个模块，来作为构建其内部</em>依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 <em>bundles</em> 的文件中。</p><p>可以通过在 <a href="https://www.webpackjs.com/configuration">webpack 配置</a>中配置 <code>entry</code> 属性，来指定一个入口起点（或多个入口起点）。默认值为 <code>./src</code>。</p><p>接下来我们看一个 <code>entry</code> 配置的最简单例子：</p><p><strong>webpack.config.js</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; &#123;  entry: &#39;.&#x2F;path&#x2F;to&#x2F;my&#x2F;entry&#x2F;file.js&#39;&#125;;</code></pre></div></figure></blockquote><h4 id="出口【output】"><a href="#出口【output】" class="headerlink" title="出口【output】"></a>出口【output】</h4><p>这个就像是C语言编译出来的<code>.exe</code>文件一样，webpack在确定好你需要编译的模块之间的联系后，就会对确定好的代码进行编译，以下是官方的解释：</p><blockquote><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundles</em>，以及如何命名这些文件，默认值为 <code>./dist</code>。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p><p><strong>webpack.config.js</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const path &#x3D; require(&#39;path&#39;);module.exports &#x3D; &#123;  entry: &#39;.&#x2F;path&#x2F;to&#x2F;my&#x2F;entry&#x2F;file.js&#39;,  output: &#123;    path: path.resolve(__dirname, &#39;dist&#39;),    filename: &#39;my-first-webpack.bundle.js&#39;  &#125;&#125;;</code></pre></div></figure><p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="https://nodejs.org/api/modules.html">Node.js 核心模块</a>，用于操作文件路径。</p></blockquote><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>这个东西是用来扩展webpack可识别的代码种类的，因为原始的webpack只能识别并编译<strong>JS</strong>代码，无法识别其他代码。例如：<strong>CSS</strong>、<strong>Less</strong>、<strong>图片</strong>等文件。所以需要<strong>Loader</strong>来加载这些无法识别的文件格式，并做相关的处理。以下是官方的解释：</p><blockquote><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://www.webpackjs.com/concepts/modules">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><blockquote><p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p></blockquote><p>在更高层面，在 webpack 的配置中 <strong>loader</strong> 有两个目标：</p><ol><li><code>test</code> 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li><code>use</code> 属性，表示进行转换时，应该使用哪个 loader。</li></ol><p><strong>webpack.config.js</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const path &#x3D; require(&#39;path&#39;);const config &#x3D; &#123;  output: &#123;    filename: &#39;my-first-webpack.bundle.js&#39;  &#125;,  module: &#123;    rules: [      &#123; test: &#x2F;\.txt$&#x2F;, use: &#39;raw-loader&#39; &#125;    ]  &#125;&#125;;module.exports &#x3D; config;</code></pre></div></figure><p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>&#x2F;<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先<strong>使用</strong> <code>raw-loader</code> 转换一下。”</p></blockquote><blockquote><p>重要的是要记得，**在 webpack 配置中定义 loader 时，要定义在 <code>module.rules</code> 中，而不是 <code>rules</code>**。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告”</p></blockquote><p>loader 还有更多我们尚未提到的具体配置属性。</p></blockquote><h4 id="插件【plugin】"><a href="#插件【plugin】" class="headerlink" title="插件【plugin】"></a>插件【plugin】</h4><p>如果你还想完成<strong>Webpack</strong>无法完成的功能，你可以使用插件来增加<strong>webpack</strong>的功能，官方介绍如下：</p><blockquote><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<a href="https://www.webpackjs.com/api/plugins">插件接口</a>功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例。</p><p><strong>webpack.config.js</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;); &#x2F;&#x2F; 通过 npm 安装const webpack &#x3D; require(&#39;webpack&#39;); &#x2F;&#x2F; 用于访问内置插件const config &#x3D; &#123;  module: &#123;    rules: [      &#123; test: &#x2F;\.txt$&#x2F;, use: &#39;raw-loader&#39; &#125;    ]  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;template: &#39;.&#x2F;src&#x2F;index.html&#39;&#125;)  ]&#125;;module.exports &#x3D; config;</code></pre></div></figure><p>webpack 提供许多开箱可用的插件！查阅我们的<a href="https://www.webpackjs.com/plugins">插件列表</a>获取更多信息。</p><p>在 webpack 配置中使用插件是简单直接的，然而也有很多值得我们进一步探讨的用例。</p></blockquote><p><strong>更多详细内容请参照官方文档：<a href="https://www.webpackjs.com/concepts/">https://www.webpackjs.com/concepts/</a></strong></p><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><h3 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h3><blockquote><p>在开始之前，请确保安装了 <a href="https://nodejs.org/en/">Node.js</a> 的最新版本。使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，是理想的起步。使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及&#x2F;或者缺少相关 package 包。</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>这里不提供安装步骤，请参照官方文档：<a href="https://www.webpackjs.com/guides/installation/">https://www.webpackjs.com/guides/installation/</a></strong></p><h2 id="删除全部模块和缓存"><a href="#删除全部模块和缓存" class="headerlink" title="删除全部模块和缓存"></a>删除全部模块和缓存</h2><p><strong>请将以下内容保存为</strong> <em>.cmd</em> <strong>文件，以管理员身份运行即可。</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@ECHO OFFSETLOCAL EnableDelayedExpansion SETLOCAL EnableExtensionsSET &#x2F;A ecode&#x3D;0:: verifySET &#x2F;P conf&#x3D;&quot;About to delete all global and local npm modules and clear the npm cache. Continue (y&#x2F;[n])?IF &#x2F;I NOT &quot;%conf%&quot;&#x3D;&#x3D;&quot;y&quot; (  ECHO operation aborted  SET &#x2F;A ecode&#x3D;!ecode!+1  GOTO END):: wipe global and local npm rootFOR %%a IN (&quot;&quot; &quot;-g&quot;) DO (  :: get root path into var  SET cmd&#x3D;npm root %%~a  FOR &#x2F;f &quot;usebackq tokens&#x3D;*&quot; %%r IN (&#96;!cmd!&#96;) DO (SET npm_root&#x3D;%%r)  :: paranoid  ECHO validating module path &quot;!npm_root!&quot;  IF &quot;!npm_root:~-12!&quot;&#x3D;&#x3D;&quot;node_modules&quot; (    IF NOT EXIST &quot;!npm_root!&quot; (      ECHO npm root does not exist &quot;!npm_root!&quot;    ) ELSE (      ECHO deleting &quot;!npm_root!&quot; ...      :: delete      RMDIR &#x2F;S &#x2F;Q &quot;!npm_root!&quot;    )  ) ELSE (      ECHO suspicious npm root, ignoring &quot;!npm_root!&quot;  )):: clear the cacheECHO clearing the npm cache ...call npm cache clean:: doneECHO done:ENDENDLOCAL &amp; EXIT &#x2F;b %ecode%</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
      <tag>构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决：PowerShell无法运行脚本的问题</title>
    <link href="/doc/1add8b5d.html"/>
    <url>/doc/1add8b5d.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>因为win10默认不允许PowerShell运行脚本，所以无法加载脚本文件</p><p>所以你经常会遇见像这样的错误</p><img src="/doc/1add8b5d/image-20201102170819455.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/1add8b5d/image-20201102170844508.png" srcset="/img/loading.gif" lazyload class=""><img src="/doc/1add8b5d/image-20201102170902352.png" srcset="/img/loading.gif" lazyload class=""><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>针对以上问题，我们可以运行以下代码开放该策略组。</p><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">set-executionpolicy remotesigned</code></pre></div></figure><p>现在就可以用了，试试看吧！</p><img src="/doc/1add8b5d/image-20201102171157572.png" srcset="/img/loading.gif" lazyload class="">]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Windows</category>
      
      <category>PowerShell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
      <tag>运行脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm设置仓库地址为国内地址</title>
    <link href="/doc/e2c2a403.html"/>
    <url>/doc/e2c2a403.html</url>
    
    <content type="html"><![CDATA[<h2 id="查看默认仓库的地址"><a href="#查看默认仓库的地址" class="headerlink" title="查看默认仓库的地址"></a>查看默认仓库的地址</h2><p>使用<code>npm get registry</code>即可查看默认的仓库地址，一般为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</code></pre></div></figure><h2 id="设置淘宝仓库地址"><a href="#设置淘宝仓库地址" class="headerlink" title="设置淘宝仓库地址"></a>设置淘宝仓库地址</h2><p>使用<code>npm config set registry http://registry.npm.taobao.org/</code>即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NPM源</tag>
      
      <tag>包管理工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm修改默全局安装路径</title>
    <link href="/doc/cce5e7b2.html"/>
    <url>/doc/cce5e7b2.html</url>
    
    <content type="html"><![CDATA[<h2 id="创建两个文件夹"><a href="#创建两个文件夹" class="headerlink" title="创建两个文件夹"></a>创建两个文件夹</h2><p>选择自己想要放置的位置去创建，这里 我选择D盘的某个位置</p><img src="/doc/cce5e7b2/image-20201102143553417.png" srcset="/img/loading.gif" lazyload class=""><h2 id="设置全局和缓存位置"><a href="#设置全局和缓存位置" class="headerlink" title="设置全局和缓存位置"></a>设置全局和缓存位置</h2><p>可使用<code>npm config ls</code>查看之前的设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">npm config set prefix &quot;XXX\XXX\node_global&quot;npm config set cache &quot;XXX\XXX\node_cache&quot;</code></pre></div></figure><h2 id="设置好后可将之前已安装好的数据移动过来"><a href="#设置好后可将之前已安装好的数据移动过来" class="headerlink" title="设置好后可将之前已安装好的数据移动过来"></a>设置好后可将之前已安装好的数据移动过来</h2><p>一般的默认路径为<code>C:\Users\xxxx\AppData\Roaming</code></p><img src="/doc/cce5e7b2/image-20201102143949048.png" srcset="/img/loading.gif" lazyload class=""><p>一一对应进行剪切移动即可。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>由于 node 全局模块大多数都是可以通过命令行访问的，还要把 “XXX\XXX\node_global” 加入到系统环境变量 PATH 中，方便直接使用命令行运行。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NPM配置</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向大佬学习，MyBatis-JdbcType类型对照表</title>
    <link href="/doc/d36dd512.html"/>
    <url>/doc/d36dd512.html</url>
    
    <content type="html"><![CDATA[<h2 id="JdbcType类型的作用"><a href="#JdbcType类型的作用" class="headerlink" title="JdbcType类型的作用"></a>JdbcType类型的作用</h2><p>在Mybatis明文建议在映射字段数据时需要将JdbcType属性加上，这样相对来说是比较安全的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;insert id&#x3D;&quot;saveRole&quot;&gt;    insert into role values (        #&#123;roleId&#125;,        #&#123;name&#125;,        #&#123;remarks&#125;,        #&#123;orderNo&#125;,        #&#123;createBy,jdbcType&#x3D;VARCHAR&#125;,        #&#123;createDept,jdbcType&#x3D;VARCHAR&#125;,        #&#123;createTime,jdbcType&#x3D;DATE&#125;,        #&#123;updateBy,jdbcType&#x3D;VARCHAR&#125;,        #&#123;updateTime,jdbcType&#x3D;DATE&#125;    )&lt;&#x2F;insert&gt;</code></pre></div></figure><p>这样，保证了前四种是不能为空的前提下，而后面几项为空时也不至于程序报错。如果createBy为空，插入的时候mybatis不知道具体转换成什么jdbcType类型，通常会使用一个默认设置，虽然默认配置一般情况下不会出错，但是遇到个别情况还是会有问题的。Mybatis经常出现的：无效的列类型: 1111 错误，就是因为没有设置JdbcType造成的。</p><h2 id="JdbcType对照表"><a href="#JdbcType对照表" class="headerlink" title="JdbcType对照表"></a>JdbcType对照表</h2><table><thead><tr><th>JDBC Type</th><th>Java Type</th></tr></thead><tbody><tr><td>CHAR</td><td>String</td></tr><tr><td>VARCHAR</td><td>String</td></tr><tr><td>LONGVARCHAR</td><td>String</td></tr><tr><td>NUMERIC</td><td>java.math.BigDecimal</td></tr><tr><td>DECIMAL</td><td>java.math.BigDecimal</td></tr><tr><td>BIT</td><td>boolean</td></tr><tr><td>BOOLEAN</td><td>boolean</td></tr><tr><td>TINYINT</td><td>byte</td></tr><tr><td>SMALLINT</td><td>short</td></tr><tr><td>INTEGER</td><td>INTEGER</td></tr><tr><td>BIGINT</td><td>long</td></tr><tr><td>REAL</td><td>float</td></tr><tr><td>FLOAT</td><td>double</td></tr><tr><td>DOUBLE</td><td>double</td></tr><tr><td>BINARY</td><td>byte[]</td></tr><tr><td>VARBINARY</td><td>byte[]</td></tr><tr><td>LONGVARBINARY</td><td>byte[]</td></tr><tr><td>DATE</td><td>java.sql.Date</td></tr><tr><td>TIME</td><td>java.sql.Time</td></tr><tr><td>TIMESTAMP</td><td>java.sql.Timestamp</td></tr><tr><td>CLOB</td><td>Clob</td></tr><tr><td>BLOB</td><td>Blob</td></tr><tr><td>ARRAY</td><td>Array</td></tr><tr><td>DISTINCT</td><td>mapping of underlying type</td></tr><tr><td>STRUCT</td><td>Struct</td></tr><tr><td>REF</td><td>Ref</td></tr><tr><td>DATALINK</td><td>java.net.URL</td></tr><tr><td>&#96;&#96;</td><td></td></tr><tr><td><strong>这里附上大佬的地址 ：</strong><a href="https://www.yanghainan.top/">https://www.yanghainan.top/</a></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>Jdbc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向大佬学习，hexo SEO优化</title>
    <link href="/doc/32abd75e.html"/>
    <url>/doc/32abd75e.html</url>
    
    <content type="html"><![CDATA[<h2 id="未优化方案"><a href="#未优化方案" class="headerlink" title="未优化方案"></a>未优化方案</h2><p>我们都知道，使用hexo编译的站点打开文章的url是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，所以，有的博客给的解决方案是：</p><p>将url直接改成sitename&#x2F;title的形式，并且title最好是用英文，在根目录的配置文件下。<br>具体修改permalink如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;www.devcheng.netroot: &#x2F;#permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;#permalink: :posts&#x2F;:category&#x2F;:year-:month-:day-:title.htmlpermalink: title.htmlpermalink_defaults:</code></pre></div></figure><p>这样写的弊端就是，没次写文章的时候你之能写个英文的title，翻阅了其他资料我发现有更好的方法。</p><h2 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h2><p>具体操作如下，使用 hexo-abbrlink这个插件。<br>先安装这个插件，命令如下：</p><p><code>npm install hexo-abbrlink --save</code><br>站点配置文件里:</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">permalink: post&#x2F;:abbrlink.htmlabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre></div></figure><p>到此就配置完成了，重新新建文章也不用局限于标题了。是一种比较奈斯的方法，值得你这样配置为了你的站点的SEO。</p><p><strong>这里附上大佬的地址 ：</strong><a href="http://www.devcheng.net/">http://www.devcheng.net/</a></p>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEO优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合redis实现分布式session共享</title>
    <link href="/doc/8c5f6480.html"/>
    <url>/doc/8c5f6480.html</url>
    
    <content type="html"><![CDATA[<h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="所需配置"><a href="#所需配置" class="headerlink" title="所需配置"></a>所需配置</h2><ul><li>yml配置</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: consumer-demo  redis:    # redis数据库索引（默认为0）    database: 0    # redis服务器地址（默认为localhost）    host: xxx.xxx.xxx.xxx    # redis端口（默认为6379）    port: 6379    # redis访问密码（默认为空）    password: xxxx    # redis连接超时时间（单位为毫秒）    timeout: 3000    # redis连接池配置    jedis:      pool:        # 最大可用连接数（默认为8，负数表示无限）        max-active: 8        # 最大空闲连接数（默认为8，负数表示无限）        max-idle: 8        # 最小空闲连接数（默认为0，该值只有为正数才有作用）        min-idle: 0        # 从连接池中获取连接最大等待时间（默认为-1，单位为毫秒，负数表示无限）        max-wait: -1</code></pre></div></figure><ul><li>需要开启<code>@EnableRedisHttpSession</code></li></ul><p>然后就可以使用了，您只需获取Session即可。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Session共享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合redis</title>
    <link href="/doc/c8132148.html"/>
    <url>/doc/c8132148.html</url>
    
    <content type="html"><![CDATA[<p>在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis<br>需要那些步骤呢。</p><ol><li><p>JedisPoolConfig(这个是配置连接池)</p></li><li><p>RedisConnectionFactory（这个是配置连接信息，这里的RedisConnectionFactory是一个接口，<br>我们需要使用它的实现类，在SpringD Data Redis方案中提供了一下四种工厂模型）</p><ul><li><code>JredisConnectionFactory</code></li><li><code>JedisConnectionFactory</code></li><li><code>LettuceConnectionFactory</code></li><li><code>SrpConnectionFactory</code></li></ul></li><li><p>RedisTemplate</p></li></ol><h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="所需配置"><a href="#所需配置" class="headerlink" title="所需配置"></a>所需配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:    redis:      host: 127.0.0.1       port: 6379      password: 123456      jedis:        pool:          max-active: 8          max-wait: -1          max-idle: 500          min-idle: 0      lettuce:        shutdown-timeout: 0</code></pre></div></figure><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTestpublic class Test_1&#123;    @Autowired    private RedisTemplate&lt;String,String&gt;redisTemplate;    @Test    public void set()&#123;        redisTemplate.opsForValue().set(&quot;myKey&quot;,&quot;myValue&quot;);        System.out.println(redisTemplate.opsForValue().get(&quot;myKey&quot;));    &#125;&#125;</code></pre></div></figure><p>这里想要保存对象还需设置序列化器！序列化器有很多，这里不再说明，请自行百度。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合minio文件系统实现上传下载和分享文件</title>
    <link href="/doc/84f51c8e.html"/>
    <url>/doc/84f51c8e.html</url>
    
    <content type="html"><![CDATA[<h2 id="搭建minio服务器"><a href="#搭建minio服务器" class="headerlink" title="搭建minio服务器"></a>搭建minio服务器</h2><p>这个我在另一篇中有说明，这里不再赘述。</p><h2 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--必要的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.minio&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;minio&lt;&#x2F;artifactId&gt;    &lt;version&gt;7.0.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--可选的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="必要的配置"><a href="#必要的配置" class="headerlink" title="必要的配置"></a>必要的配置</h2><ul><li>文件上传配置</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  servlet:    multipart:      max-file-size: 5MB      max-request-size: 5MB</code></pre></div></figure><ul><li>Configruation配置</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Minio配置 * * @author Cikaros QQ：1032325640 * @date 2020&#x2F;10&#x2F;29 17:18 *&#x2F;@Data@Configuration@ConfigurationProperties(prefix &#x3D; &quot;minio&quot;)&#x2F;&#x2F;这里的参数请在yml文件中配置出来public class MinioConfig &#123;    @ApiModelProperty(&quot;endPoint是一个URL，域名，IPv4或者IPv6地址&quot;)    private String endpoint;    @ApiModelProperty(&quot;TCP&#x2F;IP端口号&quot;)    private int port;    @ApiModelProperty(&quot;accessKey类似于用户ID，用于唯一标识你的账户&quot;)    private String accessKey;    @ApiModelProperty(&quot;secretKey是你账户的密码&quot;)    private String secretKey;    @ApiModelProperty(&quot;如果是true，则用的是https而不是http,默认值是true&quot;)    private Boolean secure;    @Bean    public MinioClient getMinioClient() throws InvalidEndpointException, InvalidPortException &#123;        MinioClient minioClient &#x3D; new MinioClient(endpoint, port, accessKey, secretKey, secure);        return minioClient;    &#125;&#125;</code></pre></div></figure><p>然后就可以用<code>MinioClient</code>这个类来操作Minio了，下面附上API文档，<strong>Copy过来的，不是原创！！！</strong></p><h1 id="Java-Client-API参考文档"><a href="#Java-Client-API参考文档" class="headerlink" title="Java Client API参考文档 "></a>Java Client API参考文档 <a href="https://slack.min.io/"><img src="https://slack.min.io/slack?type=svg" srcset="/img/loading.gif" lazyload alt="Slack"></a></h1><h2 id="初始化Minio-Client-object。"><a href="#初始化Minio-Client-object。" class="headerlink" title="初始化Minio Client object。"></a>初始化Minio Client object。</h2><h3 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;, &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;);</code></pre></div></figure><h3 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">MinioClient s3Client &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;s3.amazonaws.com&quot;, &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;);</code></pre></div></figure><table><thead><tr><th align="left">存储桶操作</th><th align="left">文件对象操作</th><th align="left">Presigned操作</th><th align="left">存储桶策略</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#makeBucket"><code>makeBucket</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#getObject"><code>getObject</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#presignedGetObject"><code>presignedGetObject</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#getBucketPolicy"><code>getBucketPolicy</code></a></td></tr><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#listBuckets"><code>listBuckets</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#putObject"><code>putObject</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#presignedPutObject"><code>presignedPutObject</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#setBucketPolicy"><code>setBucketPolicy</code></a></td></tr><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#bucketExists"><code>bucketExists</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#copyObject"><code>copyObject</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#presignedPostPolicy"><code>presignedPostPolicy</code></a></td><td align="left"></td></tr><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#removeBucket"><code>removeBucket</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#statObject"><code>statObject</code></a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#listObjects"><code>listObjects</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#removeObject"><code>removeObject</code></a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#listIncompleteUploads"><code>listIncompleteUploads</code></a></td><td align="left"><a href="https://docs.min.io/cn/java-client-api-reference.html#removeIncompleteUpload"><code>removeIncompleteUpload</code></a></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h2><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(String endpoint) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的endpoint以及匿名方式创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.lang.String-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(URL url) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的url以及匿名方式创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.net.URL-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(com.squareup.okhttp.HttpUrl url) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的HttpUrl以及匿名方式创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-com.squareup.okhttp.HttpUrl-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(String endpoint, String accessKey, String secretKey) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的endpoint、access key和secret key创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.lang.String-java.lang.String-java.lang.String-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(String endpoint, int port, String accessKey, String secretKey) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的endpoint、port、access key和secret key创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.lang.String-int-java.lang.String-java.lang.String-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(String endpoint, String accessKey, String secretKey, boolean secure) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的endpoint、access key、secret key和一个secure选项（是否使用https）创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.lang.String-java.lang.String-java.lang.String-boolean-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(String endpoint, int port, String accessKey, String secretKey, boolean secure) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的endpoint、port、access key、secret key和一个secure选项（是否使用https）创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.lang.String-int-java.lang.String-java.lang.String-boolean-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(com.squareup.okhttp.HttpUrl url, String accessKey, String secretKey) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的HttpUrl对象、access key、secret key创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-com.squareup.okhttp.HttpUrl-java.lang.String-java.lang.String-">查看 Javadoc</a></td></tr></tbody></table><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>public MinioClient(URL url, String accessKey, String secretKey) throws NullPointerException, InvalidEndpointException, InvalidPortException</code></td></tr><tr><td align="left">使用给定的URL对象、access key、secret key创建一个Minio client对象。</td></tr><tr><td align="left"><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#MinioClient-java.net.URL-java.lang.String-java.lang.String-">查看 Javadoc</a></td></tr></tbody></table><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>endpoint</code></td><td align="left"><em>string</em></td><td align="left">endPoint是一个URL，域名，IPv4或者IPv6地址。以下是合法的endpoints:</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><a href="https://s3.amazonaws.com/">https://s3.amazonaws.com</a></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><a href="https://play.min.io/">https://play.min.io</a></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">localhost</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">play.min.io</td></tr><tr><td align="left"><code>port</code></td><td align="left"><em>int</em></td><td align="left">TCP&#x2F;IP端口号。可选，默认值是，如果是http,则默认80端口，如果是https,则默认是443端口。</td></tr><tr><td align="left"><code>accessKey</code></td><td align="left"><em>string</em></td><td align="left">accessKey类似于用户ID，用于唯一标识你的账户。</td></tr><tr><td align="left"><code>secretKey</code></td><td align="left"><em>string</em></td><td align="left">secretKey是你账户的密码。</td></tr><tr><td align="left"><code>secure</code></td><td align="left"><em>boolean</em></td><td align="left">如果是true，则用的是https而不是http,默认值是true。</td></tr><tr><td align="left"><code>url</code></td><td align="left"><em>URL</em></td><td align="left">Endpoint URL对象。</td></tr><tr><td align="left"><code>url</code></td><td align="left"><em>HttpURL</em></td><td align="left">Endpoint HttpUrl对象。</td></tr></tbody></table><p><strong>示例</strong></p><h3 id="MinIO-1"><a href="#MinIO-1" class="headerlink" title="MinIO"></a>MinIO</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 1. public MinioClient(String endpoint)MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;);&#x2F;&#x2F; 2. public MinioClient(URL url)MinioClient minioClient &#x3D; new MinioClient(new URL(&quot;https:&#x2F;&#x2F;play.min.io&quot;));&#x2F;&#x2F; 3. public MinioClient(com.squareup.okhttp.HttpUrl url) MinioClient minioClient &#x3D; new MinioClient(new HttpUrl.parse(&quot;https:&#x2F;&#x2F;play.min.io&quot;));&#x2F;&#x2F; 4. public MinioClient(String endpoint, String accessKey, String secretKey)MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;, &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;);&#x2F;&#x2F; 5. public MinioClient(String endpoint, int port,  String accessKey, String secretKey)MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;, 9000, &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;);&#x2F;&#x2F; 6. public MinioClient(String endpoint, String accessKey, String secretKey, boolean insecure)MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;, &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;, true);&#x2F;&#x2F; 7. public MinioClient(String endpoint, int port,  String accessKey, String secretKey, boolean insecure)MinioClient minioClient &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;play.min.io&quot;, 9000, &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;, true);&#x2F;&#x2F; 8. public MinioClient(com.squareup.okhttp.HttpUrl url, String accessKey, String secretKey) MinioClient minioClient &#x3D; new MinioClient(new URL(&quot;https:&#x2F;&#x2F;play.min.io&quot;), &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;);&#x2F;&#x2F; 9. public MinioClient(URL url, String accessKey, String secretKey)MinioClient minioClient &#x3D; new MinioClient(HttpUrl.parse(&quot;https:&#x2F;&#x2F;play.min.io&quot;), &quot;Q3AM3UQ867SPQQA43P2F&quot;, &quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;);</code></pre></div></figure><h3 id="AWS-S3-1"><a href="#AWS-S3-1" class="headerlink" title="AWS S3"></a>AWS S3</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 1. public MinioClient(String endpoint)MinioClient s3Client &#x3D; new MinioClient(&quot;https:&#x2F;&#x2F;s3.amazonaws.com&quot;);&#x2F;&#x2F; 2. public MinioClient(URL url)MinioClient minioClient &#x3D; new MinioClient(new URL(&quot;https:&#x2F;&#x2F;s3.amazonaws.com&quot;));&#x2F;&#x2F; 3. public MinioClient(com.squareup.okhttp.HttpUrl url) MinioClient s3Client &#x3D; new MinioClient(new HttpUrl.parse(&quot;https:&#x2F;&#x2F;s3.amazonaws.com&quot;));&#x2F;&#x2F; 4. public MinioClient(String endpoint, String accessKey, String secretKey)MinioClient s3Client &#x3D; new MinioClient(&quot;s3.amazonaws.com&quot;, &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;);&#x2F;&#x2F; 5. public MinioClient(String endpoint, int port,  String accessKey, String secretKey)MinioClient s3Client &#x3D; new MinioClient(&quot;s3.amazonaws.com&quot;, 80, &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;);&#x2F;&#x2F; 6. public MinioClient(String endpoint, String accessKey, String secretKey, boolean insecure)MinioClient s3Client &#x3D; new MinioClient(&quot;s3.amazonaws.com&quot;, &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;, false);&#x2F;&#x2F; 7. public MinioClient(String endpoint, int port,  String accessKey, String secretKey, boolean insecure)MinioClient s3Client &#x3D; new MinioClient(&quot;s3.amazonaws.com&quot;, 80, &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;,false);&#x2F;&#x2F; 8. public MinioClient(com.squareup.okhttp.HttpUrl url, String accessKey, String secretKey) MinioClient s3Client &#x3D; new MinioClient(new URL(&quot;s3.amazonaws.com&quot;), &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;);&#x2F;&#x2F; 9. public MinioClient(URL url, String accessKey, String secretKey)MinioClient s3Client &#x3D; new MinioClient(HttpUrl.parse(&quot;s3.amazonaws.com&quot;), &quot;YOUR-ACCESSKEYID&quot;, &quot;YOUR-SECRETACCESSKEY&quot;);</code></pre></div></figure><h2 id="2-存储桶操作"><a href="#2-存储桶操作" class="headerlink" title="2. 存储桶操作"></a>2. 存储桶操作</h2><h3 id="makeBucket-String-bucketName"><a href="#makeBucket-String-bucketName" class="headerlink" title="makeBucket(String bucketName)"></a>makeBucket(String bucketName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void makeBucket(String bucketName);</code></pre></div></figure><p>创建一个新的存储桶</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#makeBucket-java.lang.String-">查看Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>None</code></td><td align="left">异常列表:</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 非法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部异常</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 如存储桶不存在，创建之。  boolean found &#x3D; minioClient.bucketExists(&quot;mybucket&quot;);  if (found) &#123;    System.out.println(&quot;mybucket already exists&quot;);  &#125; else &#123;    &#x2F;&#x2F; 创建名为&#39;my-bucketname&#39;的存储桶。    minioClient.makeBucket(&quot;mybucket&quot;);    System.out.println(&quot;mybucket is created successfully&quot;);  &#125;&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="listBuckets"><a href="#listBuckets" class="headerlink" title="listBuckets()"></a>listBuckets()</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Bucket&gt; listBuckets()</code></pre></div></figure><p>列出所有存储桶。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#listBuckets--">查看Javadoc</a></p><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>List Bucket</code> : List of bucket type.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务端无响应</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> :执行失败异溃</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 列出所有存储桶  List&lt;Bucket&gt; bucketList &#x3D; minioClient.listBuckets();  for (Bucket bucket : bucketList) &#123;    System.out.println(bucket.creationDate() + &quot;, &quot; + bucket.name());  &#125;&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="bucketExists-String-bucketName"><a href="#bucketExists-String-bucketName" class="headerlink" title="bucketExists(String bucketName)"></a>bucketExists(String bucketName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean bucketExists(String bucketName)</code></pre></div></figure><p>检查存储桶是否存在。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#bucketExists-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称</td></tr></tbody></table><table><thead><tr><th align="left">返回值值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>boolean</code>: true if the bucket exists</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 检查&#39;my-bucketname&#39;是否存在。  boolean found &#x3D; minioClient.bucketExists(&quot;mybucket&quot;);  if (found) &#123;    System.out.println(&quot;mybucket exists&quot;);  &#125; else &#123;    System.out.println(&quot;mybucket does not exist&quot;);  &#125;&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="removeBucket-String-bucketName"><a href="#removeBucket-String-bucketName" class="headerlink" title="removeBucket(String bucketName)"></a>removeBucket(String bucketName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void removeBucket(String bucketName)</code></pre></div></figure><p>删除一个存储桶。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#removeBucket-java.lang.String-">查看 Javadoc</a></p><p>注意: - removeBucket不会删除存储桶里的对象，你需要通过removeObject API来删除它们。</p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 删除之前先检查&#96;my-bucket&#96;是否存在。  boolean found &#x3D; minioClient.bucketExists(&quot;mybucket&quot;);  if (found) &#123;    &#x2F;&#x2F; 删除&#96;my-bucketname&#96;存储桶，注意，只有存储桶为空时才能删除成功。    minioClient.removeBucket(&quot;mybucket&quot;);    System.out.println(&quot;mybucket is removed successfully&quot;);  &#125; else &#123;    System.out.println(&quot;mybucket does not exist&quot;);  &#125;&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="listObjects-String-bucketName-String-prefix-boolean-recursive-boolean-useVersion1"><a href="#listObjects-String-bucketName-String-prefix-boolean-recursive-boolean-useVersion1" class="headerlink" title="listObjects(String bucketName, String prefix, boolean recursive, boolean useVersion1)"></a>listObjects(String bucketName, String prefix, boolean recursive, boolean useVersion1)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Iterable&lt;Result&lt;Item&gt;&gt; listObjects(String bucketName, String prefix, boolean recursive, boolean useVersion1)</code></pre></div></figure><p>列出某个存储桶中的所有对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#listObjects-java.lang.String-java.lang.String-boolean-">查看Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>prefix</code></td><td align="left"><em>String</em></td><td align="left">对象名称的前缀</td></tr><tr><td align="left"><code>recursive</code></td><td align="left"><em>boolean</em></td><td align="left">是否递归查找，如果是false,就模拟文件夹结构查找。</td></tr><tr><td align="left"><code>useVersion1</code></td><td align="left"><em>boolean</em></td><td align="left">如果是true, 使用版本1 REST API</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>Iterable&lt;Result&lt;Item&gt;&gt;</code>:an iterator of Result Items.</td><td align="left"><em>None</em></td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 检查&#39;mybucket&#39;是否存在。  boolean found &#x3D; minioClient.bucketExists(&quot;mybucket&quot;);  if (found) &#123;    &#x2F;&#x2F; 列出&#39;my-bucketname&#39;里的对象    Iterable&lt;Result&lt;Item&gt;&gt; myObjects &#x3D; minioClient.listObjects(&quot;mybucket&quot;);    for (Result&lt;Item&gt; result : myObjects) &#123;      Item item &#x3D; result.get();      System.out.println(item.lastModified() + &quot;, &quot; + item.size() + &quot;, &quot; + item.objectName());    &#125;  &#125; else &#123;    System.out.println(&quot;mybucket does not exist&quot;);  &#125;&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="listIncompleteUploads-String-bucketName-String-prefix-boolean-recursive"><a href="#listIncompleteUploads-String-bucketName-String-prefix-boolean-recursive" class="headerlink" title="listIncompleteUploads(String bucketName, String prefix, boolean recursive)"></a>listIncompleteUploads(String bucketName, String prefix, boolean recursive)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Iterable&lt;Result&lt;Upload&gt;&gt; listIncompleteUploads(String bucketName, String prefix, boolean recursive)</code></pre></div></figure><p>列出存储桶中被部分上传的对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#listIncompleteUploads-java.lang.String-java.lang.String-boolean-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>prefix</code></td><td align="left"><em>String</em></td><td align="left">对象名称的前缀，列出有该前缀的对象</td></tr><tr><td align="left"><code>recursive</code></td><td align="left"><em>boolean</em></td><td align="left">是否递归查找，如果是false,就模拟文件夹结构查找。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>Iterable&lt;Result&lt;Upload&gt;&gt;</code>: an iterator of Upload.</td><td align="left"><em>None</em></td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 检查&#39;mybucket&#39;是否存在。  boolean found &#x3D; minioClient.bucketExists(&quot;mybucket&quot;);  if (found) &#123;    &#x2F;&#x2F; 列出&#39;mybucket&#39;中所有未完成的multipart上传的的对象。     Iterable&lt;Result&lt;Upload&gt;&gt; myObjects &#x3D; minioClient.listIncompleteUploads(&quot;mybucket&quot;);    for (Result&lt;Upload&gt; result : myObjects) &#123;      Upload upload &#x3D; result.get();      System.out.println(upload.uploadId() + &quot;, &quot; + upload.objectName());    &#125;  &#125; else &#123;    System.out.println(&quot;mybucket does not exist&quot;);  &#125;&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="getBucketPolicy-String-bucketName-String-objectPrefix"><a href="#getBucketPolicy-String-bucketName-String-objectPrefix" class="headerlink" title="getBucketPolicy(String bucketName, String objectPrefix)"></a>getBucketPolicy(String bucketName, String objectPrefix)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public PolicyType getBucketPolicy(String bucketName, String objectPrefix)</code></pre></div></figure><p>获得指定对象前缀的存储桶策略。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getBucketPolicy-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectPrefix</code></td><td align="left"><em>String</em></td><td align="left">策略适用的对象的前缀</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>PolicyType</code>: The current bucket policy type for a given bucket and objectPrefix.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidObjectPrefixException</code> : 不合法的对象前缀</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchAlgorithmException</code> : 找不到相应的签名算法。</td></tr><tr><td align="left"></td><td align="left"><code>InsufficientDataException</code> : 在读到相应length之前就得到一个EOFException。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  System.out.println(&quot;Current policy: &quot; + minioClient.getBucketPolicy(&quot;myBucket&quot;, &quot;downloads&quot;));&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="setBucketPolicy-String-bucketName-String-objectPrefix-PolicyType-policy"><a href="#setBucketPolicy-String-bucketName-String-objectPrefix-PolicyType-policy" class="headerlink" title="setBucketPolicy(String bucketName, String objectPrefix, PolicyType policy)"></a>setBucketPolicy(String bucketName, String objectPrefix, PolicyType policy)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setBucketPolicy(String bucketName, String objectPrefix, PolicyType policy)</code></pre></div></figure><p>给一个存储桶+对象前缀设置策略。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#setBucketPolicy-java.lang.String-java.lang.String-io.minio.BucketPolicy-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectPrefix</code></td><td align="left"><em>String</em></td><td align="left">对象前缀。</td></tr><tr><td align="left"><code>policy</code></td><td align="left"><em>PolicyType</em></td><td align="left">要赋予的策略，可选值有[PolicyType.NONE, PolicyType.READ_ONLY, PolicyType.READ_WRITE, PolicyType.WRITE_ONLY].</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidObjectPrefixException</code> : 不合法的对象前缀</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchAlgorithmException</code> : 找不到相应的签名算法。</td></tr><tr><td align="left"></td><td align="left"><code>InsufficientDataException</code> : 在读到相应length之前就得到一个EOFException。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  minioClient.setBucketPolicy(&quot;myBucket&quot;, &quot;uploads&quot;, PolicyType.READ_ONLY);&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h2 id="3-Object-operations"><a href="#3-Object-operations" class="headerlink" title="3. Object operations"></a>3. Object operations</h2><h3 id="getObject-String-bucketName-String-objectName"><a href="#getObject-String-bucketName-String-objectName" class="headerlink" title="getObject(String bucketName, String objectName)"></a>getObject(String bucketName, String objectName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public InputStream getObject(String bucketName, String objectName, long offset)</code></pre></div></figure><p>以流的形式下载一个对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getObject-java.lang.String-java.lang.String-long-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>InputStream</code>: InputStream containing the object data.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 调用statObject()来判断对象是否存在。  &#x2F;&#x2F; 如果不存在, statObject()抛出异常,  &#x2F;&#x2F; 否则则代表对象存在。  minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  &#x2F;&#x2F; 获取&quot;myobject&quot;的输入流。  InputStream stream &#x3D; minioClient.getObject(&quot;mybucket&quot;, &quot;myobject&quot;);  &#x2F;&#x2F; 读取输入流直到EOF并打印到控制台。  byte[] buf &#x3D; new byte[16384];  int bytesRead;  while ((bytesRead &#x3D; stream.read(buf, 0, buf.length)) &gt;&#x3D; 0) &#123;    System.out.println(new String(buf, 0, bytesRead));  &#125;  &#x2F;&#x2F; 关闭流，此处为示例，流关闭最好放在finally块。  stream.close();&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="getObject-String-bucketName-String-objectName-long-offset-Long-length"><a href="#getObject-String-bucketName-String-objectName-long-offset-Long-length" class="headerlink" title="getObject(String bucketName, String objectName, long offset, Long length)"></a>getObject(String bucketName, String objectName, long offset, Long length)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public InputStream getObject(String bucketName, String objectName, long offset, Long length)</code></pre></div></figure><p>下载对象指定区域的字节数组做为流。（断点下载）</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getObject-java.lang.String-java.lang.String-long-java.lang.Long-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>offset</code></td><td align="left"><em>Long</em></td><td align="left"><code>offset</code> 是起始字节的位置</td></tr><tr><td align="left"><code>length</code></td><td align="left"><em>Long</em></td><td align="left"><code>length</code>是要读取的长度 (可选，如果无值则代表读到文件结尾)。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>InputStream</code> : InputStream containing the object’s data.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 调用statObject()来判断对象是否存在。  &#x2F;&#x2F; 如果不存在, statObject()抛出异常,  &#x2F;&#x2F; 否则则代表对象存在。  minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  &#x2F;&#x2F; 获取指定offset和length的&quot;myobject&quot;的输入流。  InputStream stream &#x3D; minioClient.getObject(&quot;mybucket&quot;, &quot;myobject&quot;, 1024L, 4096L);  &#x2F;&#x2F; 读取输入流直到EOF并打印到控制台。  byte[] buf &#x3D; new byte[16384];  int bytesRead;  while ((bytesRead &#x3D; stream.read(buf, 0, buf.length)) &gt;&#x3D; 0) &#123;    System.out.println(new String(buf, 0, bytesRead));  &#125;  &#x2F;&#x2F; 关闭流。  stream.close();&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="getObject-String-bucketName-String-objectName-String-fileName"><a href="#getObject-String-bucketName-String-objectName-String-fileName" class="headerlink" title="getObject(String bucketName, String objectName, String fileName)"></a>getObject(String bucketName, String objectName, String fileName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void getObject(String bucketName, String objectName, String fileName)</code></pre></div></figure><p>下载并将文件保存到本地。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getObject-java.lang.String-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>fileName</code></td><td align="left"><em>String</em></td><td align="left">File name.</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 调用statObject()来判断对象是否存在。  &#x2F;&#x2F; 如果不存在, statObject()抛出异常,  &#x2F;&#x2F; 否则则代表对象存在。  minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  &#x2F;&#x2F; 获取myobject的流并保存到photo.jpg文件中。  minioClient.getObject(&quot;mybucket&quot;, &quot;myobject&quot;, &quot;photo.jpg&quot;);&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="getObject-String-bucketName-String-objectName-SecretKey-key"><a href="#getObject-String-bucketName-String-objectName-SecretKey-key" class="headerlink" title="getObject(String bucketName, String objectName, SecretKey key)"></a>getObject(String bucketName, String objectName, SecretKey key)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public CipherInputStream getObject(String bucketName, String objectName, SecretKey key)</code></pre></div></figure><p>在给定的存储桶中获取整个加密对象的数据作为InputStream，然后用传入的master key解密和加密对象关联的content key。然后创建一个含有InputStream和Cipher的CipherInputStream。这个Cipher被初始为用于使用content key进行解密，所以CipherInputStream会在返回数据前，尝试读取数据并进行解密。所以read()方法返回的是处理过的原始对象数据。</p><p>CipherInputStream必须用完关闭，否则连接不会被释放。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getObject-java.lang.String-java.lang.String-javax.crypto.SecretKey-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>key</code></td><td align="left"><em>SecretKey</em></td><td align="left"><a href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/SecretKey.html">SecretKey</a>类型的数据。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidEncryptionMetadataException</code> : 加密秘钥错误。</td></tr><tr><td align="left"></td><td align="left"><code>BadPaddingException</code> : 错误的padding</td></tr><tr><td align="left"></td><td align="left"><code>IllegalBlockSizeException</code> : 不正确的block size</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchPaddingException</code> : 错误的pading类型</td></tr><tr><td align="left"></td><td align="left"><code>InvalidAlgorithmParameterException</code> : 该算法不存在</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 调用statObject()来判断对象是否存在。  &#x2F;&#x2F; 如果不存在, statObject()抛出异常,  &#x2F;&#x2F; 否则则代表对象存在。  minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  &#x2F;&#x2F;生成256位AES key。  KeyGenerator symKeyGenerator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);  symKeyGenerator.init(256);  SecretKey symKey &#x3D; symKeyGenerator.generateKey();  &#x2F;&#x2F; 获取对象数据并保存到photo.jpg  InputStream stream &#x3D; minioClient.getObject(&quot;testbucket&quot;, &quot;my-objectname&quot;, symKey);  &#x2F;&#x2F; 读流到EOF，并输出到控制台。  byte[] buf &#x3D; new byte[16384];  int bytesRead;  while ((bytesRead &#x3D; stream.read(buf, 0, buf.length)) &gt;&#x3D; 0) &#123;    System.out.println(new String(buf, 0, bytesRead, StandardCharsets.UTF_8));  &#125;  &#x2F;&#x2F; 关闭流。  stream.close();&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="getObject-String-bucketName-String-objectName-KeyPair-key"><a href="#getObject-String-bucketName-String-objectName-KeyPair-key" class="headerlink" title="getObject(String bucketName, String objectName, KeyPair key)"></a>getObject(String bucketName, String objectName, KeyPair key)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public InputStream getObject(String bucketName, String objectName, KeyPair key)</code></pre></div></figure><p>在给定的存储桶中获取整个加密对象的数据作为InputStream，然后用传入的master keyPair解密和加密对象关联的content key。然后创建一个含有InputStream和Cipher的CipherInputStream。这个Cipher被初始为用于使用content key进行解密，所以CipherInputStream会在返回数据前，尝试读取数据并进行解密。所以read()方法返回的是处理过的原始对象数据。</p><p>CipherInputStream必须用完关闭，否则连接不会被释放。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#getObject-java.lang.String-java.lang.String-java.security.KeyPair-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>key</code></td><td align="left"><em>KeyPair</em></td><td align="left">RSA <a href="https://docs.oracle.com/javase/7/docs/api/java/security/KeyPair.html">KeyPair</a>类型的对象。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidEncryptionMetadataException</code> : 加密秘钥错误。</td></tr><tr><td align="left"></td><td align="left"><code>BadPaddingException</code> : 错误的padding</td></tr><tr><td align="left"></td><td align="left"><code>IllegalBlockSizeException</code> : 不正确的block size</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchPaddingException</code> : 错误的pading类型</td></tr><tr><td align="left"></td><td align="left"><code>InvalidAlgorithmParameterException</code> : 该算法不存在</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 调用statObject()来判断对象是否存在。  &#x2F;&#x2F; 如果不存在, statObject()抛出异常,  &#x2F;&#x2F; 否则则代表对象存在。  minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  KeyPairGenerator keyGenerator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);  keyGenerator.initialize(1024, new SecureRandom());  KeyPair keypair &#x3D; keyGenerator.generateKeyPair();  &#x2F;&#x2F; 获取对象数据并保存到photo.jpg  InputStream stream &#x3D; minioClient.getObject(&quot;testbucket&quot;, &quot;my-objectname&quot;, keypair);  &#x2F;&#x2F; 读流到EOF，并输出到控制台。  byte[] buf &#x3D; new byte[16384];  int bytesRead;  while ((bytesRead &#x3D; stream.read(buf, 0, buf.length)) &gt;&#x3D; 0) &#123;    System.out.println(new String(buf, 0, bytesRead, StandardCharsets.UTF_8));  &#125;  &#x2F;&#x2F; 关闭流。  stream.close();&#125; catch (MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType"><a href="#putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType" class="headerlink" title="putObject(String bucketName, String objectName, InputStream stream, long size, String contentType)"></a>putObject(String bucketName, String objectName, InputStream stream, long size, String contentType)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void putObject(String bucketName, String objectName, InputStream stream, long size, String contentType)</code></pre></div></figure><p>通过InputStream上传对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#putObject-java.lang.String-java.lang.String-java.io.InputStream-long-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>stream</code></td><td align="left"><em>InputStream</em></td><td align="left">要上传的流。</td></tr><tr><td align="left"><code>size</code></td><td align="left"><em>long</em></td><td align="left">要上传的<code>stream</code>的size</td></tr><tr><td align="left"><code>contentType</code></td><td align="left"><em>String</em></td><td align="left">Content type。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><p>单个对象的最大大小限制在5TB。putObject在对象大于5MiB时，自动使用multiple parts方式上传。这样，当上传失败时，客户端只需要上传未成功的部分即可（类似断点上传）。上传的对象使用MD5SUM签名进行完整性验证。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  StringBuilder builder &#x3D; new StringBuilder();  for (int i &#x3D; 0; i &lt; 1000; i++) &#123;    builder.append(&quot;Sphinx of black quartz, judge my vow: Used by Adobe InDesign to display font samples. &quot;);    builder.append(&quot;(29 letters)\n&quot;);    builder.append(&quot;Jackdaws love my big sphinx of quartz: Similarly, used by Windows XP for some fonts. &quot;);    builder.append(&quot;(31 letters)\n&quot;);    builder.append(&quot;Pack my box with five dozen liquor jugs: According to Wikipedia, this one is used on &quot;);    builder.append(&quot;NASAs Space Shuttle. (32 letters)\n&quot;);    builder.append(&quot;The quick onyx goblin jumps over the lazy dwarf: Flavor text from an Unhinged Magic Card. &quot;);    builder.append(&quot;(39 letters)\n&quot;);    builder.append(&quot;How razorback-jumping frogs can level six piqued gymnasts!: Not going to win any brevity &quot;);    builder.append(&quot;awards at 49 letters long, but old-time Mac users may recognize it.\n&quot;);    builder.append(&quot;Cozy lummox gives smart squid who asks for job pen: A 41-letter tester sentence for Mac &quot;);    builder.append(&quot;computers after System 7.\n&quot;);    builder.append(&quot;A few others we like: Amazingly few discotheques provide jukeboxes; Now fax quiz Jack! my &quot;);    builder.append(&quot;brave ghost pled; Watch Jeopardy!, Alex Trebeks fun TV quiz game.\n&quot;);    builder.append(&quot;- --\n&quot;);  &#125;  ByteArrayInputStream bais &#x3D; new  ByteArrayInputStream(builder.toString().getBytes(&quot;UTF-8&quot;));  &#x2F;&#x2F; 创建对象  minioClient.putObject(&quot;mybucket&quot;, &quot;myobject&quot;, bais, bais.available(), &quot;application&#x2F;octet-stream&quot;);  bais.close();  System.out.println(&quot;myobject is uploaded successfully&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="putObject-String-bucketName-String-objectName-String-fileName"><a href="#putObject-String-bucketName-String-objectName-String-fileName" class="headerlink" title="putObject(String bucketName, String objectName, String fileName)"></a>putObject(String bucketName, String objectName, String fileName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">public void putObject(String bucketName, String objectName, String fileName)</code></pre></div></figure><p>通过文件上传到对象中。<br><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#putObject-java.lang.String-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>fileName</code></td><td align="left"><em>String</em></td><td align="left">File name.</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  minioClient.putObject(&quot;mybucket&quot;,  &quot;island.jpg&quot;, &quot;&#x2F;mnt&#x2F;photos&#x2F;island.jpg&quot;)  System.out.println(&quot;island.jpg is uploaded successfully&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType-SecretKey-key"><a href="#putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType-SecretKey-key" class="headerlink" title="putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, SecretKey key)"></a>putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, SecretKey key)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, SecretKey key)</code></pre></div></figure><p>拿到流的数据，使用随机生成的content key进行加密，并上传到指定存储桶中。同时将加密后的content key和iv做为加密对象有header也上传到存储桶中。content key使用传入到该方法的master key进行加密。</p><p>如果对象大于5MB,客户端会自动进行multi part上传。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#putObject-java.lang.String-java.lang.String-java.io.InputStream-long-java.lang.String-javax.crypto.SecretKey-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>stream</code></td><td align="left"><em>InputStream</em></td><td align="left">要上传的流。</td></tr><tr><td align="left"><code>size</code></td><td align="left"><em>long</em></td><td align="left">要上传的流的大小。</td></tr><tr><td align="left"><code>contentType</code></td><td align="left"><em>String</em></td><td align="left">Content type。</td></tr><tr><td align="left"><code>key</code></td><td align="left"><em>SecretKey</em></td><td align="left">用AES初使化的对象<a href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/SecretKey.html">SecretKey</a>。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidAlgorithmParameterException</code> : 错误的加密算法。</td></tr><tr><td align="left"></td><td align="left"><code>BadPaddingException</code> : 不正确的padding.</td></tr><tr><td align="left"></td><td align="left"><code>IllegalBlockSizeException</code> : 不正确的block。</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchPaddingException</code> : 错误的padding类型。</td></tr></tbody></table><p><strong>示例</strong></p><p>对象使用随机生成的key进行加密，然后这个用于加密数据的key又被由仅被client知道的master key(封装在encryptionMaterials对象里)进行加密。这个被加密后的key和IV做为对象的header和加密后的对象一起被上传到存储服务上。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  StringBuilder builder &#x3D; new StringBuilder();  for (int i &#x3D; 0; i &lt; 1000; i++) &#123;    builder.append(&quot;Sphinx of black quartz, judge my vow: Used by Adobe InDesign to display font samples. &quot;);    builder.append(&quot;(29 letters)\n&quot;);    builder.append(&quot;Jackdaws love my big sphinx of quartz: Similarly, used by Windows XP for some fonts. &quot;);    builder.append(&quot;(31 letters)\n&quot;);    builder.append(&quot;Pack my box with five dozen liquor jugs: According to Wikipedia, this one is used on &quot;);    builder.append(&quot;NASAs Space Shuttle. (32 letters)\n&quot;);    builder.append(&quot;The quick onyx goblin jumps over the lazy dwarf: Flavor text from an Unhinged Magic Card. &quot;);    builder.append(&quot;(39 letters)\n&quot;);    builder.append(&quot;How razorback-jumping frogs can level six piqued gymnasts!: Not going to win any brevity &quot;);    builder.append(&quot;awards at 49 letters long, but old-time Mac users may recognize it.\n&quot;);    builder.append(&quot;Cozy lummox gives smart squid who asks for job pen: A 41-letter tester sentence for Mac &quot;);    builder.append(&quot;computers after System 7.\n&quot;);    builder.append(&quot;A few others we like: Amazingly few discotheques provide jukeboxes; Now fax quiz Jack! my &quot;);    builder.append(&quot;brave ghost pled; Watch Jeopardy!, Alex Trebeks fun TV quiz game.\n&quot;);    builder.append(&quot;- --\n&quot;);  &#125;  ByteArrayInputStream bais &#x3D; new  ByteArrayInputStream(builder.toString().getBytes(&quot;UTF-8&quot;));  &#x2F;&#x2F;生成256位AES key.  KeyGenerator symKeyGenerator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);  symKeyGenerator.init(256);  SecretKey symKey &#x3D; symKeyGenerator.generateKey();  &#x2F;&#x2F; 创建一个对象  minioClient.putObject(&quot;mybucket&quot;, &quot;myobject&quot;, bais, bais.available(), &quot;application&#x2F;octet-stream&quot;, symKey);  bais.close();  System.out.println(&quot;myobject is uploaded successfully&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType-KeyPair-key"><a href="#putObject-String-bucketName-String-objectName-InputStream-stream-long-size-String-contentType-KeyPair-key" class="headerlink" title="putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, KeyPair key)"></a>putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, KeyPair key)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void putObject(String bucketName, String objectName, InputStream stream, long size, String contentType, KeyPair key)</code></pre></div></figure><p>拿到流的数据，使用随机生成的content key进行加密，并上传到指定存储桶中。同时将加密后的content key和iv做为加密对象有header也上传到存储桶中。content key使用传入到该方法的master key进行加密。</p><p>如果对象大于5MB,客户端会自动进行multi part上传。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#putObject-java.lang.String-java.lang.String-java.io.InputStream-long-java.lang.String-java.security.KeyPair-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>stream</code></td><td align="left"><em>InputStream</em></td><td align="left">要上传的流。</td></tr><tr><td align="left"><code>size</code></td><td align="left"><em>long</em></td><td align="left">要上传的流的大小。</td></tr><tr><td align="left"><code>contentType</code></td><td align="left"><em>String</em></td><td align="left">Content type。</td></tr><tr><td align="left"><code>key</code></td><td align="left"><em>KeyPair</em></td><td align="left">一个RSA <a href="https://docs.oracle.com/javase/7/docs/api/java/security/KeyPair.html">KeyPair</a>的对象。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidAlgorithmParameterException</code> : 错误的加密算法。</td></tr><tr><td align="left"></td><td align="left"><code>BadPaddingException</code> : 不正确的padding。</td></tr><tr><td align="left"></td><td align="left"><code>IllegalBlockSizeException</code> : 不正确的block。</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchPaddingException</code> : 错误的pading类型。</td></tr></tbody></table><p><strong>示例</strong></p><p>对象使用随机生成的key进行加密，然后这个用于加密数据的key又被由仅被client知道的master key(封装在encryptionMaterials对象里)进行加密。这个被加密后的key和IV做为对象的header和加密后的对象一起被上传到存储服务上。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  StringBuilder builder &#x3D; new StringBuilder();  for (int i &#x3D; 0; i &lt; 1000; i++) &#123;    builder.append(&quot;Sphinx of black quartz, judge my vow: Used by Adobe InDesign to display font samples. &quot;);    builder.append(&quot;(29 letters)\n&quot;);    builder.append(&quot;Jackdaws love my big sphinx of quartz: Similarly, used by Windows XP for some fonts. &quot;);    builder.append(&quot;(31 letters)\n&quot;);    builder.append(&quot;Pack my box with five dozen liquor jugs: According to Wikipedia, this one is used on &quot;);    builder.append(&quot;NASAs Space Shuttle. (32 letters)\n&quot;);    builder.append(&quot;The quick onyx goblin jumps over the lazy dwarf: Flavor text from an Unhinged Magic Card. &quot;);    builder.append(&quot;(39 letters)\n&quot;);    builder.append(&quot;How razorback-jumping frogs can level six piqued gymnasts!: Not going to win any brevity &quot;);    builder.append(&quot;awards at 49 letters long, but old-time Mac users may recognize it.\n&quot;);    builder.append(&quot;Cozy lummox gives smart squid who asks for job pen: A 41-letter tester sentence for Mac &quot;);    builder.append(&quot;computers after System 7.\n&quot;);    builder.append(&quot;A few others we like: Amazingly few discotheques provide jukeboxes; Now fax quiz Jack! my &quot;);    builder.append(&quot;brave ghost pled; Watch Jeopardy!, Alex Trebeks fun TV quiz game.\n&quot;);    builder.append(&quot;- --\n&quot;);  &#125;  ByteArrayInputStream bais &#x3D; new  ByteArrayInputStream(builder.toString().getBytes(&quot;UTF-8&quot;));  KeyPairGenerator keyGenerator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);  keyGenerator.initialize(1024, new SecureRandom());  KeyPair keypair &#x3D; keyGenerator.generateKeyPair();  &#x2F;&#x2F; Create an object  minioClient.putObject(&quot;mybucket&quot;, &quot;myobject&quot;, bais, bais.available(), &quot;application&#x2F;octet-stream&quot;, keypair);  bais.close();  System.out.println(&quot;myobject is uploaded successfully&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="statObject-String-bucketName-String-objectName"><a href="#statObject-String-bucketName-String-objectName" class="headerlink" title="statObject(String bucketName, String objectName)"></a>statObject(String bucketName, String objectName)</h3><p><em><code>public ObjectStat statObject(String bucketName, String objectName)</code></em></p><p>获取对象的元数据。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#statObject-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>ObjectStat</code>: Populated object meta data.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  &#x2F;&#x2F; 获得对象的元数据。  ObjectStat objectStat &#x3D; minioClient.statObject(&quot;mybucket&quot;, &quot;myobject&quot;);  System.out.println(objectStat);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="copyObject-String-bucketName-String-objectName-String-destBucketName-String-destObjectName-CopyConditions-cpConds-Map-metadata"><a href="#copyObject-String-bucketName-String-objectName-String-destBucketName-String-destObjectName-CopyConditions-cpConds-Map-metadata" class="headerlink" title="copyObject(String bucketName, String objectName, String destBucketName, String destObjectName, CopyConditions cpConds, Map metadata)"></a>copyObject(String bucketName, String objectName, String destBucketName, String destObjectName, CopyConditions cpConds, Map metadata)</h3><p><em><code>public void copyObject(String bucketName, String objectName, String destBucketName, String destObjectName, CopyConditions cpConds, Map&lt;String, String&gt; metadata)</code></em></p><p>从objectName指定的对象中将数据拷贝到destObjectName指定的对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#copyObject-java.lang.String-java.lang.String-java.lang.String-java.lang.String-io.minio.CopyConditions-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">源存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">源存储桶中的源对象名称。</td></tr><tr><td align="left"><code>destBucketName</code></td><td align="left"><em>String</em></td><td align="left">目标存储桶名称。</td></tr><tr><td align="left"><code>destObjectName</code></td><td align="left"><em>String</em></td><td align="left">要创建的目标对象名称,如果为空，默认为源对象名称。</td></tr><tr><td align="left"><code>copyConditions</code></td><td align="left"><em>CopyConditions</em></td><td align="left">拷贝操作的一些条件Map。</td></tr><tr><td align="left"><code>metadata</code></td><td align="left"><em>Map</em></td><td align="left">给目标对象的元数据Map。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><p>本API执行了一个服务端的拷贝操作。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;  CopyConditions copyConditions &#x3D; new CopyConditions();  copyConditions.setMatchETagNone(&quot;TestETag&quot;);  minioClient.copyObject(&quot;mybucket&quot;,  &quot;island.jpg&quot;, &quot;mydestbucket&quot;, &quot;processed.png&quot;, copyConditions);  System.out.println(&quot;island.jpg is uploaded successfully&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="removeObject-String-bucketName-String-objectName"><a href="#removeObject-String-bucketName-String-objectName" class="headerlink" title="removeObject(String bucketName, String objectName)"></a>removeObject(String bucketName, String objectName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void removeObject(String bucketName, String objectName)</code></pre></div></figure><p>删除一个对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#removeObject-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;      &#x2F;&#x2F; 从mybucket中删除myobject。      minioClient.removeObject(&quot;mybucket&quot;, &quot;myobject&quot;);      System.out.println(&quot;successfully removed mybucket&#x2F;myobject&quot;);&#125; catch (MinioException e) &#123;      System.out.println(&quot;Error: &quot; + e);&#125;</code></pre></div></figure><h3 id="removeObject-String-bucketName-Iterable-objectNames"><a href="#removeObject-String-bucketName-Iterable-objectNames" class="headerlink" title="removeObject(String bucketName, Iterable objectNames)"></a>removeObject(String bucketName, Iterable objectNames)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Iterable&lt;Result&lt;DeleteError&gt;&gt; removeObject(String bucketName, Iterable&lt;String&gt; objectNames)</code></pre></div></figure><p>删除多个对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#removeObject-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectNames</code></td><td align="left"><em>Iterable</em></td><td align="left">含有要删除的多个object名称的迭代器对象。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>Iterable&lt;Result&lt;DeleteError&gt;&gt;</code>:an iterator of Result DeleteError.</td><td align="left"><em>None</em></td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; objectNames &#x3D; new LinkedList&lt;String&gt;();objectNames.add(&quot;my-objectname1&quot;);objectNames.add(&quot;my-objectname2&quot;);objectNames.add(&quot;my-objectname3&quot;);try &#123;      &#x2F;&#x2F; 删除my-bucketname里的多个对象      for (Result&lt;DeleteError&gt; errorResult: minioClient.removeObject(&quot;my-bucketname&quot;, objectNames)) &#123;        DeleteError error &#x3D; errorResult.get();        System.out.println(&quot;Failed to remove &#39;&quot; + error.objectName() + &quot;&#39;. Error:&quot; + error.message());      &#125;&#125; catch (MinioException e) &#123;      System.out.println(&quot;Error: &quot; + e);&#125;</code></pre></div></figure><h3 id="removeIncompleteUpload-String-bucketName-String-objectName"><a href="#removeIncompleteUpload-String-bucketName-String-objectName" class="headerlink" title="removeIncompleteUpload(String bucketName, String objectName)"></a>removeIncompleteUpload(String bucketName, String objectName)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void removeIncompleteUpload(String bucketName, String objectName)</code></pre></div></figure><p>删除一个未完整上传的对象。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#removeIncompleteUpload-java.lang.String-java.lang.String-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>NoResponseException</code> : 服务器无响应。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>org.xmlpull.v1.XmlPullParserException</code> : 解析返回的XML异常。</td></tr><tr><td align="left"></td><td align="left"><code>ErrorResponseException</code> : 执行失败异常。</td></tr><tr><td align="left"></td><td align="left"><code>InternalException</code> : 内部错误。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    &#x2F;&#x2F; 从存储桶中删除名为myobject的未完整上传的对象。    minioClient.removeIncompleteUpload(&quot;mybucket&quot;, &quot;myobject&quot;);    System.out.println(&quot;successfully removed all incomplete upload session of my-bucketname&#x2F;my-objectname&quot;);&#125; catch(MinioException e) &#123;    System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h2 id="4-Presigned操作"><a href="#4-Presigned操作" class="headerlink" title="4. Presigned操作"></a>4. Presigned操作</h2><h3 id="presignedGetObject-String-bucketName-String-objectName-Integer-expires"><a href="#presignedGetObject-String-bucketName-String-objectName-Integer-expires" class="headerlink" title="presignedGetObject(String bucketName, String objectName, Integer expires)"></a>presignedGetObject(String bucketName, String objectName, Integer expires)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String presignedGetObject(String bucketName, String objectName, Integer expires)</code></pre></div></figure><p>生成一个给HTTP GET请求用的presigned URL。浏览器&#x2F;移动端的客户端可以用这个URL进行下载，即使其所在的存储桶是私有的。这个presigned URL可以设置一个失效时间，默认值是7天。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#presignedGetObject-java.lang.String-java.lang.String-java.lang.Integer-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>expiry</code></td><td align="left"><em>Integer</em></td><td align="left">失效时间（以秒为单位），默认是7天，不得大于七天。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>String</code> : string contains URL to download the object.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidKeyException</code> : 不合法的access key或者secret key。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchAlgorithmException</code> : 找不到相应的签名算法。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidExpiresRangeException</code> : presigned URL已经过期了。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    String url &#x3D; minioClient.presignedGetObject(&quot;mybucket&quot;, &quot;myobject&quot;, 60 * 60 * 24);    System.out.println(url);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="presignedPutObject-String-bucketName-String-objectName-Integer-expires"><a href="#presignedPutObject-String-bucketName-String-objectName-Integer-expires" class="headerlink" title="presignedPutObject(String bucketName, String objectName, Integer expires)"></a>presignedPutObject(String bucketName, String objectName, Integer expires)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String presignedPutObject(String bucketName, String objectName, Integer expires)</code></pre></div></figure><p>生成一个给HTTP PUT请求用的presigned URL。浏览器&#x2F;移动端的客户端可以用这个URL进行上传，即使其所在的存储桶是私有的。这个presigned URL可以设置一个失效时间，默认值是7天。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#presignedPutObject-java.lang.String-java.lang.String-java.lang.Integer-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bucketName</code></td><td align="left"><em>String</em></td><td align="left">存储桶名称。</td></tr><tr><td align="left"><code>objectName</code></td><td align="left"><em>String</em></td><td align="left">存储桶里的对象名称。</td></tr><tr><td align="left"><code>expiry</code></td><td align="left"><em>Integer</em></td><td align="left">失效时间（以秒为单位），默认是7天，不得大于七天。</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>String</code> : string contains URL to download the object.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidKeyException</code> : 不合法的access key或者secret key。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchAlgorithmException</code> : 找不到相应的签名算法。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidExpiresRangeException</code> : presigned URL已经过期了。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    String url &#x3D; minioClient.presignedPutObject(&quot;mybucket&quot;, &quot;myobject&quot;, 60 * 60 * 24);    System.out.println(url);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);&#125;</code></pre></div></figure><h3 id="presignedPostPolicy-PostPolicy-policy"><a href="#presignedPostPolicy-PostPolicy-policy" class="headerlink" title="presignedPostPolicy(PostPolicy policy)"></a>presignedPostPolicy(PostPolicy policy)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Map&lt;String,String&gt; presignedPostPolicy(PostPolicy policy)</code></pre></div></figure><p>允许给POST请求的presigned URL设置策略，比如接收对象上传的存储桶名称的策略，key名称前缀，过期策略。</p><p><a href="http://minio.github.io/minio-java/io/minio/MinioClient.html#presignedPostPolicy-io.minio.PostPolicy-">查看 Javadoc</a></p><p><strong>参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>policy</code></td><td align="left"><em>PostPolicy</em></td><td align="left">对象的post策略</td></tr></tbody></table><table><thead><tr><th align="left">返回值类型</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><code>Map</code>: Map of strings to construct form-data.</td><td align="left">异常列表：</td></tr><tr><td align="left"></td><td align="left"><code>InvalidBucketNameException</code> : 不合法的存储桶名称。</td></tr><tr><td align="left"></td><td align="left"><code>InvalidKeyException</code> : 不合法的access key或者secret key。</td></tr><tr><td align="left"></td><td align="left"><code>IOException</code> : 连接异常。</td></tr><tr><td align="left"></td><td align="left"><code>NoSuchAlgorithmException</code> : 找不到相应的签名算法。</td></tr></tbody></table><p><strong>示例</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    PostPolicy policy &#x3D; new PostPolicy(&quot;mybucket&quot;, &quot;myobject&quot;,  DateTime.now().plusDays(7));    policy.setContentType(&quot;image&#x2F;png&quot;);    Map&lt;String,String&gt; formData &#x3D; minioClient.presignedPostPolicy(policy);    System.out.print(&quot;curl -X POST &quot;);    for (Map.Entry&lt;String,String&gt; entry : formData.entrySet()) &#123;    System.out.print(&quot; -F &quot; + entry.getKey() + &quot;&#x3D;&quot; + entry.getValue());    &#125;    System.out.println(&quot; -F file&#x3D;@&#x2F;tmp&#x2F;userpic.png  https:&#x2F;&#x2F;play.min.io&#x2F;mybucket&quot;);&#125; catch(MinioException e) &#123;  System.out.println(&quot;Error occurred: &quot; + e);</code></pre></div></figure><h2 id="5-了解更多"><a href="#5-了解更多" class="headerlink" title="5. 了解更多"></a>5. 了解更多</h2><ul><li><a href="https://github.com/minio/minio-java-rest-example">创建属于你的照片API服务示例</a></li><li><a href="http://minio.github.io/minio-java/">完整的JavaDoc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MinIO</tag>
      
      <tag>文件上传</tag>
      
      <tag>文件下载</tag>
      
      <tag>文件分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-搭建minio</title>
    <link href="/doc/fe76e187.html"/>
    <url>/doc/fe76e187.html</url>
    
    <content type="html"><![CDATA[<h2 id="拉取最新稳定版"><a href="#拉取最新稳定版" class="headerlink" title="拉取最新稳定版"></a>拉取最新稳定版</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull minio&#x2F;miniodocker pull jessestuart&#x2F;minio</code></pre></div></figure><h2 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p 9000:9000 --name minio-test \    -d --restart&#x3D;always \    -e &quot;MINIO_ACCESS_KEY&#x3D;minio&quot; \    -e &quot;MINIO_SECRET_KEY&#x3D;root&quot; \    -v &#x2F;home&#x2F;data:&#x2F;data \    -v &#x2F;home&#x2F;config:&#x2F;root&#x2F;.minio \    minio&#x2F;minio \    server &#x2F;datadocker run -p 9000:9000 --name minio-test \    -e &quot;MINIO_ACCESS_KEY&#x3D;minio&quot; \    -e &quot;MINIO_SECRET_KEY&#x3D;minio123&quot; \    -v &#x2F;home&#x2F;data:&#x2F;data \    -v &#x2F;home&#x2F;config:&#x2F;root&#x2F;.minio \    jessestuart&#x2F;minio \    server &#x2F;data</code></pre></div></figure><blockquote><p>–name 后面是容器名称</p><p>MINIO_ACCESS_KEY 是登录名</p><p>MINIO_SECRET_KEY 是密码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MinIO</tag>
      
      <tag>Docker</tag>
      
      <tag>文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-swagger2</title>
    <link href="/doc/ea2ddfbe.html"/>
    <url>/doc/ea2ddfbe.html</url>
    
    <content type="html"><![CDATA[<h2 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--必要的依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;&lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;&lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--可有可无的依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;&lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;&lt;version&gt;1.9.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">   &#x2F;&#x2F;可写在@SpringBootApplication类中，也可写在@Configuration类中@Bean   public Docket createRestApi()&#123;       return new Docket(DocumentationType.SWAGGER_2)               .select()               .apis(RequestHandlerSelectors.basePackage(&quot;org.cikaros.controller&quot;))               .paths(PathSelectors.any()).build();   &#125;</code></pre></div></figure><h2 id="swagger2-注解整体说明"><a href="#swagger2-注解整体说明" class="headerlink" title="swagger2 注解整体说明"></a>swagger2 注解整体说明</h2><p><strong>用于controller类上：</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Api</td><td>对请求类的说明</td></tr></tbody></table><p><strong>用于方法上面（说明参数的含义）：</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@ApiOperation</td><td>方法的说明</td></tr><tr><td>@ApiImplicitParams、@ApiImplicitParam</td><td>方法的参数的说明；@ApiImplicitParams 用于指定单个参数的说明</td></tr></tbody></table><p><strong>用于方法上面（返回参数或对象的说明）：</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@ApiResponses、@ApiResponse</td><td>方法返回值的说明 ；@ApiResponses 用于指定单个参数的说明</td></tr></tbody></table><p><strong>对象类：</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@ApiModel</td><td>用在JavaBean类上，说明JavaBean的 用途</td></tr><tr><td>@ApiModelProperty</td><td>用在JavaBean类的属性上面，说明此属性的的含议</td></tr></tbody></table><h3 id="Api：请求类的说明"><a href="#Api：请求类的说明" class="headerlink" title="@Api：请求类的说明"></a>@Api：请求类的说明</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api：放在 请求的类上，与 @Controller 并列，说明类的作用，如用户模块，订单类等。tags&#x3D;&quot;说明该类的作用&quot;value&#x3D;&quot;该参数没什么意义，所以不需要配置&quot;</code></pre></div></figure><p>示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(tags&#x3D;&quot;订单模块&quot;)@Controllerpublic class OrderController &#123;&#125;</code></pre></div></figure><p><code>@Api</code> 其它属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的值会被覆盖</td></tr><tr><td>description</td><td>对api资源的描述</td></tr><tr><td>basePath</td><td>基本路径</td></tr><tr><td>position</td><td>如果配置多个Api 想改变显示的顺序位置</td></tr><tr><td>produces</td><td>如, “application&#x2F;json, application&#x2F;xml”</td></tr><tr><td>consumes</td><td>如, “application&#x2F;json, application&#x2F;xml”</td></tr><tr><td>protocols</td><td>协议类型，如: http, https, ws, wss.</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为true ，将在文档中隐藏</td></tr></tbody></table><h3 id="ApiOperation：方法的说明"><a href="#ApiOperation：方法的说明" class="headerlink" title="@ApiOperation：方法的说明"></a>@ApiOperation：方法的说明</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation：&quot;用在请求的方法上，说明方法的作用&quot;value&#x3D;&quot;说明方法的作用&quot;notes&#x3D;&quot;方法的备注说明&quot;</code></pre></div></figure><h3 id="ApiImplicitParams、-ApiImplicitParam：方法参数的说明"><a href="#ApiImplicitParams、-ApiImplicitParam：方法参数的说明" class="headerlink" title="@ApiImplicitParams、@ApiImplicitParam：方法参数的说明"></a>@ApiImplicitParams、@ApiImplicitParam：方法参数的说明</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiImplicitParams：用在请求的方法上，包含一组参数说明@ApiImplicitParam：对单个参数的说明        name：参数名    value：参数的说明、描述    required：参数是否必须必填    paramType：参数放在哪个地方        · query --&gt; 请求参数的获取：@RequestParam        · header --&gt; 请求参数的获取：@RequestHeader              · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable        · body（请求体）--&gt;  @RequestBody User user        · form（普通表单提交）       dataType：参数类型，默认String，其它值dataType&#x3D;&quot;Integer&quot;       defaultValue：参数的默认值</code></pre></div></figure><p>示列：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(tags&#x3D;&quot;用户模块&quot;)@Controllerpublic class UserController &#123;@ApiOperation(value&#x3D;&quot;用户登录&quot;,notes&#x3D;&quot;随边说点啥&quot;)@ApiImplicitParams(&#123;@ApiImplicitParam(name&#x3D;&quot;mobile&quot;,value&#x3D;&quot;手机号&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;),@ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;密码&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;),@ApiImplicitParam(name&#x3D;&quot;age&quot;,value&#x3D;&quot;年龄&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;,dataType&#x3D;&quot;Integer&quot;)&#125;)@PostMapping(&quot;&#x2F;login&quot;)public JsonResult login(@RequestParam String mobile, @RequestParam String password,@RequestParam Integer age)&#123;&#x2F;&#x2F;...    return JsonResult.ok(map);&#125;&#125;</code></pre></div></figure><h3 id="ApiResponses、-ApiResponse：方法返回值的状态码说明"><a href="#ApiResponses、-ApiResponse：方法返回值的状态码说明" class="headerlink" title="@ApiResponses、@ApiResponse：方法返回值的状态码说明"></a>@ApiResponses、@ApiResponse：方法返回值的状态码说明</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiResponses：方法返回对象的说明@ApiResponse：每个参数的说明    code：数字，例如400    message：信息，例如&quot;请求参数没填好&quot;    response：抛出异常的类</code></pre></div></figure><p>示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(tags&#x3D;&quot;用户模块&quot;)@Controllerpublic class UserController &#123;@ApiOperation(&quot;获取用户信息&quot;)@ApiImplicitParams(&#123;@ApiImplicitParam(paramType&#x3D;&quot;query&quot;, name&#x3D;&quot;userId&quot;, dataType&#x3D;&quot;String&quot;, required&#x3D;true, value&#x3D;&quot;用户Id&quot;)&#125;) @ApiResponses(&#123;@ApiResponse(code &#x3D; 200, message &#x3D; &quot;请求成功&quot;),@ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数没填好&quot;),@ApiResponse(code &#x3D; 404, message &#x3D; &quot;请求路径没有或页面跳转路径不对&quot;)&#125;) @ResponseBody@RequestMapping(&quot;&#x2F;list&quot;)public JsonResult list(@RequestParam String userId) &#123;...return JsonResult.ok().put(&quot;page&quot;, pageUtil);&#125;&#125;</code></pre></div></figure><h3 id="ApiModel：用于JavaBean上面，表示对JavaBean-的功能描述"><a href="#ApiModel：用于JavaBean上面，表示对JavaBean-的功能描述" class="headerlink" title="@ApiModel：用于JavaBean上面，表示对JavaBean 的功能描述"></a>@ApiModel：用于JavaBean上面，表示对JavaBean 的功能描述</h3><p><code>@ApiModel</code>的用途有2个：</p><ol><li>当请求数据描述，即 <code>@RequestBody</code> 时， 用于封装请求（包括数据的各种校验）数据；</li><li>当响应值是对象时，即 <code>@ResponseBody</code> 时，用于返回值对象的描述。</li></ol><h3 id="当请求数据描述时，-RequestBody-时的使用"><a href="#当请求数据描述时，-RequestBody-时的使用" class="headerlink" title="当请求数据描述时， @RequestBody 时的使用"></a>当请求数据描述时， <code>@RequestBody</code> 时的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModel(description &#x3D; &quot;用户登录&quot;)public class UserLoginVO implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;@ApiModelProperty(value &#x3D; &quot;用户名&quot;,required&#x3D;true)private String username;@ApiModelProperty(value &#x3D; &quot;密码&quot;,required&#x3D;true)private String password;&#x2F;&#x2F; getter&#x2F;setter省略&#125;@Api(tags&#x3D;&quot;用户模块&quot;)@Controllerpublic class UserController &#123;@ApiOperation(value &#x3D; &quot;用户登录&quot;, notes &#x3D; &quot;&quot;)@PostMapping(value &#x3D; &quot;&#x2F;login&quot;)public R login(@RequestBody UserLoginVO userLoginVO) &#123;User user&#x3D;userSerivce.login(userLoginVO);return R.okData(user);&#125;&#125;</code></pre></div></figure><h3 id="ApiModelProperty：用在JavaBean类的属性上面，说明属性的含义"><a href="#ApiModelProperty：用在JavaBean类的属性上面，说明属性的含义" class="headerlink" title="@ApiModelProperty：用在JavaBean类的属性上面，说明属性的含义"></a>@ApiModelProperty：用在JavaBean类的属性上面，说明属性的含义</h3><p>示例:</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModel(description&#x3D; &quot;返回响应数据&quot;)public class RestMessage implements Serializable&#123;@ApiModelProperty(value &#x3D; &quot;是否成功&quot;,required&#x3D;true)private boolean success&#x3D;true;@ApiModelProperty(value &#x3D; &quot;错误码&quot;)private Integer errCode;@ApiModelProperty(value &#x3D; &quot;提示信息&quot;)private String message;    @ApiModelProperty(value &#x3D; &quot;数据&quot;)private Object data;&#x2F;* getter&#x2F;setter 略*&#x2F;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swagger2</tag>
      
      <tag>文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud+Mybatis-plus+Hikari集成</title>
    <link href="/doc/cf6ecba4.html"/>
    <url>/doc/cf6ecba4.html</url>
    
    <content type="html"><![CDATA[<h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><ul><li><p>SpringBoot基础环境</p></li><li><p>数据库驱动</p></li><li><p>数据库连接池</p></li><li><p>mybatis-plus</p></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mariadb.jdbc&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mariadb-java-client&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.zaxxer&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;HikariCP&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></figure><h2 id="SpringBoot的yml配置"><a href="#SpringBoot的yml配置" class="headerlink" title="SpringBoot的yml配置"></a>SpringBoot的yml配置</h2><ol><li>配置数据源</li><li>配置数据库连接池</li><li>配置必要的mybatis-plus</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  ########-spring datasource-########  datasource:    #账号配置    url: jdbc:mariadb:&#x2F;&#x2F;xxx.xxx.xxx.xxx:3306&#x2F;xxx    username: xxx    password: xxx    driver-class-name: org.mariadb.jdbc.Driver    #hikari数据库连接池    hikari:      pool-name: Retail_HikariCP      minimum-idle: 5 #最小空闲连接数量      idle-timeout: 180000 #空闲连接存活最大时间，默认600000（10分钟）      maximum-pool-size: 10 #连接池最大连接数，默认是10      auto-commit: true  #此属性控制从池返回的连接的默认自动提交行为,默认值：true      max-lifetime: 1800000 #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟      connection-timeout: 30000 #数据库连接超时时间,默认30秒，即30000      connection-test-query: SELECT 1mybatis-plus:  typeAliasesPackage: &quot;org.cikaros.entity&quot;  mapperLocations: &quot;classpath:mapper&#x2F;*Mapper.xml&quot;</code></pre></div></figure><h2 id="必要的注解"><a href="#必要的注解" class="headerlink" title="必要的注解"></a>必要的注解</h2><p>@Mapper 这个注解的定义如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Inherited@Retention(RUNTIME)@Target(&#123; TYPE, METHOD, FIELD, PARAMETER &#125;)public @interface Mapper &#123;  &#x2F;&#x2F; Interface Mapper&#125;</code></pre></div></figure><p>@Mapper 一般我们用在接口上，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface UserDAO &#123;    @Select(&quot;select * from user where name &#x3D; #&#123;name&#125;&quot;)    User find(String name);    @Select(&quot;select * from user where name &#x3D; #&#123;name&#125; and pwd &#x3D; #&#123;pwd&#125;&quot;)    &#x2F;**      * 对于多个参数来说，每个参数之前都要加上@Param注解，      * 要不然会找不到对应的参数进而报错      *&#x2F;    User login(@Param(&quot;name&quot;)String name, @Param(&quot;pwd&quot;)String pwd);&#125;</code></pre></div></figure><p>使用 @Mapper，最终 Mybatis 会有一个拦截器，会自动的把 @Mapper 注解的接口生成动态代理类。这点可以在 MapperRegistry 类中的源代码中查看。</p><p>@Mapper 注解针对的是一个一个的类，相当于是一个一个 Mapper.xml 文件。而一个接口一个接口的使用 @Mapper，太麻烦了，于是 @MapperScan 就应用而生了。@MapperScan 配置一个或多个包路径，自动的扫描这些包路径下的类，自动的为它们生成代理类。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication  @MapperScan(&#123;&quot;com.xttblog.mapper&quot;,&quot;com.xttblog.dao&quot;&#125;)public class XttblogApp &#123;      public static void main(String[] args) &#123;         SpringApplication.run(XttblogApp.class, args);      &#125;  &#125;</code></pre></div></figure><p>当使用了 @MapperScan 注解，将会生成 MapperFactoryBean， 如果没有标注 @MapperScan 也就是没有 MapperFactoryBean 的实例，就走 @Import 里面的配置，具体可以在 AutoConfiguredMapperScannerRegistrar 和 MybatisAutoConfiguration 类中查看源代码进行分析。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>Mybatis-plus</tag>
      
      <tag>Hikari</tag>
      
      <tag>数据库连接池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud-Eureka</title>
    <link href="/doc/55a0ae6.html"/>
    <url>/doc/55a0ae6.html</url>
    
    <content type="html"><![CDATA[<p>Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。</p><img src="/doc/55a0ae6/1560439174201.png" srcset="/img/loading.gif" lazyload class=""><p><strong>分析</strong>：</p><ul><li>服务注册：在服务提供工程上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。<ul><li>添加依赖；</li><li>改造启动引导类；添加开启Eureka客户端发现的注解；</li><li>修改配置文件；设置Eureka 服务地址</li></ul></li><li>服务发现：在服务消费工程上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。<ul><li>添加依赖；</li><li>改造启动引导类；添加开启Eureka客户端发现的注解；</li><li>修改配置文件；设置Eureka 服务地址；</li><li>改造处理器类，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。</li></ul></li></ul><h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Eureka客户端依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--Eureka服务端依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><h2 id="所需配置"><a href="#所需配置" class="headerlink" title="所需配置"></a>所需配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>添加启动引导类注解<code>@EnableEurkeaServer</code></li><li>修改yml配置</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: $&#123;port:10000&#125;spring:  application:    name: eureka-servereureka:  client:    service-url:      defaultZone: $&#123;defaultZone:http:&#x2F;&#x2F;localhost:10000&#x2F;eureka&#125;    #不注册自己#    register-with-eureka: true    #不拉取服务#    fetch-registry: false  server:    #剔除时间    eviction-interval-timer-in-ms: 60000    #自我保护    enable-self-preservation: false</code></pre></div></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>添加启动引导类注解 <code>@EnableDiscoveryClient</code></li><li>修改配置yml</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: $&#123;port:8090&#125;spring:  application:    name: eureka-clienteureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;localhost:10000&#x2F;eureka      #拉取地址列表时间间隔      registry-fetch-interval-seconds: 15  instance:    ip-address: 127.0.0.1    prefer-ip-address: false    #心跳时间    lease-renewal-interval-in-seconds: 10    lease-expiration-duration-in-seconds: 60</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eureka</tag>
      
      <tag>服务注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud</title>
    <link href="/doc/96a41905.html"/>
    <url>/doc/96a41905.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Srping-Cloud"><a href="#什么是Srping-Cloud" class="headerlink" title="什么是Srping Cloud?"></a>什么是Srping Cloud?</h2><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p>微服务是一种架构方式，最终肯定需要技术架构去实施。<br>微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？</p><ul><li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li><li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li><li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？Spring Cloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li><li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而Spring Cloud完全支持Spring Boot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Cloud是Spring旗下的项目之一，官网地址：<a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>Spring Cloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等功能；协调分布式环境中各个系统，为各类服务提供模板性配置。其主要涉及的组件包括：</p><ul><li><p>Eureka：注册中心</p></li><li><p>Zuul、Gateway：服务网关</p></li><li><p>Ribbon：负载均衡</p></li><li><p>Feign：服务调用</p></li><li><p>Hystrix或Resilience4j：熔断器</p></li></ul><p>以上只是其中一部分，架构图：</p><img src="/doc/96a41905/image-20201025225201185.png" srcset="/img/loading.gif" lazyload class=""><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Spring Cloud不是一个组件，而是许多组件的集合；它的版本命名比较特殊，是以A到Z的为首字母的一些单词（其实是伦敦地铁站的名字）组成：</p><img src="/doc/96a41905/image-20201025225318129.png" srcset="/img/loading.gif" lazyload class=""><p>我们在项目中，使用最新稳定的<strong>Hoxton.SR8</strong>版本。</p><h2 id="系统架构的演变"><a href="#系统架构的演变" class="headerlink" title="系统架构的演变"></a>系统架构的演变</h2><h3 id="集中式架构"><a href="#集中式架构" class="headerlink" title="集中式架构"></a>集中式架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</p><img src="/doc/96a41905/image-20201025223816349.png" srcset="/img/loading.gif" lazyload class=""><p>优点：</p><ul><li>系统开发速度快</li><li>维护成本低</li><li>适用于并发要求较低的系统</li></ul><p>缺点：</p><ul><li>代码耦合度高，后期维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差</li></ul><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆<br>分：</p><img src="/doc/96a41905/image-20201025223957416.png" srcset="/img/loading.gif" lazyload class=""><p>优点：</p><ul><li>系统拆分实现了流量分担，解决了并发问题</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li></ul><p>缺点：</p><ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li></ul><h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，<br>使前端应用能更快速的响应多变的市场需求。</p><img src="/doc/96a41905/image-20201025224057066.png" srcset="/img/loading.gif" lazyload class=""><p>优点：</p><ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li></ul><p>缺点：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h3 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h3><p>SOA（Service Oriented Architecture）面向服务的架构：它是一种设计方法，其中包含多个服务， 服务之间通过相<br>互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在与操作系统进程中。各个服务之间 通过网络调用。<br>SOA结构图：</p><img src="/doc/96a41905/image-20201025224200805.png" srcset="/img/loading.gif" lazyload class=""><blockquote><p>ESB（企业服务总线），简单 来说 ESB 就是一根管道，用来连接各个服务节点。为了集 成不同系统，不同协<br>议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通。</p></blockquote><p><strong>SOA缺点</strong>：每个供应商提供的ESB产品有偏差，自身实现较为复杂；应用服务粒度较大，ESB集成整合所有服务和协<br>议、数据转换使得运维、测试部署困难。所有服务都通过一个通路通信，直接降低了通信速度。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><em>微服务架构</em> 是使用<em>一套小服务来开发单个应用的方式或途径</em> ，每个服务基于单一业务能力构建，运行在自己的进程<br>中，并使用轻量级机制通信，通常是HTTP API，并能够通过自动化部署机制来独立部署。这些服务可以使用不同的<br>编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。<br>微服务结构图：</p><img src="/doc/96a41905/image-20201025224324624.png" srcset="/img/loading.gif" lazyload class=""><blockquote><p>API Gateway网关是一个服务器，是系统的唯一入口。为每个客户端提供一个定制的API。API网关核心是，所<br>有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。如它还可以具有其它职<br>责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。通常，网关提供RESTful&#x2F;HTTP的<br>方式访问服务。而服务端通过服务注册中心进行服务注册和管理。</p></blockquote><p><strong>微服务的特点：</strong> </p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><p>微服务架构与SOA都是对系统进行拆分；微服务架构基于SOA思想，可以把微服务当做去除了ESB的SOA。ESB是<br>SOA架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。两者比较类似，但其实也<br>有一些差别：</p><table><thead><tr><th>功能</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>组件大小</td><td>大块业务逻辑</td><td>单独任务或小块业务逻辑</td></tr><tr><td>耦合</td><td>通常松耦合</td><td>总是松耦合</td></tr><tr><td>管理</td><td>着重中央管理</td><td>着重分散管理</td></tr><tr><td>目标</td><td>确保应用能够交互操作</td><td>易维护、易扩展、更轻量级的交互</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/doc/6f2612a2.html"/>
    <url>/doc/6f2612a2.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p>微服务（Microservice）虽然是当下刚兴起的比较流行的新名词，但本质上来说，微服务并非什么新的概念。</p><p>实际上，很多 SOA（面向服务的架构）实施成熟度比较好的企业，已经在使用和实施微服务了。只不过，它们只是在闷声发大财，并不介意是否有一个比较时髦的名词来明确表述 SOA 的这个发展演化趋势罢了。</p><p>微服务其实就是服务化思路的一种最佳实践方向，遵循 SOA 的思路，各个企业在服务化治理的道路上走的时间长了，踩的坑多了，整个软件交付链路上各个环节的基础设施逐渐成熟了，微服务自然而然就诞生了。</p><p>当然，之所以叫微服务，是与之前的服务化思路和实践相比较而来的。</p><p>早些年的服务实现和实施思路是将很多功能从开发到交付都打包成一个很大的服务单元（一般称为 Monolith），而微服务实现和实施思路则更强调功能趋向单一，服务单元小型化和微型化。</p><p>如果用“茶壶煮饺子”来打比方的话，原来我们是在一个茶壶里煮很多个饺子，现在（微服务化之后）则基本上是在一个茶壶煮一个饺子，而这些饺子就是服务的功能，茶壶则是将这些服务功能打包交付的服务单元，如图 1 所示。</p><img src="/doc/6f2612a2/5-1ZI0143635b8.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 论茶壶里煮“饺子”的不同形式</p><p>所以，从思路和理念上来讲，<strong>微服务就是要倡导大家尽量将功能进行拆分，将服务粒度做小，使之可以独立承担对外服务的职责，沿着这个思路开发和交付的软件服务实体就叫作“微服务”</strong>，而围绕着这个思路和理念构建的一系列基础设施和指导思想，笔者将它称为“微服务体系”。</p><h3 id="微服务是怎么来的？"><a href="#微服务是怎么来的？" class="headerlink" title="微服务是怎么来的？"></a>微服务是怎么来的？</h3><p>微服务的概念我们应该大体了解了，那么微服务又是怎么来的？原来将很多功能打包为一个很大的服务单元进行交付的做法不能满足需求吗？</p><p>实际上，并非原来“大一统”（Monolith）的服务化实践不能满足要求，也不是不好，只是，它有自己存在的合理场景。</p><p>对于 Monolith 服务来说，如果团队不大，软件复杂度不高，那么，使用 Monolith 的形式进行服务化治理是比较合适的，而且，这种方式对运维和各种基础设施的要求也不高。</p><p>但是，随着软件系统的复杂度持续飙升，软件交付的效率要求更高，投入的人力以及各项资源越来越多，基于 Monolith 的服务化思路就开始“捉襟见肘”。</p><p>在开发阶段，如果我们遵循 Monolith 的服务化理念，通常会将所有功能的实现都统一归到一个开发项目下，但随着功能的膨胀，这些功能一定会分发给不同的研发人员进行开发，造成的后果就是，大家在提交代码的时候频繁冲突并需要解决这些冲突，单一的开发项目成为了开发期间所有人的工作瓶颈。</p><p>为了减轻这种苦恼，我们自然会将项目按照要开发的功能拆分为不同的项目，从而负责不同功能的研发人员就可以在自己的代码项目上进行开发，从而解决了大家无法在开发阶段并行开发的苦恼。</p><p>到了软件交付阶段，如果我们遵循 Monolith 的服务化理念，那么，我们一定是将所有这些开发阶段并行开发的项目集合到一起进行交付。</p><p>这就涉及服务化早期实践中比较有名的“火车模型”，即交付的服务就像一辆火车，而这个服务相关的所有功能对应的项目成果，就是要装上火车车厢的一件件货物，交付的列车只有等到所有项目都开发测试完成后才可以装车出发，完成整个服务的交付。</p><p>很显然，只要有一个车厢没有准备好货物（即功能项目未开发测试完成），火车就不能发车，服务就不能交付，这大大降低了服务的交付效率。如果每个功能项目可以各自独立交付，那么就不需要都等同一辆火车，各自出发就可以了。</p><p>顺着这个思路，自然而然地，大家逐渐各自独立，每一个功能或者少数相近的功能作为单一项目开发完成后将作为一个独立的服务单元进行交付，从而在服务交付阶段，大家也能够并行不悖，各自演化而不受影响。</p><p>所以，随着服务和系统的复杂度逐渐飙升，为了能够在整个软件的交付链路上高效扩展，将独立的功能和服务单元进行拆分，从而形成一个一个的微服务是自然而然发生的事情。</p><p>这就像打不同的战役一样，在双方兵力不多、战场复杂度不高的情况下，Monolith 的统一指挥调度方式是合适的。而一旦要打大的战役（类似于系统复杂度提升），双方一定会投入大量的兵力（软件研发团队的规模增长），如果还是在狭小甚至固定的战场上进行厮杀，显然施展不开！</p><p>所以，小战役有小战役的打法，大战役有大战役的战法，而微服务实际上就是一种帮助扩展组织能力、提升团队效率的应对“大战役”的方法，它帮助我们从软件开发到交付，进而到团队和组织层面多方位进行扩展。</p><p><strong>总的来说，一方面微服务可以帮助我们应对飙升的系统复杂度；另一个方面，微服务可以帮助我们进行更大范围的扩展，从开发阶段项目并行开发的扩展，到交付阶段并行交付的扩展，再到相应的组织结构和组织能力的扩展，皆因微服务而受惠。</strong></p><h3 id="微服务的好处（优点）有哪些？"><a href="#微服务的好处（优点）有哪些？" class="headerlink" title="微服务的好处（优点）有哪些？"></a>微服务的好处（优点）有哪些？</h3><p>显然，随着系统复杂度的提升，以及对系统扩展性的要求越来越高，微服务化是一个很好的方向，但除此之外，微服务还会给我们带来哪些好处？</p><h4 id="独立，独立，还是独立"><a href="#独立，独立，还是独立" class="headerlink" title="独立，独立，还是独立"></a>独立，独立，还是独立</h4><p>我们说微服务打响的是各自的独立战争，所以，每一个微服务都是一个小王国，这些微服务跳出了“大一统”（Monolith）王国的统治，开始从各个层面打造自己的独立能力，从而保障自己的小王国可以持续稳固的运转。</p><p>首先，在开发层面，每个微服务基本上都是各自独立的项目（project），而对应各自独立项目的研发团队基本上也是独立对应，这样的结构保证了微服务的并行研发，并且各自快速迭代，不会因为所有研发都投入一个近乎单点的项目，从而造成开发阶段的瓶颈。开发阶段的独立，保证了微服务的研发可以高效进行。</p><p>服务开发期间的形态，跟服务交付期间的形态原则上是不需要完全高度统一的，即使我们在开发的时候都是各自进行，但交付的时候还是可以一起交付，不过这不是微服务的做法。</p><p>在微服务治理体系下，各个微服务交付期间也是各自独立交付的，从而使得每个微服务从开发到交付整条链路上都是独立进行，这大大加快了微服务的迭代和交付效率。</p><p>服务交付之后需要部署运行，对微服务来说，它们运行期间也是各自独立的。</p><p>微服务独立运行可以带来两个比较明显的好处，第一个就是可扩展性。我们可以快速地添加服务集群的实例，提升整个微服务集群的服务能力，而在传统 Monolith 模式下，为了能够提升服务能力，很多时候必须强化和扩展单一结点的服务能力来达成。如果单结点服务能力已经扩展到了极限，再寻求扩展的话，就得从软件到硬件整体进行重构。</p><p>软件行业有句话：“Threads don’t scale，Processes do！”*(如果线程不能够扩展，那就去扩展进程)*，很明确地道出了原来 Monolith 服务与微服务在扩展（Scale）层面的差异。</p><p>对于 <a href="http://c.biancheng.net/java/">Java</a> 开发者来说，早些年（当然现在也依然存在），我们遵循 Java EE 规范开发的 Web 应用，都需要以 WAR 包的形式部署到 TOMCAT、Jetty、RESIN 等 Web 容器中运行，即使每个 WAR 包提供的都是独立的微服务，但因为它们都是统一部署运行在一个 Web 容器中，所以扩展能力受限于 Web 容器作为一个进程（process）的现状。</p><p>无论如何调整 Web 容器内部实现的线程（thread）设置，还是会受限于 Web 容器整体的扩展能力。所以，现在很多情况下，大家都是一个 TOMCAT 只部署一个 WAR，然后通过复制和扩展多个 TOMCAT 实例来扩展整个应用服务集群。</p><p>当然，说到在 TOMCAT 实例中只部署一个 WAR 包这样的做法，实际上不单单只是因为扩展的因素，还涉及微服务运行期间给我们带来的第二个好处，即隔离性。</p><p>隔离性实际上是可扩展性的基础，当我们将每个微服务都隔离为独立的运行单元之后，任何一个或者多个微服务的失败都将只影响自己或者少量其他微服务，而不会大面积地波及整个服务运行体系。</p><p>在架构设计上有一种实践模式，即隔板模式（Bulkhead Pattern），这种架构<a href="http://c.biancheng.net/design_pattern/">设计模式</a>的首要目的就是为了隔离系统中的各个功能单元和实体，使得系统不会因为一个单元或者服务的失败而导致整体失败。</p><p>这种思路在造船行业、兵工行业都有类似的应用场景。现在任何大型船舶在设计上都会有隔舱，目的就是即使有少量进水，也可以只将进水部位隔离在小范围，不会扩散而导致船舶大面积进水，从而沉没。当年泰坦尼克号虽然沉了，但不意味着他们没有做隔舱设计，只能说，伤害度已经远远超出隔舱可以提供的基础保障范围。</p><p>在坦克的设计上，现在一般也会将弹药舱和乘员舱隔离，从而可以保障当坦克受创之后，将伤害尽量限定在指定区域，尽量减少对车乘成员的伤害。</p><p>前面我们提到，现在大家基本上弱化了 Java EE 的 Web 容器早期采用的“一个 Web 容器部署多个 WAR 包”的做法，转而使用“一个 Web 容器只部署一个 WAR 包”的做法，这实际上正是综合考虑了 Web 容器的设计和实现现状与真实需求之后做出的合理实践选择。</p><p>这些 Web 容器内部大多通过类加载器（Classloader）以及线程来实现一定程度上的依赖和功能隔离，但这些机制从基因上决定了这些做法不是最好的隔离手段。而进程（Process）拥有天然的隔离特性，所以，一个 WAR 包只部署运行在一个 Web 容器进程中才是最好的隔离方式。</p><p>现在回想一下，好像自从各个微服务打响独立战争并且独立之后，无论从哪个层面来看，各自“活”得都挺好。</p><h4 id="多语言生态"><a href="#多语言生态" class="headerlink" title="多语言生态"></a>多语言生态</h4><p>微服务独立之后，给了对应的团队和组织快速迭代和交付的能力，同时，也给团队和组织带来了更多的灵活性，实际上，对应交付不同微服务的团队或者组织来说，现在可以基于不同的计算机语言生态构建这些微服务，如图 1 所示。</p><p>微服务的提供者既可以使用 Java 或者 Go 等静态语言完成微服务的开发和交付，也可以使用 <a href="http://c.biancheng.net/python/">Python</a> 或者 Ruby 等动态语言完成微服务的开发和交付，对于团队内部拥有繁荣且有差异的语言文化来说，多语言生态下的微服务开发和交付将可以最大化的发挥团队和组织内部各成员的优势。</p><p>当然，对于多语言生态下的微服务研发来说，有一点需要注意：为了让服务的访问者可以用统一的接口访问所有这些用不同语言开发和交互的微服务，应该尽量统一微服务的服务接口和协议。</p><p>在微服务的生态下，互通性应该是需要重点关注的因素，没有互通，不但服务的访问者和用户无法很好地使用这些微服务，微服务和微服务之间也无法相互信赖和互助，这将大大损耗微服务研发体系带来的诸多好处，而多语言生态也会变成一种障碍和负累，而不是益处。</p><p>记得时任黑猫宅急便社长的小仓昌男在其所著的《黑猫宅急便的经营学》中提到一个故事，日本国铁曾经采用不同于国际标准的集装箱和铁路规格，然后发现货物的运输效率很低，经过考察发现，原来是货物从国际标准集装箱卸载之后，在通过日本国铁运输之前，需要先拆箱，重新装入日本国铁规格的集装箱，然后装载到日本国铁上进行运输。</p><p>但是，如果日本国铁采用国际标准的集装箱规格，那么货物集装箱从远洋轮船上卸载之后就可以直接装上国铁，这将大大加快运输效率（日本，国铁改革后也证明确实如此）。日本国铁在前期采用私有方案时，只关注了自己的利益和效率，舍弃了互通，也带来了效率的低下。</p><p>所以，在开发和交付微服务的时候，尤其是在多语言生态下开发和交付微服务，我们从一开始就要将互通性作为首要考虑因素，从而不会因为执迷于某些服务或者系统的单点效率而失去了整个微服务体系的整体效率。</p><img src="/doc/6f2612a2/5-1ZI0154041c7.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 多语言的微服务生态</p><h3 id="实现微服务会带来哪些挑战？"><a href="#实现微服务会带来哪些挑战？" class="headerlink" title="实现微服务会带来哪些挑战？"></a>实现微服务会带来哪些挑战？</h3><p>微服务给我们带来的并非只有好处，还有相应的一些挑战。</p><p>服务“微”化之后，一个显著的特点就是服务的数量增多了。如果将软件开发和交付也作为一种生产模式看待，那么数量众多的微服务实际上就类似于传统生产线上的产品，而在传统生产模型下，为了能够高效地生产大量产品，通常采用的就是标准化生产。</p><p>比如在汽车产业，在福特 T 型车没有出来之前，大多汽车企业的生产效率都不高，而福特在引入标准化生产线之后，福特 T 型车得以大量生产并以低成本优势快速普及。</p><p>在其他行业也是同样的道理，个性化生产虽然会深得个别用户的喜欢，但生产成本通常也会很高，生产效率因为受限于个性化需求，也无法从“熟能生巧”中获益，所以，最终用户需要为生产成本和效率付出更多的溢价才能获得最终产品。</p><p>而相对于个性化生产来说，标准化生产走的是另一条路，通过生产标准产品，使得整条生产链路可重复，从而提升了生产效率，可以为更广层面的用户提供大量“物美价廉”的标准产品。</p><p>微服务的研发和交付其实就类似于产品的生产链路，而数量大这一特点则决定了，我们无法通过个性化的生产模式来支撑整个微服务的交付链路和研发体系。</p><p>虽然微服务化之后，我们可以投入相应的人力和团队对应各个微服务的开发和交付，可扩展性上绝对没有问题，但这不意味着现实情况下我们就能这样做，因为这些都涉及人力和资源成本，而这往往是受限的。所以，使用标准化的思路来开发和交付微服务就变成了自然而然的选择：</p><p>通过标准化，我们可以重复使用开发阶段打造的一系列环境和工具支持。</p><p>通过标准化，我们可以复用支持整个微服务交付链路的各项基础设施。</p><p>通过标准化，我们可以减少采购差异导致的成本上升，同时更加高效地利用硬件资源。</p><p>通过标准化，我们可以用标准的协议和格式来治理和维护数量庞大的微服务。</p><p>如果你还对使用标准化的思路来构建微服务体系存有疑惑，那么，不妨再结合微服务的多语言生态特性思考一番：</p><p>增加一种语言生态用于微服务的开发和交付，我们是否要围绕着这种语言生态和微服务的需求重新搭建一套研发&#x2F;测试环境？</p><p>我们是否还要围绕着这种语言生态打造一系列的工具来提升日常开发的效率？</p><p>增加一种语言生态，我们是不是还要围绕这种语言生态搭建一套针对微服务的交付链路基础设施？</p><p>增加一种语言生态，我们是否还要围绕它提供特定的硬件环境以及运维支撑工具和平台？</p><p>多语言生态虽然灵活度高了，不同语种和思路的团队成员也能够百花齐放了，但是不是也同样带来了以上一系列的成本？</p><p>所以，很多事情你能做，并不意味着你一定要做。适度的收缩语言生态的选择范围，并围绕主要的语言生态构建一套标准化的微服务交付体系，或许是更为合理的做法。</p><p>要实施高效可重复的标准化微服务生产，我们需要有类似传统行业生产线的基础设施。否则，高效可重复的开发和交付大量的微服务就无从谈起，所以，完备的微服务研发和交付体系基础设施建设就成为了实施微服务的终极挑战。</p><p>一个公司或者组织要很好地或者说成熟地实施微服务化战略，为交付链路提供完备支撑的基础设施建设必不可少！</p><h2 id="Spring-IoC介绍"><a href="#Spring-IoC介绍" class="headerlink" title="Spring IoC介绍"></a>Spring IoC介绍</h2><p>有部分 <a href="http://c.biancheng.net/java/">Java</a> 开发者对 IoC（Inversion Of Control）和 DI（Dependency Injection）的概念有些混淆，认为二者是对等的。</p><p>IoC 其实有两种方式，一种就是 DI，而另一种是 DL，即 Dependency Lookup（依赖查找），前者是当前软件实体被动接受其依赖的其他组件被 IoC 容器注入，而后者则是当前软件实体主动去某个服务注册地查找其依赖的那些服务，概念之间的关系如图 1 所示可能更贴切些。</p><img src="/doc/6f2612a2/5-1ZI110520B60.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 IoC相关概念示意图</p><p>我们通常提到的 <a href="http://c.biancheng.net/spring/">Spring</a> IoC，实际上是指 Spring 框架提供的 IoC 容器实现（IoC Container），而使用 Spring IoC 容器的一个典型代码片段就是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class App &#123;        public static void main(String[] args) &#123;                ApplicationContext context &#x3D; new FileSystemXmlApplication-Context(&quot;...&quot;);                &#x2F;&#x2F; ...                MockService service &#x3D; context.getBean(MockService.class);                service.doSomething();        &#125;&#125;</code></pre></div></figure><p>任何一个使用 Spring 框架构建的独立的 Java 应用（Standalone Java Application），通常都会存在一行类似于<code>context.getBean(...);</code>的代码。</p><p>实际上，这行代码做的就是 DL 的工作，而构建的任何一种 IoC 容器背后（比如 BeanFactory 或者 ApplicationContext）发生的事情，则更多是 DI 的过程（也可能有部分 DL 的逻辑用于对接遗留系统）。</p><p>Spring 的 IoC 容器中发生的事情其实也很简单，总结下来即两个阶段：</p><ul><li>采摘和收集“咖啡豆”（bean）</li><li>研磨和烹饪咖啡</li></ul><p>Spring IoC 容器的依赖注入工作可以分为两个阶段：</p><h4 id="1）收集和注册"><a href="#1）收集和注册" class="headerlink" title="1）收集和注册"></a>1）收集和注册</h4><p>第一个阶段可以认为是构建和收集 bean 定义的阶段，在这个阶段中，我们可以通过 XML 或者 Java 代码的方式定义一些 bean，然后通过手动组装或者让容器基于某些机制自动扫描的形式，将这些 bean 定义收集到 IoC 容器中。</p><p>假设我们以 XML 配置的形式来收集并注册单一 bean，一般形式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt; ...&lt;&#x2F;bean&gt;</code></pre></div></figure><p>如果嫌逐个收集 bean 定义麻烦，想批量地收集并注册到 IoC 容器中，我们也可以通过 XML Schema 形式的配置进行批量扫描并采集和注册：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package&#x3D;&quot;com.keevol&quot;&gt;</code></pre></div></figure><p>注意基于 JavaConfig 形式的收集和注册，不管是单一还是批量，后面我们都会单独提及。</p><h4 id="2）分析和组装"><a href="#2）分析和组装" class="headerlink" title="2）分析和组装"></a>2）分析和组装</h4><p>当第一阶段工作完成后，我们可以先暂且认为 IoC 容器中充斥着一个个独立的 bean，它们之间没有任何关系。</p><p>但实际上，它们之间是有依赖关系的，所以，IoC 容器在第二阶段要干的事情就是分析这些已经在 IoC 容器之中的 bean，然后根据它们之间的依赖关系先后组装它们。</p><p>如果 IoC 容器发现某个 bean 依赖另一个 bean，它就会将这另一个 bean 注入给依赖它的那个 bean，直到所有 bean 的依赖都注入完成，所有 bean 都“整装待发”，整个 IoC 容器的工作即算完成。</p><p>至于分析和组装的依据，Spring 框架最早是通过 XML 配置文件的形式来描述 bean 与 bean 之间的关系的，随着 Java 业界研发技术和理念的转变，基于 Java 代码和 Annotation 元信息的描述方式也日渐兴盛（比如 <code>@Autowired</code> 和 <code>@Inject</code>），但不管使用哪种方式，都只是为了简化绑定逻辑描述的各种“表象”，最终都是为本阶段的最终目的服务。</p><p>很多 Java 开发者一定认为 Spring 的 XML 配置文件是一种配置（Configuration），但本质上，这些配置文件更应该是一种代码形式，XML 在这里其实可以看作一种 DSL（ Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>），它用来表述的是 bean 与 bean 之间的依赖绑定关系，如果没有 IoC 容器就要自己写代码新建（new）对象并配置（set）依赖。</p><h2 id="Spring-JavaConfig"><a href="#Spring-JavaConfig" class="headerlink" title="Spring JavaConfig"></a>Spring JavaConfig</h2><p><a href="http://c.biancheng.net/java/">Java</a> 5 的推出，加上当年基于纯 Java Annotation 的依赖注入框架 Guice 的出现，使得 <a href="http://c.biancheng.net/spring/">Spring</a> 框架及其社区也“顺应民意”，推出并持续完善了基于 Java 代码和 Annotation 元信息的依赖关系绑定描述方式，即 JavaConfig 项目。</p><p>基于 JavaConfig 方式的依赖关系绑定描述基本上映射了最早的基于 XML 的配置方式，比如：</p><h4 id="1）表达形式层面"><a href="#1）表达形式层面" class="headerlink" title="1）表达形式层面"></a>1）表达形式层面</h4><p>基于 XML 的配置方式是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;!-- bean定义 --&gt;&lt;&#x2F;beans&gt;</code></pre></div></figure><p>而基于 JavaConfig 的配置方式是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MockConfiguration&#123;        &#x2F;&#x2F; bean定义&#125; </code></pre></div></figure><p>任何一个标注了 <code>@Configuration</code> 的 Java 类定义都是一个 JavaConfig 配置类。</p><h4 id="2）注册-bean-定义层面"><a href="#2）注册-bean-定义层面" class="headerlink" title="2）注册 bean 定义层面"></a>2）注册 bean 定义层面</h4><p>基于 XML 的配置形式是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt; ...&lt;&#x2F;bean&gt;</code></pre></div></figure><p>而基于 JavaConfig 的配置形式是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MockConfiguration &#123;        @Bean        public MockService mockService() &#123;                return new MockServiceImpl();        &#125;&#125;</code></pre></div></figure><p>任何一个标注了 <code>@Bean</code> 的方法，其返回值将作为一个 bean 定义注册到 Spring 的 IoC 容器，方法名将默认成为该 bean 定义的 id。</p><h4 id="3）表达依赖注入关系层面"><a href="#3）表达依赖注入关系层面" class="headerlink" title="3）表达依赖注入关系层面"></a>3）表达依赖注入关系层面</h4><p>为了表达 bean 与 bean 之间的依赖关系，在 XML 形式中一般是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;    &lt;property name&#x3D;&quot;dependencyService&quot; ref&#x3D;&quot;dependencyService&quot; &#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;dependencyService&quot; class&#x3D;&quot;DependencyServiceImpl&quot; &#x2F;&gt; </code></pre></div></figure><p>而在 JavaConfig 中则是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MockConfiguration &#123;        @Bean        public MockService mockService() &#123;                return new MockServiceImpl(dependencyService());        &#125;        @Bean        public DependencyService dependencyService() &#123;                return new DependencyServiceImpl();        &#125;&#125;</code></pre></div></figure><p>如果一个 bean 的定义依赖其他 bean，则直接调用对应 JavaConfig 类中依赖 bean 的创建方法就可以了。</p><p>在 JavaConfig 形式的依赖注入过程中，我们使用方法调用的形式注入依赖，如果这个方法返回的对象实例只被一个 bean 依赖注入，那也还好，如果多于一个 bean 需要依赖这个方法调用返回的对象实例，那是不是意味着我们就会创建多个同一类型的对象实例？</p><p>从代码表述的逻辑来看，直觉上应该是会创建多个同一类型的对象实例，但实际上最终结果却不是这样，依赖注入的都是同一个 Singleton 的对象实例，那这是如何做到的？</p><p>笔者一开始以为 Spring 框架会通过解析 JavaConfig 的代码结构，然后通过解析器转换加上反射等方式完成这一目的，但实际上 Spring 框架的设计和实现者采用了另一种更通用的方式，这在 Spring 的参考文档中有说明。即通过拦截配置类的方法调用来避免多次初始化同一类型对象的问题，一旦拥有拦截逻辑的子类发现当前方法没有对应的类型实例时才会去请求父类的同一方法来初始化对象实例，否则直接返回之前的对象实例。</p><p>所以，原来 Spring IoC 容器中有的特性（features）在 JavaConfig 中都可以表述，只是换了一种形式而已，而且，通过声明相应的 Java Annotation 反而“内聚”一处，变得更加简洁明了了。</p><h3 id="那些高曝光率的-Annotation"><a href="#那些高曝光率的-Annotation" class="headerlink" title="那些高曝光率的 Annotation"></a>那些高曝光率的 Annotation</h3><p>至于 <code>@Configuration</code>，我想前面已经提及过了，这里不再赘述，下面我们看几个其他比较常见的 Annotation，便于为后面更好地理解 <a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 框架的奥秘做准备。</p><h4 id="1-ComponentScan"><a href="#1-ComponentScan" class="headerlink" title="1. @ComponentScan"></a>1. @ComponentScan</h4><p><code>@ComponentScan</code> 对应 XML 配置形式中的 <code>&lt;context：component-scan&gt;</code> 元素，用于配合一些元信息 Java Annotation，比如 <code>@Component</code> 和 <code>@Repository</code> 等，将标注了这些元信息 Annotation 的 bean 定义类批量采集到 Spring 的 IoC 容器中。</p><p>我们可以通过 basePackages 等属性来细粒度地定制 <code>@ComponentScan</code> 自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明 <code>@ComponentScan</code> 所在类的 package 进行扫描。</p><p><code>@ComponentScan</code> 是 SpringBoot 框架魔法得以实现的一个关键组件，大家可以重点关注，我们后面还会遇到它。</p><h4 id="2-PropertySource-与-PropertySources"><a href="#2-PropertySource-与-PropertySources" class="headerlink" title="2. @PropertySource 与 @PropertySources"></a>2. @PropertySource 与 @PropertySources</h4><p><code>@PropertySource</code> 用于从某些地方加载 *.properties 文件内容，并将其中的属性加载到 IoC 容器中，便于填充一些 bean 定义属性的占位符（placeholder），当然，这需要 PropertySourcesPlaceholderConfigurer 的配合。</p><p>如果我们使用 Java 8 或者更高版本开发，那么，我们可以并行声明多个 @PropertySource：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@PropertySource(&quot;classpath:1.properties&quot;)@PropertySource(&quot;classpath:2.properties&quot;)@PropertySource(&quot;...&quot;)public class XConfiguration&#123;        ...&#125;</code></pre></div></figure><p>如果我们使用低于 Java 8 版本的 Java 开发 Spring 应用，又想声明多个 <code>@PropertySource</code>，则需要借助 <code>@PropertySources</code> 的帮助了，代码如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PropertySources(&#123; @PropertySource(&quot;classpath:1.properties&quot;), @PropertySource(&quot;classpath:2.properties&quot;), ...&#125;)public class XConfiguration&#123;        ...&#125;</code></pre></div></figure><h4 id="3-Import-与-ImportResource"><a href="#3-Import-与-ImportResource" class="headerlink" title="3. @Import 与 @ImportResource"></a>3. @Import 与 @ImportResource</h4><p>在 XML 形式的配置中，我们通过 <code>&lt;import resource=&quot;XXX.xml&quot;/&gt;</code> 的形式将多个分开的容器配置合到一个配置中，在 JavaConfig 形式的配置中，我们则使用 <code>@Import</code> 这个 Annotation 完成同样目的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Import(MockConfiguration.class)public class XConfiguration &#123;        ...&#125;</code></pre></div></figure><p><code>@Import</code> 只负责引入 JavaConfig 形式定义的 IoC 容器配置，如果有一些遗留的配置或者遗留系统需要以 XML 形式来配置（比如 dubbo 框架），我们依然可以通过 <code>@ImportResource</code> 将它们一起合并到当前 JavaConfig 配置的容器中。</p><h2 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h2><p>随着动态语言的流行（Ruby、Groovy、Scala、Node.js），<a href="http://c.biancheng.net/java/">Java</a> 的开发显得格外的笨重，繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。</p><p>在上述环境下，<a href="http://c.biancheng.net/spring/">Spring</a> Boot 应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须手动进行配置）的理念让你的项目快速运行起来。</p><p>使用 Spring Boot 很容易创建一个独立运行（运行 jar，内嵌 <a href="http://c.biancheng.net/servlet/">Servlet</a> 容器）、准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需要很少的 Spring 配置。</p><h3 id="Spring-Boot-核心功能"><a href="#Spring-Boot-核心功能" class="headerlink" title="Spring Boot 核心功能"></a>Spring Boot 核心功能</h3><h4 id="1）独立运行的-Spring-项目"><a href="#1）独立运行的-Spring-项目" class="headerlink" title="1）独立运行的 Spring 项目"></a>1）独立运行的 Spring 项目</h4><p>Spring Boot 可以以 jar 包的形式独立运行，运行一个 Spring Boot 项目只需通过 java–jar xx.jar 来运行。</p><h4 id="2）内嵌-Servlet-容器"><a href="#2）内嵌-Servlet-容器" class="headerlink" title="2）内嵌 Servlet 容器"></a>2）内嵌 Servlet 容器</h4><p>Spring Boot 可选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。</p><h4 id="3）提供-starter-简化-Maven-配置"><a href="#3）提供-starter-简化-Maven-配置" class="headerlink" title="3）提供 starter 简化 Maven 配置"></a>3）提供 starter 简化 <a href="http://c.biancheng.net/maven/">Maven</a> 配置</h4><p>Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载，例如，当你使用了spring-boot-starter-web 时，会自动加入如图 1 所示的依赖包。</p><h4 id="4）自动配置-Spring"><a href="#4）自动配置-Spring" class="headerlink" title="4）自动配置 Spring"></a>4）自动配置 Spring</h4><p>Spring Boot 会根据在类路径中的 jar 包、类，为 jar 包里的类自动配置 Bean，这样会极大地减少我们要使用的配置。当然，Spring Boot 只是考虑了大多数的开发场景，并不是所有的场景，若在实际开发中我们需要自动配置 Bean，而 Spring Boot 没有提供支持，则可以自定义自动配置。</p><h4 id="5）准生产的应用监控"><a href="#5）准生产的应用监控" class="headerlink" title="5）准生产的应用监控"></a>5）准生产的应用监控</h4><p>Spring Boot 提供基于 http、ssh、telnet 对运行时的项目进行监控。</p><h4 id="6）无代码生成和-xml-配置"><a href="#6）无代码生成和-xml-配置" class="headerlink" title="6）无代码生成和 xml 配置"></a>6）无代码生成和 xml 配置</h4><p>Spring Boot 的神奇的不是借助于代码生成来实现的，而是通过条件注解来实现的，这是 Spring 4.x 提供的新特性。Spring 4.x 提倡使用 Java 配置和注解配置组合，而 Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。</p><h3 id="Spring-Boot的优缺点"><a href="#Spring-Boot的优缺点" class="headerlink" title="Spring Boot的优缺点"></a>Spring Boot的优缺点</h3><h4 id="1）优点"><a href="#1）优点" class="headerlink" title="1）优点"></a>1）优点</h4><ul><li>快速构建项目。</li><li>对主流开发框架的无配置集成。</li><li>项目可独立运行，无须外部依赖Servlet容器。</li><li>提供运行时的应用监控。</li><li>极大地提高了开发、部署效率。</li><li>与<a href="http://c.biancheng.net/cloud_computing/">云计算</a>的天然集成。</li></ul><h4 id="2）缺点"><a href="#2）缺点" class="headerlink" title="2）缺点"></a>2）缺点</h4><ul><li>版本迭代速度很快，一些模块改动很大。</li><li>由于不用自己做配置，报错时很难定位。</li><li>网上现成的解决方案比较少。</li></ul><h2 id="SpringBoot快速搭建"><a href="#SpringBoot快速搭建" class="headerlink" title="SpringBoot快速搭建"></a>SpringBoot快速搭建</h2><p>我们说 <a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 是 <a href="http://c.biancheng.net/spring/">Spring</a> 框架对“约定优先于配置（Convention Over Configuration）”理念的最佳实践的产物，一个典型的 SpringBoot 应用本质上其实就是一个基于 Spring 框架的应用，而如果大家对 Spring 框架已经了如指掌，那么，在我们一步步揭开 SpringBoot 微框架的面纱之后，大家就会发现“阳光之下，并无新事”。</p><p>一个典型的 SpringBoot 应用长什么样子呢？下面我们快速搭建一个SpringBoot 应用。</p><ol><li>打开浏览器，输入网址 <a href="http://start.spring.io/">http://start.spring.io/</a> ，如图 1 所示：</li></ol><img src="/doc/6f2612a2/5-1ZI1162941D6.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 spring.io页面</p><ol start="2"><li>创建一个最简单的依赖 Web 模块的 SpringBoot 应用，填写项目信息，如图 1 所示。</li></ol><p>我们在此以 <a href="http://c.biancheng.net/maven/">Maven</a> 作为项目构建方式，Spring Boot 还支持以 Gradle 作为项目构建工具。部署形式以 jar 包形式，当然也可以用传统的 war 包形式。Spring Boot 选择2.1.6，Spring boot 还支持以 Groovy 语言开发，应用中选择 <a href="http://c.biancheng.net/java/">Java</a> 作为开发语言。</p><ol start="3"><li>选择完之后，下载代码，如图 2 所示：</li></ol><img src="/doc/6f2612a2/5-1ZI116363Y28.png" srcset="/img/loading.gif" lazyload class=""><p>图 2 下载代码</p><p>一般情况下，我们会得到一个 SpringBoot 应用的启动类，如下面代码所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(DemoApplication.class, args);        &#125;&#125;</code></pre></div></figure><p>所有的 SpringBoot 无论怎么定制，本质上与上面的启动类代码是一样的，而以上代码示例中，Annotation 定义（<code>@SpringBootApplication</code>）和类定义（SpringApplication.run）最为耀眼，那么，要揭开 SpringBoot 应用的奥秘，很明显的，我们只要先从这两位开始就可以了。</p><h2 id="SpringBoot中-SpringBootApplication注解的三体结构解析"><a href="#SpringBoot中-SpringBootApplication注解的三体结构解析" class="headerlink" title="SpringBoot中@SpringBootApplication注解的三体结构解析"></a>SpringBoot中@SpringBootApplication注解的三体结构解析</h2><p><code>@SpringBootApplication</code> 是一个“三体”结构，实际上它是一个复合 Annotation：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Configuration@EnableAutoConfiguration@ComponentScanpublic @interface SpringBootApplication&#123;...&#125;</code></pre></div></figure><p>虽然它的定义使用了多个 Annotation 进行元信息标注，但实际上对于 SpringBoot 应用来说，重要的只有三个 Annotation，而“三体”结构实际上指的就是这三个 Annotation：</p><ul><li><code>@Configuration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul><p>所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAutoConfiguration@ComponentScanpublic class DemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(DemoApplication.class, args);        &#125;&#125;</code></pre></div></figure><p>但每次都写三个 Annotation 显然过于繁琐，所以写一个 <code>@SpringBootApplication</code> 这样的一站式复合 Annotation 显然更方便些。</p><h3 id="Configuration-创世纪"><a href="#Configuration-创世纪" class="headerlink" title="@Configuration 创世纪"></a>@Configuration 创世纪</h3><p>这里的 <code>@Configuration</code> 对我们来说并不陌生，它就是 <a href="http://c.biancheng.net/java/">Java</a>Config 形式的 Spring IoC 容器的配置类使用的那个 <code>@Configuration</code>，既然 SpringBoot 应用骨子里就是一个 Spring 应用，那么，自然也需要加载某个 IoC 容器的配置，而 SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，很明显，这里的启动类标注了 <code>@Configuration</code> 之后，本身其实也是一个 IoC 容器的配置类！</p><p>很多 SpringBoot 的代码示例都喜欢在启动类上直接标注 <code>@Configuration</code> 或者 <code>@SpringBootApplication</code>，对于初接触 SpringBoot 的开发者来说，其实这种做法不便于理解，如果我们将上面的 SpringBoot 启动类拆分为两个独立的 Java 类，整个形势就明朗了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAutoConfiguration@ComponentScanpublic class DemoConfiguration &#123;    @Bean    public Controller controller() &#123;        return new Controller();    &#125;&#125;public class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoConfiguration.class, args);    &#125;&#125;</code></pre></div></figure><p>所以，启动类 DemoApplication 其实就是一个标准的 Standalone 类型 Java 程序的 main 函数启动类，没有什么特殊的。而 <code>@Configuration</code> 标注的 DemoConfiguration 定义其实也是一个普通的 JavaConfig 形式的 IoC 容器配置类。</p><h3 id="EnableAutoConfiguration-的功效"><a href="#EnableAutoConfiguration-的功效" class="headerlink" title="@EnableAutoConfiguration 的功效"></a>@EnableAutoConfiguration 的功效</h3><p><code>@EnableAutoConfiguration</code> 其实也没啥“创意”，各位是否还记得 Spring 框架提供的各种名字为 <code>@Enable</code> 开头的 Annotation 定义？</p><p>比如 <code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code> 等，<code>@EnableAutoConfiguration</code> 的理念和“做事方式”其实一脉相承，简单概括一下就是，借助 <code>@Import</code> 的支持，收集和注册特定场景相关的 bean 定义：</p><ul><li><code>@EnableScheduling</code> 是通过 <code>@Import</code> 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。</li><li><code>@EnableMBeanExport</code> 是通过 <code>@Import</code> 将 JMX 相关的 bean 定义加载到 IoC 容器。</li></ul><p>而 <code>@EnableAutoConfiguration</code> 也是借助 <code>@Import</code> 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！</p><p><code>@EnableAutoConfiguration</code> 作为一个复合 Annotation，其自身定义关键信息如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;...&#125;</code></pre></div></figure><p>其中，最关键的要属 <code>@Import（EnableAutoConfigurationImportSelector.class）</code>，借助 EnableAutoConfigurationImportSelector，<code>@EnableAutoConfiguration</code> 可以帮助 SpringBoot 应用将所有符合条件的 <code>@Configuration</code> 配置都加载到当前 SpringBoot 创建并使用的 IoC 容器，就跟一只“八爪鱼”一样（如图 1 所示）。</p><img src="/doc/6f2612a2/5-1ZI1093132I5.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 EnableAutoConfiguration得以生效的关键组件关系图</p><p>借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，<code>@EnableAutoConfiguration</code> 可以“智能”地自动配置功效才得以大功告成！</p><h3 id="SpringFactoriesLoader详解"><a href="#SpringFactoriesLoader详解" class="headerlink" title="SpringFactoriesLoader详解"></a>SpringFactoriesLoader详解</h3><p>SpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案（类似于 Java 的 SPI 方案 java.util.ServiceLoader），其主要功能就是从指定的配置文件 <code>META-INF/spring.factories</code> 加载配置，spring.factories 是一个典型的 java properties 文件，配置的格式为 Key&#x3D;Value 形式，只不过 Key 和 Value 都是 Java 类型的完整类名（Fully qualified name），比如：</p><p><code>example.MyService=example.MyServiceImpl1,example.MyServiceImpl2</code> 然后框架就可以根据某个类型作为 Key 来查找对应的类型名称列表了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class SpringFactoriesLoader &#123;        &#x2F;&#x2F; ...        public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;         ...        &#125;        public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;         ...        &#125;        &#x2F;&#x2F; ...&#125;</code></pre></div></figure><p>对于 <code>@EnableAutoConfiguration</code> 来说，SpringFactoriesLoader 的用途稍微不同一些，其本意是为了提供 SPI 扩展的场景，而在 <code>@EnableAutoConfiguration</code> 的场景中，它更多是提供了一种配置查找的功能支持，即根据 <code>@EnableAutoConfiguration</code> 的完整类名 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 作为查找的 Key，获取对应的一组 <code>@Configuration</code> 类：</p><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\org.springframework.boot.autoconfigure.admin.SpringApplicationAdmin- JmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.PropertyPlaceholderAuto- Configuration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAuto-Configuration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationProperties-AutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceException-TranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-DataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-RepositoriesAutoConfiguration,\...</code></pre></div></figure><p>以上是从 SpringBoot 的 autoconfigure 依赖包中的 <code>META-INF/spring.factories</code> 配置文件中摘录的一段内容，可以很好地说明问题。</p><p>所以，<code>@EnableAutoConfiguration</code> 自动配置的魔法其实就变成了：从 classpath 中搜寻所有 <code>META-INF/spring.factories</code> 配置文件，并将其中 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项通过反射（Java Reflection）实例化为对应的标注了 <code>@Configuration</code> 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。</p><h3 id="可有可无的-ComponentScan"><a href="#可有可无的-ComponentScan" class="headerlink" title="可有可无的@ComponentScan"></a>可有可无的@ComponentScan</h3><p>为啥说 <code>@ComponentScan</code> 是可有可无的？</p><p>因为原则上来说，作为 Spring 框架里的“老一辈革命家”，<code>@ComponentScan</code> 的功能其实就是自动扫描并加载符合条件的组件或 bean 定义，最终将这些 bean 定义加载到容器中。加载 bean 定义到 Spring 的 IoC 容器，我们可以手工单个注册，不一定非要通过批量的自动扫描完成，所以说 <code>@ComponentScan</code> 是可有可无的。</p><p>对于 SpringBoot 应用来说，同样如此，比如我们本章的启动类：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAutoConfiguration@ComponentScanpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;</code></pre></div></figure><p>如果我们当前应用没有任何 bean 定义需要通过 <code>@ComponentScan</code> 加载到当前 SpringBoot 应用对应使用的 IoC 容器，那么，除去 <code>@ComponentScan</code> 的声明，当前 SpringBoot 应用依然可以照常运行，功能对等。</p><h2 id="SpringApplication-run执行流程详解"><a href="#SpringApplication-run执行流程详解" class="headerlink" title="SpringApplication.run执行流程详解"></a>SpringApplication.run执行流程详解</h2><p><a href="http://c.biancheng.net/spring/">Spring</a>Application 将一个典型的 Spring 应用启动的流程“模板化”（这里是动词），在没有特殊需求的情况下，默认模板化后的执行流程就可以满足需求了但有特殊需求也没关系，SpringApplication 在合适的流程结点开放了一系列不同类型的扩展点，我们可以通过这些扩展点对 <a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 程序的启动和关闭过程进行扩展。</p><p>最“肤浅”的扩展或者配置是 SpringApplication 通过一系列设置方法（setters）开放的定制方式，比如，我们之前的启动类的 main 方法中只有一句：</p><p><code>SpringApplication.run（DemoApplication.class，args）;</code></p><p>但如果我们想通过 SpringApplication 的一系列设置方法来扩展启动行为，则可以用如下方式进行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DemoApplication &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; SpringApplication.run(DemoConfiguration.class, args);        SpringApplication bootstrap &#x3D; new SpringApplication(Demo - Configuration.class);        bootstrap.setBanner(new Banner() &#123;            @Override            public void printBanner(Environment environment, Class&lt;?&gt; aClass, PrintStream printStream) &#123;                &#x2F;&#x2F; 比如打印一个我们喜欢的ASCII Arts字符画            &#125;        &#125;);        bootstrap.setBannerMode(Banner.Mode.CONSOLE);        &#x2F;&#x2F; 其他定制设置...        bootstrap.run(args);    &#125;&#125;</code></pre></div></figure><p>设置自定义 banner 最简单的方式其实是把 ASCII Art 字符画放到一个资源文件，然后通过 ResourceBanner 来加载：</p><p><code>bootstrap.setBanner(new ResourceBanner(new ClassPathResource(&quot;banner.txt&quot;)));</code></p><p>这里也可以直接在 src&#x2F;main&#x2F;resource 下新建 banner.txt</p><p>可以去下面网站（喜欢哪个用哪个）去生成自己的个性 banner，再拷贝过去就行啦：</p><ul><li><a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></li><li>[<a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type">http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type</a> Something](<a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type">http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type</a> Something )</li></ul><p>大部分情况下，SpringApplication 已经提供了很好的默认设置，所以，我们不再对这些表层进行探究了，因为对表层之下的东西进行探究才是我们的最终目的。</p><h3 id="深入探索-SpringApplication-执行流程"><a href="#深入探索-SpringApplication-执行流程" class="headerlink" title="深入探索 SpringApplication 执行流程"></a>深入探索 SpringApplication 执行流程</h3><p>SpringApplication 的 run 方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><ol><li><p>如果我们使用的是 SpringApplication 的静态 run 方法，那么，这个方法里面首先需要创建一个 SpringApplication 对象实例，然后调用这个创建好的 SpringApplication 的实例 run方 法。在 SpringApplication 实例初始化的时候，它会提前做几件事情：</p><p>根据 classpath 里面是否存在某个特征类（<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>）来决定是否应该创建一个为 Web 应用使用的 ApplicationContext 类型，还是应该创建一个标准 Standalone 应用使用的 ApplicationContext 类型。</p><p>使用 SpringFactoriesLoader 在应用的 classpath 中查找并加载所有可用的 ApplicationContextInitializer。</p><p>使用 SpringFactoriesLoader 在应用的 classpath 中查找并加载所有可用的 ApplicationListener。</p><p>推断并设置 main 方法的定义类。</p></li><li><p>SpringApplication 实例初始化完成并且完成设置后，就开始执行 run 方法的逻辑了，方法执行伊始，首先遍历执行所有通过 SpringFactoriesLoader 可以查找到并加载的 SpringApplicationRunListener，调用它们的 started() 方法，告诉这些 SpringApplicationRunListener，“嘿，SpringBoot 应用要开始执行咯！”。</p></li><li><p>创建并配置当前 SpringBoot 应用将要使用的 Environment（包括配置要使用的 PropertySource 以及 Profile）。</p></li><li><p>遍历调用所有 SpringApplicationRunListener 的 environmentPrepared（）的方法，告诉它们：“当前 SpringBoot 应用使用的 Environment 准备好咯！”。</p></li><li><p>如果 SpringApplication的showBanner 属性被设置为 true，则打印 banner（SpringBoot 1.3.x版本，这里应该是基于 Banner.Mode 决定 banner 的打印行为）。这一步的逻辑其实可以不关心，我认为唯一的用途就是“好玩”（Just For Fun）。</p></li><li><p>根据用户是否明确设置了applicationContextClass 类型以及初始化阶段的推断结果，决定该为当前 SpringBoot 应用创建什么类型的 ApplicationContext 并创建完成，然后根据条件决定是否添加 ShutdownHook，决定是否使用自定义的 BeanNameGenerator，决定是否使用自定义的 ResourceLoader，当然，最重要的，将之前准备好的 Environment 设置给创建好的 ApplicationContext 使用。</p></li><li><p>ApplicationContext 创建好之后，SpringApplication 会再次借助 Spring-FactoriesLoader，查找并加载 classpath 中所有可用的 ApplicationContext-Initializer，然后遍历调用这些 ApplicationContextInitializer 的 initialize（applicationContext）方法来对已经创建好的 ApplicationContext 进行进一步的处理。</p></li><li><p>遍历调用所有 SpringApplicationRunListener 的 contextPrepared（）方法，通知它们：“SpringBoot 应用使用的 ApplicationContext 准备好啦！”</p></li><li><p>最核心的一步，将之前通过 <code>@EnableAutoConfiguration</code> 获取的所有配置以及其他形式的 IoC 容器配置加载到已经准备完毕的 ApplicationContext。</p></li><li><p>遍历调用所有 SpringApplicationRunListener 的 contextLoaded() 方法，告知所有 SpringApplicationRunListener，ApplicationContext “装填完毕”！</p></li><li><p>调用 ApplicationContext 的 refresh() 方法，完成 IoC 容器可用的最后一道工序。</p></li><li><p>查找当前 ApplicationContext 中是否注册有 CommandLineRunner，如果有，则遍历执行它们。</p></li><li><p>正常情况下，遍历执行 SpringApplicationRunListener 的 finished() 方法，告知它们：“搞定！”。（如果整个过程出现异常，则依然调用所有 SpringApplicationRunListener 的 finished() 方法，只不过这种情况下会将异常信息一并传入处理）。</p></li></ol><p>至此，一个完整的 SpringBoot 应用启动完毕！</p><p>整个过程看起来冗长无比，但其实很多都是一些事件通知的扩展点，如果我们将这些逻辑暂时忽略，那么，其实整个 SpringBoot 应用启动的逻辑就可以压缩到极其精简的几步，如图 1 所示。</p><img src="/doc/6f2612a2/5-1ZI1144050494.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 SpringBoot应用启动步骤简要示意图</p><p>前后对比我们就可以发现，其实 SpringApplication 提供的这些各类扩展点近乎“喧宾夺主”，占据了一个 Spring 应用启动逻辑的大部分“江山”，除了初始化并准备好 ApplicationContext，剩下的大部分工作都是通过这些扩展点完成的，所以，我们接下来对各类扩展点进行逐一剖析。</p><h3 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h3><p>SpringApplicationRunListener 是一个只有 SpringBoot 应用的 main 方法执行过程中接收不同执行时点事件通知的监听者：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface SpringApplicationRunListener &#123;        void started();        void environmentPrepared(ConfigurableEnvironment environment);        void contextPrepared(ConfigurableApplicationContext context);       void contextLoaded(ConfigurableApplicationContext context);        void finished(ConfigurableApplicationContext context, Throwable exception);&#125;</code></pre></div></figure><p>对于我们来说，基本没什么常见的场景需要自己实现一个 Spring-ApplicationRunListener，即使 SpringBoot 默认也只是实现了一个 <code>org.springframework.boot.context.event.EventPublishingRunListener</code>，用于在 SpringBoot 启动的不同时点发布不同的应用事件类型（ApplicationEvent），如果有哪些 ApplicationListener 对这些应用事件感兴趣，则可以接收并处理。</p><p>假设我们真的有场景需要自定义一个 SpringApplicationRunListener 实现，那么有一点需要注意，即任何一个 SpringApplicationRunListener 实现类的构造方法（Constructor）需要有两个构造参数，一个构造参数的类型就是我们的 <code>org.springframework.boot.SpringApplication</code>，另外一个就是 args 参数列表的 String[]：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DemoSpringApplicationRunListener implements SpringApplicationRunListener &#123;        @Override        public void started() &#123;                &#x2F;&#x2F; do whatever you want to do        &#125;        @Override        public void environmentPrepared(ConfigurableEnvironment environment) &#123;                &#x2F;&#x2F; do whatever you want to do        &#125;        @Override        public void contextPrepared(ConfigurableApplicationContext context) &#123;                &#x2F;&#x2F; do whatever you want to do    &#125;        @Override        public void contextLoaded(ConfigurableApplicationContext context) &#123;                &#x2F;&#x2F; do whatever you want to do        &#125;        @Override        public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;                &#x2F;&#x2F; do whatever you want to do        &#125;&#125;</code></pre></div></figure><p>之后，我们可以通过 SpringFactoriesLoader 立下的规矩，在当前 SpringBoot 应用的 classpath 下的<code> META-INF/spring.factories</code> 文件中进行类似如下的配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">org.springframework.boot.SpringApplicationRunListener&#x3D;\com.keevol.springboot.demo.DemoSpringApplicationRunListener</code></pre></div></figure><p>然后 SpringApplication 就会在运行的时候调用它啦！</p><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>ApplicationListener 其实是老面孔，属于 Spring 框架对 <a href="http://c.biancheng.net/java/">Java</a> 中实现的监听者模式的一种框架实现，这里唯一值得着重强调的是，对于初次接触 SpringBoot，但对 Spring 框架本身又没有过多接触的开发者来说，可能会将这个名字与 SpringApplicationRunListener 混淆。</p><p>关于 ApplicationListener 我们就不做过多介绍了，如果感兴趣，请参考 Spring 框架相关的资料和书籍。</p><p>如果我们要为 SpringBoot 应用添加自定义的 ApplicationListener，有两种方式：</p><ul><li>通过 <code>SpringApplication.addListeners（..）</code>或者 <code>SpringApplication.setListeners（..）</code>方法添加一个或者多个自定义的 ApplicationListener。</li><li>借助 SpringFactoriesLoader 机制，在 <code>META-INF/spring.factories </code>文件中添加配置（以下代码是为 SpringBoot 默认注册的 ApplicationListener 配置）。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">org.springframework.context.ApplicationListener&#x3D;\org.springframework.boot.builder.ParentContextCloserApplicationListener,\org.springframework.boot.cloudfoundry.VcapApplicationListener,\org.springframework.boot.context.FileEncodingApplicationListener,\org.springframework.boot.context.config.AnsiOutputApplicationListener,\org.springframework.boot.context.config.ConfigFileApplicationListener,\org.springframework.boot.context.config.DelegatingApplicationListener,\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicat-ionListener,\org.springframework.boot.logging.ClasspathLoggingApplicationListener,\org.springframework.boot.logging.LoggingApplicationListener</code></pre></div></figure><p>关于 ApplicationListener，我们就说这些。</p><h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><p>ApplicationContextInitializer 也是 Spring 框架原有的概念，这个类的主要目的就是在 ConfigurableApplicationContext 类型（或者子类型）的 ApplicationContext 做 refresh 之前，允许我们对 ConfigurableApplicationContext 的实例做进一步的设置或者处理。</p><p>实现一个 ApplicationContextInitializer 很简单，因为它只有一个方法需要实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DemoApplicationContextInitializer implements ApplicationContextInitializer &#123;        @Override        public void initialize(ConfigurableApplicationContext applicationContext) &#123;                &#x2F;&#x2F; do whatever you want with applicationContext,                &#x2F;&#x2F; e.g.                applicationContext.registerShutdownHook();        &#125;&#125;</code></pre></div></figure><p>不过，一般情况下我们基本不会需要自定义一个 ApplicationContext-Initializer，即使 SpringBoot 框架默认也只是注册了三个实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">org.springframework.context.ApplicationContextInitializer&#x3D;\org.springframework.boot.context.ConfigurationWarningsApplication-ContextInitializer,\org.springframework.boot.context.ContextIdApplicationContextInitia-lizer,\org.springframework.boot.context.config.DelegatingApplicationContex-tInitializer</code></pre></div></figure><p>如果我们真的需要自定义一个 ApplicationContextInitializer，那么只要像上面这样，通过 SpringFactoriesLoader 机制进行配置，或者通过 <code>SpringApplication.addInitializers（..）</code>设置即可。</p><h3 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h3><p>CommandLineRunner 是很好的扩展接口，不是 Spring 框架原有的“宝贝”，它属于 SpringBoot 应用特定的回调扩展接口。源码如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CommandLineRunner &#123;        void run(String... args) throws Exception;&#125;</code></pre></div></figure><p>CommandLineRunner 需要大家关注的其实就两点：</p><ol><li><p>所有 CommandLineRunner 的执行时点在 SpringBoot 应用的 Application-Context 完全初始化开始工作之后（可以认为是 main 方法执行完成之前最后一步）。</p></li><li><p>只要存在于当前 SpringBoot 应用的 ApplicationContext 中的任何 Command-LineRunner，都会被加载执行（不管你是手动注册这个 CommandLineRunner 到 IoC 容器，还是自动扫描进去的）。</p></li></ol><p>与其他几个扩展点接口类型相似，建议 CommandLineRunner 的实现类使用 <code>@org.springframework.core.annotation.Order</code> 进行标注或者实现 <code>org.springframework.core.Ordered</code> 接口，便于对它们的执行顺序进行调整，这其实十分重要，我们不希望顺序不当的 CommandLineRunner 实现类阻塞了后面其他 CommandLineRunner 的执行。</p><h2 id="SpringBoot的自动配置"><a href="#SpringBoot的自动配置" class="headerlink" title="SpringBoot的自动配置"></a>SpringBoot的自动配置</h2><p>在教程《<a href="http://c.biancheng.net/view/4625.html">@SpringBootApplication注解</a>》中讲到 <code>@EnableAutoConfiguration</code> 可以借助 <a href="http://c.biancheng.net/spring/">Spring</a>FactoriesLoader 这个特性将标注了 <code>@Configuration</code> 的 <a href="http://c.biancheng.net/java/">Java</a>Config 类“一股脑儿”的汇总并加载到最终的 ApplicationContext，不过，这其实只是“简化版”的说明。</p><p>实际上，基于 <code>@EnableAutoConfiguration</code> 的自动配置功能拥有更加强大的调控能力，通过配合比如基于条件的配置能力或者调整加载顺序，我们可以对自动配置进行更加细粒度的调整和控制。</p><h3 id="基于条件的自动配置"><a href="#基于条件的自动配置" class="headerlink" title="基于条件的自动配置"></a>基于条件的自动配置</h3><p>基于条件的自动配置来源于 Spring 框架中“基于条件的配置”这一特性。在 Spring 框架中，我们可以使用 <code>@Conditional</code> 这个 Annotation 配合 <code>@Configuration</code> 或者 <code>@Bean</code> 等 Annotation 来干预一个配置或者 bean 定义是否能够生效，其最终实现的效果或者语义类似于如下伪代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(符合 @Conditional 规定的条件)&#123;  加载当前配置(enable current Configuration)或者注册当前bean定义；&#125;</code></pre></div></figure><p>要实现基于条件的配置，我们只要通过 <code>@Conditional</code> 指定自己的 Condition 实现类就可以了（可以应用于类型 Type 的标注或者方法 Method 的标注）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Conditional(&#123;MyCondition1.class, MyCondition2.class, ...&#125;)</code></pre></div></figure><p>最主要的是，<code>@Conditional</code> 可以作为一个 Meta Annotation 用来标注其他 Annotation 实现类，从而构建各色的复合 Annotation，比如 <a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 的 autoconfigure 模块就基于这一优良的革命传统，实现了一批 Annotation（位于 <code>org.springframework.boot.autoconfigure.condition</code> 包下），条件注解如下：</p><ul><li><code>@ConditionalOnBean</code>：当容器里有指定的 Bean 的条件下。</li><li><code>@ConditionalOnClass</code>：当类路径下有指定的类的条件下。</li><li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件。</li><li><code>@ConditionalOnJava</code>：基于 JVM 版本作为判断条件。</li><li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下查找指定的位置。</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下。</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定的类的条件下。</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下。</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值。</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值。</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选的 Bean。</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项目的条件下。</li></ul><p>有了这些复合 Annotation 的配合，我们就可以结合 <code>@EnableAuto-Configurationn</code> 实现基于条件的自动配置了。</p><p>SpringBoot 能够风靡，很大一部分功劳需要归功于它预先提供的一系列自动配置的依赖模块，而这些依赖模块都是基于以上 @Conditional 复合 Annotation 实现的，这也意味着所有的这些依赖模块都是按需加载的，只有符合某些特定条件，这些依赖模块才会生效，这也就是我们所谓的“智能”自动配置。</p><h3 id="调整自动配置的顺序"><a href="#调整自动配置的顺序" class="headerlink" title="调整自动配置的顺序"></a>调整自动配置的顺序</h3><p>在实现自动配置的过程中，除了可以提供基于条件的配置，我们还可以对当前要提供的配置或者组件的加载顺序进行相应调整，从而让这些配置或者组件之间的依赖分析和组装可以顺利完成。</p><p>我们可以使用 <code>@org.springframework.boot.autoconfigure.AutoConfigureBefore</code> 或者 <code>@org.springframework.boot.autoconfigure.AutoConfigureAfter</code> 让当前配置或者组件在某个其他组件之前或者之后进行，比如，假设我们希望某些 JMX 操作相关的 bean 定义在 MBeanServer 配置完成之后进行，那么我们就可以提供一个类似如下的配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@AutoConfigureAfter(JmxAutoConfiguration.class)public class AfterMBeanServerReadyConfiguration &#123;        @AutoWired       MBeanServer mBeanServer;         &#x2F;&#x2F;通过 @Bean 添加必要的 bean 定义&#125;</code></pre></div></figure><p>至此，我们对 SpringBoot 的核心组件完成了基本的剖析，综合来看，大部分的东西都是 Spring 框架背后原有的一些概念和实践方式，SpringBoot 只是在这些概念和实践方式上对特定的场景实现进行了固化和升华，而也恰恰是这些固化让我们开发基于 Spring 框架的应用更加方便高效。</p><h2 id="Spring-Boot-Starter常用依赖模块详解"><a href="#Spring-Boot-Starter常用依赖模块详解" class="headerlink" title="Spring-Boot-Starter常用依赖模块详解"></a>Spring-Boot-Starter常用依赖模块详解</h2><p>一般认为，<a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 微框架从两个主要层面影响 <a href="http://c.biancheng.net/spring/">Spring</a> 社区的开发者们：</p><ul><li>基于 Spring 框架的“约定优先于配置（COC）”理念以及最佳实践之路。</li><li>提供了针对日常企业应用研发各种场景的 spring-boot-starter 自动配置依赖模块，如此多“开箱即用”的依赖模块，使得开发各种场景的 Spring 应用更加快速和高效。</li></ul><p>SpringBoot 提供的这些“开箱即用”的依赖模块都约定以 spring-boot-starter- 作为命名的前缀，并且皆位于 org.springframework.boot 包或者命名空间下（虽然 SpringBoot 的官方参考文档中提到不建议大家使用 spring-boot-starter- 来命名自己写的类似的自动配置依赖模块，但实际上，配合不同的 groupId，这不应该是什么问题）。</p><p>如果我们访问 <a href="http://start.spring.io/">http://start.spring.io</a>，并单击图 1 中的“Switch to the full version”链接，就会发现 SpringBoot1.3.2 默认支持和提供了大约 80 多个自动配置依赖模块。</p><img src="/doc/6f2612a2/5-1ZP112212b32.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 Spring Initializr示意图</p><p>鉴于数量如此之多，并且也不是所有人都会在任何一个应用中用到所有，这里我们只对几个常见的通用 spring-boot-starter 模块进行讲解，希望大家可以举一反三，灵活应用所有日后工作过程中将会用到的那些 spring-boot-starter 模块。</p><p>所有的 spring-boot-starter 都有约定俗成的默认配置，但允许我们调整这些配置以改变默认的配置行为，即“约定优先于配置”。在介绍相应的 spring-boot-starter 的默认配置（约定）以及可调整配置之前，我们有必要对 SpringBoot 应用的配置约定先做一个简单的介绍。</p><h3 id="spring-boot-starter-logging和spring-boot-starter-web"><a href="#spring-boot-starter-logging和spring-boot-starter-web" class="headerlink" title="spring-boot-starter-logging和spring-boot-starter-web"></a>spring-boot-starter-logging和spring-boot-starter-web</h3><p>本节主要讲解 spring-boot-starter-logging 和 spring-boot-starter-web 两个常见通用的 spring-boot-starter 模块。</p><h4 id="应用日志和spring-boot-starter-logging"><a href="#应用日志和spring-boot-starter-logging" class="headerlink" title="应用日志和spring-boot-starter-logging"></a>应用日志和spring-boot-starter-logging</h4><p><a href="http://c.biancheng.net/java/">Java</a> 的日志系统多种多样，从 java.util 默认提供的日志支持，到 log4j，log4j2，commons logging 等，复杂繁多，所以，应用日志系统的配置就会比较特殊，从而 spring-boot-starter-logging 也比较特殊一些，下面将其作为我们第一个了解的自动配置依赖模块。</p><p>假如 maven 依赖中添加了 spring-boot-starter-logging，如以下代码所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;        &lt;groupId&gt; org.springframework.boot &lt;&#x2F;groupId&gt;        &lt;artifactId&gt; spring-boot-starter-logging &lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><p>那么，我们的 <a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 应用将自动使用 logback 作为应用日志框架，<a href="http://c.biancheng.net/spring/">Spring</a>Boot 启动的时候，由 org.springframework.boot.logging.Logging-Application-Listener 根据情况初始化并使用。</p><p>SpringBoot 为我们提供了很多默认的日志配置，所以，只要将 spring-boot-starter-logging 作为依赖加入到当前应用的 classpath，则“开箱即用”，不需要做任何多余的配置，但假设我们要对默认 SpringBoot 提供的应用日志设定做调整，则可以通过几种方式进行配置调整：</p><ul><li>遵循 logback 的约定，在 classpath 中使用自己定制的 logback.xml 配置文件。</li><li>在文件系统中任何一个位置提供自己的 logback.xml 配置文件，然后通过 logging.config 配置项指向这个配置文件来启用它，比如在 application.properties 中指定如下的配置。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">logging.config&#x3D;&#x2F;&#123;some.path.you.defined&#125;&#x2F;any-logfile-name-I-like.log</code></pre></div></figure><p>SpringBoot 默认允许我们通过在配置文件或者命令行等方式使用 logging.file 和 logging.path 来自定义日志文件的名称和存放路径，不过，这只是允许我们在 SpringBoot 框架预先定义的默认日志系统设定的基础上做有限的设置，如果我们希望更灵活的配置，最好通过框架特定的配置方式提供相应的配置文件，然后通过 logging.config 来启用。</p><p>如果大家更习惯使用 log4j 或者 log4j2，那么也可以采用类似的方式将它们对应的 spring-boot-starter 依赖模块加到 <a href="http://c.biancheng.net/maven/">Maven</a> 依赖中即可：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;        &lt;groupId&gt; org.springframework.boot &lt;&#x2F;groupId&gt;        &lt;artifactId&gt; spring-boot-starter-log4j &lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><p>或者</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;        &lt;groupId&gt; org.springframework.boot &lt;&#x2F;groupId&gt;        &lt;artifactId&gt; spring-boot-starter-log4j2 &lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><p>但一定不要将这些完成同一目的的 spring-boot-starter 都加到依赖中。</p><h4 id="快速-Web-应用开发与-spring-boot-starter-web"><a href="#快速-Web-应用开发与-spring-boot-starter-web" class="headerlink" title="快速 Web 应用开发与 spring-boot-starter-web"></a>快速 Web 应用开发与 spring-boot-starter-web</h4><p>在这个互联网时代，使用 Spring 框架除了开发少数的独立应用，大部分情况下实际上在使用 SpringMVC 开发 web 应用，为了帮我们简化快速搭建并开发一个 Web 项目，SpringBoot 为我们提供了 spring-boot-starter-web 自动配置模块。</p><p>只要将 spring-boot-starter-web 加入项目的 maven 依赖：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div></figure><p>我们就得到了一个直接可执行的 Web 应用，当前项目下运行 <code>mvn spring-boot：run </code>就可以直接启动一个使用了嵌入式 tomcat 服务请求的 Web 应用，只不过，我们还没有提供任何服务 Web 请求的 Controller，所以，访问任何路径都会返回一个 SpringBoot 默认提供的错误页面（一般称其为 whitelabel error page），我们可以在当前项目下新建一个服务根路径 Web 请求的 Controller 实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerpublic class IndexController &#123;    @RequestMapping(&quot;&#x2F;&quot;)        public String index() &#123;                return &quot;hello, there&quot;;        &#125;&#125;</code></pre></div></figure><p>重新运行 <code>mvn spring-boot：run</code> 并访问 <a href="http://localhost：8080，错误页面将被我们的">http://localhost：8080，错误页面将被我们的</a> Controller 返回的消息所替代，一个简单的 Web 应用就这样完成了。</p><p>但是，简单的背后，其实却有很多“潜规则”（约定），我们只有充分了解了这些“潜规则”，才能更好地应用 spring-boot-starter-web。</p><h4 id="项目结构层面的约定"><a href="#项目结构层面的约定" class="headerlink" title="项目结构层面的约定"></a>项目结构层面的约定</h4><p>项目结构层面与传统打包为 war 的 Java Web 应用的差异在于，静态文件和页面模板的存放位置变了，原来是放在 <code>src/main/webapp</code> 目录下的一系列资源，现在都统一放在 <code>src/main/resources</code> 相应子目录下，比如：</p><ul><li><code>src/main/resources/static</code> 用于存放各类静态资源，比如 css，js 等。</li><li><code>src/main/resources/templates</code> 用于存放模板文件，比如 *.vm。</li></ul><p>当然，如果还是希望以 war 包的形式，而不是 SpringBoot 推荐使用的独立 jar 包形式发布 Web 应用，也可以继续原来 Java Web 应用的项目结构约定。</p><h4 id="SpringMVC-框架层面的约定和定制"><a href="#SpringMVC-框架层面的约定和定制" class="headerlink" title="SpringMVC 框架层面的约定和定制"></a>SpringMVC 框架层面的约定和定制</h4><p>spring-boot-starter-web 默认将为我们自动配置如下一些 SpringMVC 必要组件：</p><ul><li>必要的 ViewResolver，比如 ContentNegotiatingViewResolver 和 Bean-NameViewResolver。</li><li>将必要的 Converter、GenericConverter 和 Formatter 等 bean 注册到 IoC 容器。</li><li>添加一系列的 HttpMessageConverter 以便支持对 Web 请求和相应的类型转换。</li><li>自动配置和注册 MessageCodesResolver。</li><li>其他。</li></ul><p>任何时候，如果我们对默认提供的 SpringMVC 组件设定不满意，都可以在 IoC 容器中注册新的同类型的 bean 定义来替换，或者直接提供一个基于 WebMvcConfigurerAdapter 类型的 bean 定义来定制，甚至直接提供一个标注了 <code>@EnableWebMvc</code> 的 <code>@Configuration</code> 配置类完全接管所有 SpringMVC 的相关配置，自己完全重新配置。</p><h3 id="spring-boot-starter-jdbc与数据访问"><a href="#spring-boot-starter-jdbc与数据访问" class="headerlink" title="spring-boot-starter-jdbc与数据访问"></a>spring-boot-starter-jdbc与数据访问</h3><p>大部分 <a href="http://c.biancheng.net/java/">Java</a> 应用都需要访问数据库，尤其是服务层，所以，<a href="http://c.biancheng.net/spring_boot/">SpringBoot</a> 会为我们自动配置相应的数据访问设施。</p><p>若想 <a href="http://c.biancheng.net/spring/">Spring</a>Boot 为我们自动配置数据访问的基础设施，那么，我们需要直接或者间接地依赖 spring-jdbc，一旦 spring-jdbc 位于我们 SpringBoot 应用的 classpath，即会触发数据访问相关的自动配置行为，最简单的做法就是把 spring-boot-starter-jdbc 加为应用的依赖。</p><p>默认情况下，如果我们没有配置任何 DataSource，那么，SpringBoot 会为我们自动配置一个基于嵌入式数据库的 DataSource，这种自动配置行为其实很适合于测试场景，但对实际的开发帮助不大，基本上我们会自己配置一个 DataSource 实例，或者通过自动配置模块提供的配置参数对 DataSource 实例进行自定义的配置。</p><p>假设我们的 SpringBoot 应用只依赖一个数据库，那么，使用 DataSource 自动配置模块提供的配置参数是最方便的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;&#123;database host&#125;:3306&#x2F;&#123;databaseName&#125;spring.datasource.username&#x3D;&#123;database username&#125;spring.datasource.password&#x3D;&#123;database password&#125;</code></pre></div></figure><p>当然，自己配置一个 DataSource 也是可以的，SpringBoot 也会智能地选择我们自己配置的这个 DataSource 实例（只不过必要性真不大）。</p><p>除了 DataSource 会自动配置，SpringBoot 还会自动配置相应的 JdbcTemplate、DataSourceTransactionManager 等关联“设施”，可谓服务周到，我们只要在使用的地方注入就可以了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">class SomeDao &#123;       @Autowired        JdbcTemplate jdbcTemplate;        public &lt;T&gt; List&lt;T&gt; queryForList(String sql)&#123;               &#x2F;&#x2F; ...        &#125;        &#x2F;&#x2F; ...&#125;</code></pre></div></figure><p>不过，spring-boot-starter-jdbc 以及与其相关的自动配置也不总是带来便利，在某些场景下，我们可能会在一个应用中需要依赖和访问多个数据库，这个时候就会出现问题了。</p><p>假设我们在 ApplicationContext 中配置了多个 DataSource 实例指向多个数据库：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic DataSource dataSource1() throws Throwable &#123;        DruidDataSource dataSource &#x3D; new DruidDataSource();        dataSource.setUrl(...);        dataSource.setUsername(...);        dataSource.setPassword(...);        &#x2F;&#x2F; TODO other settings if necessary in the future.        return dataSource;&#125;@Beanpublic DataSource dataSource2() throws Throwable &#123;        DruidDataSource dataSource &#x3D; new DruidDataSource();        dataSource.setUrl(...);       dataSource.setUsername(...);       dataSource.setPassword(...);        &#x2F;&#x2F; TODO other settings if necessary in the future.        return dataSource;&#125;</code></pre></div></figure><p>那么，不好意思，启动 SpringBoot 应用的时候会抛出类似如下的异常（Exception）：</p><p>Exception）：No qualifying bean of type [javax.sql.DataSource] is defined: expected single matching bean but found 2 </p><p>为了避免这种情况的发生，我们需要在 SpringBoot 的启动类上做点儿“手脚”：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication(exclude &#x3D; &#123; DataSourceAutoConfiguration.class,        DataSourceTransactionManagerAutoConfiguration.class &#125;)public class UnveilSpringChapter3Application &#123;        public static void main(String[] args) &#123;        SpringApplication.run(UnveilSpringChapter3Application.class, args);        &#125;&#125;</code></pre></div></figure><p>也就是说，我们需要在这种场景下排除掉对 SpringBoot 默认提供的 DataSource 相关的自动配置。但如果我们还是想要享受 SpringBoot 提供的自动配置 DataSource 的机能，也可以通过为其中一个 DataSource 配置添加 org.springframework.context.annotation.Primary 这个 Annotation 的方式以实现两全其美：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@Primarypublic DataSource dataSource1() throws Throwable &#123;        DruidDataSource dataSource &#x3D; new DruidDataSource();        dataSource.setUrl(...);        dataSource.setUsername(...);        dataSource.setPassword(...);        &#x2F;&#x2F; TODO other settings if necessary in the future.        return dataSource;&#125;@Beanpublic DataSource dataSource2() throws Throwable &#123;        DruidDataSource dataSource &#x3D; new DruidDataSource();        dataSource.setUrl(...);        dataSource.setUsername(...);        dataSource.setPassword(...);        &#x2F;&#x2F; TODO other settings if necessary in the future.        return dataSource;    &#125;</code></pre></div></figure><p>另外，SpringBoot 还提供了很多其他数据访问相关的自动配置模块，比如 spring-boot-starter-data-jpa、spring-boot-starter-data-mongodb 等，大家可以根据自己数据访问的具体场景选择使用这些自动配置模块。</p><p>如果选择了 spring-boot-starter-data-jpa 等关系数据库相关的数据访问自动配置模块，并且还需要同时依赖访问多个数据库，那么，也需要相应的在 SpringBoot 启动类中排除掉这些自动配置模块中的 AutoConfiguration 实现类（对应 spring-boot-starter-data-jpa 是 JpaRepositoriesAutoConfiguration），或者标注某个 DataSource 为 @Primary。</p><h4 id="SpringBoot-应用的数据库版本化管理"><a href="#SpringBoot-应用的数据库版本化管理" class="headerlink" title="SpringBoot 应用的数据库版本化管理"></a>SpringBoot 应用的数据库版本化管理</h4><p>关于如何针对数据库的变更进行版本化管理，从 Ruby On Rails 的 migration 支持，到 Java 的 MyBatis Migrations，Flyway 以及 Liquibase，都给出了相应的最佳实践建议和方案。</p><p>但是，数据库 migrations 的实践方式并没有在国内普遍应用起来，大部分都是靠人来解决，这或许可以用一句“成熟度不够”来解释，另外一个原因或许是职能明确分工后造成的局面。</p><p>如果仔细分析以上数据库 migration 方案就会发现，它们给出的应用场景和实践几乎都是单应用、单部署的，这在庞大单一部署单元（Monolith）的年代显然是很适合的，因为应用从开发到发布部署，再到启动，整个生命周期内，应用相关的所有“原材料”都集中在一起进行管理，而且国外开发者往往偏“特种作战”（Full-Stack Developer），一身多能，从而数据库 migration 这种实践自然可以成型并广泛应用。</p><p>但回到国内来看，我们往往是“集团军作战”，拼的是“大部队+明确分工”的模式，而且应用所面向的服务人数也往往更为庞大，所以，整个应用的交付链路上各个环节之间的衔接是不同的人，而应用最终部署的拓扑又往往是分布式部署居多，所以，在一个项目单元里维护数据库的 migration 脚本然后部署后启动前执行这些脚本就变得不合时宜了：</p><p>1）从职责上，这些 migration 脚本虽然大部分情况下都是开发人员写，但写完之后要不要进行 SQL 审查，是否符合规范，这些又会涉及应用运维 DBA。</p><p>代码管理系统对开发来说很亲切，对 DBA 来说则不尽然，而且 DBA 往往还要一人服务多个团队多个项目，从 DBA 的角度来说，他更愿意将 SQL 集中到一处进行管理，而不是分散在各个项目中。</p><p>2）应用分布式部署之后，就不单单是单一部署在应用启动的之前直接执行一次 migration 脚本那么简单了，你要执行多次，虽然 migration 方案都有版本控制，变更应该最终状态都是一样的，但这多个部署节点上都执行同一逻辑显然是多余的。</p><p>更复杂一点儿，多个应用可能同时使用同一个数据库的情况，一个项目的数据库 migration 操作跟另一个项目的数据库 migration 操作会不会在互不知晓的情况下产生冲突和破坏？</p><p>所以，数据库 migration 的思路和实践很好，但不能照搬（任何事情其实皆如此），不过，我们可以结合现有的一些数据库 migration 方案，比如 flyway 或者 liquibase，我们可以对这些数据库 migration 的基础设施和支持外部化（Externalize），一个可能的架构如图 1 所示。</p><img src="/doc/6f2612a2/5-1ZP1110249323.png" srcset="/img/loading.gif" lazyload class=""><p>图 1 集中管控的数据库 Migration 架构示意图</p><p>在这个架构中，数据库 migration 的版本化管理剥离到了单独的管理系统，单一项目中不再保存完整历史的 migration 记录，而只需要提供当次发布要牵扯的数据库变更 SQL。</p><p>在项目发布的时候，由 DBA 进行统一的审查并纳入单独的数据库 migration 管理系统，由单独的数据库 migration 管理系统来管理完整的数据库 migration 记录，可以根据数据库的粒度进行管理和状态同步，从而既可以在开发阶段让开发人员可以集中管理数据库 SQL，又能在发布期间审查 SQL 并同步 migration 状态和完整的历史记录管理。</p><p>当然，这一切可以实现的前提是有一套完整的软件交付链路支撑平台，能够从流程上，软件生命周期管理上进行统一的治理和规范，后面教程中会跟大家做进一步深入的探讨。</p><p>不管怎么样，SpringBoot 还是为大家提供了针对 Flyway 和 Liquibase 的自动配置功能（org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration 和 org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration），对于单一开发和部署的应用来说，还是可以考虑的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>JavaEE</tag>
      
      <tag>Spring脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu配置Docker镜像加速</title>
    <link href="/doc/dcd863fe.html"/>
    <url>/doc/dcd863fe.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>在<code>/etc/docker/</code>文件夹下新建<code>daemon.json</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</code></pre></div></figure></li><li><p>编辑<code>daemon.json</code>文件，并写入以下内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;registry-mirrors&quot;: [    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;  ]&#125;</code></pre></div></figure></li><li><p>保存并退出编辑后，重载守护进程以及重启Docker：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reload</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service docker restart</code></pre></div></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Docker源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu开启Docker远程访问</title>
    <link href="/doc/c70454ac.html"/>
    <url>/doc/c70454ac.html</url>
    
    <content type="html"><![CDATA[<p>Docker的启动配置文件在Ubuntu18.04系统的路径为&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</p><ol><li><p>进入到&#x2F;lib&#x2F;systemd&#x2F;system路径下，然后编辑docker.service配置文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</code></pre></div></figure></li><li><p>找到ExecStart所对应的行，修改为（Docker的远程访问接口为2375）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H fd:&#x2F;&#x2F; --containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock</code></pre></div></figure></li><li><p>保存并退出编辑后，重载守护进程以及重启Docker：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reload</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service docker restart</code></pre></div></figure></li><li><p>可通过执行命令查看是否开放了远程访问端口：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl status docker.service</code></pre></div></figure></li><li><p>最后打开网址测试一下吧！</p><p><a href="http://your-ip:2375/info">http://your-IP:2375/info</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>远程访问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装Docker</title>
    <link href="/doc/457e5fca.html"/>
    <url>/doc/457e5fca.html</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu-安装-Docker"><a href="#Ubuntu-安装-Docker" class="headerlink" title="Ubuntu 安装 Docker"></a>Ubuntu 安装 Docker</h2><blockquote><p>当然如果你不愿意用这么麻烦的方法，还有更简单的方式，，可以使用官方安装脚本自动安装</p><p>使用aliyun镜像源（仅适用于公网环境）<br><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></p><p>完成后直接使用第8步测试即可</p></blockquote><ol><li><p><strong>先卸载可能存在的旧版本Docker，若不存在可忽略。</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get remove docker docker-engine docker-ce docker.io</code></pre></div></figure></li><li><p><strong>更新apt包索引</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get update</code></pre></div></figure></li><li><p>**安装以下包以使apt可以通过HTTPS使用存储库 **</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt install -y apt-transport-https ca-certificates curl software-properties-common</code></pre></div></figure></li><li><p><strong>添加docker的安装密钥</strong></p><blockquote><p>使用阿里云的docker源进行安装的话要添加对应源的密钥，docker官方的要对应官方的密钥，选择不同的源安装密钥不一样的</p></blockquote><p><strong>阿里云</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -fsSL http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</code></pre></div></figure><p><strong>国外官方docker</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</code></pre></div></figure><p>对于不同的源只是网址里面的域名变化了，但同样可以使用其他的源，比如网易、中科大等</p></li><li><p><strong>在ubuntu的系统源中添加对应的docker源</strong></p><blockquote><p>ubuntu的系统源文件位置位于<code>/etc/apt/sources.list</code></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">add-apt-repository &quot;deb [arch&#x3D;arm64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot;</code></pre></div></figure><p>其中<code>$(lsb_release -cs)</code>是个系统函数，可以自动获取当前ubuntu系统的版本，<code>arm64</code>对应的cpu的版本，我的主板是arm的，如果是电脑或者服务器注意是安装 amd64的，需要把<code>arm64</code>替换成<code>amd64</code><br>同理第四步，添加docker镜像源的时候，网址里面的域名也要看选择哪个源而变化的，上面举例的是docker官方的也可以使用阿里的源添加进去<br><a href="https://developer.aliyun.com/mirror/docker-ce">https://developer.aliyun.com/mirror/docker-ce</a></p></li><li><p>再次更新 apt 包索引</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get update</code></pre></div></figure></li><li><p>安装最新版本的Docker CE</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install docker.io</code></pre></div></figure><blockquote><p>如果在第7步安装中出现404或者没有找到包的情况，说明在第5步的时候镜像源配置出错，或者是当前的镜像源没有同步到最新的版本，考虑换一个，如果是用官方的话，是最稳的，没有同步的情况，就是慢了一点。</p></blockquote></li><li><p>验证docker</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status docker</code></pre></div></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu替换国内源</title>
    <link href="/doc/8c6bc871.html"/>
    <url>/doc/8c6bc871.html</url>
    
    <content type="html"><![CDATA[<h2 id="备份sources-list文件"><a href="#备份sources-list文件" class="headerlink" title="备份sources.list文件"></a>备份sources.list文件</h2><p>在console中输入<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.pak</code>进行文件备份</p><h2 id="修改sources-list文件"><a href="#修改sources-list文件" class="headerlink" title="修改sources.list文件"></a>修改sources.list文件</h2><p>在console中输入<code>sudo vim /etc/apt/sources.list</code>进行文件修改</p><p>替换文件内容为以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 默认注释了源码仓库，如有需要可自行取消注释deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial main main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse</code></pre></div></figure><p>中科大源网s站有如下说明：</p><p><strong>arm ubuntu开发板的apt的库和普通ubuntu的库是不一样的，arm的是ubuntu-ports库。<br>所以只要将sources.list文件中的ubuntu 改为ubuntu-port即可</strong>，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 默认注释了源码仓库，如有需要可自行取消注释deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial main main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-updates main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-backports main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-security main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-proposed main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu-ports&#x2F; xenial-proposed main restricted universe multiverse</code></pre></div></figure><p><strong>阿里源：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</code></pre></div></figure><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="Ubuntu换源后，更新提示缺少公钥"><a href="#Ubuntu换源后，更新提示缺少公钥" class="headerlink" title="Ubuntu换源后，更新提示缺少公钥"></a>Ubuntu换源后，更新提示缺少公钥</h3><p>可通过<code>sudo apt-key adv</code>指令为其增加公钥，具体如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys &lt;缺失的公钥&gt;</code></pre></div></figure><p>这种方案对22.04以下是合理的，但是对22.04及以上版本是不认可的，Ubuntu 不希望您在单个 <code>/etc/apt/trusted.gpg</code> 文件中添加所有签名密钥。它建议使用位于 <code>/etc/apt/trusted.gpg.d</code> 目录中的单独文件。</p><p>如果你已经这么做了，你可以尝试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cp &#x2F;etc&#x2F;apt&#x2F;trusted.gpg &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d</code></pre></div></figure><p>若您没有这么做，您可以尝试<a href="/doc/2964f075.html">Ubuntu弃用apt-key</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Source源</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
