

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/ci.png">
  <link rel="icon" href="/img/ci.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cikaros">
  <meta name="keywords" content="个人博客,Cikaros,博客,ikaros,java,Java,Spring,spring,WTF,王天福,Cikaros`s space">
  
    <meta name="description" content="什么是ServletServlet（Servlet Applet），全称为Java Servlet，未有中文翻译。它是用Java编写的服务端程序。其主要功能在于交互式浏览和修改数据并生成动态的Web内容。狭义的Servlet是指Java语言所实现的一个接口，广义的Servlet是指任何实现了这个Sevlet接口的类，一般情况下均认为是后者。 Servlet运行与支持Java的应用服务器中，例如To">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习Servlet">
<meta property="og:url" content="https://blog.cikaros.top/doc/93a9a5ba.html">
<meta property="og:site_name" content="Cikaros,一个无名的小站~">
<meta property="og:description" content="什么是ServletServlet（Servlet Applet），全称为Java Servlet，未有中文翻译。它是用Java编写的服务端程序。其主要功能在于交互式浏览和修改数据并生成动态的Web内容。狭义的Servlet是指Java语言所实现的一个接口，广义的Servlet是指任何实现了这个Sevlet接口的类，一般情况下均认为是后者。 Servlet运行与支持Java的应用服务器中，例如To">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513130638615">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513195355316">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513203525684">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/2018051320493643">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/2018051320525170">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513205522756">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513210445501">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513205620262">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513210539156">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513210927639">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513204459256">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513204718428">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513204808318">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20181222161836740.png">
<meta property="og:image" content="https://blog.cikaros.top/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Servlet/20181222161836740.png">
<meta property="og:image" content="https://blog.cikaros.top/doc/93a9a5ba/20181222162311326.png">
<meta property="article:published_time" content="2020-11-11T08:06:21.000Z">
<meta property="article:modified_time" content="2025-03-03T13:37:40.597Z">
<meta property="article:author" content="Cikaros">
<meta property="article:tag" content="Tomcat">
<meta property="article:tag" content="Servlet">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.cikaros.top/doc/93a9a5ba/20180513130638615">
  
  
  
    <meta name="google-site-verification" content="RaCa-4GkAi8EznP5oa39oSQtZP5EVOWgnM_1OTMF_no" />
  
  <title>深入学习Servlet - Cikaros,一个无名的小站~</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.net/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.staticfile.net/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.net/hint.css/3.0.0/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.net/prism/1.21.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="https://at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.cikaros.top","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":null},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":"G-1NCZJW9QCG","woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cikaros&#39;s space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-th-large"></i>
                <span>OS专题</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/28e04973.html" target="_self">
                    
                    <span>引言</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/168b0cd8.html" target="_self">
                    
                    <span>环境搭建</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/ddfee3ec.html" target="_self">
                    
                    <span>了解MBR引导过程</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/8f901e2d.html" target="_self">
                    
                    <span>了解如何输出文本</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/4cd4de27.html" target="_self">
                    
                    <span>了解CPU</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/47db40c6.html" target="_self">
                    
                    <span>了解内存组成规则</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/7fb90e78.html" target="_self">
                    
                    <span>了解栈</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/93fdb9ff.html" target="_self">
                    
                    <span>了解函数和字符串</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/26508ea8.html" target="_self">
                    
                    <span>了解16位实模式下的内存编制</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/b5315bfb.html" target="_self">
                    
                    <span>开始引导磁盘</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/44b6e221.html" target="_self">
                    
                    <span>开始编写32位打印函数</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/cb82816a.html" target="_self">
                    
                    <span>开始编写GDT</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/doc/b4d9c09.html" target="_self">
                    
                    <span>运行32位程序</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/anime" target="_self">
                <i class="iconfont icon-image"></i>
                <span>看个图</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" 
     style="background: url('/static/img/index.html') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入学习Servlet"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Cikaros
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-11-11 16:06" pubdate>
          2020年11月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          6.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          57 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入学习Servlet</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2025-03-03T21:37:40+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>Servlet（Servlet Applet），全称为Java Servlet，未有中文翻译。它是用Java编写的服务端程序。其主要功能在于交互式浏览和修改数据并生成动态的Web内容。狭义的Servlet是指Java语言所实现的一个接口，广义的Servlet是指任何实现了这个Sevlet接口的类，一般情况下均认为是后者。</p>
<p>Servlet运行与支持Java的应用服务器中，例如Tomcat。从实现上来说，Servlet可以响应任何类型的请求，但绝大多数情况用来扩展基于HTTP协议的Web服务器。</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><pre><code class="mermaid">sequenceDiagram
	participant Client
	participant Server
	participant Servlet
	Client-&gt;&gt;Server:Http请求
	Server-&gt;&gt;Servlet:启动并调用Servlet
	Servlet-&gt;&gt;Server:根据Http请求，返回生成的响应内容
	Server-&gt;&gt;Client:将Servlet返回的响应内容，处理并返回</code></pre>

<h2 id="Servlet-API简介"><a href="#Servlet-API简介" class="headerlink" title="Servlet API简介"></a>Servlet API简介</h2><p>Servlet API 包含以下4个Java Package：</p>
<ol>
<li><code>javax.servlet</code> 其中包含定义Servlet和Servlet容器之间契约的类和接口。</li>
<li><code>javax.servlet.http</code> 其中包含定义HTTP Servlet和Servlet容器之间的关系。</li>
<li><code>javax.servlet.annotation</code> 其中包含标注Servlet、Filter、Listener的注解。它还为被标注的元件定义元数据。</li>
<li><code>javax.servlet.descriptor</code>，其中包含提供程序化登录Web应用程序的配置信息类型。</li>
</ol>
<h2 id="Servlet的主要类型"><a href="#Servlet的主要类型" class="headerlink" title="Servlet的主要类型"></a>Servlet的主要类型</h2><pre><code class="mermaid">classDiagram
	class Servlet&#123;
		init(ServletConfig) void
		service(ServletRequest,ServletResponse) void
		destroy() void
		getServletConfig() ServletConfig
	&#125;
	&lt;&lt;interface&gt;&gt; Servlet
	ServletConfig&lt;--Servlet : 依赖
	ServletConfig&lt;..Servlet : 关联
	
	class ServletConfig&#123;
	 	getInitParameter(String) String
		getParameterNames() Enumeration
		getServletContext() ServletContext
	&#125;
	&lt;&lt;interface&gt;&gt; ServletConfig
	
	
	class GenericServlet
	&lt;&lt;abstruct&gt;&gt; GenericServlet
	Servlet&lt;|..GenericServlet:实现
	
	class ServletRequest
	&lt;&lt;interface&gt;&gt; ServletRequest
	ServletRequest&lt;..Servlet
	
	class ServletResponse
	&lt;&lt;interface&gt;&gt; ServletResponse
	ServletResponse&lt;..Servlet
	
	class ServletContext
	&lt;&lt;interface&gt;&gt; ServletContext
	ServletContext&lt;--ServletConfig
	
	class HttpServletRequest
	&lt;&lt;interface&gt;&gt; HttpServletRequest
	ServletRequest&lt;|--HttpServletRequest
	
	class HttpServletResponse
	&lt;&lt;interface&gt;&gt; HttpServletResponse
	ServletResponse&lt;|--HttpServletResponse
	
	class HttpServlet
	GenericServlet&lt;--HttpServlet:继承
	HttpServletRequest&lt;..HttpServlet
	HttpServletResponse&lt;..HttpServlet
	</code></pre>

<h2 id="Servlet的工作原理"><a href="#Servlet的工作原理" class="headerlink" title="Servlet的工作原理"></a>Servlet的工作原理</h2><p>Servlet接口定义了Servlet与Servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用他具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。</p>
<p>用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p>
<p> ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p>
<h2 id="Servlet接口中定义的方法"><a href="#Servlet接口中定义的方法" class="headerlink" title="Servlet接口中定义的方法"></a>Servlet接口中定义的方法</h2><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Servlet &#123;
    &#x2F;&#x2F;初始化方法
    void init(ServletConfig var1) throws ServletException;
 	&#x2F;&#x2F;获取ServletConfig对象
    ServletConfig getServletConfig();
 	&#x2F;&#x2F;服务方法，也是业务的核心处理方法
    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
 	&#x2F;&#x2F;获取Servlet信息
    String getServletInfo();
 	&#x2F;&#x2F;销毁方法
    void destroy();
&#125;</code></pre></div></figure>

<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：</p>
<ol>
<li><p>init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。</p>
</li>
<li><p>service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。</p>
</li>
<li><p>destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</p>
</li>
</ol>
<h2 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a>ServletRequest接口</h2><p> Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。</p>
<p>让我们来看一看ServletRequest接口的部分内容：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ServletRequest &#123;
 
    int getContentLength();&#x2F;&#x2F;返回请求主体的字节数
 
    String getContentType();&#x2F;&#x2F;返回主体的MIME类型
 
    String getParameter(String var1);&#x2F;&#x2F;返回请求参数的值
 
&#125;</code></pre></div></figure>

<p>其中，getParameter是在ServletRequest中最常用的方法，可用于获取查询字符串的值。</p>
<h2 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h2><p>javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p>
<p>让我们也来看看ServletResponse内部定义了哪些方法：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ServletResponse &#123;
    String getCharacterEncoding();
 
    String getContentType();
 
    ServletOutputStream getOutputStream() throws IOException;
 
    PrintWriter getWriter() throws IOException;
 
    void setCharacterEncoding(String var1);
 
    void setContentLength(int var1);
 
    void setContentType(String var1);
 
    void setBufferSize(int var1);
 
    int getBufferSize();
 
    void flushBuffer() throws IOException;
 
    void resetBuffer();
 
    boolean isCommitted();
 
    void reset();
 
    void setLocale(Locale var1);
 
    Locale getLocale();
&#125;</code></pre></div></figure>

<p>其中的getWriter方法，它返回了一个可以向客户端发送文本的的Java.io.PrintWriter对象。默认情况下，PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。</p>
<p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。</p>
<p>还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送二进制数据的。</p>
<p>在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text&#x2F;html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset&#x3D;UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p>
<h2 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h2><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。</p>
<p>其中几个方法如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取在Web.xml中配置的Servlet-Name的值
String getServletName();
&#x2F;&#x2F;获取Servlet的初始化参数
String getInitParameter(String name);
&#x2F;&#x2F;获取所有的Servlet初始化参数的名称
Enumeration getInitParameterNames();</code></pre></div></figure>

<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p>ServletContext对象表示Servlet应用程序。每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。</p>
<p>通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。</p>
<p>那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</p>
<p>ServletContext中的下列方法负责处理属性：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取属性
Object getAttribute(String var1);
&#x2F;&#x2F;获取属性名枚举
Enumeration&lt;String&gt; getAttributeNames();
&#x2F;&#x2F;设置属性
void setAttribute(String var1, Object var2);
&#x2F;&#x2F;删除属性
void removeAttribute(String var1);</code></pre></div></figure>

<p>上述方法是四大域对象特有的方法，域对象包括Page、Request、Session、Application。</p>
<h2 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h2><p>我们编写Servlet类需要实现Servlet接口的所有方法，即使某些方法不需要使用也必须要全部实现，并且还需要自己手动维护ServletConfig这个对象的引用。所有这样实现Servlet是很麻烦的一件事。</p>
<p>GenericService抽象类帮我们解决了这个问题。本着尽可能使代码简洁的原则，GenericServlet实现了Servlet和ServletConfig接口，下面是GenericServlet抽象类的具体代码：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;
    private static final String LSTRING_FILE &#x3D; &quot;javax.servlet.LocalStrings&quot;;
    private static ResourceBundle lStrings &#x3D; ResourceBundle.getBundle(&quot;javax.servlet.LocalStrings&quot;);
    private transient ServletConfig config;
 
    public GenericServlet() &#123;
    &#125;
 
    public void destroy() &#123;
    &#125;
 
    public String getInitParameter(String name) &#123;
        ServletConfig sc &#x3D; this.getServletConfig();
        if (sc &#x3D;&#x3D; null) &#123;
            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));
        &#125; else &#123;
            return sc.getInitParameter(name);
        &#125;
    &#125;
 
    public Enumeration&lt;String&gt; getInitParameterNames() &#123;
        ServletConfig sc &#x3D; this.getServletConfig();
        if (sc &#x3D;&#x3D; null) &#123;
            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));
        &#125; else &#123;
            return sc.getInitParameterNames();
        &#125;
    &#125;
 
    public ServletConfig getServletConfig() &#123;
        return this.config;
    &#125;
 
    public ServletContext getServletContext() &#123;
        ServletConfig sc &#x3D; this.getServletConfig();
        if (sc &#x3D;&#x3D; null) &#123;
            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));
        &#125; else &#123;
            return sc.getServletContext();
        &#125;
    &#125;
 
    public String getServletInfo() &#123;
        return &quot;&quot;;
    &#125;
 
    public void init(ServletConfig config) throws ServletException &#123;
        this.config &#x3D; config;
        this.init();
    &#125;
 
    public void init() throws ServletException &#123;
    &#125;
 
    public void log(String msg) &#123;
        this.getServletContext().log(this.getServletName() + &quot;: &quot; + msg);
    &#125;
 
    public void log(String message, Throwable t) &#123;
        this.getServletContext().log(this.getServletName() + &quot;: &quot; + message, t);
    &#125;
 
    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
 
    public String getServletName() &#123;
        ServletConfig sc &#x3D; this.getServletConfig();
        if (sc &#x3D;&#x3D; null) &#123;
            throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));
        &#125; else &#123;
            return sc.getServletName();
        &#125;
    &#125;
&#125;</code></pre></div></figure>

<p>其中，GenericServlet抽象类相比于直接实现Servlet接口，有以下几个好处：</p>
<ol>
<li><p>为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。</p>
</li>
<li><p>提供方法，包围ServletConfig对象中的方法。</p>
</li>
<li><p>将init( )方法中的ServletConfig参数赋给了一个内部的ServletConfig引用从而来保存ServletConfig对象，不需要程序员自己去维护ServletConfig了。</p>
</li>
</ol>
<p>但是，我们发现在GenericServlet抽象类中还存在着另一个没有任何参数的init()方法：</p>
<p>设计者的初衷到底是为了什么呢？在第一个带参数的init（）方法中就已经把ServletConfig对象传入并且通过引用保存好了，完成了Servlet的初始化过程，那么为什么后面还要加上一个不带任何参数的init（）方法呢？这不是多此一举吗？</p>
<p>当然不是多此一举了，存在必然有存在它的道理。我们知道，抽象类是无法直接产生实例的，需要另一个类去继承这个抽象类，那么就会发生方法覆盖的问题，如果在类中覆盖了GenericServlet抽象类的init（）方法，那么程序员就必须手动的去维护ServletConfig对象了，还得调用super.init(servletConfig）方法去调用父类GenericServlet的初始化方法来保存ServletConfig对象，这样会给程序员带来很大的麻烦。GenericServlet提供的第二个不带参数的init( )方法，就是为了解决上述问题的。</p>
<p>这个不带参数的init（）方法，是在ServletConfig对象被赋给ServletConfig引用后，由第一个带参数的init(ServletConfig servletconfig)方法调用的，那么这意味着，当程序员如果需要覆盖这个GenericServlet的初始化方法，则只需要覆盖那个不带参数的init( )方法就好了，此时，servletConfig对象仍然有GenericServlet保存着。</p>
<p>说了这么多，通过扩展GenericServlet抽象类，就不需要覆盖没有计划改变的方法。因此，代码将会变得更加的简洁，程序员的工作也会减少很多。</p>
<p>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p>
<h2 id="Javax-servlet-http包内容"><a href="#Javax-servlet-http包内容" class="headerlink" title="Javax.servlet.http包内容"></a>Javax.servlet.http包内容</h2><p> 之所以所HttpServlet要比GenericServlet强大，其实也是有道理的。HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class HttpServlet extends GenericServlet implements Serializable </code></pre></div></figure>

<p>HttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax。servlet.http包是Servlet API中的第二个包，其中包含了用于编写Servlet应用程序的类和接口。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。</p>
<pre><code class="mermaid">classDiagram
	class Servlet
	&lt;&lt;interface&gt;&gt; Servlet
	
	class GenericServlet
	&lt;&lt;abstruct&gt;&gt; GenericServlet
	Servlet&lt;|..GenericServlet:实现
	
	class HttpServlet
	&lt;&lt;abstruct&gt;&gt; HttpServlet
	GenericServlet&lt;|--HttpServlet:继承
	
	class ServletRequest
	&lt;&lt;interface&gt;&gt; ServletRequest
	
	class HttpServletRequest
	&lt;&lt;interface&gt;&gt; HttpServletRequest
	ServletRequest&lt;|--HttpServletRequest:继承
	
	class ServletResponse
	&lt;&lt;interface&gt;&gt; ServletResponse
	
	class HttpServletResponse
	&lt;&lt;interface&gt;&gt; HttpServletResponse
	ServletResponse&lt;|--HttpServletResponse:继承
	
	class HttpSession
	&lt;&lt;interface&gt;&gt; HttpSession
	
	class Coookie
	</code></pre>

<h3 id="HttpServlet抽象类"><a href="#HttpServlet抽象类" class="headerlink" title="HttpServlet抽象类"></a>HttpServlet抽象类</h3><p>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</p>
<p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p>
<p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。</p>
<p>让我们来具体的看一看HttpServlet抽象类是如何实现自己的service方法吧：</p>
<p>首先来看GenericServlet抽象类中是如何定义service方法的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;</code></pre></div></figure>

<p>我们看到是一个抽象方法，也就是HttpServlet要自己去实现这个service方法，我们在看看HttpServlet是怎么覆盖这个service方法的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;
    HttpServletRequest request;
    HttpServletResponse response;
    try &#123;
        request &#x3D; (HttpServletRequest)req;
        response &#x3D; (HttpServletResponse)res;
    &#125; catch (ClassCastException var6) &#123;
        throw new ServletException(&quot;non-HTTP request or response&quot;);
    &#125;
    this.service(request, response);
&#125;</code></pre></div></figure>

<p>我们发现，HttpServlet中的service方法把接收到的ServletRequsest类型的对象转换成了HttpServletRequest类型的对象，把ServletResponse类型的对象转换成了HttpServletResponse类型的对象。之所以能够这样强制的转换，<strong>是因为在调用Servlet的Service方法时，Servlet容器总会传入一个HttpServletRequest对象和HttpServletResponse对象，预备使用HTTP</strong>。因此，转换类型当然不会出错了。</p>
<p>转换之后，service方法把两个转换后的对象传入了另一个service方法，那么我们再来看看这个方法是如何实现的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    String method &#x3D; req.getMethod();
    long lastModified;
    if (method.equals(&quot;GET&quot;)) &#123;
        lastModified &#x3D; this.getLastModified(req);
        if (lastModified &#x3D;&#x3D; -1L) &#123;
            this.doGet(req, resp);
        &#125; else &#123;
            long ifModifiedSince &#x3D; req.getDateHeader(&quot;If-Modified-Since&quot;);
            if (ifModifiedSince &lt; lastModified) &#123;
                this.maybeSetLastModified(resp, lastModified);
                this.doGet(req, resp);
            &#125; else &#123;
                resp.setStatus(304);
            &#125;
        &#125;
    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;
        lastModified &#x3D; this.getLastModified(req);
        this.maybeSetLastModified(resp, lastModified);
        this.doHead(req, resp);
    &#125; else if (method.equals(&quot;POST&quot;)) &#123;
        this.doPost(req, resp);
    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;
        this.doPut(req, resp);
    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;
        this.doDelete(req, resp);
    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;
        this.doOptions(req, resp);
    &#125; else if (method.equals(&quot;TRACE&quot;)) 
        this.doTrace(req, resp);
    &#125; else &#123;
        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs &#x3D; new Object[]&#123;method&#125;;
        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);
        resp.sendError(501, errMsg);
    &#125;
&#125;</code></pre></div></figure>

<p>我们发现，这个service方法的参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象。</p>
<p>接下来我们再看看service方法是如何工作的，我们会发现在service方法中还是没有任何的服务逻辑，但是却在解析HttpServletRequest中的方法参数，并调用以下方法之一：doGet,doPost,doHead,doPut,doTrace,doOptions和doDelete。这7种方法中，每一种方法都表示一个Http方法。doGet和doPost是最常用的。所以，如果我们需要实现具体的服务逻辑，不再需要覆盖service方法了，只需要覆盖doGet或者doPost就好了。</p>
<p>总之，HttpServlet有两个特性是GenericServlet所不具备的：</p>
<ol>
<li><p>不用覆盖service方法，而是覆盖doGet或者doPost方法。在少数情况，还会覆盖其他的5个方法。</p>
</li>
<li><p>使用的是HttpServletRequest和HttpServletResponse对象。</p>
</li>
</ol>
<h3 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p> HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getContextPath();&#x2F;&#x2F;返回请求上下文的请求URI部分
Cookie[] getCookies();&#x2F;&#x2F;返回一个cookie对象数组
String getHeader(String var1);&#x2F;&#x2F;返回指定HTTP标题的值
String getMethod();&#x2F;&#x2F;返回生成这个请求HTTP的方法名称
String getQueryString();&#x2F;&#x2F;返回请求URL中的查询字符串
HttpSession getSession();&#x2F;&#x2F;返回与这个请求相关的会话对象</code></pre></div></figure>

<h3 id="HttpServletRequest内封装的请求"><a href="#HttpServletRequest内封装的请求" class="headerlink" title="HttpServletRequest内封装的请求"></a>HttpServletRequest内封装的请求</h3><p>因为Request代表请求，所以我们可以通过该对象分别获得HTTP请求的请求行，请求头和请求体。</p>
<p>关于HTTP具体的详细解释，可以参考我的另一篇博文：JavaWeb——HTTP。</p>
<img src="/doc/93a9a5ba/20180513130638615" srcset="/img/loading.gif" lazyload class="">

<h3 id="通过request获得请求行"><a href="#通过request获得请求行" class="headerlink" title="通过request获得请求行"></a>通过request获得请求行</h3><p>假设查询字符串为：username&#x3D;zhangsan&amp;password&#x3D;123</p>
<p>获得客户端的请求方式：<code>String getMethod()</code></p>
<p>获得请求的资源：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getRequestURI() &#x2F;&#x2F;获取uri

StringBuffer getRequestURL() &#x2F;&#x2F;获取url

String getContextPath() &#x2F;&#x2F;获取web应用的名称

String getQueryString() &#x2F;&#x2F;获取提交url地址后的参数字符串</code></pre></div></figure>



<h3 id="通过request获得请求头"><a href="#通过request获得请求头" class="headerlink" title="通过request获得请求头"></a>通过request获得请求头</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">long getDateHeader(String name) &#x2F;&#x2F;获取头数据

String getHeader(String name) &#x2F;&#x2F;获取头信息

Enumeration getHeaderNames() &#x2F;&#x2F;获取头信息名枚举

Enumeration getHeaders(String name) &#x2F;&#x2F;获取头信息枚举

int getIntHeader(String name) &#x2F;&#x2F;获取整型数头信息</code></pre></div></figure>

<p>referer头的作用：执行该此访问的的来源，做防盗链</p>
<h3 id="通过request获得请求体"><a href="#通过request获得请求体" class="headerlink" title="通过request获得请求体"></a>通过request获得请求体</h3><p>请求体中的内容是通过post提交的请求参数，格式是：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">username&#x3D;zhangsan&amp;password&#x3D;123&amp;hobby&#x3D;football&amp;hobby&#x3D;basketball</code></pre></div></figure>

<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>zhangsan</td>
</tr>
<tr>
<td>password</td>
<td>123</td>
</tr>
<tr>
<td>hobby</td>
<td>football，basketball</td>
</tr>
</tbody></table>
<p>以上面参数为例，通过一下方法获得请求参数：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getParameter(String name) &#x2F;&#x2F;获取参数

String[] getParameterValues(String name) &#x2F;&#x2F;获取参数数组

Enumeration getParameterNames() &#x2F;&#x2F;获取参数名枚举

Map&lt;String,String[]&gt; getParameterMap() &#x2F;&#x2F;获取参数Map</code></pre></div></figure>

<p><strong>注意：get请求方式的请求参数 上述的方法一样可以获得。</strong></p>
<h3 id="Request乱码问题的解决方法"><a href="#Request乱码问题的解决方法" class="headerlink" title="Request乱码问题的解决方法"></a>Request乱码问题的解决方法</h3><p>在前面我们讲过，在service中使用的编码解码方式默认为：ISO-8859-1编码，但此编码并不支持中文，因此会出现乱码问题，所以我们需要手动修改编码方式为UTF-8编码，才能解决中文乱码问题，下面是发生乱码的具体细节：</p>
<img src="/doc/93a9a5ba/20180513195355316" srcset="/img/loading.gif" lazyload class="">

<p>解决post提交方式的乱码：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p>
<p>解决get提交的方式的乱码：<code>parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</code></p>
<h3 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h3><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。  由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<h3 id="HttpServletResponse内封装的响应"><a href="#HttpServletResponse内封装的响应" class="headerlink" title="HttpServletResponse内封装的响应"></a>HttpServletResponse内封装的响应</h3><img src="/doc/93a9a5ba/20180513203525684" srcset="/img/loading.gif" lazyload class="">

<h3 id="通过Response设置响应"><a href="#通过Response设置响应" class="headerlink" title="通过Response设置响应"></a>通过Response设置响应</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">void addCookie(Cookie var1);&#x2F;&#x2F;给这个响应添加一个cookie
void addHeader(String var1, String var2);&#x2F;&#x2F;给这个请求添加一个响应头
void sendRedirect(String var1) throws IOException;&#x2F;&#x2F;发送一条响应码，讲浏览器跳转到指定的位置
void setStatus(int var1);&#x2F;&#x2F;设置响应行的状态码
void addHeader(String name, String value)
void addIntHeader(String name, int value)
void addDateHeader(String name, long date)
void setHeader(String name, String value)
void setDateHeader(String name, long date)
void setIntHeader(String name, int value)</code></pre></div></figure>

<p>其中，add表示添加，而set表示设置</p>
<p>PrintWriter getWriter()</p>
<p>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response  缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>ServletOutputStream getOutputStream()</p>
<p>获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。</p>
<img src="/doc/93a9a5ba/2018051320493643" srcset="/img/loading.gif" lazyload class="">

<p>注意：虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。</p>
<img src="/doc/93a9a5ba/2018051320525170" srcset="/img/loading.gif" lazyload class="">

<h3 id="Response的乱码问题"><a href="#Response的乱码问题" class="headerlink" title="Response的乱码问题"></a>Response的乱码问题</h3><hr>
<img src="/doc/93a9a5ba/20180513205522756" srcset="/img/loading.gif" lazyload class="">

<p>原因：response缓冲区的默认编码是iso8859-1，此码表中没有中文。所以需要更改response的编码方式：</p>
<img src="/doc/93a9a5ba/20180513210445501" srcset="/img/loading.gif" lazyload class="">

<img src="/doc/93a9a5ba/20180513205620262" srcset="/img/loading.gif" lazyload class="">

<p>通过更改response的编码方式为UTF-8，任然无法解决乱码问题，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。</p>
<img src="/doc/93a9a5ba/20180513210539156" srcset="/img/loading.gif" lazyload class="">

<p>上面通过调用两个方式分别改变服务端对于Response的编码方式以及浏览器的解码方式为同样的UTF-8编码来解决编码方式不一样发生乱码的问题。</p>
<p>response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)方法即可。</p>
<img src="/doc/93a9a5ba/20180513210927639" srcset="/img/loading.gif" lazyload class="">

<img src="/doc/93a9a5ba/20180513204459256" srcset="/img/loading.gif" lazyload class="">

<h3 id="Response的工作流程"><a href="#Response的工作流程" class="headerlink" title="Response的工作流程"></a>Response的工作流程</h3><img src="/doc/93a9a5ba/20180513204718428" srcset="/img/loading.gif" lazyload class="">

<h3 id="Servlet的工作流程"><a href="#Servlet的工作流程" class="headerlink" title="Servlet的工作流程"></a>Servlet的工作流程</h3><img src="/doc/93a9a5ba/20180513204808318" srcset="/img/loading.gif" lazyload class="">

<h3 id="ServletContextListener（Servlet全局监听器）"><a href="#ServletContextListener（Servlet全局监听器）" class="headerlink" title="ServletContextListener（Servlet全局监听器）"></a>ServletContextListener（Servlet全局监听器）</h3><p>首先要说明的是，ServletContextListener是一个接口，我们随便写一个类，只要这个类实现了ServletContextListener接口，那么这个类就实现了【监听ServletContext】的功能。那么，这个神奇的接口是如何定义的呢？我们来看一下这个接口的内部情况：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javax.servlet;
import java.util.EventListener;
public interface ServletContextListener extends EventListener &#123;   
    void contextInitialized(ServletContextEvent var1);
	void contextDestroyed(ServletContextEvent var1); 
&#125;</code></pre></div></figure>

<p>我们发现，在这个接口中只声明了两个方法，分别是<code>void contextInitialized(ServletContextEvent var1)</code>和<code>void contextDestroyed(ServletContextEvent var1)</code>方法，所以，我们很容易的就能猜测到，ServletContext的生命只有两种，分别是：</p>
<p>1.ServletContext初始化。（应用start时）———-&gt;Servlet容器调用<code>void contextInitialized(ServletContextEvent var1)</code></p>
<p>2.ServletContext销毁。（应用stop时）———-&gt;Servlet容器调用<code> void contextDestroyed(ServletContextEvent var1)</code></p>
<p>因此，我们大概能够猜到ServletContextListener的工作机制了，当应用启动时，ServletContext进行初始化，然后Servlet容器会自动调用正在监听ServletContext的ServletContextListener的<code>void contextInitialized(ServletContextEvent var1)</code>方法，并向其传入一个ServletContextEvent对象。当应用停止时，ServletContext被销毁，此时Servlet容器也会自动地调用正在监听ServletContext的ServletContextListener的<code>void contextDestroyed(ServletContextEvent var1)</code>方法。</p>
<p>为了验证我们的猜测，我们来随便写一个类，并且实现ServletContextListener接口，即实现监听ServletContext的功能：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
public class MyListener implements ServletContextListener &#123;

  @Override
  public void contextInitialized(ServletContextEvent servletContextEvent) &#123;
    System.out.println(&quot;ServletContextListener.contextInitialized方法被调用&quot;);
  &#125;

  @Override
  public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;
    System.out.println(&quot;ServletContextListener.contextDestroyed方法被调用&quot;);
  &#125;

&#125;</code></pre></div></figure>

<p>然后，在web.xml中注册我们自己写的这个MyListener:</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;
	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;
	version&#x3D;&quot;4.0&quot;&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;MyListener&lt;&#x2F;listener-class&gt;
    &lt;&#x2F;listener&gt;
&lt;&#x2F;web-app&gt;</code></pre></div></figure>

<p>接下来，让我们启动一下Tomcat，看一看会发生什么吧！控制台打印信息如下：</p>
<img src="/doc/93a9a5ba/20181222161836740.png" srcset="/img/loading.gif" lazyload class="">
<p><img src="/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Servlet/20181222161836740.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们发现，当应用启动时，ServletContextListener.contextInitialized（）方法被调用了。这其实是Servlet容器偷偷干的事情。那么，当我们停止Tomcat时，按照猜想，Servlet容器应该也会偷偷调用void contextDestroyed(ServletContextEvent var1)方法，来通知ServletContextListener监听器：ServletContext已经被销毁了。那么，事实是不是和我们猜想的一模一样呢？让我们来停止Tomcat的运行，看一看控制台的情况吧：</p>
<img src="/doc/93a9a5ba/20181222162311326.png" srcset="/img/loading.gif" lazyload class="">

<p>我们发现，<code>void contextDestroyed(ServletContextEvent var1)</code>方法确实被Servlet容器调用了。因此，我们的猜想得到了证实。</p>
<h3 id="【进阶】ServletContextListener在Spring中的应用"><a href="#【进阶】ServletContextListener在Spring中的应用" class="headerlink" title="【进阶】ServletContextListener在Spring中的应用"></a>【进阶】ServletContextListener在Spring中的应用</h3><p>如果基础好一点的童鞋，或者已经学过Spring框架的同学，建议阅读下面的内容，没有学过Spring也没有关系，可以先学或者学完之后再回头来看一看，Spring容器是如何借用ServletContextListener这个接口来实例化的。</p>
<p>首先让我们再来回顾一下ServletContext的概念，ServletContext翻译成中文叫做“Servlet上下文”或者“Servlet全局”，但是这个翻译我认为翻译的实在是有点牵强，也导致了许多的开发者不明白这个变量到底具体代表了什么。其实ServletContext就是一个“域对象”，它存在于整个应用中，并在在整个应用中有且仅有1份，它表示了当前整个应用的“状态”，你也可以理解为某个时刻的ServletContext代表了这个应用在某个时刻的“一张快照”，这张“快照”里面包含了有关应用的许多信息，应用的所有组件都可以从ServletContext获取当前应用的状态信息。ServletContext随着程序的启动而创建，随着程序的停止而销毁。通俗点说，我们可以往这个ServletContext域对象中“存东西”，然后也可以在别的地方中“取出来”。</p>
<p>我们知道，Spring容器可以通过：</p>
<p><code>ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;配置文件的路径&quot;）;</code></p>
<p>显示地实例化一个Spring IOC容器。也可以像下面一样，在web.xml中注册Spring IOC容器：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;
&lt;&#x2F;listener&gt;
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;
&lt;&#x2F;context-param&gt;</code></pre></div></figure>

<p>其中的监听器类【org.springframework.web.context.ContextLoaderListener】实现了ServletContextListener接口，能够监听ServletContext的生命周期中的“初始化”和“销毁”。注意，这个【org.springframework.web.context.ContextLoaderListener】监听器类当然不是我们自己写的哦，是人家Spring团队写的，我们只要拿来用就行了。当然，别忘记导入相关的Jar包。（<strong>spring-web-4.2.4.RELEASE.jar</strong>）</p>
<p>那么，Spring团队给我们提供的这个监听器类是如何实现：当ServletContext初始化后，Spring IOC容器也能跟着初始化的呢？怀着好奇心，让我们再来看一看【org.springframework.web.context.ContextLoaderListener】的内部实现情况吧。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.springframework.web.context;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;
    
	public ContextLoaderListener() &#123;
	&#125;
    
	public ContextLoaderListener(WebApplicationContext context) &#123;
    	super(context);
  	&#125;

&#x2F;&#x2F;--------------------------------------------------------重点关注下面这里哦！-----------------------------------------------------------------------
  	public void contextInitialized(ServletContextEvent event) &#123;
    	this.initWebApplicationContext(event.getServletContext());
  	&#125;

&#x2F;&#x2F;--------------------------------------------------------重点关注上面这里哦！-----------------------------------------------------------------------
  	public void contextDestroyed(ServletContextEvent event) &#123;
    	this.closeWebApplicationContext(event.getServletContext());
    	ContextCleanupListener.cleanupAttributes(event.getServletContext());
  	&#125;

&#125;</code></pre></div></figure>

<p>我们发现，【org.springframework.web.context.ContextLoaderListener】这个类实现了ServletContextListener接口中的两个方法，其中，当ServletContext初始化后， <code>public void contextInitialized(ServletContextEvent event)</code>方法被调用，接下来执行<code>initWebApplicationContext(event.getServletContext())</code>方法，但是我们发现这个方法并没有在这个类中声明，因此，我们再看一下其父类中是如何声明的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;
     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) !&#x3D; null) &#123;
         throw new IllegalStateException(&quot;Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
 	&#125; else &#123;
      	Log logger &#x3D; LogFactory.getLog(ContextLoader.class);
     	servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
     	if (logger.isInfoEnabled()) &#123;
         	logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
        	&#125;
     	long startTime &#x3D; System.currentTimeMillis();
     	try &#123;
         	if (this.context &#x3D;&#x3D; null) &#123;
             	 this.context &#x3D; this.createWebApplicationContext(servletContext);
         	&#125;
         	if (this.context instanceof ConfigurableWebApplicationContext) &#123;
             	ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext)this.context;
                	if (!cwac.isActive()) &#123;
                 	if (cwac.getParent() &#x3D;&#x3D; null) &#123;
                     	ApplicationContext parent &#x3D; this.loadParentContext(servletContext);
                     	cwac.setParent(parent);
                  	&#125;
                 	this.configureAndRefreshWebApplicationContext(cwac, servletContext);
             	&#125;
         	&#125;
            	servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
        	ClassLoader ccl &#x3D; Thread.currentThread().getContextClassLoader();
         	if (ccl &#x3D;&#x3D; ContextLoader.class.getClassLoader()) &#123;
          	   	currentContext &#x3D; this.context;
          	&#125; else if (ccl !&#x3D; null) &#123;
             	currentContextPerThread.put(ccl, this.context);
         	&#125;
         	if (logger.isDebugEnabled()) &#123;
                	logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
         	&#125;
         	if (logger.isInfoEnabled()) &#123;
             	long elapsedTime &#x3D; System.currentTimeMillis() - startTime;
              	logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
         	&#125;
         	return this.context;
     	&#125; catch (RuntimeException var8) &#123;
            	logger.error(&quot;Context initialization failed&quot;, var8);
         	servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var8);
         	throw var8;
     	&#125; catch (Error var9) &#123;
          	logger.error(&quot;Context initialization failed&quot;, var9);
         	servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var9);
         	throw var9;
     	&#125;
    	&#125;
&#125;</code></pre></div></figure>

<p>分析到这一步，我们发现Spring容器在这个方法中被实例化了。接下来，就让我们整理一下整体的思路：</p>
<p>当Servlet容器启动时，ServletContext对象被初始化，然后Servlet容器调用web.xml中注册的监听器的</p>
<p>public void contextInitialized(ServletContextEvent event)</p>
<p>方法，而在监听器中，调用了this.initWebApplicationContext(event.getServletContext())方法，在这个方法中实例化了Spring IOC容器。即ApplicationContext对象。</p>
<p>因此，当ServletContext创建时我们可以创建applicationContext对象，当ServletContext销毁时，我们可以销毁applicationContext对象。这样applicationContext就和ServletContext“共生死了”。</p>
<h2 id="博文来源"><a href="#博文来源" class="headerlink" title="博文来源"></a>博文来源</h2><p>为防止所需博文丢失，所以<strong>copy</strong>了大佬的博文，这里重点标注一下博文来源：</p>
<blockquote>
<p>版权声明：本文为博主原创文章，遵循<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。</p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Tomcat/" class="category-chain-item">Tomcat</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Tomcat/" class="print-no-link">#Tomcat</a>
      
        <a href="/tags/Servlet/" class="print-no-link">#Servlet</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入学习Servlet</div>
      <div>https://blog.cikaros.top/doc/93a9a5ba.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cikaros</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年11月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/doc/7be41d9.html" title="mermaid流程图文档">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mermaid流程图文档</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/doc/af559c1b.html" title="ubuntu防火墙常用命令">
                        <span class="hidden-mobile">ubuntu防火墙常用命令</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.staticfile.net/valine/1.4.14/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"3cYeJPCmBzloJAiih22BpOwC-gzGzoHsz","appKey":"uLqClWuRHNwvKmIQC8gKnx92","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://3cyejpcm.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"3cYeJPCmBzloJAiih22BpOwC-gzGzoHsz","appkey":"uLqClWuRHNwvKmIQC8gKnx92"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  





  <script>
  Fluid.utils.createScript('https://cdn.staticfile.net/mermaid/10.7.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>





  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="/img/admire.png" class="rounded mx-auto d-block mt-5" style="width:400px; height:400px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.net/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.net/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.staticfile.net/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.net/tocbot/4.11.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://cdn.staticfile.net/prism/1.21.0/components/prism-core.min.js" ></script>

  <script  src="https://cdn.staticfile.net/prism/1.21.0/plugins/autoloader/prism-autoloader.min.js" ></script>

  <script  src="https://cdn.staticfile.net/prism/1.21.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://cdn.staticfile.net/clipboard.js/2.0.6/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://cdn.staticfile.net/mathjax/3.0.5/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
  <div id="a-player"></div>
  <link defer rel="stylesheet" href="https://cdn.staticfile.net/aplayer/1.10.1/APlayer.min.css" />
  <script src="https://cdn.staticfile.net/aplayer/1.10.1/APlayer.min.js"></script>
  <script defer src="/js/aplayer.js"></script>
  <script defer src="/js/custom_banner_img.js"></script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"01/assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/01/assets/assets/haru02.model.json"},"display":{"position":"right","width":150,"height":350},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>
